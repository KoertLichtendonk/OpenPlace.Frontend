var $1 = Object.defineProperty;
var $g = (m) => {
	throw TypeError(m);
};
var G1 = (m, a, p) =>
	a in m
		? $1(m, a, { enumerable: !0, configurable: !0, writable: !0, value: p })
		: (m[a] = p);
var xr = (m, a, p) => G1(m, typeof a != "symbol" ? a + "" : a, p),
	zf = (m, a, p) => a.has(m) || $g("Cannot " + p);
var ot = (m, a, p) => (
		zf(m, a, "read from private field"), p ? p.call(m) : a.get(m)
	),
	Ar = (m, a, p) =>
		a.has(m)
			? $g("Cannot add the same private member more than once")
			: a instanceof WeakSet
			? a.add(m)
			: a.set(m, p),
	na = (m, a, p, y) => (
		zf(m, a, "write to private field"), y ? y.call(m, p) : a.set(m, p), p
	),
	jr = (m, a, p) => (zf(m, a, "access private method"), p);
import "../chunks/Ch2Ub8FX.js";
import { o as Fn, s as oi } from "../chunks/DoL3ojdE.js";
import {
	a1 as H1,
	b8 as W1,
	bp as X1,
	ba as Y1,
	bq as K1,
	b3 as J1,
	br as Q1,
	au as st,
	g as x,
	aw as se,
	av as bi,
	at as $n,
	p as Lr,
	f as Te,
	d as A,
	r as k,
	s as j,
	u as ft,
	n as yn,
	t as We,
	ax as di,
	b as $,
	c as Dr,
	y as Wr,
	v as Pr,
	bn as Nu,
	x as Mm,
	z as ul,
	ay as er,
	a as Ct,
	b4 as wi,
	aI as ex,
	aH as Gg,
	aJ as tx,
	aL as Iv,
	bs as uo,
	az as pa,
	bt as Mv,
	$ as rx,
} from "../chunks/CMvZtFtm.js";
import { s as de } from "../chunks/DVA6u9-7.js";
import {
	p as zt,
	i as Oe,
	r as nr,
	s as Is,
	u as kv,
} from "../chunks/BF50aS-j.js";
import { h as nx } from "../chunks/P77cUGnY.js";
import {
	r as Ka,
	f as Ni,
	a as zr,
	g as Av,
	b as ar,
	s as Tr,
	e as kc,
	h as Ou,
	c as Yo,
} from "../chunks/C5yqZvKC.js";
import { a as ll, k as ju, t as Ai } from "../chunks/BBgyHb-Z.js";
import { g as km, b as ix } from "../chunks/CyB--sFG.js";
import { p as yi } from "../chunks/B6ZK_HZO.js";
import {
	S as Wi,
	a as Qr,
	t as Fr,
	u as Mt,
	v as So,
	g as ai,
	w as ax,
	x as ox,
	y as sx,
	P as lx,
	z as cx,
	A as ux,
	j as hx,
	B as dx,
	C as Hg,
	D as Lf,
	E as px,
	F as fx,
	d as mx,
	G as _x,
} from "../chunks/BRM3t761.js";
import {
	c as Ev,
	A as aa,
	a as Hf,
	g as Df,
	p as gx,
	b as vx,
} from "../chunks/C0GlPMrk.js";
import { h as Am } from "../chunks/DueIxFLX.js";
import { b as Ko } from "../chunks/0wx1llIh.js";
import { L as yx } from "../chunks/CgCA7Awo.js";
import { g as Ne, l as xx } from "../chunks/CV9xcpLq.js";
import { c as Ah } from "../chunks/CHGjpGz-.js";
import { d as bx, L as Em, p as zm } from "../chunks/BKioTOWR.js";
import {
	c as Wf,
	D as zv,
	p as wx,
	r as Tx,
	t as Cx,
	b as Sx,
	R as Px,
} from "../chunks/Cqwd83E5.js";
import { e as hi, i as hp } from "../chunks/CXkjfmFU.js";
import { c as Lm, b as dp, a as Ix } from "../chunks/Dpga8uG-.js";
import { P as co, t as Lv } from "../chunks/D3yaN7Zl.js";
import {
	l as Mx,
	p as Dm,
	m as Dv,
	v as kx,
	s as Ax,
} from "../chunks/BsOIMr0T.js";
import { g as Oi, a as pp, c as Ex, b as zx } from "../chunks/lE0oaQc5.js";
import { f as cl, t as Lx } from "../chunks/DBSOMMI_.js";
import { A as Dx, c as Ss } from "../chunks/Dt3xBOvm.js";
import {
	A as Rv,
	d as Bv,
	D as Fv,
	a as fp,
	r as Rx,
	I as Wg,
	e as Bx,
	c as Fx,
	P as Ov,
	b as Ox,
} from "../chunks/BA2Qx8r3.js";
import { f as ia, s as Hd } from "../chunks/wZ7b5CwQ.js";
import { C as Rm, G as Xg, c as Nx, T as Xf } from "../chunks/DLfdYhzo.js";
import "../chunks/BOREeBzQ.js";
import { i as Nv } from "../chunks/Z_72d8Vp.js";
import { L as jv } from "../chunks/D3yDgRbd.js";
import { c as xi } from "../chunks/CdTXrPIO.js";
import { L as jx, T as Vv, a as Vx } from "../chunks/Bn0Xcwmn.js";
import { _ as qx } from "../chunks/BI7eddl7.js";
import { c as qv } from "../chunks/C4yB2Gnm.js";
import { R as Zx } from "../chunks/m3o6lEf1.js";
import { W as Ux } from "../chunks/DCynssDD.js";
import { r as $x } from "../chunks/C3E1P42D.js";
(function () {
	try {
		var m =
			typeof window < "u"
				? window
				: typeof global < "u"
				? global
				: typeof globalThis < "u"
				? globalThis
				: typeof self < "u"
				? self
				: {};
		m.SENTRY_RELEASE = { id: "9ccec90dcd6b8d85831cf2b37643f1564d033383" };
	} catch {}
})();
try {
	(function () {
		var m =
				typeof window < "u"
					? window
					: typeof global < "u"
					? global
					: typeof globalThis < "u"
					? globalThis
					: typeof self < "u"
					? self
					: {},
			a = new m.Error().stack;
		a &&
			((m._sentryDebugIds = m._sentryDebugIds || {}),
			(m._sentryDebugIds[a] = "adf93bd4-0a14-4f4e-9af7-5f1b369a26cd"),
			(m._sentryDebugIdIdentifier =
				"sentry-dbid-adf93bd4-0a14-4f4e-9af7-5f1b369a26cd"));
	})();
} catch {}
const Gx = [];
function Hx(m, a = !1, p = !1) {
	return Wd(m, new Map(), "", Gx, null, p);
}
function Wd(m, a, p, y, M = null, z = !1) {
	if (typeof m == "object" && m !== null) {
		var T = a.get(m);
		if (T !== void 0) return T;
		if (m instanceof Map) return new Map(m);
		if (m instanceof Set) return new Set(m);
		if (H1(m)) {
			var s = Array(m.length);
			a.set(m, s), M !== null && a.set(M, s);
			for (var B = 0; B < m.length; B += 1) {
				var O = m[B];
				B in m && (s[B] = Wd(O, a, p, y, null, z));
			}
			return s;
		}
		if (W1(m) === X1) {
			(s = {}), a.set(m, s), M !== null && a.set(M, s);
			for (var X in m) s[X] = Wd(m[X], a, p, y, null, z);
			return s;
		}
		if (m instanceof Date) return structuredClone(m);
		if (typeof m.toJSON == "function" && !z) return Wd(m.toJSON(), a, p, y, m);
	}
	if (m instanceof EventTarget) return m;
	try {
		return structuredClone(m);
	} catch {
		return m;
	}
}
function Wx() {
	return Symbol(Y1);
}
function mp(m, a) {
	K1(window, ["resize"], () => J1(() => a(window[m])));
}
const Xx = Q1,
	Yx = () => "Log in",
	Kx = () => "Entrar",
	Jx = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Yx() : Kx()),
	Qx = () => "Store",
	eb = () => "Loja",
	Zv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Qx() : eb()),
	tb = () => "Alliance",
	rb = () => "Aliança",
	_p = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? tb() : rb()),
	nb = () => "Leaderboard",
	ib = () => "Ranking",
	Bm = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? nb() : ib()),
	ab = () => "Unlock",
	ob = () => "Destravar",
	sb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? ab() : ob()),
	lb = () => "Lock",
	cb = () => "Travar",
	ub = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? lb() : cb()),
	hb = () => "Info",
	db = () => "Informações",
	pb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? hb() : db()),
	fb = () => "Zoom in",
	mb = () => "Aumentar zoom",
	_b = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? fb() : mb()),
	gb = () => "Zoom out",
	vb = () => "Diminuir zoom",
	yb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? gb() : vb()),
	xb = () => "Previous location",
	bb = () => "Localização anterior",
	wb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? xb() : bb()),
	Tb = () => "Offline",
	Cb = () => "Offline",
	Sb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Tb() : Cb()),
	Pb = () => "Zoom in to see the pixels",
	Ib = () => "Amplie para ver os pixels",
	Mb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Pb() : Ib()),
	kb = () => "Phone verification required",
	Ab = () => "Verificação de telefone necessária",
	Yg = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? kb() : Ab()),
	Eb = () => "My location",
	zb = () => "Minha localização",
	Lb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Eb() : zb()),
	Db = () => "You don't have charges to paint. Wait to recharge.",
	Rb = () => "Você não possui tinta para pintar. Aguarde para carrega-las.",
	Bb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Db() : Rb()),
	Fb = () => "Map powered by:",
	Ob = () => "Mapa fornecido por:",
	Nb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Fb() : Ob()),
	jb = () => "OpenMapTiles Data from",
	Vb = () => "OpenMapTiles com dados do",
	qb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? jb() : Vb()),
	Zb = () => "Overview",
	Ub = () => "Visão Geral",
	$b = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Zb() : Ub()),
	Gb = () => "How to paint faster",
	Hb = () => "Como pintar mais rápido",
	Wb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Gb() : Hb()),
	Xb = () => "When painting, click on the button",
	Yb = () => "Quando pintar clique no botão",
	Kb = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Xb() : Yb()),
	Jb = () =>
		"on the top right corner of the screen. This will lock the screen but it'll also enable painting by moving your finger over the map.",
	Qb = () =>
		"no canto superior direito da tela. Isso bloqueará a tela, mas também permitirá pintar movendo o dedo sobre o mapa.",
	e2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Jb() : Qb()),
	t2 = () => "Hold",
	r2 = () => "Segure",
	n2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? t2() : r2()),
	i2 = () => "SPACE",
	a2 = () => "Espaço",
	o2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? i2() : a2()),
	s2 = () => "and move your cursor over the map.",
	l2 = () => "e mova seu cursor sobre o mapa.",
	c2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? s2() : l2()),
	u2 = () => "Explore",
	h2 = () => "Explorar",
	d2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? u2() : h2()),
	p2 = () => "Recharge paint charges",
	f2 = () => "Recarga de tinta",
	m2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? p2() : f2()),
	_2 = () => "Items",
	g2 = () => "Itens",
	v2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? _2() : g2()),
	y2 = () => "Get more charges",
	x2 = () => "Recarregue tinta para pintar",
	b2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? y2() : x2()),
	w2 = (m) => `+${m.amount} Max. Charges`,
	T2 = (m) => `+${m.amount} Tinta máxima`,
	C2 = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? w2(m) : T2(m)),
	S2 = () => "Increase your maximum paint charges capacity",
	P2 = () => "Aumente sua capacidade máxima de tinta",
	I2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? S2() : P2()),
	M2 = () => "Profile picture",
	k2 = () => "Imagem de perfil",
	A2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? M2() : k2()),
	E2 = () => "Add a new 16x16 profile picture",
	z2 = () => "Adicionar uma nova imagem de perfil 16x16",
	L2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? E2() : z2()),
	D2 = () => "Not enough droplets",
	R2 = () => "Droplets insuficientes",
	gp = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? D2() : R2()),
	B2 = () => "Show profile",
	F2 = () => "Exibir perfil",
	O2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? B2() : F2()),
	N2 = () => "Menu",
	j2 = () => "Menu",
	V2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? N2() : j2()),
	q2 = (m) => `Could not install the app: ${m.error}`,
	Z2 = (m) => `Não pode instalar o app: ${m.error}`,
	U2 = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? q2(m) : Z2(m)),
	$2 = () => "Install App",
	G2 = () => "Instalar App",
	H2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? $2() : G2()),
	W2 = () => "Livestreams",
	X2 = () => "Livestreams",
	Y2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? W2() : X2()),
	K2 = () => "Log Out",
	J2 = () => "Log Out",
	Q2 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? K2() : J2()),
	ew = () => "Hide UI",
	tw = () => "Esconder UI",
	rw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? ew() : tw()),
	nw = () => "Change picture:",
	iw = () => "Change picture:",
	aw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? nw() : iw()),
	ow = () => "Show last painted pixel on alliance",
	sw = () => "Mostrar último pixel pintado na aliança",
	lw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? ow() : sw()),
	cw = () => "Delete Account",
	uw = () => "Deletar Conta",
	Yf = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? cw() : uw()),
	hw = () => "Are you absolutely sure?",
	dw = () => "Você tem certeza absoluta?",
	pw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? hw() : dw()),
	fw = () =>
		"This will permanently delete your account and all associated data. This action cannot be undone.",
	mw = () =>
		"Isso excluirá permanentemente sua conta e todos os dados associados. Esta ação não pode ser desfeita.",
	_w = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? fw() : mw()),
	gw = () => "Profile",
	vw = () => "Perfil",
	yw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? gw() : vw()),
	xw = () =>
		"Display your country’s flag next to your username. Plus, when painting in regions where you own the corresponding flag, you recover 10% of the charges spent.",
	bw = () =>
		"Exiba a bandeira do seu país ao lado do seu nome de usuário. Além disso, ao pintar em regiões onde você possui a bandeira correspondente, você recupera 10% das tintas gastas.",
	ww = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? xw() : bw()),
	Tw = () => "Does not need to be equipped to provide the bonus",
	Cw = () => "Não precisa estar equipada para obter o bônus",
	Sw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Tw() : Cw()),
	Pw = () => "Equipped",
	Iw = () => "Equipado",
	Mw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Pw() : Iw()),
	kw = () => "Equip",
	Aw = () => "Equipar",
	Ew = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? kw() : Aw()),
	zw = () => "Country",
	Lw = () => "País",
	Uv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? zw() : Lw()),
	Dw = () => "No country found.",
	Rw = () => "País não encontrado.",
	Bw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Dw() : Rw()),
	Fw = () => "Welcome to",
	Ow = () => "Bem vindo ao",
	Nw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Fw() : Ow()),
	jw = () => "Rules",
	Vw = () => "Regras",
	qw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? jw() : Vw()),
	Zw = () => "Important",
	Uw = () => "Importante",
	$w = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Zw() : Uw()),
	Gw = () =>
		"🚫 No inappropriate content (+18, hate speech, inappropriate links, highly suggestive material, ...)",
	Hw = () =>
		"🚫 Conteúdo inapropriado não permitido (+18, discurso de ódio, links inapropriados, conteúdo altamente sugestivo, ...)",
	Ww = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Gw() : Hw()),
	Xw = () =>
		"😈 Do not paint over other artworks using random colors or patterns just to mess things up",
	Yw = () =>
		"😈 Não desenhe por cima de outras artes usando cores ou padrões aleatórios só para bagunçar",
	Kw = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Xw() : Yw()),
	Jw = () => "🧑‍🤝‍🧑 Do not paint with more than one account",
	Qw = () => "🧑‍🤝‍🧑 Não desenhe com mais de uma conta",
	e5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Jw() : Qw()),
	t5 = () => "🤖 Use of bots is not allowed",
	r5 = () => "🤖 Usar bots não é permitido",
	n5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? t5() : r5()),
	i5 = () => "🙅 Disclosing other's personal information is not allowed",
	a5 = () => "🙅 Divulgar informações pessoais dos outros não é permitido",
	o5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? i5() : a5()),
	s5 = () =>
		"✅ Painting over other artworks to complement them or create a new drawing is allowed",
	l5 = () =>
		"✅ Desenhar sobre outras artes para complementar ou criar novas artes é permitido",
	c5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? s5() : l5()),
	u5 = () =>
		"✅ Griefing political party flags or portraits of politicians is allowed",
	h5 = () =>
		"✅ Desenhar sobre bandeiras de partidos e retratos de políticos é permitido",
	d5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? u5() : h5()),
	p5 = () =>
		"Violations of these rules may lead to suspension of your account or removal of drawings.",
	f5 = () =>
		"A violação destas regras pode levar à suspensão da conta ou à remoção de desenhos.",
	m5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? p5() : f5()),
	_5 = () => "Understood",
	g5 = () => "Entendido",
	v5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? _5() : g5()),
	y5 = () => "Toggle art opacity",
	x5 = () => "Alterar opacidade",
	$v = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? y5() : x5()),
	b5 = () => "Paint",
	w5 = () => "Pintar",
	Gv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? b5() : w5()),
	T5 = () => "Select a color",
	C5 = () => "Selecione uma color",
	S5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? T5() : C5()),
	P5 = () => "Select a pixel to erase",
	I5 = () => "Selecione um pixel para apagar",
	M5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? P5() : I5()),
	k5 = () => "Pick a color from the map",
	A5 = () => "Escolha uma cor do mapa",
	E5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? k5() : A5()),
	z5 = () => "Click",
	L5 = () => "Clique",
	D5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? z5() : L5()),
	R5 = () => "SPACE",
	B5 = () => "ESPAÇO",
	F5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? R5() : B5()),
	O5 = () => "or hold",
	N5 = () => "ou segure",
	j5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? O5() : N5()),
	V5 = () => "to paint,",
	q5 = () => "para pintar",
	Z5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? V5() : q5()),
	U5 = () => "You can paint more than 1 pixel",
	$5 = () => "Você pode pintar mais de 1 pixel",
	G5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? U5() : $5()),
	H5 = () => "Paint pixel",
	W5 = () => "Pintar pixel",
	X5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? H5() : W5()),
	Y5 = () => "Color Picker",
	K5 = () => "Conta Gotas",
	J5 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Y5() : K5()),
	Q5 = () => "+2 max. charge/level",
	e3 = () => "+2 tinta máxima/level",
	t3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Q5() : e3()),
	r3 = () => "Name",
	n3 = () => "Nome",
	Kf = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? r3() : n3()),
	i3 = () => "Discord Username",
	a3 = () => "Usuário do Discord",
	o3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? i3() : a3()),
	s3 = () => "Max. Charges",
	l3 = () => "Tinta máxima",
	Kg = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? s3() : l3()),
	c3 = () => "Paint Charges",
	u3 = () => "Tintas",
	h3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? c3() : u3()),
	d3 = (m) => `+${m.amount} Paint Charges`,
	p3 = (m) => `+${m.amount} Tintas`,
	f3 = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? d3(m) : p3(m)),
	m3 = () => "Leave alliance",
	_3 = () => "Sair da aliança",
	g3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? m3() : _3()),
	v3 = () => "Headquarters",
	y3 = () => "Quartel General",
	x3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? v3() : y3()),
	b3 = () => "Not set",
	w3 = () => "Não configurado",
	T3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? b3() : w3()),
	C3 = () => "You are not in an alliance",
	S3 = () => "Você não está em uma aliança",
	P3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? C3() : S3()),
	I3 = () => "Get invited to an alliance",
	M3 = () => "Seja convidado para uma aliança",
	k3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? I3() : M3()),
	A3 = () => "OR",
	E3 = () => "OU",
	z3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? A3() : E3()),
	L3 = () => "Create an alliance",
	D3 = () => "Crie uma aliança",
	R3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? L3() : D3()),
	B3 = () => "Invite link",
	F3 = () => "Link de convite",
	O3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? B3() : F3()),
	N3 = () =>
		"Send the link below to everybody you want to invite to the alliance",
	j3 = () =>
		"Envie o link abaixo para quem você deseja convidar para a aliança",
	V3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? N3() : j3()),
	q3 = () => "Copied",
	Z3 = () => "Copiado",
	Fm = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? q3() : Z3()),
	U3 = () => "No description",
	$3 = () => "Sem descrição",
	Hv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? U3() : $3()),
	G3 = () => "Invite",
	H3 = () => "Convite",
	W3 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? G3() : H3()),
	X3 = () => "No pixels painted",
	Y3 = () => "Nenhum pixel pintado",
	Om = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? X3() : Y3()),
	K3 = () => "Today",
	J3 = () => "Hoje",
	vp = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? K3() : J3()),
	Q3 = () => "Week",
	eT = () => "Semana",
	tT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? Q3() : eT()),
	rT = () => "Month",
	nT = () => "Mês",
	iT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? rT() : nT()),
	aT = () => "All time",
	oT = () => "Geral",
	sT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? aT() : oT()),
	lT = () => "this week",
	cT = () => "nesta semana",
	Nm = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? lT() : cT()),
	uT = () => "this month",
	hT = () => "neste mês",
	jm = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? uT() : hT()),
	dT = () => "Create alliance",
	pT = () => "Criar aliança",
	fT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? dT() : pT()),
	mT = () => "Alliance Name",
	_T = () => "Nome da aliança",
	gT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? mT() : _T()),
	vT = () => "Create",
	yT = () => "Criar",
	xT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? vT() : yT()),
	bT = () => "Give admin",
	wT = () => "Tornar admin",
	TT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? bT() : wT()),
	CT = () => "Ban from alliance",
	ST = () => "Banir da aliança",
	Wv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? CT() : ST()),
	PT = () => "No action",
	IT = () => "Sem opção",
	MT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? PT() : IT()),
	kT = () => "Unban",
	AT = () => "Desbanir",
	ET = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? kT() : AT()),
	zT = () => "No banned users",
	LT = () => "Sem usuários banidos",
	DT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? zT() : LT()),
	RT = () => "Update",
	BT = () => "Atualizar",
	FT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? RT() : BT()),
	OT = () => "Error giving admin to user",
	NT = () => "Erro ao tornar usuário admin",
	jT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? OT() : NT()),
	VT = () => "Users",
	qT = () => "Usuários",
	ZT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? VT() : qT()),
	UT = () => "Banned",
	$T = () => "Banido",
	Xv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? UT() : $T()),
	GT = () => "Regions",
	HT = () => "Regiões",
	WT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? GT() : HT()),
	XT = () => "Countries",
	YT = () => "Países",
	KT = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? XT() : YT()),
	JT = () => "Players",
	QT = () => "Jogadores",
	Yv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? JT() : QT()),
	eC = () => "Alliances",
	tC = () => "Alianças",
	Kv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? eC() : tC()),
	rC = () => "Region",
	nC = () => "Região",
	iC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? rC() : nC()),
	aC = () => "Pixels",
	oC = () => "Pixels",
	vc = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? aC() : oC()),
	sC = () => "Painted",
	lC = () => "Pintados",
	yc = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? sC() : lC()),
	cC = () => "Pixels painted inside the region",
	uC = () => "Pixels pintados dentro da região",
	hC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? cC() : uC()),
	dC = () => "Not painted",
	pC = () => "Não pintado",
	fC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? dC() : pC()),
	mC = () => "Painted by",
	_C = () => "Pintado por",
	gC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? mC() : _C()),
	vC = () => "Limit reached",
	yC = () => "Limite atingido",
	xC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? vC() : yC()),
	bC = () => "Favorite",
	wC = () => "Favoritar",
	TC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? bC() : wC()),
	CC = () => "Share",
	SC = () => "Compartilhar",
	PC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? CC() : SC()),
	IC = () => "Share place",
	MC = () => "Compartilhar local",
	kC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? IC() : MC()),
	AC = () => "Mute",
	EC = () => "Mutar",
	zC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? AC() : EC()),
	LC = () => "Unmute",
	DC = () => "Desmutar",
	RC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? LC() : DC()),
	BC = () => "Select the headquarters location",
	FC = () => "Selecione a localização do quartel general",
	OC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? BC() : FC()),
	NC = () => "Pixels painted inside the country",
	jC = () => "Pixels pintados dentro do país",
	VC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? NC() : jC()),
	qC = () => "Username copied to clipboard",
	ZC = () => "Usuário copiado",
	UC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? qC() : ZC()),
	$C = () => "No more charges",
	GC = () => "Acabou a tinta",
	HC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? $C() : GC()),
	WC = () =>
		"You are not allowed to use multiple accounts. Use your main account to paint.",
	XC = () =>
		"Não é permitido usar várias contas. Use sua conta principal para pintar.",
	YC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? WC() : XC()),
	KC = () => "SMS sent to",
	JC = () => "SMS enviado para",
	QC = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? KC() : JC()),
	eS = () => "Phone successfully verified",
	tS = () => "Telefone verificado com sucesso",
	rS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? eS() : tS()),
	nS = () => "Not a valid phone number",
	iS = () => "Não é um número válido",
	aS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? nS() : iS()),
	oS = () => "Location unfavorited",
	sS = () => "Localização desfavoritada",
	lS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? oS() : sS()),
	cS = () => "Location favorited",
	uS = () => "Localização favoritada",
	hS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? cS() : uS()),
	dS = () => "Giving admin to user",
	pS = () => "Tornar usuário um admin",
	fS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? dS() : pS()),
	mS = () => "Profile updated",
	_S = () => "Perfil atualizado",
	gS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? mS() : _S()),
	vS = () => "Successfully linked your Discord account.",
	yS = () => "A sua conta Discord foi conectada com sucesso.",
	xS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? vS() : yS()),
	bS = () => "Discord unlinked",
	wS = () => "Discord desconectado",
	TS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? bS() : wS()),
	CS = () => "Link your Discord",
	SS = () => "Conectar Discord",
	PS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? CS() : SS()),
	IS = (m) => `Unlink Discord (${m.username})`,
	MS = (m) => `Desconectar Discord (${m.username})`,
	kS = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? IS(m) : MS(m)),
	AS = () => "Account successfully deleted",
	ES = () => "Conta deletada com sucesso",
	zS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? AS() : ES()),
	LS = () => "Logged out",
	DS = () => "Logout feito",
	RS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? LS() : DS()),
	BS = () => "Could not logout. Try refreshing the page.",
	FS = () => "Não foi possível sair da conta. Tente recarregar a página.",
	OS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? BS() : FS()),
	NS = () => "You need to zoom in to select a pixel",
	jS = () => "Dê zoom para selecionar um pixel",
	VS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? NS() : jS()),
	qS = () => "Phone verification",
	ZS = () => "Verificação de telefone",
	US = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? qS() : ZS()),
	$S = () =>
		"Please verify your phone number to continue playing. This helps us keep bots out and ensure a safe, creative experience for everyone.",
	GS = () =>
		"Por favor, verifique com seu telefone para continuar jogando. Isso nos ajuda a filtrar bots e manter um experiência segura e criativa para todos.",
	HS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? $S() : GS()),
	WS = () => "Send Code",
	XS = () => "Enviar o código",
	YS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? WS() : XS()),
	KS = () => "Input the code",
	JS = () => "Insira o código",
	QS = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? KS() : JS()),
	eP = () => "Sent to",
	tP = () => "Enviar para",
	rP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? eP() : tP()),
	nP = () => "Resend Code",
	iP = () => "Reenviar Código",
	aP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? nP() : iP()),
	oP = () => "Try another number",
	sP = () => "Tentar outro número",
	lP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? oP() : sP()),
	cP = () => "Edit profile",
	uP = () => "Editar perfil",
	hP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? cP() : uP()),
	dP = () => "Image",
	pP = () => "Imagem",
	fP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? dP() : pP()),
	mP = () => "Download",
	_P = () => "Download",
	gP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? mP() : _P()),
	vP = () => "Image copied to clipboard",
	yP = () => "Imagem copiada para a área de transferência",
	xP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? vP() : yP()),
	bP = () => "My map is lagging",
	wP = () => "Meu mapa está travando",
	TP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? bP() : wP()),
	CP = () => "Verify if",
	SP = () => "Verifique se",
	PP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? CP() : SP()),
	IP = () => "Use hardware acceleration when available",
	MP = () => "Usar aceleração gráfica quando disponível",
	kP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? IP() : MP()),
	AP = () => "is enabled on",
	EP = () => "está habilitado em",
	zP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? AP() : EP()),
	LP = () => "Follow the instructions to enable hardware acceleration",
	DP = () => "Siga a instrução para habilitar a aceleração de hardware",
	RP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? LP() : DP()),
	BP = () => "Moderation",
	FP = () => "Moderação",
	OP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? BP() : FP()),
	NP = () => "Terms",
	jP = () => "Termos",
	VP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? NP() : jP()),
	qP = () => "Privacy",
	ZP = () => "Privacidade",
	UP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? qP() : ZP()),
	$P = () => "Refund",
	GP = () => "Reembolso",
	Jv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? $P() : GP()),
	HP = () => "Clear area",
	WP = () => "Limpar área",
	XP = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? HP() : WP()),
	YP = () => "Select the area's first corner",
	KP = () => "Selecione o primeiro canto da área",
	Qv = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? YP() : KP()),
	JP = () => "Select the area's opposite corner",
	QP = () => "Selecione o canto oposto da área",
	e0 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? JP() : QP()),
	eI = () => "Admin",
	tI = () => "Administração",
	rI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? eI() : tI()),
	nI = (m) => `Reason: ${m.reason}`,
	iI = (m) => `Motivo: ${m.reason}`,
	aI = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? nI(m) : iI(m)),
	oI = () => "No corresponding region on the map (cosmetic effect only)",
	sI = () => "Não possui região no mapa (apenas efeito cosmético)",
	lI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? oI() : sI()),
	cI = () => "Flag without region on the map",
	uI = () => "Bandeira sem região no mapa",
	hI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? cI() : uI()),
	dI = (m) =>
		`The flag of <b>${m.country}</b> does not have corresponding areas on the map and will only have cosmetic effects.`,
	pI = (m) =>
		`A bandeira <b>${m.country}</b> não possui regiões correspondente no mapa e só terá efeito cosmético.`,
	fI = (m, a = {}) => ((a.locale ?? Ne()) === "en" ? dI(m) : pI(m)),
	mI = () => "Dark mode",
	_I = () => "Modo escuro",
	gI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? mI() : _I()),
	vI = () => "Light mode",
	yI = () => "Modo claro",
	xI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? vI() : yI()),
	bI = () => "Log out from all devices",
	wI = () => "Sair de todos os dispositivos",
	TI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? bI() : wI()),
	CI = () => "Log out from all devices",
	SI = () => "Sair de todos os dispositivos",
	PI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? CI() : SI()),
	II = () => "This action will log your account out from all devices.",
	MI = () => "Essa ação ira desconectar sua conta de todos os dispositivos.",
	kI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? II() : MI()),
	AI = () => "Sessions successfully revoked",
	EI = () => "Sessões encerradas com sucesso",
	zI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? AI() : EI()),
	LI = () => "Error revoking sessions. Try again later.",
	DI = () => "Erro ao encerrar sessões. Tente novamente mais tarde.",
	RI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? LI() : DI()),
	BI = () => "More",
	FI = () => "Mais",
	OI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? BI() : FI()),
	NI = () => "This action is irreversible, do you want to proceed?",
	jI = () => "Esta ação é irreversível,você quer prosseguir?",
	VI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? NI() : jI()),
	qI = () => "Please confirm by entering your username:",
	ZI = () => "Por favor, confirme digitando seu nome de usuário:",
	UI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? qI() : ZI()),
	$I = () => "Type your username",
	GI = () => "Digite seu nome de usuário",
	HI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? $I() : GI()),
	WI = () => "This action may take some time to be completed.",
	XI = () => "Essa ação pode levar algum tempo para ser realizada.",
	YI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? WI() : XI()),
	KI = () => "Ban appeal",
	JI = () => "Revisão de banimento",
	QI = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? KI() : JI()),
	e4 = () => "Suggestions",
	t4 = () => "Sugestões",
	r4 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? e4() : t4()),
	n4 = () => "Bug report",
	i4 = () => "Reportar bug",
	a4 = (m = {}, a = {}) => ((a.locale ?? Ne()) === "en" ? n4() : i4()),
	$o = (2 * Math.PI * 6378137) / 2;
class fl {
	constructor(a = 256) {
		xr(this, "initialResolution");
		(this.tileSize = a), (this.initialResolution = (2 * $o) / this.tileSize);
	}
	latLonToMeters(a, p) {
		const y = (p / 180) * $o,
			M =
				((Math.log(Math.tan(((90 + a) * Math.PI) / 360)) / (Math.PI / 180)) *
					$o) /
				180;
		return [y, M];
	}
	metersToLatLon(a, p) {
		const y = (a / $o) * 180;
		let M = (p / $o) * 180;
		return (
			(M =
				(180 / Math.PI) *
				(2 * Math.atan(Math.exp((M * Math.PI) / 180)) - Math.PI / 2)),
			[M, y]
		);
	}
	pixelsToMeters(a, p, y) {
		const M = this.resolution(y),
			z = a * M - $o,
			T = $o - p * M;
		return [z, T];
	}
	pixelsToLatLon(a, p, y) {
		const [M, z] = this.pixelsToMeters(a, p, y);
		return this.metersToLatLon(M, z);
	}
	latLonToPixels(a, p, y) {
		const [M, z] = this.latLonToMeters(a, p);
		return this.metersToPixels(M, z, y);
	}
	latLonToPixelsFloor(a, p, y) {
		const [M, z] = this.latLonToPixels(a, p, y);
		return [Math.floor(M), Math.floor(z)];
	}
	metersToPixels(a, p, y) {
		const M = this.resolution(y),
			z = (a + $o) / M,
			T = ($o - p) / M;
		return [z, T];
	}
	latLonToTile(a, p, y) {
		const [M, z] = this.latLonToMeters(a, p);
		return this.metersToTile(M, z, y);
	}
	metersToTile(a, p, y) {
		const [M, z] = this.metersToPixels(a, p, y);
		return this.pixelsToTile(M, z);
	}
	pixelsToTile(a, p) {
		const y = Math.ceil(a / this.tileSize) - 1,
			M = Math.ceil(p / this.tileSize) - 1;
		return [y, M];
	}
	pixelsToTileLocal(a, p) {
		return {
			tile: this.pixelsToTile(a, p),
			pixel: [Math.floor(a) % this.tileSize, Math.floor(p) % this.tileSize],
		};
	}
	tileBounds(a, p, y) {
		const [M, z] = this.pixelsToMeters(a * this.tileSize, p * this.tileSize, y),
			[T, s] = this.pixelsToMeters(
				(a + 1) * this.tileSize,
				(p + 1) * this.tileSize,
				y
			);
		return { min: [M, z], max: [T, s] };
	}
	tileBoundsLatLon(a, p, y) {
		const M = this.tileBounds(a, p, y);
		return {
			min: this.metersToLatLon(M.min[0], M.min[1]),
			max: this.metersToLatLon(M.max[0], M.max[1]),
		};
	}
	resolution(a) {
		return this.initialResolution / 2 ** a;
	}
	latLonToTileAndPixel(a, p, y) {
		const [M, z] = this.latLonToMeters(a, p),
			[T, s] = this.metersToTile(M, z, y),
			[B, O] = this.metersToPixels(M, z, y);
		return {
			tile: [T, s],
			pixel: [Math.floor(B) % this.tileSize, Math.floor(O) % this.tileSize],
		};
	}
	pixelBounds(a, p, y) {
		return {
			min: this.pixelsToMeters(a, p, y),
			max: this.pixelsToMeters(a + 1, p + 1, y),
		};
	}
	pixelToBoundsLatLon(a, p, y) {
		const M = this.pixelBounds(a, p, y),
			z = 0.001885,
			T = (M.max[0] - M.min[0]) * z,
			s = (M.max[1] - M.min[1]) * z;
		return (
			(M.min[0] -= T),
			(M.max[0] -= T),
			(M.min[1] -= s),
			(M.max[1] -= s),
			{
				min: this.metersToLatLon(M.min[0], M.min[1]),
				max: this.metersToLatLon(M.max[0], M.max[1]),
			}
		);
	}
	latLonToTileBoundsLatLon(a, p, y) {
		const [M, z] = this.latLonToMeters(a, p),
			[T, s] = this.metersToTile(M, z, y);
		return this.tileBoundsLatLon(T, s, y);
	}
	latLonToPixelBoundsLatLon(a, p, y) {
		const [M, z] = this.latLonToMeters(a, p),
			[T, s] = this.metersToPixels(M, z, y);
		return this.pixelToBoundsLatLon(Math.floor(T), Math.floor(s), y);
	}
	latLonToRegionAndPixel(a, p, y, M = Wi.regionSize) {
		const [z, T] = this.latLonToPixelsFloor(a, p, y),
			s = this.tileSize * M;
		return {
			region: [Math.floor(z / s), Math.floor(T / s)],
			pixel: [z % s, T % s],
		};
	}
}
function Vm(m, a = !0) {
	const { min: p, max: y } = m;
	return a
		? [
				[p[1], y[0]],
				[y[1], y[0]],
				[y[1], p[0]],
				[p[1], p[0]],
		  ]
		: [
				[p[0], y[1]],
				[y[0], y[1]],
				[y[0], p[1]],
				[p[0], p[1]],
		  ];
}
function qm(m) {
	return [(m.min[0] + m.max[0]) / 2, (m.min[1] + m.max[1]) / 2];
}
const o4 =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==",
	Jg =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=";
function s4(m) {
	return Math.floor(Math.random() * m);
}
const Jf = 14.5;
async function l4() {
	const m = h4();
	if (m) return m;
	try {
		if (
			(await navigator.permissions.query({ name: "geolocation" })).state ===
			"granted"
		) {
			const p = await new Promise((y, M) =>
				navigator.geolocation.getCurrentPosition(
					(z) => y(z),
					(z) => M(z)
				)
			);
			return { lat: p.coords.latitude, lng: p.coords.longitude, zoom: Jf };
		}
	} catch (a) {
		console.error(a);
	}
	return { ...c4().pos, zoom: Jf };
}
function c4() {
	const m = Object.entries(u4),
		a = s4(m.length),
		[p, y] = m[a];
	return { city: p, pos: y };
}
const u4 = {
		tokyo: { lat: 35.677545560719665, lng: 139.76394445809638 },
		paris: { lat: 48.8537151734952, lng: 2.3484026030630787 },
		newYork: { lat: 40.71283173786517, lng: -74.00599771376795 },
		saoPaulo: { lat: -23.550584064565356, lng: -46.63339720713918 },
		sydney: { lat: -33.86943325619071, lng: 151.2083447239608 },
	},
	t0 = "location";
function Co(m, a) {
	localStorage.setItem(t0, JSON.stringify({ ...m, zoom: a }));
}
function h4() {
	const m = localStorage.getItem(t0);
	if (!m) return;
	const a = JSON.parse(m);
	return a.zoom ?? (a.zoom = Jf), a;
}
var Hu, Wu;
class d4 {
	constructor() {
		Ar(this, Hu, st(-1));
		Ar(this, Wu, st([]));
	}
	get idx() {
		return x(ot(this, Hu));
	}
	set idx(a) {
		se(ot(this, Hu), a, !0);
	}
	get entries() {
		return x(ot(this, Wu));
	}
	set entries(a) {
		se(ot(this, Wu), a);
	}
	hasNext() {
		return this.idx < this.entries.length - 1;
	}
	goToNext(a) {
		const p = this.idx + 1,
			y = this.entries[p];
		y && ((this.idx = p), a.flyTo({ center: y.pos, zoom: y.zoom }));
	}
	hasPrev() {
		return this.idx > 0;
	}
	goToPrev(a) {
		const p = this.idx - 1,
			y = this.entries[p];
		y && ((this.idx = p), a.flyTo({ center: y.pos, zoom: y.zoom }));
	}
	isEmpty() {
		return this.entries.length === 0;
	}
	push(a) {
		(this.idx = this.idx + 1),
			(this.entries = [...this.entries.slice(0, this.idx), a]);
	}
}
(Hu = new WeakMap()), (Wu = new WeakMap());
const hl = new d4();
function Zm(m) {
	return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default")
		? m.default
		: m;
}
var Xd = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.6.2/LICENSE.txt
 */ var p4 = Xd.exports,
	Qg;
function f4() {
	return (
		Qg ||
			((Qg = 1),
			(function (m, a) {
				(function (p, y) {
					m.exports = y();
				})(p4, function () {
					var p = {},
						y = {};
					function M(T, s, B) {
						if (((y[T] = B), T === "index")) {
							var O =
									"var sharedModule = {}; (" +
									y.shared +
									")(sharedModule); (" +
									y.worker +
									")(sharedModule);",
								X = {};
							return (
								y.shared(X),
								y.index(p, X),
								typeof window < "u" &&
									p.setWorkerUrl(
										window.URL.createObjectURL(
											new Blob([O], { type: "text/javascript" })
										)
									),
								p
							);
						}
					}
					M("shared", ["exports"], function (T) {
						function s(n, t, r, o) {
							return new (r || (r = Promise))(function (c, f) {
								function _(S) {
									try {
										b(o.next(S));
									} catch (I) {
										f(I);
									}
								}
								function v(S) {
									try {
										b(o.throw(S));
									} catch (I) {
										f(I);
									}
								}
								function b(S) {
									var I;
									S.done
										? c(S.value)
										: ((I = S.value),
										  I instanceof r
												? I
												: new r(function (L) {
														L(I);
												  })).then(_, v);
								}
								b((o = o.apply(n, t || [])).next());
							});
						}
						function B(n, t) {
							(this.x = n), (this.y = t);
						}
						function O(n) {
							return n &&
								n.__esModule &&
								Object.prototype.hasOwnProperty.call(n, "default")
								? n.default
								: n;
						}
						var X, K;
						typeof SuppressedError == "function" && SuppressedError,
							(B.prototype = {
								clone() {
									return new B(this.x, this.y);
								},
								add(n) {
									return this.clone()._add(n);
								},
								sub(n) {
									return this.clone()._sub(n);
								},
								multByPoint(n) {
									return this.clone()._multByPoint(n);
								},
								divByPoint(n) {
									return this.clone()._divByPoint(n);
								},
								mult(n) {
									return this.clone()._mult(n);
								},
								div(n) {
									return this.clone()._div(n);
								},
								rotate(n) {
									return this.clone()._rotate(n);
								},
								rotateAround(n, t) {
									return this.clone()._rotateAround(n, t);
								},
								matMult(n) {
									return this.clone()._matMult(n);
								},
								unit() {
									return this.clone()._unit();
								},
								perp() {
									return this.clone()._perp();
								},
								round() {
									return this.clone()._round();
								},
								mag() {
									return Math.sqrt(this.x * this.x + this.y * this.y);
								},
								equals(n) {
									return this.x === n.x && this.y === n.y;
								},
								dist(n) {
									return Math.sqrt(this.distSqr(n));
								},
								distSqr(n) {
									const t = n.x - this.x,
										r = n.y - this.y;
									return t * t + r * r;
								},
								angle() {
									return Math.atan2(this.y, this.x);
								},
								angleTo(n) {
									return Math.atan2(this.y - n.y, this.x - n.x);
								},
								angleWith(n) {
									return this.angleWithSep(n.x, n.y);
								},
								angleWithSep(n, t) {
									return Math.atan2(
										this.x * t - this.y * n,
										this.x * n + this.y * t
									);
								},
								_matMult(n) {
									const t = n[2] * this.x + n[3] * this.y;
									return (
										(this.x = n[0] * this.x + n[1] * this.y), (this.y = t), this
									);
								},
								_add(n) {
									return (this.x += n.x), (this.y += n.y), this;
								},
								_sub(n) {
									return (this.x -= n.x), (this.y -= n.y), this;
								},
								_mult(n) {
									return (this.x *= n), (this.y *= n), this;
								},
								_div(n) {
									return (this.x /= n), (this.y /= n), this;
								},
								_multByPoint(n) {
									return (this.x *= n.x), (this.y *= n.y), this;
								},
								_divByPoint(n) {
									return (this.x /= n.x), (this.y /= n.y), this;
								},
								_unit() {
									return this._div(this.mag()), this;
								},
								_perp() {
									const n = this.y;
									return (this.y = this.x), (this.x = -n), this;
								},
								_rotate(n) {
									const t = Math.cos(n),
										r = Math.sin(n),
										o = r * this.x + t * this.y;
									return (this.x = t * this.x - r * this.y), (this.y = o), this;
								},
								_rotateAround(n, t) {
									const r = Math.cos(n),
										o = Math.sin(n),
										c = t.y + o * (this.x - t.x) + r * (this.y - t.y);
									return (
										(this.x = t.x + r * (this.x - t.x) - o * (this.y - t.y)),
										(this.y = c),
										this
									);
								},
								_round() {
									return (
										(this.x = Math.round(this.x)),
										(this.y = Math.round(this.y)),
										this
									);
								},
								constructor: B,
							}),
							(B.convert = function (n) {
								if (n instanceof B) return n;
								if (Array.isArray(n)) return new B(+n[0], +n[1]);
								if (n.x !== void 0 && n.y !== void 0) return new B(+n.x, +n.y);
								throw new Error("Expected [x, y] or {x, y} point format");
							});
						var ne = (function () {
								if (K) return X;
								function n(t, r, o, c) {
									(this.cx = 3 * t),
										(this.bx = 3 * (o - t) - this.cx),
										(this.ax = 1 - this.cx - this.bx),
										(this.cy = 3 * r),
										(this.by = 3 * (c - r) - this.cy),
										(this.ay = 1 - this.cy - this.by),
										(this.p1x = t),
										(this.p1y = r),
										(this.p2x = o),
										(this.p2y = c);
								}
								return (
									(K = 1),
									(X = n),
									(n.prototype = {
										sampleCurveX: function (t) {
											return ((this.ax * t + this.bx) * t + this.cx) * t;
										},
										sampleCurveY: function (t) {
											return ((this.ay * t + this.by) * t + this.cy) * t;
										},
										sampleCurveDerivativeX: function (t) {
											return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
										},
										solveCurveX: function (t, r) {
											if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
											if (t > 1) return 1;
											for (var o = t, c = 0; c < 8; c++) {
												var f = this.sampleCurveX(o) - t;
												if (Math.abs(f) < r) return o;
												var _ = this.sampleCurveDerivativeX(o);
												if (Math.abs(_) < 1e-6) break;
												o -= f / _;
											}
											var v = 0,
												b = 1;
											for (
												o = t, c = 0;
												c < 20 &&
												((f = this.sampleCurveX(o)), !(Math.abs(f - t) < r));
												c++
											)
												t > f ? (v = o) : (b = o), (o = 0.5 * (b - v) + v);
											return o;
										},
										solve: function (t, r) {
											return this.sampleCurveY(this.solveCurveX(t, r));
										},
									}),
									X
								);
							})(),
							H = O(ne);
						let fe, ge;
						function Ie() {
							return (
								fe == null &&
									(fe =
										typeof OffscreenCanvas < "u" &&
										new OffscreenCanvas(1, 1).getContext("2d") &&
										typeof createImageBitmap == "function"),
								fe
							);
						}
						function Ae() {
							if (ge == null && ((ge = !1), Ie())) {
								const t = new OffscreenCanvas(5, 5).getContext("2d", {
									willReadFrequently: !0,
								});
								if (t) {
									for (let o = 0; o < 25; o++) {
										const c = 4 * o;
										(t.fillStyle = `rgb(${c},${c + 1},${c + 2})`),
											t.fillRect(o % 5, Math.floor(o / 5), 1, 1);
									}
									const r = t.getImageData(0, 0, 5, 5).data;
									for (let o = 0; o < 100; o++)
										if (o % 4 != 3 && r[o] !== o) {
											ge = !0;
											break;
										}
								}
							}
							return ge || !1;
						}
						var De = 1e-6,
							Ee = typeof Float32Array < "u" ? Float32Array : Array;
						function Fe() {
							var n = new Ee(9);
							return (
								Ee != Float32Array &&
									((n[1] = 0),
									(n[2] = 0),
									(n[3] = 0),
									(n[5] = 0),
									(n[6] = 0),
									(n[7] = 0)),
								(n[0] = 1),
								(n[4] = 1),
								(n[8] = 1),
								n
							);
						}
						function $e(n) {
							return (
								(n[0] = 1),
								(n[1] = 0),
								(n[2] = 0),
								(n[3] = 0),
								(n[4] = 0),
								(n[5] = 1),
								(n[6] = 0),
								(n[7] = 0),
								(n[8] = 0),
								(n[9] = 0),
								(n[10] = 1),
								(n[11] = 0),
								(n[12] = 0),
								(n[13] = 0),
								(n[14] = 0),
								(n[15] = 1),
								n
							);
						}
						function Je() {
							var n = new Ee(3);
							return (
								Ee != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)), n
							);
						}
						function qe(n) {
							return Math.hypot(n[0], n[1], n[2]);
						}
						function Ze(n, t, r) {
							var o = new Ee(3);
							return (o[0] = n), (o[1] = t), (o[2] = r), o;
						}
						function Qe(n, t, r) {
							return (
								(n[0] = t[0] + r[0]),
								(n[1] = t[1] + r[1]),
								(n[2] = t[2] + r[2]),
								n
							);
						}
						function Le(n, t, r) {
							return (n[0] = t[0] * r), (n[1] = t[1] * r), (n[2] = t[2] * r), n;
						}
						function et(n, t, r) {
							var o = t[0],
								c = t[1],
								f = t[2],
								_ = r[0],
								v = r[1],
								b = r[2];
							return (
								(n[0] = c * b - f * v),
								(n[1] = f * _ - o * b),
								(n[2] = o * v - c * _),
								n
							);
						}
						Math.hypot ||
							(Math.hypot = function () {
								for (var n = 0, t = arguments.length; t--; )
									n += arguments[t] * arguments[t];
								return Math.sqrt(n);
							});
						var nt,
							Ue = qe;
						function ke(n, t, r) {
							var o = t[0],
								c = t[1],
								f = t[2],
								_ = t[3];
							return (
								(n[0] = r[0] * o + r[4] * c + r[8] * f + r[12] * _),
								(n[1] = r[1] * o + r[5] * c + r[9] * f + r[13] * _),
								(n[2] = r[2] * o + r[6] * c + r[10] * f + r[14] * _),
								(n[3] = r[3] * o + r[7] * c + r[11] * f + r[15] * _),
								n
							);
						}
						function vt() {
							var n = new Ee(4);
							return (
								Ee != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
								(n[3] = 1),
								n
							);
						}
						function ee(n, t, r, o) {
							var c = (0.5 * Math.PI) / 180;
							(t *= c), (r *= c), (o *= c);
							var f = Math.sin(t),
								_ = Math.cos(t),
								v = Math.sin(r),
								b = Math.cos(r),
								S = Math.sin(o),
								I = Math.cos(o);
							return (
								(n[0] = f * b * I - _ * v * S),
								(n[1] = _ * v * I + f * b * S),
								(n[2] = _ * b * S - f * v * I),
								(n[3] = _ * b * I + f * v * S),
								n
							);
						}
						function re() {
							var n = new Ee(2);
							return Ee != Float32Array && ((n[0] = 0), (n[1] = 0)), n;
						}
						function he(n, t) {
							var r = new Ee(2);
							return (r[0] = n), (r[1] = t), r;
						}
						Je(),
							(nt = new Ee(4)),
							Ee != Float32Array &&
								((nt[0] = 0), (nt[1] = 0), (nt[2] = 0), (nt[3] = 0)),
							Je(),
							Ze(1, 0, 0),
							Ze(0, 1, 0),
							vt(),
							vt(),
							Fe(),
							re();
						const oe = 8192;
						function ze(n, t, r) {
							return (
								t * (oe / (n.tileSize * Math.pow(2, r - n.tileID.overscaledZ)))
							);
						}
						function je(n, t) {
							return ((n % t) + t) % t;
						}
						function pt(n, t, r) {
							return n * (1 - r) + t * r;
						}
						function it(n) {
							if (n <= 0) return 0;
							if (n >= 1) return 1;
							const t = n * n,
								r = t * n;
							return 4 * (n < 0.5 ? r : 3 * (n - t) + r - 0.75);
						}
						function ct(n, t, r, o) {
							const c = new H(n, t, r, o);
							return (f) => c.solve(f);
						}
						const It = ct(0.25, 0.1, 0.25, 1);
						function Dt(n, t, r) {
							return Math.min(r, Math.max(t, n));
						}
						function at(n, t, r) {
							const o = r - t,
								c = ((((n - t) % o) + o) % o) + t;
							return c === t ? r : c;
						}
						function dt(n, ...t) {
							for (const r of t) for (const o in r) n[o] = r[o];
							return n;
						}
						let yt = 1;
						function xt(n, t, r) {
							const o = {};
							for (const c in n) o[c] = t.call(this, n[c], c, n);
							return o;
						}
						function St(n, t, r) {
							const o = {};
							for (const c in n) t.call(this, n[c], c, n) && (o[c] = n[c]);
							return o;
						}
						function wt(n) {
							return Array.isArray(n)
								? n.map(wt)
								: typeof n == "object" && n
								? xt(n, wt)
								: n;
						}
						const _t = {};
						function Lt(n) {
							_t[n] || (typeof console < "u" && console.warn(n), (_t[n] = !0));
						}
						function Rt(n, t, r) {
							return (r.y - n.y) * (t.x - n.x) > (t.y - n.y) * (r.x - n.x);
						}
						function $t(n) {
							return (
								typeof WorkerGlobalScope < "u" &&
								n !== void 0 &&
								n instanceof WorkerGlobalScope
							);
						}
						let tr = null;
						function Qt(n) {
							return typeof ImageBitmap < "u" && n instanceof ImageBitmap;
						}
						const Ot =
							"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
						function Nt(n, t, r, o, c) {
							return s(this, void 0, void 0, function* () {
								if (typeof VideoFrame > "u")
									throw new Error("VideoFrame not supported");
								const f = new VideoFrame(n, { timestamp: 0 });
								try {
									const _ = f == null ? void 0 : f.format;
									if (!_ || (!_.startsWith("BGR") && !_.startsWith("RGB")))
										throw new Error(`Unrecognized format ${_}`);
									const v = _.startsWith("BGR"),
										b = new Uint8ClampedArray(o * c * 4);
									if (
										(yield f.copyTo(
											b,
											(function (S, I, L, F, q) {
												const Z = 4 * Math.max(-I, 0),
													W = (Math.max(0, L) - L) * F * 4 + Z,
													J = 4 * F,
													le = Math.max(0, I),
													Re = Math.max(0, L);
												return {
													rect: {
														x: le,
														y: Re,
														width: Math.min(S.width, I + F) - le,
														height: Math.min(S.height, L + q) - Re,
													},
													layout: [{ offset: W, stride: J }],
												};
											})(n, t, r, o, c)
										),
										v)
									)
										for (let S = 0; S < b.length; S += 4) {
											const I = b[S];
											(b[S] = b[S + 2]), (b[S + 2] = I);
										}
									return b;
								} finally {
									f.close();
								}
							});
						}
						let or, cr;
						function Vr(n, t, r, o) {
							return (
								n.addEventListener(t, r, o),
								{
									unsubscribe: () => {
										n.removeEventListener(t, r, o);
									},
								}
							);
						}
						function mr(n) {
							return (n * Math.PI) / 180;
						}
						function hr(n) {
							return (n / Math.PI) * 180;
						}
						const _r = {
								touchstart: !0,
								touchmove: !0,
								touchmoveWindow: !0,
								touchend: !0,
								touchcancel: !0,
							},
							Ir = {
								dblclick: !0,
								click: !0,
								mouseover: !0,
								mouseout: !0,
								mousedown: !0,
								mousemove: !0,
								mousemoveWindow: !0,
								mouseup: !0,
								mouseupWindow: !0,
								contextmenu: !0,
								wheel: !0,
							},
							qr = "AbortError";
						function ue() {
							return new Error(qr);
						}
						const V = {
							MAX_PARALLEL_IMAGE_REQUESTS: 16,
							MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
							MAX_TILE_CACHE_ZOOM_LEVELS: 5,
							REGISTERED_PROTOCOLS: {},
							WORKER_URL: "",
						};
						function U(n) {
							return V.REGISTERED_PROTOCOLS[n.substring(0, n.indexOf("://"))];
						}
						const Y = "global-dispatcher";
						class ie extends Error {
							constructor(t, r, o, c) {
								super(`AJAXError: ${r} (${t}): ${o}`),
									(this.status = t),
									(this.statusText = r),
									(this.url = o),
									(this.body = c);
							}
						}
						const pe = () =>
								$t(self)
									? self.worker && self.worker.referrer
									: (window.location.protocol === "blob:"
											? window.parent
											: window
									  ).location.href,
							Se = function (n, t) {
								if (/:\/\//.test(n.url) && !/^https?:|^file:/.test(n.url)) {
									const o = U(n.url);
									if (o) return o(n, t);
									if ($t(self) && self.worker && self.worker.actor)
										return self.worker.actor.sendAsync(
											{ type: "GR", data: n, targetMapId: Y },
											t
										);
								}
								if (
									!(
										/^file:/.test((r = n.url)) ||
										(/^file:/.test(pe()) && !/^\w+:/.test(r))
									)
								) {
									if (
										fetch &&
										Request &&
										AbortController &&
										Object.prototype.hasOwnProperty.call(
											Request.prototype,
											"signal"
										)
									)
										return (function (o, c) {
											return s(this, void 0, void 0, function* () {
												const f = new Request(o.url, {
													method: o.method || "GET",
													body: o.body,
													credentials: o.credentials,
													headers: o.headers,
													cache: o.cache,
													referrer: pe(),
													signal: c.signal,
												});
												let _, v;
												o.type !== "json" ||
													f.headers.has("Accept") ||
													f.headers.set("Accept", "application/json");
												try {
													_ = yield fetch(f);
												} catch (S) {
													throw new ie(0, S.message, o.url, new Blob());
												}
												if (!_.ok) {
													const S = yield _.blob();
													throw new ie(_.status, _.statusText, o.url, S);
												}
												v =
													o.type === "arrayBuffer" || o.type === "image"
														? _.arrayBuffer()
														: o.type === "json"
														? _.json()
														: _.text();
												const b = yield v;
												if (c.signal.aborted) throw ue();
												return {
													data: b,
													cacheControl: _.headers.get("Cache-Control"),
													expires: _.headers.get("Expires"),
												};
											});
										})(n, t);
									if ($t(self) && self.worker && self.worker.actor)
										return self.worker.actor.sendAsync(
											{ type: "GR", data: n, mustQueue: !0, targetMapId: Y },
											t
										);
								}
								var r;
								return (function (o, c) {
									return new Promise((f, _) => {
										var v;
										const b = new XMLHttpRequest();
										b.open(o.method || "GET", o.url, !0),
											(o.type !== "arrayBuffer" && o.type !== "image") ||
												(b.responseType = "arraybuffer");
										for (const S in o.headers)
											b.setRequestHeader(S, o.headers[S]);
										o.type === "json" &&
											((b.responseType = "text"),
											(!((v = o.headers) === null || v === void 0) &&
												v.Accept) ||
												b.setRequestHeader("Accept", "application/json")),
											(b.withCredentials = o.credentials === "include"),
											(b.onerror = () => {
												_(new Error(b.statusText));
											}),
											(b.onload = () => {
												if (!c.signal.aborted)
													if (
														((b.status >= 200 && b.status < 300) ||
															b.status === 0) &&
														b.response !== null
													) {
														let S = b.response;
														if (o.type === "json")
															try {
																S = JSON.parse(b.response);
															} catch (I) {
																return void _(I);
															}
														f({
															data: S,
															cacheControl:
																b.getResponseHeader("Cache-Control"),
															expires: b.getResponseHeader("Expires"),
														});
													} else {
														const S = new Blob([b.response], {
															type: b.getResponseHeader("Content-Type"),
														});
														_(new ie(b.status, b.statusText, o.url, S));
													}
											}),
											c.signal.addEventListener("abort", () => {
												b.abort(), _(ue());
											}),
											b.send(o.body);
									});
								})(n, t);
							};
						function Me(n) {
							if (
								!n ||
								n.indexOf("://") <= 0 ||
								n.indexOf("data:image/") === 0 ||
								n.indexOf("blob:") === 0
							)
								return !0;
							const t = new URL(n),
								r = window.location;
							return t.protocol === r.protocol && t.host === r.host;
						}
						function we(n, t, r) {
							(r[n] && r[n].indexOf(t) !== -1) ||
								((r[n] = r[n] || []), r[n].push(t));
						}
						function Ve(n, t, r) {
							if (r && r[n]) {
								const o = r[n].indexOf(t);
								o !== -1 && r[n].splice(o, 1);
							}
						}
						class ut {
							constructor(t, r = {}) {
								dt(this, r), (this.type = t);
							}
						}
						class Ke extends ut {
							constructor(t, r = {}) {
								super("error", dt({ error: t }, r));
							}
						}
						class kt {
							on(t, r) {
								return (
									(this._listeners = this._listeners || {}),
									we(t, r, this._listeners),
									{
										unsubscribe: () => {
											this.off(t, r);
										},
									}
								);
							}
							off(t, r) {
								return (
									Ve(t, r, this._listeners),
									Ve(t, r, this._oneTimeListeners),
									this
								);
							}
							once(t, r) {
								return r
									? ((this._oneTimeListeners = this._oneTimeListeners || {}),
									  we(t, r, this._oneTimeListeners),
									  this)
									: new Promise((o) => this.once(t, o));
							}
							fire(t, r) {
								typeof t == "string" && (t = new ut(t, r || {}));
								const o = t.type;
								if (this.listens(o)) {
									t.target = this;
									const c =
										this._listeners && this._listeners[o]
											? this._listeners[o].slice()
											: [];
									for (const v of c) v.call(this, t);
									const f =
										this._oneTimeListeners && this._oneTimeListeners[o]
											? this._oneTimeListeners[o].slice()
											: [];
									for (const v of f)
										Ve(o, v, this._oneTimeListeners), v.call(this, t);
									const _ = this._eventedParent;
									_ &&
										(dt(
											t,
											typeof this._eventedParentData == "function"
												? this._eventedParentData()
												: this._eventedParentData
										),
										_.fire(t));
								} else t instanceof Ke && console.error(t.error);
								return this;
							}
							listens(t) {
								return (
									(this._listeners &&
										this._listeners[t] &&
										this._listeners[t].length > 0) ||
									(this._oneTimeListeners &&
										this._oneTimeListeners[t] &&
										this._oneTimeListeners[t].length > 0) ||
									(this._eventedParent && this._eventedParent.listens(t))
								);
							}
							setEventedParent(t, r) {
								return (
									(this._eventedParent = t), (this._eventedParentData = r), this
								);
							}
						}
						var ye = {
							$version: 8,
							$root: {
								version: { required: !0, type: "enum", values: [8] },
								name: { type: "string" },
								metadata: { type: "*" },
								center: { type: "array", value: "number" },
								centerAltitude: { type: "number" },
								zoom: { type: "number" },
								bearing: {
									type: "number",
									default: 0,
									period: 360,
									units: "degrees",
								},
								pitch: { type: "number", default: 0, units: "degrees" },
								roll: { type: "number", default: 0, units: "degrees" },
								state: { type: "state", default: {} },
								light: { type: "light" },
								sky: { type: "sky" },
								projection: { type: "projection" },
								terrain: { type: "terrain" },
								sources: { required: !0, type: "sources" },
								sprite: { type: "sprite" },
								glyphs: { type: "string" },
								transition: { type: "transition" },
								layers: { required: !0, type: "array", value: "layer" },
							},
							sources: { "*": { type: "source" } },
							source: [
								"source_vector",
								"source_raster",
								"source_raster_dem",
								"source_geojson",
								"source_video",
								"source_image",
							],
							source_vector: {
								type: { required: !0, type: "enum", values: { vector: {} } },
								url: { type: "string" },
								tiles: { type: "array", value: "string" },
								bounds: {
									type: "array",
									value: "number",
									length: 4,
									default: [-180, -85.051129, 180, 85.051129],
								},
								scheme: {
									type: "enum",
									values: { xyz: {}, tms: {} },
									default: "xyz",
								},
								minzoom: { type: "number", default: 0 },
								maxzoom: { type: "number", default: 22 },
								attribution: { type: "string" },
								promoteId: { type: "promoteId" },
								volatile: { type: "boolean", default: !1 },
								"*": { type: "*" },
							},
							source_raster: {
								type: { required: !0, type: "enum", values: { raster: {} } },
								url: { type: "string" },
								tiles: { type: "array", value: "string" },
								bounds: {
									type: "array",
									value: "number",
									length: 4,
									default: [-180, -85.051129, 180, 85.051129],
								},
								minzoom: { type: "number", default: 0 },
								maxzoom: { type: "number", default: 22 },
								tileSize: { type: "number", default: 512, units: "pixels" },
								scheme: {
									type: "enum",
									values: { xyz: {}, tms: {} },
									default: "xyz",
								},
								attribution: { type: "string" },
								volatile: { type: "boolean", default: !1 },
								"*": { type: "*" },
							},
							source_raster_dem: {
								type: {
									required: !0,
									type: "enum",
									values: { "raster-dem": {} },
								},
								url: { type: "string" },
								tiles: { type: "array", value: "string" },
								bounds: {
									type: "array",
									value: "number",
									length: 4,
									default: [-180, -85.051129, 180, 85.051129],
								},
								minzoom: { type: "number", default: 0 },
								maxzoom: { type: "number", default: 22 },
								tileSize: { type: "number", default: 512, units: "pixels" },
								attribution: { type: "string" },
								encoding: {
									type: "enum",
									values: { terrarium: {}, mapbox: {}, custom: {} },
									default: "mapbox",
								},
								redFactor: { type: "number", default: 1 },
								blueFactor: { type: "number", default: 1 },
								greenFactor: { type: "number", default: 1 },
								baseShift: { type: "number", default: 0 },
								volatile: { type: "boolean", default: !1 },
								"*": { type: "*" },
							},
							source_geojson: {
								type: { required: !0, type: "enum", values: { geojson: {} } },
								data: { required: !0, type: "*" },
								maxzoom: { type: "number", default: 18 },
								attribution: { type: "string" },
								buffer: {
									type: "number",
									default: 128,
									maximum: 512,
									minimum: 0,
								},
								filter: { type: "*" },
								tolerance: { type: "number", default: 0.375 },
								cluster: { type: "boolean", default: !1 },
								clusterRadius: { type: "number", default: 50, minimum: 0 },
								clusterMaxZoom: { type: "number" },
								clusterMinPoints: { type: "number" },
								clusterProperties: { type: "*" },
								lineMetrics: { type: "boolean", default: !1 },
								generateId: { type: "boolean", default: !1 },
								promoteId: { type: "promoteId" },
							},
							source_video: {
								type: { required: !0, type: "enum", values: { video: {} } },
								urls: { required: !0, type: "array", value: "string" },
								coordinates: {
									required: !0,
									type: "array",
									length: 4,
									value: { type: "array", length: 2, value: "number" },
								},
							},
							source_image: {
								type: { required: !0, type: "enum", values: { image: {} } },
								url: { required: !0, type: "string" },
								coordinates: {
									required: !0,
									type: "array",
									length: 4,
									value: { type: "array", length: 2, value: "number" },
								},
							},
							layer: {
								id: { type: "string", required: !0 },
								type: {
									type: "enum",
									values: {
										fill: {},
										line: {},
										symbol: {},
										circle: {},
										heatmap: {},
										"fill-extrusion": {},
										raster: {},
										hillshade: {},
										"color-relief": {},
										background: {},
									},
									required: !0,
								},
								metadata: { type: "*" },
								source: { type: "string" },
								"source-layer": { type: "string" },
								minzoom: { type: "number", minimum: 0, maximum: 24 },
								maxzoom: { type: "number", minimum: 0, maximum: 24 },
								filter: { type: "filter" },
								layout: { type: "layout" },
								paint: { type: "paint" },
							},
							layout: [
								"layout_fill",
								"layout_line",
								"layout_circle",
								"layout_heatmap",
								"layout_fill-extrusion",
								"layout_symbol",
								"layout_raster",
								"layout_hillshade",
								"layout_color-relief",
								"layout_background",
							],
							layout_background: {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_fill: {
								"fill-sort-key": {
									type: "number",
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_circle: {
								"circle-sort-key": {
									type: "number",
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_heatmap: {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							"layout_fill-extrusion": {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_line: {
								"line-cap": {
									type: "enum",
									values: { butt: {}, round: {}, square: {} },
									default: "butt",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"line-join": {
									type: "enum",
									values: { bevel: {}, round: {}, miter: {} },
									default: "miter",
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"line-miter-limit": {
									type: "number",
									default: 2,
									requires: [{ "line-join": "miter" }],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"line-round-limit": {
									type: "number",
									default: 1.05,
									requires: [{ "line-join": "round" }],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"line-sort-key": {
									type: "number",
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_symbol: {
								"symbol-placement": {
									type: "enum",
									values: { point: {}, line: {}, "line-center": {} },
									default: "point",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"symbol-spacing": {
									type: "number",
									default: 250,
									minimum: 1,
									units: "pixels",
									requires: [{ "symbol-placement": "line" }],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"symbol-avoid-edges": {
									type: "boolean",
									default: !1,
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"symbol-sort-key": {
									type: "number",
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"symbol-z-order": {
									type: "enum",
									values: { auto: {}, "viewport-y": {}, source: {} },
									default: "auto",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-allow-overlap": {
									type: "boolean",
									default: !1,
									requires: ["icon-image", { "!": "icon-overlap" }],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-overlap": {
									type: "enum",
									values: { never: {}, always: {}, cooperative: {} },
									requires: ["icon-image"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-ignore-placement": {
									type: "boolean",
									default: !1,
									requires: ["icon-image"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-optional": {
									type: "boolean",
									default: !1,
									requires: ["icon-image", "text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-rotation-alignment": {
									type: "enum",
									values: { map: {}, viewport: {}, auto: {} },
									default: "auto",
									requires: ["icon-image"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-size": {
									type: "number",
									default: 1,
									minimum: 0,
									units: "factor of the original icon size",
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-text-fit": {
									type: "enum",
									values: { none: {}, width: {}, height: {}, both: {} },
									default: "none",
									requires: ["icon-image", "text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-text-fit-padding": {
									type: "array",
									value: "number",
									length: 4,
									default: [0, 0, 0, 0],
									units: "pixels",
									requires: [
										"icon-image",
										"text-field",
										{ "icon-text-fit": ["both", "width", "height"] },
									],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-image": {
									type: "resolvedImage",
									tokens: !0,
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-rotate": {
									type: "number",
									default: 0,
									period: 360,
									units: "degrees",
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-padding": {
									type: "padding",
									default: [2],
									units: "pixels",
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-keep-upright": {
									type: "boolean",
									default: !1,
									requires: [
										"icon-image",
										{ "icon-rotation-alignment": "map" },
										{ "symbol-placement": ["line", "line-center"] },
									],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-offset": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-anchor": {
									type: "enum",
									values: {
										center: {},
										left: {},
										right: {},
										top: {},
										bottom: {},
										"top-left": {},
										"top-right": {},
										"bottom-left": {},
										"bottom-right": {},
									},
									default: "center",
									requires: ["icon-image"],
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"icon-pitch-alignment": {
									type: "enum",
									values: { map: {}, viewport: {}, auto: {} },
									default: "auto",
									requires: ["icon-image"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-pitch-alignment": {
									type: "enum",
									values: { map: {}, viewport: {}, auto: {} },
									default: "auto",
									requires: ["text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-rotation-alignment": {
									type: "enum",
									values: {
										map: {},
										viewport: {},
										"viewport-glyph": {},
										auto: {},
									},
									default: "auto",
									requires: ["text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-field": {
									type: "formatted",
									default: "",
									tokens: !0,
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-font": {
									type: "array",
									value: "string",
									default: ["Open Sans Regular", "Arial Unicode MS Regular"],
									requires: ["text-field"],
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-size": {
									type: "number",
									default: 16,
									minimum: 0,
									units: "pixels",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-max-width": {
									type: "number",
									default: 10,
									minimum: 0,
									units: "ems",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-line-height": {
									type: "number",
									default: 1.2,
									units: "ems",
									requires: ["text-field"],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-letter-spacing": {
									type: "number",
									default: 0,
									units: "ems",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-justify": {
									type: "enum",
									values: { auto: {}, left: {}, center: {}, right: {} },
									default: "center",
									requires: ["text-field"],
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-radial-offset": {
									type: "number",
									units: "ems",
									default: 0,
									requires: ["text-field"],
									"property-type": "data-driven",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
								},
								"text-variable-anchor": {
									type: "array",
									value: "enum",
									values: {
										center: {},
										left: {},
										right: {},
										top: {},
										bottom: {},
										"top-left": {},
										"top-right": {},
										"bottom-left": {},
										"bottom-right": {},
									},
									requires: ["text-field", { "symbol-placement": ["point"] }],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-variable-anchor-offset": {
									type: "variableAnchorOffsetCollection",
									requires: ["text-field", { "symbol-placement": ["point"] }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-anchor": {
									type: "enum",
									values: {
										center: {},
										left: {},
										right: {},
										top: {},
										bottom: {},
										"top-left": {},
										"top-right": {},
										"bottom-left": {},
										"bottom-right": {},
									},
									default: "center",
									requires: ["text-field", { "!": "text-variable-anchor" }],
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-max-angle": {
									type: "number",
									default: 45,
									units: "degrees",
									requires: [
										"text-field",
										{ "symbol-placement": ["line", "line-center"] },
									],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-writing-mode": {
									type: "array",
									value: "enum",
									values: { horizontal: {}, vertical: {} },
									requires: ["text-field", { "symbol-placement": ["point"] }],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-rotate": {
									type: "number",
									default: 0,
									period: 360,
									units: "degrees",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-padding": {
									type: "number",
									default: 2,
									minimum: 0,
									units: "pixels",
									requires: ["text-field"],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-keep-upright": {
									type: "boolean",
									default: !0,
									requires: [
										"text-field",
										{ "text-rotation-alignment": "map" },
										{ "symbol-placement": ["line", "line-center"] },
									],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-transform": {
									type: "enum",
									values: { none: {}, uppercase: {}, lowercase: {} },
									default: "none",
									requires: ["text-field"],
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-offset": {
									type: "array",
									value: "number",
									units: "ems",
									length: 2,
									default: [0, 0],
									requires: ["text-field", { "!": "text-radial-offset" }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature"],
									},
									"property-type": "data-driven",
								},
								"text-allow-overlap": {
									type: "boolean",
									default: !1,
									requires: ["text-field", { "!": "text-overlap" }],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-overlap": {
									type: "enum",
									values: { never: {}, always: {}, cooperative: {} },
									requires: ["text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-ignore-placement": {
									type: "boolean",
									default: !1,
									requires: ["text-field"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-optional": {
									type: "boolean",
									default: !1,
									requires: ["text-field", "icon-image"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_raster: {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							layout_hillshade: {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							"layout_color-relief": {
								visibility: {
									type: "enum",
									values: { visible: {}, none: {} },
									default: "visible",
									"property-type": "constant",
								},
							},
							filter: { type: "array", value: "*" },
							filter_operator: {
								type: "enum",
								values: {
									"==": {},
									"!=": {},
									">": {},
									">=": {},
									"<": {},
									"<=": {},
									in: {},
									"!in": {},
									all: {},
									any: {},
									none: {},
									has: {},
									"!has": {},
								},
							},
							geometry_type: {
								type: "enum",
								values: { Point: {}, LineString: {}, Polygon: {} },
							},
							function: {
								expression: { type: "expression" },
								stops: { type: "array", value: "function_stop" },
								base: { type: "number", default: 1, minimum: 0 },
								property: { type: "string", default: "$zoom" },
								type: {
									type: "enum",
									values: {
										identity: {},
										exponential: {},
										interval: {},
										categorical: {},
									},
									default: "exponential",
								},
								colorSpace: {
									type: "enum",
									values: { rgb: {}, lab: {}, hcl: {} },
									default: "rgb",
								},
								default: { type: "*", required: !1 },
							},
							function_stop: {
								type: "array",
								minimum: 0,
								maximum: 24,
								value: ["number", "color"],
								length: 2,
							},
							expression: { type: "array", value: "*", minimum: 1 },
							light: {
								anchor: {
									type: "enum",
									default: "viewport",
									values: { map: {}, viewport: {} },
									"property-type": "data-constant",
									transition: !1,
									expression: { interpolated: !1, parameters: ["zoom"] },
								},
								position: {
									type: "array",
									default: [1.15, 210, 30],
									length: 3,
									value: "number",
									"property-type": "data-constant",
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
								},
								color: {
									type: "color",
									"property-type": "data-constant",
									default: "#ffffff",
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								intensity: {
									type: "number",
									"property-type": "data-constant",
									default: 0.5,
									minimum: 0,
									maximum: 1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
							},
							sky: {
								"sky-color": {
									type: "color",
									"property-type": "data-constant",
									default: "#88C6FC",
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"horizon-color": {
									type: "color",
									"property-type": "data-constant",
									default: "#ffffff",
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"fog-color": {
									type: "color",
									"property-type": "data-constant",
									default: "#ffffff",
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"fog-ground-blend": {
									type: "number",
									"property-type": "data-constant",
									default: 0.5,
									minimum: 0,
									maximum: 1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"horizon-fog-blend": {
									type: "number",
									"property-type": "data-constant",
									default: 0.8,
									minimum: 0,
									maximum: 1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"sky-horizon-blend": {
									type: "number",
									"property-type": "data-constant",
									default: 0.8,
									minimum: 0,
									maximum: 1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
								"atmosphere-blend": {
									type: "number",
									"property-type": "data-constant",
									default: 0.8,
									minimum: 0,
									maximum: 1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									transition: !0,
								},
							},
							terrain: {
								source: { type: "string", required: !0 },
								exaggeration: { type: "number", minimum: 0, default: 1 },
							},
							projection: {
								type: {
									type: "projectionDefinition",
									default: "mercator",
									"property-type": "data-constant",
									transition: !1,
									expression: { interpolated: !0, parameters: ["zoom"] },
								},
							},
							paint: [
								"paint_fill",
								"paint_line",
								"paint_circle",
								"paint_heatmap",
								"paint_fill-extrusion",
								"paint_symbol",
								"paint_raster",
								"paint_hillshade",
								"paint_color-relief",
								"paint_background",
							],
							paint_fill: {
								"fill-antialias": {
									type: "boolean",
									default: !0,
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									requires: [{ "!": "fill-pattern" }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-outline-color": {
									type: "color",
									transition: !0,
									requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["fill-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-pattern": {
									type: "resolvedImage",
									transition: !0,
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "cross-faded-data-driven",
								},
							},
							"paint_fill-extrusion": {
								"fill-extrusion-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-extrusion-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									requires: [{ "!": "fill-extrusion-pattern" }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-extrusion-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-extrusion-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["fill-extrusion-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"fill-extrusion-pattern": {
									type: "resolvedImage",
									transition: !0,
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "cross-faded-data-driven",
								},
								"fill-extrusion-height": {
									type: "number",
									default: 0,
									minimum: 0,
									units: "meters",
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-extrusion-base": {
									type: "number",
									default: 0,
									minimum: 0,
									units: "meters",
									transition: !0,
									requires: ["fill-extrusion-height"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"fill-extrusion-vertical-gradient": {
									type: "boolean",
									default: !0,
									transition: !1,
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							paint_line: {
								"line-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									requires: [{ "!": "line-pattern" }],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"line-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["line-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"line-width": {
									type: "number",
									default: 1,
									minimum: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-gap-width": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-offset": {
									type: "number",
									default: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-blur": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"line-dasharray": {
									type: "array",
									value: "number",
									minimum: 0,
									transition: !0,
									units: "line widths",
									requires: [{ "!": "line-pattern" }],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "cross-faded",
								},
								"line-pattern": {
									type: "resolvedImage",
									transition: !0,
									expression: {
										interpolated: !1,
										parameters: ["zoom", "feature"],
									},
									"property-type": "cross-faded-data-driven",
								},
								"line-gradient": {
									type: "color",
									transition: !1,
									requires: [
										{ "!": "line-dasharray" },
										{ "!": "line-pattern" },
										{ source: "geojson", has: { lineMetrics: !0 } },
									],
									expression: {
										interpolated: !0,
										parameters: ["line-progress"],
									},
									"property-type": "color-ramp",
								},
							},
							paint_circle: {
								"circle-radius": {
									type: "number",
									default: 5,
									minimum: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-blur": {
									type: "number",
									default: 0,
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"circle-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["circle-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"circle-pitch-scale": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"circle-pitch-alignment": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "viewport",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"circle-stroke-width": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-stroke-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"circle-stroke-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
							},
							paint_heatmap: {
								"heatmap-radius": {
									type: "number",
									default: 30,
									minimum: 1,
									transition: !0,
									units: "pixels",
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"heatmap-weight": {
									type: "number",
									default: 1,
									minimum: 0,
									transition: !1,
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"heatmap-intensity": {
									type: "number",
									default: 1,
									minimum: 0,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"heatmap-color": {
									type: "color",
									default: [
										"interpolate",
										["linear"],
										["heatmap-density"],
										0,
										"rgba(0, 0, 255, 0)",
										0.1,
										"royalblue",
										0.3,
										"cyan",
										0.5,
										"lime",
										0.7,
										"yellow",
										1,
										"red",
									],
									transition: !1,
									expression: {
										interpolated: !0,
										parameters: ["heatmap-density"],
									},
									"property-type": "color-ramp",
								},
								"heatmap-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							paint_symbol: {
								"icon-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"icon-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"icon-halo-color": {
									type: "color",
									default: "rgba(0, 0, 0, 0)",
									transition: !0,
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"icon-halo-width": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"icon-halo-blur": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									requires: ["icon-image"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"icon-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									requires: ["icon-image"],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"icon-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["icon-image", "icon-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"text-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									overridable: !0,
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"text-halo-color": {
									type: "color",
									default: "rgba(0, 0, 0, 0)",
									transition: !0,
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"text-halo-width": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"text-halo-blur": {
									type: "number",
									default: 0,
									minimum: 0,
									transition: !0,
									units: "pixels",
									requires: ["text-field"],
									expression: {
										interpolated: !0,
										parameters: ["zoom", "feature", "feature-state"],
									},
									"property-type": "data-driven",
								},
								"text-translate": {
									type: "array",
									value: "number",
									length: 2,
									default: [0, 0],
									transition: !0,
									units: "pixels",
									requires: ["text-field"],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"text-translate-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "map",
									requires: ["text-field", "text-translate"],
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							paint_raster: {
								"raster-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-hue-rotate": {
									type: "number",
									default: 0,
									period: 360,
									transition: !0,
									units: "degrees",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-brightness-min": {
									type: "number",
									default: 0,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-brightness-max": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-saturation": {
									type: "number",
									default: 0,
									minimum: -1,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-contrast": {
									type: "number",
									default: 0,
									minimum: -1,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-resampling": {
									type: "enum",
									values: { linear: {}, nearest: {} },
									default: "linear",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"raster-fade-duration": {
									type: "number",
									default: 300,
									minimum: 0,
									transition: !1,
									units: "milliseconds",
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							paint_hillshade: {
								"hillshade-illumination-direction": {
									type: "numberArray",
									default: 335,
									minimum: 0,
									maximum: 359,
									transition: !1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-illumination-altitude": {
									type: "numberArray",
									default: 45,
									minimum: 0,
									maximum: 90,
									transition: !1,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-illumination-anchor": {
									type: "enum",
									values: { map: {}, viewport: {} },
									default: "viewport",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-exaggeration": {
									type: "number",
									default: 0.5,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-shadow-color": {
									type: "colorArray",
									default: "#000000",
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-highlight-color": {
									type: "colorArray",
									default: "#FFFFFF",
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-accent-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"hillshade-method": {
									type: "enum",
									values: {
										standard: {},
										basic: {},
										combined: {},
										igor: {},
										multidirectional: {},
									},
									default: "standard",
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							"paint_color-relief": {
								"color-relief-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"color-relief-color": {
									type: "color",
									transition: !1,
									expression: { interpolated: !0, parameters: ["elevation"] },
									"property-type": "color-ramp",
								},
							},
							paint_background: {
								"background-color": {
									type: "color",
									default: "#000000",
									transition: !0,
									requires: [{ "!": "background-pattern" }],
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
								"background-pattern": {
									type: "resolvedImage",
									transition: !0,
									expression: { interpolated: !1, parameters: ["zoom"] },
									"property-type": "cross-faded",
								},
								"background-opacity": {
									type: "number",
									default: 1,
									minimum: 0,
									maximum: 1,
									transition: !0,
									expression: { interpolated: !0, parameters: ["zoom"] },
									"property-type": "data-constant",
								},
							},
							transition: {
								duration: {
									type: "number",
									default: 300,
									minimum: 0,
									units: "milliseconds",
								},
								delay: {
									type: "number",
									default: 0,
									minimum: 0,
									units: "milliseconds",
								},
							},
							"property-type": {
								"data-driven": { type: "property-type" },
								"cross-faded": { type: "property-type" },
								"cross-faded-data-driven": { type: "property-type" },
								"color-ramp": { type: "property-type" },
								"data-constant": { type: "property-type" },
								constant: { type: "property-type" },
							},
							promoteId: { "*": { type: "string" } },
						};
						const Bt = [
							"type",
							"source",
							"source-layer",
							"minzoom",
							"maxzoom",
							"filter",
							"layout",
						];
						function rr(n, t) {
							const r = {};
							for (const o in n) o !== "ref" && (r[o] = n[o]);
							return (
								Bt.forEach((o) => {
									o in t && (r[o] = t[o]);
								}),
								r
							);
						}
						function Kt(n, t) {
							if (Array.isArray(n)) {
								if (!Array.isArray(t) || n.length !== t.length) return !1;
								for (let r = 0; r < n.length; r++)
									if (!Kt(n[r], t[r])) return !1;
								return !0;
							}
							if (typeof n == "object" && n !== null && t !== null) {
								if (
									typeof t != "object" ||
									Object.keys(n).length !== Object.keys(t).length
								)
									return !1;
								for (const r in n) if (!Kt(n[r], t[r])) return !1;
								return !0;
							}
							return n === t;
						}
						function gr(n, t) {
							n.push(t);
						}
						function Ur(n, t, r) {
							gr(r, { command: "addSource", args: [n, t[n]] });
						}
						function nn(n, t, r) {
							gr(t, { command: "removeSource", args: [n] }), (r[n] = !0);
						}
						function mn(n, t, r, o) {
							nn(n, r, o), Ur(n, t, r);
						}
						function _n(n, t, r) {
							let o;
							for (o in n[r])
								if (
									Object.prototype.hasOwnProperty.call(n[r], o) &&
									o !== "data" &&
									!Kt(n[r][o], t[r][o])
								)
									return !1;
							for (o in t[r])
								if (
									Object.prototype.hasOwnProperty.call(t[r], o) &&
									o !== "data" &&
									!Kt(n[r][o], t[r][o])
								)
									return !1;
							return !0;
						}
						function Vt(n, t, r, o, c, f) {
							(n = n || {}), (t = t || {});
							for (const _ in n)
								Object.prototype.hasOwnProperty.call(n, _) &&
									(Kt(n[_], t[_]) ||
										r.push({ command: f, args: [o, _, t[_], c] }));
							for (const _ in t)
								Object.prototype.hasOwnProperty.call(t, _) &&
									!Object.prototype.hasOwnProperty.call(n, _) &&
									(Kt(n[_], t[_]) ||
										r.push({ command: f, args: [o, _, t[_], c] }));
						}
						function Et(n) {
							return n.id;
						}
						function dr(n, t) {
							return (n[t.id] = t), n;
						}
						class ht {
							constructor(t, r, o, c) {
								(this.message = (t ? `${t}: ` : "") + o),
									c && (this.identifier = c),
									r != null && r.__line__ && (this.line = r.__line__);
							}
						}
						function Xr(n, ...t) {
							for (const r of t) for (const o in r) n[o] = r[o];
							return n;
						}
						class Yr extends Error {
							constructor(t, r) {
								super(r), (this.message = r), (this.key = t);
							}
						}
						class Zr {
							constructor(t, r = []) {
								(this.parent = t), (this.bindings = {});
								for (const [o, c] of r) this.bindings[o] = c;
							}
							concat(t) {
								return new Zr(this, t);
							}
							get(t) {
								if (this.bindings[t]) return this.bindings[t];
								if (this.parent) return this.parent.get(t);
								throw new Error(`${t} not found in scope.`);
							}
							has(t) {
								return (
									!!this.bindings[t] || (!!this.parent && this.parent.has(t))
								);
							}
						}
						const mt = { kind: "null" },
							He = { kind: "number" },
							At = { kind: "string" },
							Ft = { kind: "boolean" },
							Jt = { kind: "color" },
							Cr = { kind: "projectionDefinition" },
							Er = { kind: "object" },
							ur = { kind: "value" },
							rn = { kind: "collator" },
							pn = { kind: "formatted" },
							gn = { kind: "padding" },
							ln = { kind: "colorArray" },
							En = { kind: "numberArray" },
							pr = { kind: "resolvedImage" },
							In = { kind: "variableAnchorOffsetCollection" };
						function tn(n, t) {
							return { kind: "array", itemType: n, N: t };
						}
						function en(n) {
							if (n.kind === "array") {
								const t = en(n.itemType);
								return typeof n.N == "number"
									? `array<${t}, ${n.N}>`
									: n.itemType.kind === "value"
									? "array"
									: `array<${t}>`;
							}
							return n.kind;
						}
						const ma = [
							mt,
							He,
							At,
							Ft,
							Jt,
							Cr,
							pn,
							Er,
							tn(ur),
							gn,
							En,
							ln,
							pr,
							In,
						];
						function pi(n, t) {
							if (t.kind === "error") return null;
							if (n.kind === "array") {
								if (
									t.kind === "array" &&
									((t.N === 0 && t.itemType.kind === "value") ||
										!pi(n.itemType, t.itemType)) &&
									(typeof n.N != "number" || n.N === t.N)
								)
									return null;
							} else {
								if (n.kind === t.kind) return null;
								if (n.kind === "value") {
									for (const r of ma) if (!pi(r, t)) return null;
								}
							}
							return `Expected ${en(n)} but found ${en(t)} instead.`;
						}
						function Xi(n, t) {
							return t.some((r) => r.kind === n.kind);
						}
						function Zn(n, t) {
							return t.some((r) =>
								r === "null"
									? n === null
									: r === "array"
									? Array.isArray(n)
									: r === "object"
									? n && !Array.isArray(n) && typeof n == "object"
									: r === typeof n
							);
						}
						function ni(n, t) {
							return n.kind === "array" && t.kind === "array"
								? n.itemType.kind === t.itemType.kind && typeof n.N == "number"
								: n.kind === t.kind;
						}
						const Zi = 0.96422,
							Yi = 0.82521,
							Ei = 4 / 29,
							zi = 6 / 29,
							Ki = 3 * zi * zi,
							oa = zi * zi * zi,
							Ta = Math.PI / 180,
							bt = 180 / Math.PI;
						function Xt(n) {
							return (n %= 360) < 0 && (n += 360), n;
						}
						function Br([n, t, r, o]) {
							let c, f;
							const _ = On(
								(0.2225045 * (n = xn(n)) +
									0.7168786 * (t = xn(t)) +
									0.0606169 * (r = xn(r))) /
									1
							);
							n === t && t === r
								? (c = f = _)
								: ((c = On(
										(0.4360747 * n + 0.3850649 * t + 0.1430804 * r) / Zi
								  )),
								  (f = On(
										(0.0139322 * n + 0.0971045 * t + 0.7141733 * r) / Yi
								  )));
							const v = 116 * _ - 16;
							return [v < 0 ? 0 : v, 500 * (c - _), 200 * (_ - f), o];
						}
						function xn(n) {
							return n <= 0.04045
								? n / 12.92
								: Math.pow((n + 0.055) / 1.055, 2.4);
						}
						function On(n) {
							return n > oa ? Math.pow(n, 1 / 3) : n / Ki + Ei;
						}
						function Yn([n, t, r, o]) {
							let c = (n + 16) / 116,
								f = isNaN(t) ? c : c + t / 500,
								_ = isNaN(r) ? c : c - r / 200;
							return (
								(c = 1 * wn(c)),
								(f = Zi * wn(f)),
								(_ = Yi * wn(_)),
								[
									Vn(3.1338561 * f - 1.6168667 * c - 0.4906146 * _),
									Vn(-0.9787684 * f + 1.9161415 * c + 0.033454 * _),
									Vn(0.0719453 * f - 0.2289914 * c + 1.4052427 * _),
									o,
								]
							);
						}
						function Vn(n) {
							return (n =
								n <= 0.00304
									? 12.92 * n
									: 1.055 * Math.pow(n, 1 / 2.4) - 0.055) < 0
								? 0
								: n > 1
								? 1
								: n;
						}
						function wn(n) {
							return n > zi ? n * n * n : Ki * (n - Ei);
						}
						const Ji =
							Object.hasOwn ||
							function (n, t) {
								return Object.prototype.hasOwnProperty.call(n, t);
							};
						function sr(n, t) {
							return Ji(n, t) ? n[t] : void 0;
						}
						function Ut(n) {
							return parseInt(n.padEnd(2, n), 16) / 255;
						}
						function $r(n, t) {
							return lr(t ? n / 100 : n, 0, 1);
						}
						function lr(n, t, r) {
							return Math.min(Math.max(t, n), r);
						}
						function Tn(n) {
							return !n.some(Number.isNaN);
						}
						const an = {
							aliceblue: [240, 248, 255],
							antiquewhite: [250, 235, 215],
							aqua: [0, 255, 255],
							aquamarine: [127, 255, 212],
							azure: [240, 255, 255],
							beige: [245, 245, 220],
							bisque: [255, 228, 196],
							black: [0, 0, 0],
							blanchedalmond: [255, 235, 205],
							blue: [0, 0, 255],
							blueviolet: [138, 43, 226],
							brown: [165, 42, 42],
							burlywood: [222, 184, 135],
							cadetblue: [95, 158, 160],
							chartreuse: [127, 255, 0],
							chocolate: [210, 105, 30],
							coral: [255, 127, 80],
							cornflowerblue: [100, 149, 237],
							cornsilk: [255, 248, 220],
							crimson: [220, 20, 60],
							cyan: [0, 255, 255],
							darkblue: [0, 0, 139],
							darkcyan: [0, 139, 139],
							darkgoldenrod: [184, 134, 11],
							darkgray: [169, 169, 169],
							darkgreen: [0, 100, 0],
							darkgrey: [169, 169, 169],
							darkkhaki: [189, 183, 107],
							darkmagenta: [139, 0, 139],
							darkolivegreen: [85, 107, 47],
							darkorange: [255, 140, 0],
							darkorchid: [153, 50, 204],
							darkred: [139, 0, 0],
							darksalmon: [233, 150, 122],
							darkseagreen: [143, 188, 143],
							darkslateblue: [72, 61, 139],
							darkslategray: [47, 79, 79],
							darkslategrey: [47, 79, 79],
							darkturquoise: [0, 206, 209],
							darkviolet: [148, 0, 211],
							deeppink: [255, 20, 147],
							deepskyblue: [0, 191, 255],
							dimgray: [105, 105, 105],
							dimgrey: [105, 105, 105],
							dodgerblue: [30, 144, 255],
							firebrick: [178, 34, 34],
							floralwhite: [255, 250, 240],
							forestgreen: [34, 139, 34],
							fuchsia: [255, 0, 255],
							gainsboro: [220, 220, 220],
							ghostwhite: [248, 248, 255],
							gold: [255, 215, 0],
							goldenrod: [218, 165, 32],
							gray: [128, 128, 128],
							green: [0, 128, 0],
							greenyellow: [173, 255, 47],
							grey: [128, 128, 128],
							honeydew: [240, 255, 240],
							hotpink: [255, 105, 180],
							indianred: [205, 92, 92],
							indigo: [75, 0, 130],
							ivory: [255, 255, 240],
							khaki: [240, 230, 140],
							lavender: [230, 230, 250],
							lavenderblush: [255, 240, 245],
							lawngreen: [124, 252, 0],
							lemonchiffon: [255, 250, 205],
							lightblue: [173, 216, 230],
							lightcoral: [240, 128, 128],
							lightcyan: [224, 255, 255],
							lightgoldenrodyellow: [250, 250, 210],
							lightgray: [211, 211, 211],
							lightgreen: [144, 238, 144],
							lightgrey: [211, 211, 211],
							lightpink: [255, 182, 193],
							lightsalmon: [255, 160, 122],
							lightseagreen: [32, 178, 170],
							lightskyblue: [135, 206, 250],
							lightslategray: [119, 136, 153],
							lightslategrey: [119, 136, 153],
							lightsteelblue: [176, 196, 222],
							lightyellow: [255, 255, 224],
							lime: [0, 255, 0],
							limegreen: [50, 205, 50],
							linen: [250, 240, 230],
							magenta: [255, 0, 255],
							maroon: [128, 0, 0],
							mediumaquamarine: [102, 205, 170],
							mediumblue: [0, 0, 205],
							mediumorchid: [186, 85, 211],
							mediumpurple: [147, 112, 219],
							mediumseagreen: [60, 179, 113],
							mediumslateblue: [123, 104, 238],
							mediumspringgreen: [0, 250, 154],
							mediumturquoise: [72, 209, 204],
							mediumvioletred: [199, 21, 133],
							midnightblue: [25, 25, 112],
							mintcream: [245, 255, 250],
							mistyrose: [255, 228, 225],
							moccasin: [255, 228, 181],
							navajowhite: [255, 222, 173],
							navy: [0, 0, 128],
							oldlace: [253, 245, 230],
							olive: [128, 128, 0],
							olivedrab: [107, 142, 35],
							orange: [255, 165, 0],
							orangered: [255, 69, 0],
							orchid: [218, 112, 214],
							palegoldenrod: [238, 232, 170],
							palegreen: [152, 251, 152],
							paleturquoise: [175, 238, 238],
							palevioletred: [219, 112, 147],
							papayawhip: [255, 239, 213],
							peachpuff: [255, 218, 185],
							peru: [205, 133, 63],
							pink: [255, 192, 203],
							plum: [221, 160, 221],
							powderblue: [176, 224, 230],
							purple: [128, 0, 128],
							rebeccapurple: [102, 51, 153],
							red: [255, 0, 0],
							rosybrown: [188, 143, 143],
							royalblue: [65, 105, 225],
							saddlebrown: [139, 69, 19],
							salmon: [250, 128, 114],
							sandybrown: [244, 164, 96],
							seagreen: [46, 139, 87],
							seashell: [255, 245, 238],
							sienna: [160, 82, 45],
							silver: [192, 192, 192],
							skyblue: [135, 206, 235],
							slateblue: [106, 90, 205],
							slategray: [112, 128, 144],
							slategrey: [112, 128, 144],
							snow: [255, 250, 250],
							springgreen: [0, 255, 127],
							steelblue: [70, 130, 180],
							tan: [210, 180, 140],
							teal: [0, 128, 128],
							thistle: [216, 191, 216],
							tomato: [255, 99, 71],
							turquoise: [64, 224, 208],
							violet: [238, 130, 238],
							wheat: [245, 222, 179],
							white: [255, 255, 255],
							whitesmoke: [245, 245, 245],
							yellow: [255, 255, 0],
							yellowgreen: [154, 205, 50],
						};
						function Cn(n, t, r) {
							return n + r * (t - n);
						}
						function Gn(n, t, r) {
							return n.map((o, c) => Cn(o, t[c], r));
						}
						class Mr {
							constructor(t, r, o, c = 1, f = !0) {
								(this.r = t),
									(this.g = r),
									(this.b = o),
									(this.a = c),
									f ||
										((this.r *= c),
										(this.g *= c),
										(this.b *= c),
										c || this.overwriteGetter("rgb", [t, r, o, c]));
							}
							static parse(t) {
								if (t instanceof Mr) return t;
								if (typeof t != "string") return;
								const r = (function (o) {
									if ((o = o.toLowerCase().trim()) === "transparent")
										return [0, 0, 0, 0];
									const c = sr(an, o);
									if (c) {
										const [_, v, b] = c;
										return [_ / 255, v / 255, b / 255, 1];
									}
									if (
										o.startsWith("#") &&
										/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)
									) {
										const _ = o.length < 6 ? 1 : 2;
										let v = 1;
										return [
											Ut(o.slice(v, (v += _))),
											Ut(o.slice(v, (v += _))),
											Ut(o.slice(v, (v += _))),
											Ut(o.slice(v, v + _) || "ff"),
										];
									}
									if (o.startsWith("rgb")) {
										const _ = o.match(
											/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
										);
										if (_) {
											const [v, b, S, I, L, F, q, Z, W, J, le, Re] = _,
												xe = [I || " ", q || " ", J].join("");
											if (
												xe === "  " ||
												xe === "  /" ||
												xe === ",," ||
												xe === ",,,"
											) {
												const Ce = [S, F, W].join(""),
													Ye = Ce === "%%%" ? 100 : Ce === "" ? 255 : 0;
												if (Ye) {
													const lt = [
														lr(+b / Ye, 0, 1),
														lr(+L / Ye, 0, 1),
														lr(+Z / Ye, 0, 1),
														le ? $r(+le, Re) : 1,
													];
													if (Tn(lt)) return lt;
												}
											}
											return;
										}
									}
									const f = o.match(
										/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/
									);
									if (f) {
										const [_, v, b, S, I, L, F, q, Z] = f,
											W = [b || " ", I || " ", F].join("");
										if (
											W === "  " ||
											W === "  /" ||
											W === ",," ||
											W === ",,,"
										) {
											const J = [
												+v,
												lr(+S, 0, 100),
												lr(+L, 0, 100),
												q ? $r(+q, Z) : 1,
											];
											if (Tn(J))
												return (function ([le, Re, xe, Ce]) {
													function Ye(lt) {
														const Pt = (lt + le / 30) % 12,
															Yt = Re * Math.min(xe, 1 - xe);
														return (
															xe -
															Yt * Math.max(-1, Math.min(Pt - 3, 9 - Pt, 1))
														);
													}
													return (
														(le = Xt(le)),
														(Re /= 100),
														(xe /= 100),
														[Ye(0), Ye(8), Ye(4), Ce]
													);
												})(J);
										}
									}
								})(t);
								return r ? new Mr(...r, !1) : void 0;
							}
							get rgb() {
								const { r: t, g: r, b: o, a: c } = this,
									f = c || 1 / 0;
								return this.overwriteGetter("rgb", [t / f, r / f, o / f, c]);
							}
							get hcl() {
								return this.overwriteGetter(
									"hcl",
									(function (t) {
										const [r, o, c, f] = Br(t),
											_ = Math.sqrt(o * o + c * c);
										return [
											Math.round(1e4 * _) ? Xt(Math.atan2(c, o) * bt) : NaN,
											_,
											r,
											f,
										];
									})(this.rgb)
								);
							}
							get lab() {
								return this.overwriteGetter("lab", Br(this.rgb));
							}
							overwriteGetter(t, r) {
								return Object.defineProperty(this, t, { value: r }), r;
							}
							toString() {
								const [t, r, o, c] = this.rgb;
								return `rgba(${[t, r, o]
									.map((f) => Math.round(255 * f))
									.join(",")},${c})`;
							}
							static interpolate(t, r, o, c = "rgb") {
								switch (c) {
									case "rgb": {
										const [f, _, v, b] = Gn(t.rgb, r.rgb, o);
										return new Mr(f, _, v, b, !1);
									}
									case "hcl": {
										const [f, _, v, b] = t.hcl,
											[S, I, L, F] = r.hcl;
										let q, Z;
										if (isNaN(f) || isNaN(S))
											isNaN(f)
												? isNaN(S)
													? (q = NaN)
													: ((q = S), (v !== 1 && v !== 0) || (Z = I))
												: ((q = f), (L !== 1 && L !== 0) || (Z = _));
										else {
											let xe = S - f;
											S > f && xe > 180
												? (xe -= 360)
												: S < f && f - S > 180 && (xe += 360),
												(q = f + o * xe);
										}
										const [W, J, le, Re] = (function ([xe, Ce, Ye, lt]) {
											return (
												(xe = isNaN(xe) ? 0 : xe * Ta),
												Yn([Ye, Math.cos(xe) * Ce, Math.sin(xe) * Ce, lt])
											);
										})([q, Z ?? Cn(_, I, o), Cn(v, L, o), Cn(b, F, o)]);
										return new Mr(W, J, le, Re, !1);
									}
									case "lab": {
										const [f, _, v, b] = Yn(Gn(t.lab, r.lab, o));
										return new Mr(f, _, v, b, !1);
									}
								}
							}
						}
						(Mr.black = new Mr(0, 0, 0, 1)),
							(Mr.white = new Mr(1, 1, 1, 1)),
							(Mr.transparent = new Mr(0, 0, 0, 0)),
							(Mr.red = new Mr(1, 0, 0, 1));
						class Mn {
							constructor(t, r, o) {
								(this.sensitivity = t
									? r
										? "variant"
										: "case"
									: r
									? "accent"
									: "base"),
									(this.locale = o),
									(this.collator = new Intl.Collator(
										this.locale ? this.locale : [],
										{ sensitivity: this.sensitivity, usage: "search" }
									));
							}
							compare(t, r) {
								return this.collator.compare(t, r);
							}
							resolvedLocale() {
								return new Intl.Collator(
									this.locale ? this.locale : []
								).resolvedOptions().locale;
							}
						}
						const bn = ["bottom", "center", "top"];
						class cn {
							constructor(t, r, o, c, f, _) {
								(this.text = t),
									(this.image = r),
									(this.scale = o),
									(this.fontStack = c),
									(this.textColor = f),
									(this.verticalAlign = _);
							}
						}
						class Sn {
							constructor(t) {
								this.sections = t;
							}
							static fromString(t) {
								return new Sn([new cn(t, null, null, null, null, null)]);
							}
							isEmpty() {
								return (
									this.sections.length === 0 ||
									!this.sections.some(
										(t) =>
											t.text.length !== 0 ||
											(t.image && t.image.name.length !== 0)
									)
								);
							}
							static factory(t) {
								return t instanceof Sn ? t : Sn.fromString(t);
							}
							toString() {
								return this.sections.length === 0
									? ""
									: this.sections.map((t) => t.text).join("");
							}
						}
						class kn {
							constructor(t) {
								this.values = t.slice();
							}
							static parse(t) {
								if (t instanceof kn) return t;
								if (typeof t == "number") return new kn([t, t, t, t]);
								if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
									for (const r of t) if (typeof r != "number") return;
									switch (t.length) {
										case 1:
											t = [t[0], t[0], t[0], t[0]];
											break;
										case 2:
											t = [t[0], t[1], t[0], t[1]];
											break;
										case 3:
											t = [t[0], t[1], t[2], t[1]];
									}
									return new kn(t);
								}
							}
							toString() {
								return JSON.stringify(this.values);
							}
							static interpolate(t, r, o) {
								return new kn(Gn(t.values, r.values, o));
							}
						}
						class vn {
							constructor(t) {
								this.values = t.slice();
							}
							static parse(t) {
								if (t instanceof vn) return t;
								if (typeof t == "number") return new vn([t]);
								if (Array.isArray(t)) {
									for (const r of t) if (typeof r != "number") return;
									return new vn(t);
								}
							}
							toString() {
								return JSON.stringify(this.values);
							}
							static interpolate(t, r, o) {
								return new vn(Gn(t.values, r.values, o));
							}
						}
						class fn {
							constructor(t) {
								this.values = t.slice();
							}
							static parse(t) {
								if (t instanceof fn) return t;
								if (typeof t == "string") {
									const o = Mr.parse(t);
									return o ? new fn([o]) : void 0;
								}
								if (!Array.isArray(t)) return;
								const r = [];
								for (const o of t) {
									if (typeof o != "string") return;
									const c = Mr.parse(o);
									if (!c) return;
									r.push(c);
								}
								return new fn(r);
							}
							toString() {
								return JSON.stringify(this.values);
							}
							static interpolate(t, r, o, c = "rgb") {
								const f = [];
								if (t.values.length != r.values.length)
									throw new Error(
										`colorArray: Arrays have mismatched length (${t.values.length} vs. ${r.values.length}), cannot interpolate.`
									);
								for (let _ = 0; _ < t.values.length; _++)
									f.push(Mr.interpolate(t.values[_], r.values[_], o, c));
								return new fn(f);
							}
						}
						class on extends Error {
							constructor(t) {
								super(t), (this.name = "RuntimeError");
							}
							toJSON() {
								return this.message;
							}
						}
						const po = new Set([
							"center",
							"left",
							"right",
							"top",
							"bottom",
							"top-left",
							"top-right",
							"bottom-left",
							"bottom-right",
						]);
						class fi {
							constructor(t) {
								this.values = t.slice();
							}
							static parse(t) {
								if (t instanceof fi) return t;
								if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
									for (let r = 0; r < t.length; r += 2) {
										const o = t[r],
											c = t[r + 1];
										if (
											typeof o != "string" ||
											!po.has(o) ||
											!Array.isArray(c) ||
											c.length !== 2 ||
											typeof c[0] != "number" ||
											typeof c[1] != "number"
										)
											return;
									}
									return new fi(t);
								}
							}
							toString() {
								return JSON.stringify(this.values);
							}
							static interpolate(t, r, o) {
								const c = t.values,
									f = r.values;
								if (c.length !== f.length)
									throw new on(
										`Cannot interpolate values of different length. from: ${t.toString()}, to: ${r.toString()}`
									);
								const _ = [];
								for (let v = 0; v < c.length; v += 2) {
									if (c[v] !== f[v])
										throw new on(
											`Cannot interpolate values containing mismatched anchors. from[${v}]: ${c[v]}, to[${v}]: ${f[v]}`
										);
									_.push(c[v]);
									const [b, S] = c[v + 1],
										[I, L] = f[v + 1];
									_.push([Cn(b, I, o), Cn(S, L, o)]);
								}
								return new fi(_);
							}
						}
						class Hn {
							constructor(t) {
								(this.name = t.name), (this.available = t.available);
							}
							toString() {
								return this.name;
							}
							static fromString(t) {
								return t ? new Hn({ name: t, available: !1 }) : null;
							}
						}
						class jn {
							constructor(t, r, o) {
								(this.from = t), (this.to = r), (this.transition = o);
							}
							static interpolate(t, r, o) {
								return new jn(t, r, o);
							}
							static parse(t) {
								return t instanceof jn
									? t
									: Array.isArray(t) &&
									  t.length === 3 &&
									  typeof t[0] == "string" &&
									  typeof t[1] == "string" &&
									  typeof t[2] == "number"
									? new jn(t[0], t[1], t[2])
									: typeof t == "object" &&
									  typeof t.from == "string" &&
									  typeof t.to == "string" &&
									  typeof t.transition == "number"
									? new jn(t.from, t.to, t.transition)
									: typeof t == "string"
									? new jn(t, t, 1)
									: void 0;
							}
						}
						function zn(n, t, r, o) {
							return typeof n == "number" &&
								n >= 0 &&
								n <= 255 &&
								typeof t == "number" &&
								t >= 0 &&
								t <= 255 &&
								typeof r == "number" &&
								r >= 0 &&
								r <= 255
								? o === void 0 || (typeof o == "number" && o >= 0 && o <= 1)
									? null
									: `Invalid rgba value [${[n, t, r, o].join(
											", "
									  )}]: 'a' must be between 0 and 1.`
								: `Invalid rgba value [${(typeof o == "number"
										? [n, t, r, o]
										: [n, t, r]
								  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
						}
						function qa(n) {
							if (
								n === null ||
								typeof n == "string" ||
								typeof n == "boolean" ||
								typeof n == "number" ||
								n instanceof jn ||
								n instanceof Mr ||
								n instanceof Mn ||
								n instanceof Sn ||
								n instanceof kn ||
								n instanceof vn ||
								n instanceof fn ||
								n instanceof fi ||
								n instanceof Hn
							)
								return !0;
							if (Array.isArray(n)) {
								for (const t of n) if (!qa(t)) return !1;
								return !0;
							}
							if (typeof n == "object") {
								for (const t in n) if (!qa(n[t])) return !1;
								return !0;
							}
							return !1;
						}
						function Rr(n) {
							if (n === null) return mt;
							if (typeof n == "string") return At;
							if (typeof n == "boolean") return Ft;
							if (typeof n == "number") return He;
							if (n instanceof Mr) return Jt;
							if (n instanceof jn) return Cr;
							if (n instanceof Mn) return rn;
							if (n instanceof Sn) return pn;
							if (n instanceof kn) return gn;
							if (n instanceof vn) return En;
							if (n instanceof fn) return ln;
							if (n instanceof fi) return In;
							if (n instanceof Hn) return pr;
							if (Array.isArray(n)) {
								const t = n.length;
								let r;
								for (const o of n) {
									const c = Rr(o);
									if (r) {
										if (r === c) continue;
										r = ur;
										break;
									}
									r = c;
								}
								return tn(r || ur, t);
							}
							return Er;
						}
						function Gr(n) {
							const t = typeof n;
							return n === null
								? ""
								: t === "string" || t === "number" || t === "boolean"
								? String(n)
								: n instanceof Mr ||
								  n instanceof jn ||
								  n instanceof Sn ||
								  n instanceof kn ||
								  n instanceof vn ||
								  n instanceof fn ||
								  n instanceof fi ||
								  n instanceof Hn
								? n.toString()
								: JSON.stringify(n);
						}
						class _a {
							constructor(t, r) {
								(this.type = t), (this.value = r);
							}
							static parse(t, r) {
								if (t.length !== 2)
									return r.error(
										`'literal' expression requires exactly one argument, but found ${
											t.length - 1
										} instead.`
									);
								if (!qa(t[1])) return r.error("invalid value");
								const o = t[1];
								let c = Rr(o);
								const f = r.expectedType;
								return (
									c.kind !== "array" ||
										c.N !== 0 ||
										!f ||
										f.kind !== "array" ||
										(typeof f.N == "number" && f.N !== 0) ||
										(c = f),
									new _a(c, o)
								);
							}
							evaluate() {
								return this.value;
							}
							eachChild() {}
							outputDefined() {
								return !0;
							}
						}
						const un = { string: At, number: He, boolean: Ft, object: Er };
						class Li {
							constructor(t, r) {
								(this.type = t), (this.args = r);
							}
							static parse(t, r) {
								if (t.length < 2)
									return r.error("Expected at least one argument.");
								let o,
									c = 1;
								const f = t[0];
								if (f === "array") {
									let v, b;
									if (t.length > 2) {
										const S = t[1];
										if (typeof S != "string" || !(S in un) || S === "object")
											return r.error(
												'The item type argument of "array" must be one of string, number, boolean',
												1
											);
										(v = un[S]), c++;
									} else v = ur;
									if (t.length > 3) {
										if (
											t[2] !== null &&
											(typeof t[2] != "number" ||
												t[2] < 0 ||
												t[2] !== Math.floor(t[2]))
										)
											return r.error(
												'The length argument to "array" must be a positive integer literal',
												2
											);
										(b = t[2]), c++;
									}
									o = tn(v, b);
								} else {
									if (!un[f])
										throw new Error(`Types doesn't contain name = ${f}`);
									o = un[f];
								}
								const _ = [];
								for (; c < t.length; c++) {
									const v = r.parse(t[c], c, ur);
									if (!v) return null;
									_.push(v);
								}
								return new Li(o, _);
							}
							evaluate(t) {
								for (let r = 0; r < this.args.length; r++) {
									const o = this.args[r].evaluate(t);
									if (!pi(this.type, Rr(o))) return o;
									if (r === this.args.length - 1)
										throw new on(
											`Expected value to be of type ${en(
												this.type
											)}, but found ${en(Rr(o))} instead.`
										);
								}
								throw new Error();
							}
							eachChild(t) {
								this.args.forEach(t);
							}
							outputDefined() {
								return this.args.every((t) => t.outputDefined());
							}
						}
						const ga = {
							"to-boolean": Ft,
							"to-color": Jt,
							"to-number": He,
							"to-string": At,
						};
						class sa {
							constructor(t, r) {
								(this.type = t), (this.args = r);
							}
							static parse(t, r) {
								if (t.length < 2)
									return r.error("Expected at least one argument.");
								const o = t[0];
								if (!ga[o])
									throw new Error(
										`Can't parse ${o} as it is not part of the known types`
									);
								if ((o === "to-boolean" || o === "to-string") && t.length !== 2)
									return r.error("Expected one argument.");
								const c = ga[o],
									f = [];
								for (let _ = 1; _ < t.length; _++) {
									const v = r.parse(t[_], _, ur);
									if (!v) return null;
									f.push(v);
								}
								return new sa(c, f);
							}
							evaluate(t) {
								switch (this.type.kind) {
									case "boolean":
										return !!this.args[0].evaluate(t);
									case "color": {
										let r, o;
										for (const c of this.args) {
											if (((r = c.evaluate(t)), (o = null), r instanceof Mr))
												return r;
											if (typeof r == "string") {
												const f = t.parseColor(r);
												if (f) return f;
											} else if (
												Array.isArray(r) &&
												((o =
													r.length < 3 || r.length > 4
														? `Invalid rgba value ${JSON.stringify(
																r
														  )}: expected an array containing either three or four numeric values.`
														: zn(r[0], r[1], r[2], r[3])),
												!o)
											)
												return new Mr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
										}
										throw new on(
											o ||
												`Could not parse color from value '${
													typeof r == "string" ? r : JSON.stringify(r)
												}'`
										);
									}
									case "padding": {
										let r;
										for (const o of this.args) {
											r = o.evaluate(t);
											const c = kn.parse(r);
											if (c) return c;
										}
										throw new on(
											`Could not parse padding from value '${
												typeof r == "string" ? r : JSON.stringify(r)
											}'`
										);
									}
									case "numberArray": {
										let r;
										for (const o of this.args) {
											r = o.evaluate(t);
											const c = vn.parse(r);
											if (c) return c;
										}
										throw new on(
											`Could not parse numberArray from value '${
												typeof r == "string" ? r : JSON.stringify(r)
											}'`
										);
									}
									case "colorArray": {
										let r;
										for (const o of this.args) {
											r = o.evaluate(t);
											const c = fn.parse(r);
											if (c) return c;
										}
										throw new on(
											`Could not parse colorArray from value '${
												typeof r == "string" ? r : JSON.stringify(r)
											}'`
										);
									}
									case "variableAnchorOffsetCollection": {
										let r;
										for (const o of this.args) {
											r = o.evaluate(t);
											const c = fi.parse(r);
											if (c) return c;
										}
										throw new on(
											`Could not parse variableAnchorOffsetCollection from value '${
												typeof r == "string" ? r : JSON.stringify(r)
											}'`
										);
									}
									case "number": {
										let r = null;
										for (const o of this.args) {
											if (((r = o.evaluate(t)), r === null)) return 0;
											const c = Number(r);
											if (!isNaN(c)) return c;
										}
										throw new on(
											`Could not convert ${JSON.stringify(r)} to number.`
										);
									}
									case "formatted":
										return Sn.fromString(Gr(this.args[0].evaluate(t)));
									case "resolvedImage":
										return Hn.fromString(Gr(this.args[0].evaluate(t)));
									case "projectionDefinition":
										return this.args[0].evaluate(t);
									default:
										return Gr(this.args[0].evaluate(t));
								}
							}
							eachChild(t) {
								this.args.forEach(t);
							}
							outputDefined() {
								return this.args.every((t) => t.outputDefined());
							}
						}
						const Ja = ["Unknown", "Point", "LineString", "Polygon"];
						class Ms {
							constructor() {
								(this.globals = null),
									(this.feature = null),
									(this.featureState = null),
									(this.formattedSection = null),
									(this._parseColorCache = new Map()),
									(this.availableImages = null),
									(this.canonical = null);
							}
							id() {
								return this.feature && "id" in this.feature
									? this.feature.id
									: null;
							}
							geometryType() {
								return this.feature
									? typeof this.feature.type == "number"
										? Ja[this.feature.type]
										: this.feature.type
									: null;
							}
							geometry() {
								return this.feature && "geometry" in this.feature
									? this.feature.geometry
									: null;
							}
							canonicalID() {
								return this.canonical;
							}
							properties() {
								return (this.feature && this.feature.properties) || {};
							}
							parseColor(t) {
								let r = this._parseColorCache.get(t);
								return (
									r || ((r = Mr.parse(t)), this._parseColorCache.set(t, r)), r
								);
							}
						}
						class Ca {
							constructor(t, r, o = [], c, f = new Zr(), _ = []) {
								(this.registry = t),
									(this.path = o),
									(this.key = o.map((v) => `[${v}]`).join("")),
									(this.scope = f),
									(this.errors = _),
									(this.expectedType = c),
									(this._isConstant = r);
							}
							parse(t, r, o, c, f = {}) {
								return r
									? this.concat(r, o, c)._parse(t, f)
									: this._parse(t, f);
							}
							_parse(t, r) {
								function o(c, f, _) {
									return _ === "assert"
										? new Li(f, [c])
										: _ === "coerce"
										? new sa(f, [c])
										: c;
								}
								if (
									((t !== null &&
										typeof t != "string" &&
										typeof t != "boolean" &&
										typeof t != "number") ||
										(t = ["literal", t]),
									Array.isArray(t))
								) {
									if (t.length === 0)
										return this.error(
											'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
										);
									const c = t[0];
									if (typeof c != "string")
										return (
											this.error(
												`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`,
												0
											),
											null
										);
									const f = this.registry[c];
									if (f) {
										let _ = f.parse(t, this);
										if (!_) return null;
										if (this.expectedType) {
											const v = this.expectedType,
												b = _.type;
											if (
												(v.kind !== "string" &&
													v.kind !== "number" &&
													v.kind !== "boolean" &&
													v.kind !== "object" &&
													v.kind !== "array") ||
												b.kind !== "value"
											) {
												if (
													(v.kind === "projectionDefinition" &&
														["string", "array"].includes(b.kind)) ||
													(["color", "formatted", "resolvedImage"].includes(
														v.kind
													) &&
														["value", "string"].includes(b.kind)) ||
													(["padding", "numberArray"].includes(v.kind) &&
														["value", "number", "array"].includes(b.kind)) ||
													(v.kind === "colorArray" &&
														["value", "string", "array"].includes(b.kind)) ||
													(v.kind === "variableAnchorOffsetCollection" &&
														["value", "array"].includes(b.kind))
												)
													_ = o(_, v, r.typeAnnotation || "coerce");
												else if (this.checkSubtype(v, b)) return null;
											} else _ = o(_, v, r.typeAnnotation || "assert");
										}
										if (
											!(_ instanceof _a) &&
											_.type.kind !== "resolvedImage" &&
											this._isConstant(_)
										) {
											const v = new Ms();
											try {
												_ = new _a(_.type, _.evaluate(v));
											} catch (b) {
												return this.error(b.message), null;
											}
										}
										return _;
									}
									return this.error(
										`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`,
										0
									);
								}
								return this.error(
									t === void 0
										? "'undefined' value invalid. Use null instead."
										: typeof t == "object"
										? 'Bare objects invalid. Use ["literal", {...}] instead.'
										: `Expected an array, but found ${typeof t} instead.`
								);
							}
							concat(t, r, o) {
								const c =
										typeof t == "number" ? this.path.concat(t) : this.path,
									f = o ? this.scope.concat(o) : this.scope;
								return new Ca(
									this.registry,
									this._isConstant,
									c,
									r || null,
									f,
									this.errors
								);
							}
							error(t, ...r) {
								const o = `${this.key}${r.map((c) => `[${c}]`).join("")}`;
								this.errors.push(new Yr(o, t));
							}
							checkSubtype(t, r) {
								const o = pi(t, r);
								return o && this.error(o), o;
							}
						}
						class Qa {
							constructor(t, r) {
								(this.type = r.type),
									(this.bindings = [].concat(t)),
									(this.result = r);
							}
							evaluate(t) {
								return this.result.evaluate(t);
							}
							eachChild(t) {
								for (const r of this.bindings) t(r[1]);
								t(this.result);
							}
							static parse(t, r) {
								if (t.length < 4)
									return r.error(
										`Expected at least 3 arguments, but found ${
											t.length - 1
										} instead.`
									);
								const o = [];
								for (let f = 1; f < t.length - 1; f += 2) {
									const _ = t[f];
									if (typeof _ != "string")
										return r.error(
											`Expected string, but found ${typeof _} instead.`,
											f
										);
									if (/[^a-zA-Z0-9_]/.test(_))
										return r.error(
											"Variable names must contain only alphanumeric characters or '_'.",
											f
										);
									const v = r.parse(t[f + 1], f + 1);
									if (!v) return null;
									o.push([_, v]);
								}
								const c = r.parse(
									t[t.length - 1],
									t.length - 1,
									r.expectedType,
									o
								);
								return c ? new Qa(o, c) : null;
							}
							outputDefined() {
								return this.result.outputDefined();
							}
						}
						class Jo {
							constructor(t, r) {
								(this.type = r.type),
									(this.name = t),
									(this.boundExpression = r);
							}
							static parse(t, r) {
								if (t.length !== 2 || typeof t[1] != "string")
									return r.error(
										"'var' expression requires exactly one string literal argument."
									);
								const o = t[1];
								return r.scope.has(o)
									? new Jo(o, r.scope.get(o))
									: r.error(
											`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`,
											1
									  );
							}
							evaluate(t) {
								return this.boundExpression.evaluate(t);
							}
							eachChild() {}
							outputDefined() {
								return !1;
							}
						}
						class gl {
							constructor(t, r, o) {
								(this.type = t), (this.index = r), (this.input = o);
							}
							static parse(t, r) {
								if (t.length !== 3)
									return r.error(
										`Expected 2 arguments, but found ${t.length - 1} instead.`
									);
								const o = r.parse(t[1], 1, He),
									c = r.parse(t[2], 2, tn(r.expectedType || ur));
								return o && c ? new gl(c.type.itemType, o, c) : null;
							}
							evaluate(t) {
								const r = this.index.evaluate(t),
									o = this.input.evaluate(t);
								if (r < 0) throw new on(`Array index out of bounds: ${r} < 0.`);
								if (r >= o.length)
									throw new on(
										`Array index out of bounds: ${r} > ${o.length - 1}.`
									);
								if (r !== Math.floor(r))
									throw new on(
										`Array index must be an integer, but found ${r} instead.`
									);
								return o[r];
							}
							eachChild(t) {
								t(this.index), t(this.input);
							}
							outputDefined() {
								return !1;
							}
						}
						class vl {
							constructor(t, r) {
								(this.type = Ft), (this.needle = t), (this.haystack = r);
							}
							static parse(t, r) {
								if (t.length !== 3)
									return r.error(
										`Expected 2 arguments, but found ${t.length - 1} instead.`
									);
								const o = r.parse(t[1], 1, ur),
									c = r.parse(t[2], 2, ur);
								return o && c
									? Xi(o.type, [Ft, At, He, mt, ur])
										? new vl(o, c)
										: r.error(
												`Expected first argument to be of type boolean, string, number or null, but found ${en(
													o.type
												)} instead`
										  )
									: null;
							}
							evaluate(t) {
								const r = this.needle.evaluate(t),
									o = this.haystack.evaluate(t);
								if (!o) return !1;
								if (!Zn(r, ["boolean", "string", "number", "null"]))
									throw new on(
										`Expected first argument to be of type boolean, string, number or null, but found ${en(
											Rr(r)
										)} instead.`
									);
								if (!Zn(o, ["string", "array"]))
									throw new on(
										`Expected second argument to be of type array or string, but found ${en(
											Rr(o)
										)} instead.`
									);
								return o.indexOf(r) >= 0;
							}
							eachChild(t) {
								t(this.needle), t(this.haystack);
							}
							outputDefined() {
								return !0;
							}
						}
						class Sa {
							constructor(t, r, o) {
								(this.type = He),
									(this.needle = t),
									(this.haystack = r),
									(this.fromIndex = o);
							}
							static parse(t, r) {
								if (t.length <= 2 || t.length >= 5)
									return r.error(
										`Expected 3 or 4 arguments, but found ${
											t.length - 1
										} instead.`
									);
								const o = r.parse(t[1], 1, ur),
									c = r.parse(t[2], 2, ur);
								if (!o || !c) return null;
								if (!Xi(o.type, [Ft, At, He, mt, ur]))
									return r.error(
										`Expected first argument to be of type boolean, string, number or null, but found ${en(
											o.type
										)} instead`
									);
								if (t.length === 4) {
									const f = r.parse(t[3], 3, He);
									return f ? new Sa(o, c, f) : null;
								}
								return new Sa(o, c);
							}
							evaluate(t) {
								const r = this.needle.evaluate(t),
									o = this.haystack.evaluate(t);
								if (!Zn(r, ["boolean", "string", "number", "null"]))
									throw new on(
										`Expected first argument to be of type boolean, string, number or null, but found ${en(
											Rr(r)
										)} instead.`
									);
								let c;
								if (
									(this.fromIndex && (c = this.fromIndex.evaluate(t)),
									Zn(o, ["string"]))
								) {
									const f = o.indexOf(r, c);
									return f === -1 ? -1 : [...o.slice(0, f)].length;
								}
								if (Zn(o, ["array"])) return o.indexOf(r, c);
								throw new on(
									`Expected second argument to be of type array or string, but found ${en(
										Rr(o)
									)} instead.`
								);
							}
							eachChild(t) {
								t(this.needle),
									t(this.haystack),
									this.fromIndex && t(this.fromIndex);
							}
							outputDefined() {
								return !1;
							}
						}
						class Ti {
							constructor(t, r, o, c, f, _) {
								(this.inputType = t),
									(this.type = r),
									(this.input = o),
									(this.cases = c),
									(this.outputs = f),
									(this.otherwise = _);
							}
							static parse(t, r) {
								if (t.length < 5)
									return r.error(
										`Expected at least 4 arguments, but found only ${
											t.length - 1
										}.`
									);
								if (t.length % 2 != 1)
									return r.error("Expected an even number of arguments.");
								let o, c;
								r.expectedType &&
									r.expectedType.kind !== "value" &&
									(c = r.expectedType);
								const f = {},
									_ = [];
								for (let S = 2; S < t.length - 1; S += 2) {
									let I = t[S];
									const L = t[S + 1];
									Array.isArray(I) || (I = [I]);
									const F = r.concat(S);
									if (I.length === 0)
										return F.error("Expected at least one branch label.");
									for (const Z of I) {
										if (typeof Z != "number" && typeof Z != "string")
											return F.error(
												"Branch labels must be numbers or strings."
											);
										if (
											typeof Z == "number" &&
											Math.abs(Z) > Number.MAX_SAFE_INTEGER
										)
											return F.error(
												`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
											);
										if (typeof Z == "number" && Math.floor(Z) !== Z)
											return F.error(
												"Numeric branch labels must be integer values."
											);
										if (o) {
											if (F.checkSubtype(o, Rr(Z))) return null;
										} else o = Rr(Z);
										if (f[String(Z)] !== void 0)
											return F.error("Branch labels must be unique.");
										f[String(Z)] = _.length;
									}
									const q = r.parse(L, S, c);
									if (!q) return null;
									(c = c || q.type), _.push(q);
								}
								const v = r.parse(t[1], 1, ur);
								if (!v) return null;
								const b = r.parse(t[t.length - 1], t.length - 1, c);
								return b
									? v.type.kind !== "value" &&
									  r.concat(1).checkSubtype(o, v.type)
										? null
										: new Ti(o, c, v, f, _, b)
									: null;
							}
							evaluate(t) {
								const r = this.input.evaluate(t);
								return (
									(Rr(r) === this.inputType && this.outputs[this.cases[r]]) ||
									this.otherwise
								).evaluate(t);
							}
							eachChild(t) {
								t(this.input), this.outputs.forEach(t), t(this.otherwise);
							}
							outputDefined() {
								return (
									this.outputs.every((t) => t.outputDefined()) &&
									this.otherwise.outputDefined()
								);
							}
						}
						class Qo {
							constructor(t, r, o) {
								(this.type = t), (this.branches = r), (this.otherwise = o);
							}
							static parse(t, r) {
								if (t.length < 4)
									return r.error(
										`Expected at least 3 arguments, but found only ${
											t.length - 1
										}.`
									);
								if (t.length % 2 != 0)
									return r.error("Expected an odd number of arguments.");
								let o;
								r.expectedType &&
									r.expectedType.kind !== "value" &&
									(o = r.expectedType);
								const c = [];
								for (let _ = 1; _ < t.length - 1; _ += 2) {
									const v = r.parse(t[_], _, Ft);
									if (!v) return null;
									const b = r.parse(t[_ + 1], _ + 1, o);
									if (!b) return null;
									c.push([v, b]), (o = o || b.type);
								}
								const f = r.parse(t[t.length - 1], t.length - 1, o);
								if (!f) return null;
								if (!o) throw new Error("Can't infer output type");
								return new Qo(o, c, f);
							}
							evaluate(t) {
								for (const [r, o] of this.branches)
									if (r.evaluate(t)) return o.evaluate(t);
								return this.otherwise.evaluate(t);
							}
							eachChild(t) {
								for (const [r, o] of this.branches) t(r), t(o);
								t(this.otherwise);
							}
							outputDefined() {
								return (
									this.branches.every(([t, r]) => r.outputDefined()) &&
									this.otherwise.outputDefined()
								);
							}
						}
						class ks {
							constructor(t, r, o, c) {
								(this.type = t),
									(this.input = r),
									(this.beginIndex = o),
									(this.endIndex = c);
							}
							static parse(t, r) {
								if (t.length <= 2 || t.length >= 5)
									return r.error(
										`Expected 3 or 4 arguments, but found ${
											t.length - 1
										} instead.`
									);
								const o = r.parse(t[1], 1, ur),
									c = r.parse(t[2], 2, He);
								if (!o || !c) return null;
								if (!Xi(o.type, [tn(ur), At, ur]))
									return r.error(
										`Expected first argument to be of type array or string, but found ${en(
											o.type
										)} instead`
									);
								if (t.length === 4) {
									const f = r.parse(t[3], 3, He);
									return f ? new ks(o.type, o, c, f) : null;
								}
								return new ks(o.type, o, c);
							}
							evaluate(t) {
								const r = this.input.evaluate(t),
									o = this.beginIndex.evaluate(t);
								let c;
								if (
									(this.endIndex && (c = this.endIndex.evaluate(t)),
									Zn(r, ["string"]))
								)
									return [...r].slice(o, c).join("");
								if (Zn(r, ["array"])) return r.slice(o, c);
								throw new on(
									`Expected first argument to be of type array or string, but found ${en(
										Rr(r)
									)} instead.`
								);
							}
							eachChild(t) {
								t(this.input),
									t(this.beginIndex),
									this.endIndex && t(this.endIndex);
							}
							outputDefined() {
								return !1;
							}
						}
						function Mo(n, t) {
							const r = n.length - 1;
							let o,
								c,
								f = 0,
								_ = r,
								v = 0;
							for (; f <= _; )
								if (
									((v = Math.floor((f + _) / 2)),
									(o = n[v]),
									(c = n[v + 1]),
									o <= t)
								) {
									if (v === r || t < c) return v;
									f = v + 1;
								} else {
									if (!(o > t)) throw new on("Input is not a number.");
									_ = v - 1;
								}
							return 0;
						}
						class ei {
							constructor(t, r, o) {
								(this.type = t),
									(this.input = r),
									(this.labels = []),
									(this.outputs = []);
								for (const [c, f] of o)
									this.labels.push(c), this.outputs.push(f);
							}
							static parse(t, r) {
								if (t.length - 1 < 4)
									return r.error(
										`Expected at least 4 arguments, but found only ${
											t.length - 1
										}.`
									);
								if ((t.length - 1) % 2 != 0)
									return r.error("Expected an even number of arguments.");
								const o = r.parse(t[1], 1, He);
								if (!o) return null;
								const c = [];
								let f = null;
								r.expectedType &&
									r.expectedType.kind !== "value" &&
									(f = r.expectedType);
								for (let _ = 1; _ < t.length; _ += 2) {
									const v = _ === 1 ? -1 / 0 : t[_],
										b = t[_ + 1],
										S = _,
										I = _ + 1;
									if (typeof v != "number")
										return r.error(
											'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
											S
										);
									if (c.length && c[c.length - 1][0] >= v)
										return r.error(
											'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
											S
										);
									const L = r.parse(b, I, f);
									if (!L) return null;
									(f = f || L.type), c.push([v, L]);
								}
								return new ei(f, o, c);
							}
							evaluate(t) {
								const r = this.labels,
									o = this.outputs;
								if (r.length === 1) return o[0].evaluate(t);
								const c = this.input.evaluate(t);
								if (c <= r[0]) return o[0].evaluate(t);
								const f = r.length;
								return c >= r[f - 1]
									? o[f - 1].evaluate(t)
									: o[Mo(r, c)].evaluate(t);
							}
							eachChild(t) {
								t(this.input);
								for (const r of this.outputs) t(r);
							}
							outputDefined() {
								return this.outputs.every((t) => t.outputDefined());
							}
						}
						function Fh(n) {
							return n &&
								n.__esModule &&
								Object.prototype.hasOwnProperty.call(n, "default")
								? n.default
								: n;
						}
						var As,
							Ec,
							bp = (function () {
								if (Ec) return As;
								function n(t, r, o, c) {
									(this.cx = 3 * t),
										(this.bx = 3 * (o - t) - this.cx),
										(this.ax = 1 - this.cx - this.bx),
										(this.cy = 3 * r),
										(this.by = 3 * (c - r) - this.cy),
										(this.ay = 1 - this.cy - this.by),
										(this.p1x = t),
										(this.p1y = r),
										(this.p2x = o),
										(this.p2y = c);
								}
								return (
									(Ec = 1),
									(As = n),
									(n.prototype = {
										sampleCurveX: function (t) {
											return ((this.ax * t + this.bx) * t + this.cx) * t;
										},
										sampleCurveY: function (t) {
											return ((this.ay * t + this.by) * t + this.cy) * t;
										},
										sampleCurveDerivativeX: function (t) {
											return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
										},
										solveCurveX: function (t, r) {
											if ((r === void 0 && (r = 1e-6), t < 0)) return 0;
											if (t > 1) return 1;
											for (var o = t, c = 0; c < 8; c++) {
												var f = this.sampleCurveX(o) - t;
												if (Math.abs(f) < r) return o;
												var _ = this.sampleCurveDerivativeX(o);
												if (Math.abs(_) < 1e-6) break;
												o -= f / _;
											}
											var v = 0,
												b = 1;
											for (
												o = t, c = 0;
												c < 20 &&
												((f = this.sampleCurveX(o)), !(Math.abs(f - t) < r));
												c++
											)
												t > f ? (v = o) : (b = o), (o = 0.5 * (b - v) + v);
											return o;
										},
										solve: function (t, r) {
											return this.sampleCurveY(this.solveCurveX(t, r));
										},
									}),
									As
								);
							})(),
							es = Fh(bp);
						class Di {
							constructor(t, r, o, c, f) {
								(this.type = t),
									(this.operator = r),
									(this.interpolation = o),
									(this.input = c),
									(this.labels = []),
									(this.outputs = []);
								for (const [_, v] of f)
									this.labels.push(_), this.outputs.push(v);
							}
							static interpolationFactor(t, r, o, c) {
								let f = 0;
								if (t.name === "exponential") f = Es(r, t.base, o, c);
								else if (t.name === "linear") f = Es(r, 1, o, c);
								else if (t.name === "cubic-bezier") {
									const _ = t.controlPoints;
									f = new es(_[0], _[1], _[2], _[3]).solve(Es(r, 1, o, c));
								}
								return f;
							}
							static parse(t, r) {
								let [o, c, f, ..._] = t;
								if (!Array.isArray(c) || c.length === 0)
									return r.error(
										"Expected an interpolation type expression.",
										1
									);
								if (c[0] === "linear") c = { name: "linear" };
								else if (c[0] === "exponential") {
									const S = c[1];
									if (typeof S != "number")
										return r.error(
											"Exponential interpolation requires a numeric base.",
											1,
											1
										);
									c = { name: "exponential", base: S };
								} else {
									if (c[0] !== "cubic-bezier")
										return r.error(
											`Unknown interpolation type ${String(c[0])}`,
											1,
											0
										);
									{
										const S = c.slice(1);
										if (
											S.length !== 4 ||
											S.some((I) => typeof I != "number" || I < 0 || I > 1)
										)
											return r.error(
												"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
												1
											);
										c = { name: "cubic-bezier", controlPoints: S };
									}
								}
								if (t.length - 1 < 4)
									return r.error(
										`Expected at least 4 arguments, but found only ${
											t.length - 1
										}.`
									);
								if ((t.length - 1) % 2 != 0)
									return r.error("Expected an even number of arguments.");
								if (((f = r.parse(f, 2, He)), !f)) return null;
								const v = [];
								let b = null;
								(o !== "interpolate-hcl" && o !== "interpolate-lab") ||
								r.expectedType == ln
									? r.expectedType &&
									  r.expectedType.kind !== "value" &&
									  (b = r.expectedType)
									: (b = Jt);
								for (let S = 0; S < _.length; S += 2) {
									const I = _[S],
										L = _[S + 1],
										F = S + 3,
										q = S + 4;
									if (typeof I != "number")
										return r.error(
											'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
											F
										);
									if (v.length && v[v.length - 1][0] >= I)
										return r.error(
											'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
											F
										);
									const Z = r.parse(L, q, b);
									if (!Z) return null;
									(b = b || Z.type), v.push([I, Z]);
								}
								return ni(b, He) ||
									ni(b, Cr) ||
									ni(b, Jt) ||
									ni(b, gn) ||
									ni(b, En) ||
									ni(b, ln) ||
									ni(b, In) ||
									ni(b, tn(He))
									? new Di(b, o, c, f, v)
									: r.error(`Type ${en(b)} is not interpolatable.`);
							}
							evaluate(t) {
								const r = this.labels,
									o = this.outputs;
								if (r.length === 1) return o[0].evaluate(t);
								const c = this.input.evaluate(t);
								if (c <= r[0]) return o[0].evaluate(t);
								const f = r.length;
								if (c >= r[f - 1]) return o[f - 1].evaluate(t);
								const _ = Mo(r, c),
									v = Di.interpolationFactor(
										this.interpolation,
										c,
										r[_],
										r[_ + 1]
									),
									b = o[_].evaluate(t),
									S = o[_ + 1].evaluate(t);
								switch (this.operator) {
									case "interpolate":
										switch (this.type.kind) {
											case "number":
												return Cn(b, S, v);
											case "color":
												return Mr.interpolate(b, S, v);
											case "padding":
												return kn.interpolate(b, S, v);
											case "colorArray":
												return fn.interpolate(b, S, v);
											case "numberArray":
												return vn.interpolate(b, S, v);
											case "variableAnchorOffsetCollection":
												return fi.interpolate(b, S, v);
											case "array":
												return Gn(b, S, v);
											case "projectionDefinition":
												return jn.interpolate(b, S, v);
										}
									case "interpolate-hcl":
										switch (this.type.kind) {
											case "color":
												return Mr.interpolate(b, S, v, "hcl");
											case "colorArray":
												return fn.interpolate(b, S, v, "hcl");
										}
									case "interpolate-lab":
										switch (this.type.kind) {
											case "color":
												return Mr.interpolate(b, S, v, "lab");
											case "colorArray":
												return fn.interpolate(b, S, v, "lab");
										}
								}
							}
							eachChild(t) {
								t(this.input);
								for (const r of this.outputs) t(r);
							}
							outputDefined() {
								return this.outputs.every((t) => t.outputDefined());
							}
						}
						function Es(n, t, r, o) {
							const c = o - r,
								f = n - r;
							return c === 0
								? 0
								: t === 1
								? f / c
								: (Math.pow(t, f) - 1) / (Math.pow(t, c) - 1);
						}
						const Za = {
							color: Mr.interpolate,
							number: Cn,
							padding: kn.interpolate,
							numberArray: vn.interpolate,
							colorArray: fn.interpolate,
							variableAnchorOffsetCollection: fi.interpolate,
							array: Gn,
						};
						class zs {
							constructor(t, r) {
								(this.type = t), (this.args = r);
							}
							static parse(t, r) {
								if (t.length < 2)
									return r.error("Expected at least one argument.");
								let o = null;
								const c = r.expectedType;
								c && c.kind !== "value" && (o = c);
								const f = [];
								for (const v of t.slice(1)) {
									const b = r.parse(v, 1 + f.length, o, void 0, {
										typeAnnotation: "omit",
									});
									if (!b) return null;
									(o = o || b.type), f.push(b);
								}
								if (!o) throw new Error("No output type");
								const _ = c && f.some((v) => pi(c, v.type));
								return new zs(_ ? ur : o, f);
							}
							evaluate(t) {
								let r,
									o = null,
									c = 0;
								for (const f of this.args)
									if (
										(c++,
										(o = f.evaluate(t)),
										o &&
											o instanceof Hn &&
											!o.available &&
											(r || (r = o.name),
											(o = null),
											c === this.args.length && (o = r)),
										o !== null)
									)
										break;
								return o;
							}
							eachChild(t) {
								this.args.forEach(t);
							}
							outputDefined() {
								return this.args.every((t) => t.outputDefined());
							}
						}
						function Ls(n, t) {
							return n === "==" || n === "!="
								? t.kind === "boolean" ||
										t.kind === "string" ||
										t.kind === "number" ||
										t.kind === "null" ||
										t.kind === "value"
								: t.kind === "string" ||
										t.kind === "number" ||
										t.kind === "value";
						}
						function Ds(n, t, r, o) {
							return o.compare(t, r) === 0;
						}
						function ji(n, t, r) {
							const o = n !== "==" && n !== "!=";
							return class r0 {
								constructor(f, _, v) {
									(this.type = Ft),
										(this.lhs = f),
										(this.rhs = _),
										(this.collator = v),
										(this.hasUntypedArgument =
											f.type.kind === "value" || _.type.kind === "value");
								}
								static parse(f, _) {
									if (f.length !== 3 && f.length !== 4)
										return _.error("Expected two or three arguments.");
									const v = f[0];
									let b = _.parse(f[1], 1, ur);
									if (!b) return null;
									if (!Ls(v, b.type))
										return _.concat(1).error(
											`"${v}" comparisons are not supported for type '${en(
												b.type
											)}'.`
										);
									let S = _.parse(f[2], 2, ur);
									if (!S) return null;
									if (!Ls(v, S.type))
										return _.concat(2).error(
											`"${v}" comparisons are not supported for type '${en(
												S.type
											)}'.`
										);
									if (
										b.type.kind !== S.type.kind &&
										b.type.kind !== "value" &&
										S.type.kind !== "value"
									)
										return _.error(
											`Cannot compare types '${en(b.type)}' and '${en(
												S.type
											)}'.`
										);
									o &&
										(b.type.kind === "value" && S.type.kind !== "value"
											? (b = new Li(S.type, [b]))
											: b.type.kind !== "value" &&
											  S.type.kind === "value" &&
											  (S = new Li(b.type, [S])));
									let I = null;
									if (f.length === 4) {
										if (
											b.type.kind !== "string" &&
											S.type.kind !== "string" &&
											b.type.kind !== "value" &&
											S.type.kind !== "value"
										)
											return _.error(
												"Cannot use collator to compare non-string types."
											);
										if (((I = _.parse(f[3], 3, rn)), !I)) return null;
									}
									return new r0(b, S, I);
								}
								evaluate(f) {
									const _ = this.lhs.evaluate(f),
										v = this.rhs.evaluate(f);
									if (o && this.hasUntypedArgument) {
										const b = Rr(_),
											S = Rr(v);
										if (
											b.kind !== S.kind ||
											(b.kind !== "string" && b.kind !== "number")
										)
											throw new on(
												`Expected arguments for "${n}" to be (string, string) or (number, number), but found (${b.kind}, ${S.kind}) instead.`
											);
									}
									if (this.collator && !o && this.hasUntypedArgument) {
										const b = Rr(_),
											S = Rr(v);
										if (b.kind !== "string" || S.kind !== "string")
											return t(f, _, v);
									}
									return this.collator
										? r(f, _, v, this.collator.evaluate(f))
										: t(f, _, v);
								}
								eachChild(f) {
									f(this.lhs), f(this.rhs), this.collator && f(this.collator);
								}
								outputDefined() {
									return !0;
								}
							};
						}
						const Oh = ji(
								"==",
								function (n, t, r) {
									return t === r;
								},
								Ds
							),
							yl = ji(
								"!=",
								function (n, t, r) {
									return t !== r;
								},
								function (n, t, r, o) {
									return !Ds(0, t, r, o);
								}
							),
							wp = ji(
								"<",
								function (n, t, r) {
									return t < r;
								},
								function (n, t, r, o) {
									return o.compare(t, r) < 0;
								}
							),
							zc = ji(
								">",
								function (n, t, r) {
									return t > r;
								},
								function (n, t, r, o) {
									return o.compare(t, r) > 0;
								}
							),
							Tp = ji(
								"<=",
								function (n, t, r) {
									return t <= r;
								},
								function (n, t, r, o) {
									return o.compare(t, r) <= 0;
								}
							),
							Cp = ji(
								">=",
								function (n, t, r) {
									return t >= r;
								},
								function (n, t, r, o) {
									return o.compare(t, r) >= 0;
								}
							);
						class xl {
							constructor(t, r, o) {
								(this.type = rn),
									(this.locale = o),
									(this.caseSensitive = t),
									(this.diacriticSensitive = r);
							}
							static parse(t, r) {
								if (t.length !== 2) return r.error("Expected one argument.");
								const o = t[1];
								if (typeof o != "object" || Array.isArray(o))
									return r.error(
										"Collator options argument must be an object."
									);
								const c = r.parse(
									o["case-sensitive"] !== void 0 && o["case-sensitive"],
									1,
									Ft
								);
								if (!c) return null;
								const f = r.parse(
									o["diacritic-sensitive"] !== void 0 &&
										o["diacritic-sensitive"],
									1,
									Ft
								);
								if (!f) return null;
								let _ = null;
								return o.locale && ((_ = r.parse(o.locale, 1, At)), !_)
									? null
									: new xl(c, f, _);
							}
							evaluate(t) {
								return new Mn(
									this.caseSensitive.evaluate(t),
									this.diacriticSensitive.evaluate(t),
									this.locale ? this.locale.evaluate(t) : null
								);
							}
							eachChild(t) {
								t(this.caseSensitive),
									t(this.diacriticSensitive),
									this.locale && t(this.locale);
							}
							outputDefined() {
								return !1;
							}
						}
						class Lc {
							constructor(t, r, o, c, f) {
								(this.type = At),
									(this.number = t),
									(this.locale = r),
									(this.currency = o),
									(this.minFractionDigits = c),
									(this.maxFractionDigits = f);
							}
							static parse(t, r) {
								if (t.length !== 3) return r.error("Expected two arguments.");
								const o = r.parse(t[1], 1, He);
								if (!o) return null;
								const c = t[2];
								if (typeof c != "object" || Array.isArray(c))
									return r.error(
										"NumberFormat options argument must be an object."
									);
								let f = null;
								if (c.locale && ((f = r.parse(c.locale, 1, At)), !f))
									return null;
								let _ = null;
								if (c.currency && ((_ = r.parse(c.currency, 1, At)), !_))
									return null;
								let v = null;
								if (
									c["min-fraction-digits"] &&
									((v = r.parse(c["min-fraction-digits"], 1, He)), !v)
								)
									return null;
								let b = null;
								return c["max-fraction-digits"] &&
									((b = r.parse(c["max-fraction-digits"], 1, He)), !b)
									? null
									: new Lc(o, f, _, v, b);
							}
							evaluate(t) {
								return new Intl.NumberFormat(
									this.locale ? this.locale.evaluate(t) : [],
									{
										style: this.currency ? "currency" : "decimal",
										currency: this.currency
											? this.currency.evaluate(t)
											: void 0,
										minimumFractionDigits: this.minFractionDigits
											? this.minFractionDigits.evaluate(t)
											: void 0,
										maximumFractionDigits: this.maxFractionDigits
											? this.maxFractionDigits.evaluate(t)
											: void 0,
									}
								).format(this.number.evaluate(t));
							}
							eachChild(t) {
								t(this.number),
									this.locale && t(this.locale),
									this.currency && t(this.currency),
									this.minFractionDigits && t(this.minFractionDigits),
									this.maxFractionDigits && t(this.maxFractionDigits);
							}
							outputDefined() {
								return !1;
							}
						}
						class ko {
							constructor(t) {
								(this.type = pn), (this.sections = t);
							}
							static parse(t, r) {
								if (t.length < 2)
									return r.error("Expected at least one argument.");
								const o = t[1];
								if (!Array.isArray(o) && typeof o == "object")
									return r.error(
										"First argument must be an image or text section."
									);
								const c = [];
								let f = !1;
								for (let _ = 1; _ <= t.length - 1; ++_) {
									const v = t[_];
									if (f && typeof v == "object" && !Array.isArray(v)) {
										f = !1;
										let b = null;
										if (
											v["font-scale"] &&
											((b = r.parse(v["font-scale"], 1, He)), !b)
										)
											return null;
										let S = null;
										if (
											v["text-font"] &&
											((S = r.parse(v["text-font"], 1, tn(At))), !S)
										)
											return null;
										let I = null;
										if (
											v["text-color"] &&
											((I = r.parse(v["text-color"], 1, Jt)), !I)
										)
											return null;
										let L = null;
										if (v["vertical-align"]) {
											if (
												typeof v["vertical-align"] == "string" &&
												!bn.includes(v["vertical-align"])
											)
												return r.error(
													`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${v["vertical-align"]}' instead.`
												);
											if (((L = r.parse(v["vertical-align"], 1, At)), !L))
												return null;
										}
										const F = c[c.length - 1];
										(F.scale = b),
											(F.font = S),
											(F.textColor = I),
											(F.verticalAlign = L);
									} else {
										const b = r.parse(t[_], 1, ur);
										if (!b) return null;
										const S = b.type.kind;
										if (
											S !== "string" &&
											S !== "value" &&
											S !== "null" &&
											S !== "resolvedImage"
										)
											return r.error(
												"Formatted text type must be 'string', 'value', 'image' or 'null'."
											);
										(f = !0),
											c.push({
												content: b,
												scale: null,
												font: null,
												textColor: null,
												verticalAlign: null,
											});
									}
								}
								return new ko(c);
							}
							evaluate(t) {
								return new Sn(
									this.sections.map((r) => {
										const o = r.content.evaluate(t);
										return Rr(o) === pr
											? new cn(
													"",
													o,
													null,
													null,
													null,
													r.verticalAlign ? r.verticalAlign.evaluate(t) : null
											  )
											: new cn(
													Gr(o),
													null,
													r.scale ? r.scale.evaluate(t) : null,
													r.font ? r.font.evaluate(t).join(",") : null,
													r.textColor ? r.textColor.evaluate(t) : null,
													r.verticalAlign ? r.verticalAlign.evaluate(t) : null
											  );
									})
								);
							}
							eachChild(t) {
								for (const r of this.sections)
									t(r.content),
										r.scale && t(r.scale),
										r.font && t(r.font),
										r.textColor && t(r.textColor),
										r.verticalAlign && t(r.verticalAlign);
							}
							outputDefined() {
								return !1;
							}
						}
						class Dc {
							constructor(t) {
								(this.type = pr), (this.input = t);
							}
							static parse(t, r) {
								if (t.length !== 2) return r.error("Expected two arguments.");
								const o = r.parse(t[1], 1, At);
								return o ? new Dc(o) : r.error("No image name provided.");
							}
							evaluate(t) {
								const r = this.input.evaluate(t),
									o = Hn.fromString(r);
								return (
									o &&
										t.availableImages &&
										(o.available = t.availableImages.indexOf(r) > -1),
									o
								);
							}
							eachChild(t) {
								t(this.input);
							}
							outputDefined() {
								return !1;
							}
						}
						class bl {
							constructor(t) {
								(this.type = He), (this.input = t);
							}
							static parse(t, r) {
								if (t.length !== 2)
									return r.error(
										`Expected 1 argument, but found ${t.length - 1} instead.`
									);
								const o = r.parse(t[1], 1);
								return o
									? o.type.kind !== "array" &&
									  o.type.kind !== "string" &&
									  o.type.kind !== "value"
										? r.error(
												`Expected argument of type string or array, but found ${en(
													o.type
												)} instead.`
										  )
										: new bl(o)
									: null;
							}
							evaluate(t) {
								const r = this.input.evaluate(t);
								if (typeof r == "string") return [...r].length;
								if (Array.isArray(r)) return r.length;
								throw new on(
									`Expected value to be of type string or array, but found ${en(
										Rr(r)
									)} instead.`
								);
							}
							eachChild(t) {
								t(this.input);
							}
							outputDefined() {
								return !1;
							}
						}
						const Pa = 8192;
						function Sp(n, t) {
							const r = (180 + n[0]) / 360,
								o =
									(180 -
										(180 / Math.PI) *
											Math.log(
												Math.tan(Math.PI / 4 + (n[1] * Math.PI) / 360)
											)) /
									360,
								c = Math.pow(2, t.z);
							return [Math.round(r * c * Pa), Math.round(o * c * Pa)];
						}
						function wl(n, t) {
							const r = Math.pow(2, t.z);
							return [
								((c = (n[0] / Pa + t.x) / r), 360 * c - 180),
								((o = (n[1] / Pa + t.y) / r),
								(360 / Math.PI) *
									Math.atan(Math.exp(((180 - 360 * o) * Math.PI) / 180)) -
									90),
							];
							var o, c;
						}
						function Rs(n, t) {
							(n[0] = Math.min(n[0], t[0])),
								(n[1] = Math.min(n[1], t[1])),
								(n[2] = Math.max(n[2], t[0])),
								(n[3] = Math.max(n[3], t[1]));
						}
						function Bs(n, t) {
							return !(
								n[0] <= t[0] ||
								n[2] >= t[2] ||
								n[1] <= t[1] ||
								n[3] >= t[3]
							);
						}
						function Pp(n, t, r) {
							const o = n[0] - t[0],
								c = n[1] - t[1],
								f = n[0] - r[0],
								_ = n[1] - r[1];
							return o * _ - f * c == 0 && o * f <= 0 && c * _ <= 0;
						}
						function Tl(n, t, r, o) {
							return (
								(c = [o[0] - r[0], o[1] - r[1]])[0] *
									(f = [t[0] - n[0], t[1] - n[1]])[1] -
									c[1] * f[0] !=
									0 && !(!jh(n, t, r, o) || !jh(r, o, n, t))
							);
							var c, f;
						}
						function Ip(n, t, r) {
							for (const o of r)
								for (let c = 0; c < o.length - 1; ++c)
									if (Tl(n, t, o[c], o[c + 1])) return !0;
							return !1;
						}
						function Ao(n, t, r = !1) {
							let o = !1;
							for (const v of t)
								for (let b = 0; b < v.length - 1; b++) {
									if (Pp(n, v[b], v[b + 1])) return r;
									(f = v[b])[1] > (c = n)[1] != (_ = v[b + 1])[1] > c[1] &&
										c[0] <
											((_[0] - f[0]) * (c[1] - f[1])) / (_[1] - f[1]) + f[0] &&
										(o = !o);
								}
							var c, f, _;
							return o;
						}
						function Nh(n, t) {
							for (const r of t) if (Ao(n, r)) return !0;
							return !1;
						}
						function Rc(n, t) {
							for (const r of n) if (!Ao(r, t)) return !1;
							for (let r = 0; r < n.length - 1; ++r)
								if (Ip(n[r], n[r + 1], t)) return !1;
							return !0;
						}
						function Mp(n, t) {
							for (const r of t) if (Rc(n, r)) return !0;
							return !1;
						}
						function jh(n, t, r, o) {
							const c = o[0] - r[0],
								f = o[1] - r[1],
								_ = (n[0] - r[0]) * f - c * (n[1] - r[1]),
								v = (t[0] - r[0]) * f - c * (t[1] - r[1]);
							return (_ > 0 && v < 0) || (_ < 0 && v > 0);
						}
						function Bc(n, t, r) {
							const o = [];
							for (let c = 0; c < n.length; c++) {
								const f = [];
								for (let _ = 0; _ < n[c].length; _++) {
									const v = Sp(n[c][_], r);
									Rs(t, v), f.push(v);
								}
								o.push(f);
							}
							return o;
						}
						function Vh(n, t, r) {
							const o = [];
							for (let c = 0; c < n.length; c++) {
								const f = Bc(n[c], t, r);
								o.push(f);
							}
							return o;
						}
						function Cl(n, t, r, o) {
							if (n[0] < r[0] || n[0] > r[2]) {
								const c = 0.5 * o;
								let f = n[0] - r[0] > c ? -o : r[0] - n[0] > c ? o : 0;
								f === 0 && (f = n[0] - r[2] > c ? -o : r[2] - n[0] > c ? o : 0),
									(n[0] += f);
							}
							Rs(t, n);
						}
						function qh(n, t, r, o) {
							const c = Math.pow(2, o.z) * Pa,
								f = [o.x * Pa, o.y * Pa],
								_ = [];
							for (const v of n)
								for (const b of v) {
									const S = [b.x + f[0], b.y + f[1]];
									Cl(S, t, r, c), _.push(S);
								}
							return _;
						}
						function Zh(n, t, r, o) {
							const c = Math.pow(2, o.z) * Pa,
								f = [o.x * Pa, o.y * Pa],
								_ = [];
							for (const b of n) {
								const S = [];
								for (const I of b) {
									const L = [I.x + f[0], I.y + f[1]];
									Rs(t, L), S.push(L);
								}
								_.push(S);
							}
							if (t[2] - t[0] <= c / 2) {
								((v = t)[0] = v[1] = 1 / 0), (v[2] = v[3] = -1 / 0);
								for (const b of _) for (const S of b) Cl(S, t, r, c);
							}
							var v;
							return _;
						}
						class Eo {
							constructor(t, r) {
								(this.type = Ft), (this.geojson = t), (this.geometries = r);
							}
							static parse(t, r) {
								if (t.length !== 2)
									return r.error(
										`'within' expression requires exactly one argument, but found ${
											t.length - 1
										} instead.`
									);
								if (qa(t[1])) {
									const o = t[1];
									if (o.type === "FeatureCollection") {
										const c = [];
										for (const f of o.features) {
											const { type: _, coordinates: v } = f.geometry;
											_ === "Polygon" && c.push(v),
												_ === "MultiPolygon" && c.push(...v);
										}
										if (c.length)
											return new Eo(o, {
												type: "MultiPolygon",
												coordinates: c,
											});
									} else if (o.type === "Feature") {
										const c = o.geometry.type;
										if (c === "Polygon" || c === "MultiPolygon")
											return new Eo(o, o.geometry);
									} else if (o.type === "Polygon" || o.type === "MultiPolygon")
										return new Eo(o, o);
								}
								return r.error(
									"'within' expression requires valid geojson object that contains polygon geometry type."
								);
							}
							evaluate(t) {
								if (t.geometry() != null && t.canonicalID() != null) {
									if (t.geometryType() === "Point")
										return (function (r, o) {
											const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
												f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
												_ = r.canonicalID();
											if (o.type === "Polygon") {
												const v = Bc(o.coordinates, f, _),
													b = qh(r.geometry(), c, f, _);
												if (!Bs(c, f)) return !1;
												for (const S of b) if (!Ao(S, v)) return !1;
											}
											if (o.type === "MultiPolygon") {
												const v = Vh(o.coordinates, f, _),
													b = qh(r.geometry(), c, f, _);
												if (!Bs(c, f)) return !1;
												for (const S of b) if (!Nh(S, v)) return !1;
											}
											return !0;
										})(t, this.geometries);
									if (t.geometryType() === "LineString")
										return (function (r, o) {
											const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
												f = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
												_ = r.canonicalID();
											if (o.type === "Polygon") {
												const v = Bc(o.coordinates, f, _),
													b = Zh(r.geometry(), c, f, _);
												if (!Bs(c, f)) return !1;
												for (const S of b) if (!Rc(S, v)) return !1;
											}
											if (o.type === "MultiPolygon") {
												const v = Vh(o.coordinates, f, _),
													b = Zh(r.geometry(), c, f, _);
												if (!Bs(c, f)) return !1;
												for (const S of b) if (!Mp(S, v)) return !1;
											}
											return !0;
										})(t, this.geometries);
								}
								return !1;
							}
							eachChild() {}
							outputDefined() {
								return !0;
							}
						}
						let Fc = class {
							constructor(n = [], t = (r, o) => (r < o ? -1 : r > o ? 1 : 0)) {
								if (
									((this.data = n),
									(this.length = this.data.length),
									(this.compare = t),
									this.length > 0)
								)
									for (let r = (this.length >> 1) - 1; r >= 0; r--)
										this._down(r);
							}
							push(n) {
								this.data.push(n), this._up(this.length++);
							}
							pop() {
								if (this.length === 0) return;
								const n = this.data[0],
									t = this.data.pop();
								return (
									--this.length > 0 && ((this.data[0] = t), this._down(0)), n
								);
							}
							peek() {
								return this.data[0];
							}
							_up(n) {
								const { data: t, compare: r } = this,
									o = t[n];
								for (; n > 0; ) {
									const c = (n - 1) >> 1,
										f = t[c];
									if (r(o, f) >= 0) break;
									(t[n] = f), (n = c);
								}
								t[n] = o;
							}
							_down(n) {
								const { data: t, compare: r } = this,
									o = this.length >> 1,
									c = t[n];
								for (; n < o; ) {
									let f = 1 + (n << 1);
									const _ = f + 1;
									if (
										(_ < this.length && r(t[_], t[f]) < 0 && (f = _),
										r(t[f], c) >= 0)
									)
										break;
									(t[n] = t[f]), (n = f);
								}
								t[n] = c;
							}
						};
						function Oc(n, t, r = 0, o = n.length - 1, c = kp) {
							for (; o > r; ) {
								if (o - r > 600) {
									const b = o - r + 1,
										S = t - r + 1,
										I = Math.log(b),
										L = 0.5 * Math.exp((2 * I) / 3),
										F =
											0.5 *
											Math.sqrt((I * L * (b - L)) / b) *
											(S - b / 2 < 0 ? -1 : 1);
									Oc(
										n,
										t,
										Math.max(r, Math.floor(t - (S * L) / b + F)),
										Math.min(o, Math.floor(t + ((b - S) * L) / b + F)),
										c
									);
								}
								const f = n[t];
								let _ = r,
									v = o;
								for (Fs(n, r, t), c(n[o], f) > 0 && Fs(n, r, o); _ < v; ) {
									for (Fs(n, _, v), _++, v--; c(n[_], f) < 0; ) _++;
									for (; c(n[v], f) > 0; ) v--;
								}
								c(n[r], f) === 0 ? Fs(n, r, v) : (v++, Fs(n, v, o)),
									v <= t && (r = v + 1),
									t <= v && (o = v - 1);
							}
						}
						function Fs(n, t, r) {
							const o = n[t];
							(n[t] = n[r]), (n[r] = o);
						}
						function kp(n, t) {
							return n < t ? -1 : n > t ? 1 : 0;
						}
						function Os(n, t) {
							if (n.length <= 1) return [n];
							const r = [];
							let o, c;
							for (const f of n) {
								const _ = Ap(f);
								_ !== 0 &&
									((f.area = Math.abs(_)),
									c === void 0 && (c = _ < 0),
									c === _ < 0 ? (o && r.push(o), (o = [f])) : o.push(f));
							}
							if ((o && r.push(o), t > 1))
								for (let f = 0; f < r.length; f++)
									r[f].length <= t ||
										(Oc(r[f], t, 1, r[f].length - 1, Uh),
										(r[f] = r[f].slice(0, t)));
							return r;
						}
						function Uh(n, t) {
							return t.area - n.area;
						}
						function Ap(n) {
							let t = 0;
							for (let r, o, c = 0, f = n.length, _ = f - 1; c < f; _ = c++)
								(r = n[c]), (o = n[_]), (t += (o.x - r.x) * (r.y + o.y));
							return t;
						}
						const $h = 1 / 298.257223563,
							Gh = $h * (2 - $h),
							Nc = Math.PI / 180;
						class jc {
							constructor(t) {
								const r = 6378.137 * Nc * 1e3,
									o = Math.cos(t * Nc),
									c = 1 / (1 - Gh * (1 - o * o)),
									f = Math.sqrt(c);
								(this.kx = r * f * o), (this.ky = r * f * c * (1 - Gh));
							}
							distance(t, r) {
								const o = this.wrap(t[0] - r[0]) * this.kx,
									c = (t[1] - r[1]) * this.ky;
								return Math.sqrt(o * o + c * c);
							}
							pointOnLine(t, r) {
								let o,
									c,
									f,
									_,
									v = 1 / 0;
								for (let b = 0; b < t.length - 1; b++) {
									let S = t[b][0],
										I = t[b][1],
										L = this.wrap(t[b + 1][0] - S) * this.kx,
										F = (t[b + 1][1] - I) * this.ky,
										q = 0;
									(L === 0 && F === 0) ||
										((q =
											(this.wrap(r[0] - S) * this.kx * L +
												(r[1] - I) * this.ky * F) /
											(L * L + F * F)),
										q > 1
											? ((S = t[b + 1][0]), (I = t[b + 1][1]))
											: q > 0 &&
											  ((S += (L / this.kx) * q), (I += (F / this.ky) * q))),
										(L = this.wrap(r[0] - S) * this.kx),
										(F = (r[1] - I) * this.ky);
									const Z = L * L + F * F;
									Z < v && ((v = Z), (o = S), (c = I), (f = b), (_ = q));
								}
								return {
									point: [o, c],
									index: f,
									t: Math.max(0, Math.min(1, _)),
								};
							}
							wrap(t) {
								for (; t < -180; ) t += 360;
								for (; t > 180; ) t -= 360;
								return t;
							}
						}
						function Hh(n, t) {
							return t[0] - n[0];
						}
						function Sl(n) {
							return n[1] - n[0] + 1;
						}
						function eo(n, t) {
							return n[1] >= n[0] && n[1] < t;
						}
						function Pn(n, t) {
							if (n[0] > n[1]) return [null, null];
							const r = Sl(n);
							if (t) {
								if (r === 2) return [n, null];
								const c = Math.floor(r / 2);
								return [
									[n[0], n[0] + c],
									[n[0] + c, n[1]],
								];
							}
							if (r === 1) return [n, null];
							const o = Math.floor(r / 2) - 1;
							return [
								[n[0], n[0] + o],
								[n[0] + o + 1, n[1]],
							];
						}
						function Vc(n, t) {
							if (!eo(t, n.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
							const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
							for (let o = t[0]; o <= t[1]; ++o) Rs(r, n[o]);
							return r;
						}
						function qc(n) {
							const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
							for (const r of n) for (const o of r) Rs(t, o);
							return t;
						}
						function Wh(n) {
							return (
								n[0] !== -1 / 0 &&
								n[1] !== -1 / 0 &&
								n[2] !== 1 / 0 &&
								n[3] !== 1 / 0
							);
						}
						function Zc(n, t, r) {
							if (!Wh(n) || !Wh(t)) return NaN;
							let o = 0,
								c = 0;
							return (
								n[2] < t[0] && (o = t[0] - n[2]),
								n[0] > t[2] && (o = n[0] - t[2]),
								n[1] > t[3] && (c = n[1] - t[3]),
								n[3] < t[1] && (c = t[1] - n[3]),
								r.distance([0, 0], [o, c])
							);
						}
						function zo(n, t, r) {
							const o = r.pointOnLine(t, n);
							return r.distance(n, o.point);
						}
						function Uc(n, t, r, o, c) {
							const f = Math.min(zo(n, [r, o], c), zo(t, [r, o], c)),
								_ = Math.min(zo(r, [n, t], c), zo(o, [n, t], c));
							return Math.min(f, _);
						}
						function Ep(n, t, r, o, c) {
							if (!eo(t, n.length) || !eo(o, r.length)) return 1 / 0;
							let f = 1 / 0;
							for (let _ = t[0]; _ < t[1]; ++_) {
								const v = n[_],
									b = n[_ + 1];
								for (let S = o[0]; S < o[1]; ++S) {
									const I = r[S],
										L = r[S + 1];
									if (Tl(v, b, I, L)) return 0;
									f = Math.min(f, Uc(v, b, I, L, c));
								}
							}
							return f;
						}
						function zp(n, t, r, o, c) {
							if (!eo(t, n.length) || !eo(o, r.length)) return NaN;
							let f = 1 / 0;
							for (let _ = t[0]; _ <= t[1]; ++_)
								for (let v = o[0]; v <= o[1]; ++v)
									if (((f = Math.min(f, c.distance(n[_], r[v]))), f === 0))
										return f;
							return f;
						}
						function Lp(n, t, r) {
							if (Ao(n, t, !0)) return 0;
							let o = 1 / 0;
							for (const c of t) {
								const f = c[0],
									_ = c[c.length - 1];
								if (f !== _ && ((o = Math.min(o, zo(n, [_, f], r))), o === 0))
									return o;
								const v = r.pointOnLine(c, n);
								if (((o = Math.min(o, r.distance(n, v.point))), o === 0))
									return o;
							}
							return o;
						}
						function Dp(n, t, r, o) {
							if (!eo(t, n.length)) return NaN;
							for (let f = t[0]; f <= t[1]; ++f) if (Ao(n[f], r, !0)) return 0;
							let c = 1 / 0;
							for (let f = t[0]; f < t[1]; ++f) {
								const _ = n[f],
									v = n[f + 1];
								for (const b of r)
									for (let S = 0, I = b.length, L = I - 1; S < I; L = S++) {
										const F = b[L],
											q = b[S];
										if (Tl(_, v, F, q)) return 0;
										c = Math.min(c, Uc(_, v, F, q, o));
									}
							}
							return c;
						}
						function Xh(n, t) {
							for (const r of n) for (const o of r) if (Ao(o, t, !0)) return !0;
							return !1;
						}
						function Rp(n, t, r, o = 1 / 0) {
							const c = qc(n),
								f = qc(t);
							if (o !== 1 / 0 && Zc(c, f, r) >= o) return o;
							if (Bs(c, f)) {
								if (Xh(n, t)) return 0;
							} else if (Xh(t, n)) return 0;
							let _ = 1 / 0;
							for (const v of n)
								for (let b = 0, S = v.length, I = S - 1; b < S; I = b++) {
									const L = v[I],
										F = v[b];
									for (const q of t)
										for (let Z = 0, W = q.length, J = W - 1; Z < W; J = Z++) {
											const le = q[J],
												Re = q[Z];
											if (Tl(L, F, le, Re)) return 0;
											_ = Math.min(_, Uc(L, F, le, Re, r));
										}
								}
							return _;
						}
						function Yh(n, t, r, o, c, f) {
							if (!f) return;
							const _ = Zc(Vc(o, f), c, r);
							_ < t && n.push([_, f, [0, 0]]);
						}
						function Pl(n, t, r, o, c, f, _) {
							if (!f || !_) return;
							const v = Zc(Vc(o, f), Vc(c, _), r);
							v < t && n.push([v, f, _]);
						}
						function Il(n, t, r, o, c = 1 / 0) {
							let f = Math.min(o.distance(n[0], r[0][0]), c);
							if (f === 0) return f;
							const _ = new Fc([[0, [0, n.length - 1], [0, 0]]], Hh),
								v = qc(r);
							for (; _.length > 0; ) {
								const b = _.pop();
								if (b[0] >= f) continue;
								const S = b[1],
									I = t ? 50 : 100;
								if (Sl(S) <= I) {
									if (!eo(S, n.length)) return NaN;
									if (t) {
										const L = Dp(n, S, r, o);
										if (isNaN(L) || L === 0) return L;
										f = Math.min(f, L);
									} else
										for (let L = S[0]; L <= S[1]; ++L) {
											const F = Lp(n[L], r, o);
											if (((f = Math.min(f, F)), f === 0)) return 0;
										}
								} else {
									const L = Pn(S, t);
									Yh(_, f, o, n, v, L[0]), Yh(_, f, o, n, v, L[1]);
								}
							}
							return f;
						}
						function Ml(n, t, r, o, c, f = 1 / 0) {
							let _ = Math.min(f, c.distance(n[0], r[0]));
							if (_ === 0) return _;
							const v = new Fc([[0, [0, n.length - 1], [0, r.length - 1]]], Hh);
							for (; v.length > 0; ) {
								const b = v.pop();
								if (b[0] >= _) continue;
								const S = b[1],
									I = b[2],
									L = t ? 50 : 100,
									F = o ? 50 : 100;
								if (Sl(S) <= L && Sl(I) <= F) {
									if (!eo(S, n.length) && eo(I, r.length)) return NaN;
									let q;
									if (t && o) (q = Ep(n, S, r, I, c)), (_ = Math.min(_, q));
									else if (t && !o) {
										const Z = n.slice(S[0], S[1] + 1);
										for (let W = I[0]; W <= I[1]; ++W)
											if (((q = zo(r[W], Z, c)), (_ = Math.min(_, q)), _ === 0))
												return _;
									} else if (!t && o) {
										const Z = r.slice(I[0], I[1] + 1);
										for (let W = S[0]; W <= S[1]; ++W)
											if (((q = zo(n[W], Z, c)), (_ = Math.min(_, q)), _ === 0))
												return _;
									} else (q = zp(n, S, r, I, c)), (_ = Math.min(_, q));
								} else {
									const q = Pn(S, t),
										Z = Pn(I, o);
									Pl(v, _, c, n, r, q[0], Z[0]),
										Pl(v, _, c, n, r, q[0], Z[1]),
										Pl(v, _, c, n, r, q[1], Z[0]),
										Pl(v, _, c, n, r, q[1], Z[1]);
								}
							}
							return _;
						}
						function $c(n) {
							return n.type === "MultiPolygon"
								? n.coordinates.map((t) => ({
										type: "Polygon",
										coordinates: t,
								  }))
								: n.type === "MultiLineString"
								? n.coordinates.map((t) => ({
										type: "LineString",
										coordinates: t,
								  }))
								: n.type === "MultiPoint"
								? n.coordinates.map((t) => ({ type: "Point", coordinates: t }))
								: [n];
						}
						class Lo {
							constructor(t, r) {
								(this.type = He), (this.geojson = t), (this.geometries = r);
							}
							static parse(t, r) {
								if (t.length !== 2)
									return r.error(
										`'distance' expression requires exactly one argument, but found ${
											t.length - 1
										} instead.`
									);
								if (qa(t[1])) {
									const o = t[1];
									if (o.type === "FeatureCollection")
										return new Lo(
											o,
											o.features.map((c) => $c(c.geometry)).flat()
										);
									if (o.type === "Feature") return new Lo(o, $c(o.geometry));
									if ("type" in o && "coordinates" in o)
										return new Lo(o, $c(o));
								}
								return r.error(
									"'distance' expression requires valid geojson object that contains polygon geometry type."
								);
							}
							evaluate(t) {
								if (t.geometry() != null && t.canonicalID() != null) {
									if (t.geometryType() === "Point")
										return (function (r, o) {
											const c = r.geometry(),
												f = c.flat().map((b) => wl([b.x, b.y], r.canonical));
											if (c.length === 0) return NaN;
											const _ = new jc(f[0][1]);
											let v = 1 / 0;
											for (const b of o) {
												switch (b.type) {
													case "Point":
														v = Math.min(
															v,
															Ml(f, !1, [b.coordinates], !1, _, v)
														);
														break;
													case "LineString":
														v = Math.min(v, Ml(f, !1, b.coordinates, !0, _, v));
														break;
													case "Polygon":
														v = Math.min(v, Il(f, !1, b.coordinates, _, v));
												}
												if (v === 0) return v;
											}
											return v;
										})(t, this.geometries);
									if (t.geometryType() === "LineString")
										return (function (r, o) {
											const c = r.geometry(),
												f = c.flat().map((b) => wl([b.x, b.y], r.canonical));
											if (c.length === 0) return NaN;
											const _ = new jc(f[0][1]);
											let v = 1 / 0;
											for (const b of o) {
												switch (b.type) {
													case "Point":
														v = Math.min(
															v,
															Ml(f, !0, [b.coordinates], !1, _, v)
														);
														break;
													case "LineString":
														v = Math.min(v, Ml(f, !0, b.coordinates, !0, _, v));
														break;
													case "Polygon":
														v = Math.min(v, Il(f, !0, b.coordinates, _, v));
												}
												if (v === 0) return v;
											}
											return v;
										})(t, this.geometries);
									if (t.geometryType() === "Polygon")
										return (function (r, o) {
											const c = r.geometry();
											if (c.length === 0 || c[0].length === 0) return NaN;
											const f = Os(c, 0).map((b) =>
													b.map((S) =>
														S.map((I) => wl([I.x, I.y], r.canonical))
													)
												),
												_ = new jc(f[0][0][0][1]);
											let v = 1 / 0;
											for (const b of o)
												for (const S of f) {
													switch (b.type) {
														case "Point":
															v = Math.min(v, Il([b.coordinates], !1, S, _, v));
															break;
														case "LineString":
															v = Math.min(v, Il(b.coordinates, !0, S, _, v));
															break;
														case "Polygon":
															v = Math.min(v, Rp(S, b.coordinates, _, v));
													}
													if (v === 0) return v;
												}
											return v;
										})(t, this.geometries);
								}
								return NaN;
							}
							eachChild() {}
							outputDefined() {
								return !0;
							}
						}
						class Ns {
							constructor(t) {
								(this.type = ur), (this.key = t);
							}
							static parse(t, r) {
								if (t.length !== 2)
									return r.error(
										`Expected 1 argument, but found ${t.length - 1} instead.`
									);
								const o = t[1];
								return o == null
									? r.error("Global state property must be defined.")
									: typeof o != "string"
									? r.error(
											`Global state property must be string, but found ${typeof t[1]} instead.`
									  )
									: new Ns(o);
							}
							evaluate(t) {
								var r;
								const o =
									(r = t.globals) === null || r === void 0
										? void 0
										: r.globalState;
								return o && Object.keys(o).length !== 0
									? sr(o, this.key)
									: null;
							}
							eachChild() {}
							outputDefined() {
								return !1;
							}
						}
						const ts = {
							"==": Oh,
							"!=": yl,
							">": zc,
							"<": wp,
							">=": Cp,
							"<=": Tp,
							array: Li,
							at: gl,
							boolean: Li,
							case: Qo,
							coalesce: zs,
							collator: xl,
							format: ko,
							image: Dc,
							in: vl,
							"index-of": Sa,
							interpolate: Di,
							"interpolate-hcl": Di,
							"interpolate-lab": Di,
							length: bl,
							let: Qa,
							literal: _a,
							match: Ti,
							number: Li,
							"number-format": Lc,
							object: Li,
							slice: ks,
							step: ei,
							string: Li,
							"to-boolean": sa,
							"to-color": sa,
							"to-number": sa,
							"to-string": sa,
							var: Jo,
							within: Eo,
							distance: Lo,
							"global-state": Ns,
						};
						class va {
							constructor(t, r, o, c) {
								(this.name = t),
									(this.type = r),
									(this._evaluate = o),
									(this.args = c);
							}
							evaluate(t) {
								return this._evaluate(t, this.args);
							}
							eachChild(t) {
								this.args.forEach(t);
							}
							outputDefined() {
								return !1;
							}
							static parse(t, r) {
								const o = t[0],
									c = va.definitions[o];
								if (!c)
									return r.error(
										`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`,
										0
									);
								const f = Array.isArray(c) ? c[0] : c.type,
									_ = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads,
									v = _.filter(
										([S]) => !Array.isArray(S) || S.length === t.length - 1
									);
								let b = null;
								for (const [S, I] of v) {
									b = new Ca(r.registry, kl, r.path, null, r.scope);
									const L = [];
									let F = !1;
									for (let q = 1; q < t.length; q++) {
										const Z = t[q],
											W = Array.isArray(S) ? S[q - 1] : S.type,
											J = b.parse(Z, 1 + L.length, W);
										if (!J) {
											F = !0;
											break;
										}
										L.push(J);
									}
									if (!F)
										if (Array.isArray(S) && S.length !== L.length)
											b.error(
												`Expected ${S.length} arguments, but found ${L.length} instead.`
											);
										else {
											for (let q = 0; q < L.length; q++) {
												const Z = Array.isArray(S) ? S[q] : S.type,
													W = L[q];
												b.concat(q + 1).checkSubtype(Z, W.type);
											}
											if (b.errors.length === 0) return new va(o, f, I, L);
										}
								}
								if (v.length === 1) r.errors.push(...b.errors);
								else {
									const S = (v.length ? v : _)
											.map(([L]) => {
												return (
													(F = L),
													Array.isArray(F)
														? `(${F.map(en).join(", ")})`
														: `(${en(F.type)}...)`
												);
												var F;
											})
											.join(" | "),
										I = [];
									for (let L = 1; L < t.length; L++) {
										const F = r.parse(t[L], 1 + I.length);
										if (!F) return null;
										I.push(en(F.type));
									}
									r.error(
										`Expected arguments of type ${S}, but found (${I.join(
											", "
										)}) instead.`
									);
								}
								return null;
							}
							static register(t, r) {
								va.definitions = r;
								for (const o in r) t[o] = va;
							}
						}
						function Kh(n, [t, r, o, c]) {
							(t = t.evaluate(n)), (r = r.evaluate(n)), (o = o.evaluate(n));
							const f = c ? c.evaluate(n) : 1,
								_ = zn(t, r, o, f);
							if (_) throw new on(_);
							return new Mr(t / 255, r / 255, o / 255, f, !1);
						}
						function Jh(n, t) {
							return n in t;
						}
						function Gc(n, t) {
							const r = t[n];
							return r === void 0 ? null : r;
						}
						function Do(n) {
							return { type: n };
						}
						function kl(n) {
							if (n instanceof Jo) return kl(n.boundExpression);
							if (
								(n instanceof va && n.name === "error") ||
								n instanceof xl ||
								n instanceof Eo ||
								n instanceof Lo ||
								n instanceof Ns
							)
								return !1;
							const t = n instanceof sa || n instanceof Li;
							let r = !0;
							return (
								n.eachChild((o) => {
									r = t ? r && kl(o) : r && o instanceof _a;
								}),
								!!r &&
									Al(n) &&
									El(n, [
										"zoom",
										"heatmap-density",
										"elevation",
										"line-progress",
										"accumulated",
										"is-supported-script",
									])
							);
						}
						function Al(n) {
							if (
								(n instanceof va &&
									((n.name === "get" && n.args.length === 1) ||
										n.name === "feature-state" ||
										(n.name === "has" && n.args.length === 1) ||
										n.name === "properties" ||
										n.name === "geometry-type" ||
										n.name === "id" ||
										/^filter-/.test(n.name))) ||
								n instanceof Eo ||
								n instanceof Lo
							)
								return !1;
							let t = !0;
							return (
								n.eachChild((r) => {
									t && !Al(r) && (t = !1);
								}),
								t
							);
						}
						function js(n) {
							if (n instanceof va && n.name === "feature-state") return !1;
							let t = !0;
							return (
								n.eachChild((r) => {
									t && !js(r) && (t = !1);
								}),
								t
							);
						}
						function El(n, t) {
							if (n instanceof va && t.indexOf(n.name) >= 0) return !1;
							let r = !0;
							return (
								n.eachChild((o) => {
									r && !El(o, t) && (r = !1);
								}),
								r
							);
						}
						function Qh(n) {
							return { result: "success", value: n };
						}
						function rs(n) {
							return { result: "error", value: n };
						}
						function fo(n) {
							return (
								n["property-type"] === "data-driven" ||
								n["property-type"] === "cross-faded-data-driven"
							);
						}
						function ed(n) {
							return (
								!!n.expression && n.expression.parameters.indexOf("zoom") > -1
							);
						}
						function Hc(n) {
							return !!n.expression && n.expression.interpolated;
						}
						function sn(n) {
							return n instanceof Number
								? "number"
								: n instanceof String
								? "string"
								: n instanceof Boolean
								? "boolean"
								: Array.isArray(n)
								? "array"
								: n === null
								? "null"
								: typeof n;
						}
						function Vs(n) {
							return (
								typeof n == "object" &&
								n !== null &&
								!Array.isArray(n) &&
								Rr(n) === Er
							);
						}
						function Bp(n) {
							return n;
						}
						function td(n, t) {
							const r = n.stops && typeof n.stops[0][0] == "object",
								o = r || !(r || n.property !== void 0),
								c = n.type || (Hc(t) ? "exponential" : "interval"),
								f = (function (I) {
									switch (I.type) {
										case "color":
											return Mr.parse;
										case "padding":
											return kn.parse;
										case "numberArray":
											return vn.parse;
										case "colorArray":
											return fn.parse;
										default:
											return null;
									}
								})(t);
							if (
								(f &&
									((n = Xr({}, n)).stops &&
										(n.stops = n.stops.map((I) => [I[0], f(I[1])])),
									(n.default = f(n.default ? n.default : t.default))),
								n.colorSpace &&
									(_ = n.colorSpace) !== "rgb" &&
									_ !== "hcl" &&
									_ !== "lab")
							)
								throw new Error(`Unknown color space: "${n.colorSpace}"`);
							var _;
							const v = (function (I) {
								switch (I) {
									case "exponential":
										return nd;
									case "interval":
										return Fp;
									case "categorical":
										return rd;
									case "identity":
										return Op;
									default:
										throw new Error(`Unknown function type "${I}"`);
								}
							})(c);
							let b, S;
							if (c === "categorical") {
								b = Object.create(null);
								for (const I of n.stops) b[I[0]] = I[1];
								S = typeof n.stops[0][0];
							}
							if (r) {
								const I = {},
									L = [];
								for (let Z = 0; Z < n.stops.length; Z++) {
									const W = n.stops[Z],
										J = W[0].zoom;
									I[J] === void 0 &&
										((I[J] = {
											zoom: J,
											type: n.type,
											property: n.property,
											default: n.default,
											stops: [],
										}),
										L.push(J)),
										I[J].stops.push([W[0].value, W[1]]);
								}
								const F = [];
								for (const Z of L) F.push([I[Z].zoom, td(I[Z], t)]);
								const q = { name: "linear" };
								return {
									kind: "composite",
									interpolationType: q,
									interpolationFactor: Di.interpolationFactor.bind(void 0, q),
									zoomStops: F.map((Z) => Z[0]),
									evaluate: ({ zoom: Z }, W) =>
										nd({ stops: F, base: n.base }, t, Z).evaluate(Z, W),
								};
							}
							if (o) {
								const I =
									c === "exponential"
										? {
												name: "exponential",
												base: n.base !== void 0 ? n.base : 1,
										  }
										: null;
								return {
									kind: "camera",
									interpolationType: I,
									interpolationFactor: Di.interpolationFactor.bind(void 0, I),
									zoomStops: n.stops.map((L) => L[0]),
									evaluate: ({ zoom: L }) => v(n, t, L, b, S),
								};
							}
							return {
								kind: "source",
								evaluate(I, L) {
									const F =
										L && L.properties ? L.properties[n.property] : void 0;
									return F === void 0
										? mo(n.default, t.default)
										: v(n, t, F, b, S);
								},
							};
						}
						function mo(n, t, r) {
							return n !== void 0
								? n
								: t !== void 0
								? t
								: r !== void 0
								? r
								: void 0;
						}
						function rd(n, t, r, o, c) {
							return mo(typeof r === c ? o[r] : void 0, n.default, t.default);
						}
						function Fp(n, t, r) {
							if (sn(r) !== "number") return mo(n.default, t.default);
							const o = n.stops.length;
							if (o === 1 || r <= n.stops[0][0]) return n.stops[0][1];
							if (r >= n.stops[o - 1][0]) return n.stops[o - 1][1];
							const c = Mo(
								n.stops.map((f) => f[0]),
								r
							);
							return n.stops[c][1];
						}
						function nd(n, t, r) {
							const o = n.base !== void 0 ? n.base : 1;
							if (sn(r) !== "number") return mo(n.default, t.default);
							const c = n.stops.length;
							if (c === 1 || r <= n.stops[0][0]) return n.stops[0][1];
							if (r >= n.stops[c - 1][0]) return n.stops[c - 1][1];
							const f = Mo(
									n.stops.map((I) => I[0]),
									r
								),
								_ = (function (I, L, F, q) {
									const Z = q - F,
										W = I - F;
									return Z === 0
										? 0
										: L === 1
										? W / Z
										: (Math.pow(L, W) - 1) / (Math.pow(L, Z) - 1);
								})(r, o, n.stops[f][0], n.stops[f + 1][0]),
								v = n.stops[f][1],
								b = n.stops[f + 1][1],
								S = Za[t.type] || Bp;
							return typeof v.evaluate == "function"
								? {
										evaluate(...I) {
											const L = v.evaluate.apply(void 0, I),
												F = b.evaluate.apply(void 0, I);
											if (L !== void 0 && F !== void 0)
												return S(L, F, _, n.colorSpace);
										},
								  }
								: S(v, b, _, n.colorSpace);
						}
						function Op(n, t, r) {
							switch (t.type) {
								case "color":
									r = Mr.parse(r);
									break;
								case "formatted":
									r = Sn.fromString(r.toString());
									break;
								case "resolvedImage":
									r = Hn.fromString(r.toString());
									break;
								case "padding":
									r = kn.parse(r);
									break;
								case "colorArray":
									r = fn.parse(r);
									break;
								case "numberArray":
									r = vn.parse(r);
									break;
								default:
									sn(r) === t.type ||
										(t.type === "enum" && t.values[r]) ||
										(r = void 0);
							}
							return mo(r, n.default, t.default);
						}
						va.register(ts, {
							error: [
								{ kind: "error" },
								[At],
								(n, [t]) => {
									throw new on(t.evaluate(n));
								},
							],
							typeof: [At, [ur], (n, [t]) => en(Rr(t.evaluate(n)))],
							"to-rgba": [
								tn(He, 4),
								[Jt],
								(n, [t]) => {
									const [r, o, c, f] = t.evaluate(n).rgb;
									return [255 * r, 255 * o, 255 * c, f];
								},
							],
							rgb: [Jt, [He, He, He], Kh],
							rgba: [Jt, [He, He, He, He], Kh],
							has: {
								type: Ft,
								overloads: [
									[[At], (n, [t]) => Jh(t.evaluate(n), n.properties())],
									[[At, Er], (n, [t, r]) => Jh(t.evaluate(n), r.evaluate(n))],
								],
							},
							get: {
								type: ur,
								overloads: [
									[[At], (n, [t]) => Gc(t.evaluate(n), n.properties())],
									[[At, Er], (n, [t, r]) => Gc(t.evaluate(n), r.evaluate(n))],
								],
							},
							"feature-state": [
								ur,
								[At],
								(n, [t]) => Gc(t.evaluate(n), n.featureState || {}),
							],
							properties: [Er, [], (n) => n.properties()],
							"geometry-type": [At, [], (n) => n.geometryType()],
							id: [ur, [], (n) => n.id()],
							zoom: [He, [], (n) => n.globals.zoom],
							"heatmap-density": [He, [], (n) => n.globals.heatmapDensity || 0],
							elevation: [He, [], (n) => n.globals.elevation || 0],
							"line-progress": [He, [], (n) => n.globals.lineProgress || 0],
							accumulated: [
								ur,
								[],
								(n) =>
									n.globals.accumulated === void 0
										? null
										: n.globals.accumulated,
							],
							"+": [
								He,
								Do(He),
								(n, t) => {
									let r = 0;
									for (const o of t) r += o.evaluate(n);
									return r;
								},
							],
							"*": [
								He,
								Do(He),
								(n, t) => {
									let r = 1;
									for (const o of t) r *= o.evaluate(n);
									return r;
								},
							],
							"-": {
								type: He,
								overloads: [
									[[He, He], (n, [t, r]) => t.evaluate(n) - r.evaluate(n)],
									[[He], (n, [t]) => -t.evaluate(n)],
								],
							},
							"/": [He, [He, He], (n, [t, r]) => t.evaluate(n) / r.evaluate(n)],
							"%": [He, [He, He], (n, [t, r]) => t.evaluate(n) % r.evaluate(n)],
							ln2: [He, [], () => Math.LN2],
							pi: [He, [], () => Math.PI],
							e: [He, [], () => Math.E],
							"^": [
								He,
								[He, He],
								(n, [t, r]) => Math.pow(t.evaluate(n), r.evaluate(n)),
							],
							sqrt: [He, [He], (n, [t]) => Math.sqrt(t.evaluate(n))],
							log10: [
								He,
								[He],
								(n, [t]) => Math.log(t.evaluate(n)) / Math.LN10,
							],
							ln: [He, [He], (n, [t]) => Math.log(t.evaluate(n))],
							log2: [He, [He], (n, [t]) => Math.log(t.evaluate(n)) / Math.LN2],
							sin: [He, [He], (n, [t]) => Math.sin(t.evaluate(n))],
							cos: [He, [He], (n, [t]) => Math.cos(t.evaluate(n))],
							tan: [He, [He], (n, [t]) => Math.tan(t.evaluate(n))],
							asin: [He, [He], (n, [t]) => Math.asin(t.evaluate(n))],
							acos: [He, [He], (n, [t]) => Math.acos(t.evaluate(n))],
							atan: [He, [He], (n, [t]) => Math.atan(t.evaluate(n))],
							min: [
								He,
								Do(He),
								(n, t) => Math.min(...t.map((r) => r.evaluate(n))),
							],
							max: [
								He,
								Do(He),
								(n, t) => Math.max(...t.map((r) => r.evaluate(n))),
							],
							abs: [He, [He], (n, [t]) => Math.abs(t.evaluate(n))],
							round: [
								He,
								[He],
								(n, [t]) => {
									const r = t.evaluate(n);
									return r < 0 ? -Math.round(-r) : Math.round(r);
								},
							],
							floor: [He, [He], (n, [t]) => Math.floor(t.evaluate(n))],
							ceil: [He, [He], (n, [t]) => Math.ceil(t.evaluate(n))],
							"filter-==": [
								Ft,
								[At, ur],
								(n, [t, r]) => n.properties()[t.value] === r.value,
							],
							"filter-id-==": [Ft, [ur], (n, [t]) => n.id() === t.value],
							"filter-type-==": [
								Ft,
								[At],
								(n, [t]) => n.geometryType() === t.value,
							],
							"filter-<": [
								Ft,
								[At, ur],
								(n, [t, r]) => {
									const o = n.properties()[t.value],
										c = r.value;
									return typeof o == typeof c && o < c;
								},
							],
							"filter-id-<": [
								Ft,
								[ur],
								(n, [t]) => {
									const r = n.id(),
										o = t.value;
									return typeof r == typeof o && r < o;
								},
							],
							"filter->": [
								Ft,
								[At, ur],
								(n, [t, r]) => {
									const o = n.properties()[t.value],
										c = r.value;
									return typeof o == typeof c && o > c;
								},
							],
							"filter-id->": [
								Ft,
								[ur],
								(n, [t]) => {
									const r = n.id(),
										o = t.value;
									return typeof r == typeof o && r > o;
								},
							],
							"filter-<=": [
								Ft,
								[At, ur],
								(n, [t, r]) => {
									const o = n.properties()[t.value],
										c = r.value;
									return typeof o == typeof c && o <= c;
								},
							],
							"filter-id-<=": [
								Ft,
								[ur],
								(n, [t]) => {
									const r = n.id(),
										o = t.value;
									return typeof r == typeof o && r <= o;
								},
							],
							"filter->=": [
								Ft,
								[At, ur],
								(n, [t, r]) => {
									const o = n.properties()[t.value],
										c = r.value;
									return typeof o == typeof c && o >= c;
								},
							],
							"filter-id->=": [
								Ft,
								[ur],
								(n, [t]) => {
									const r = n.id(),
										o = t.value;
									return typeof r == typeof o && r >= o;
								},
							],
							"filter-has": [Ft, [ur], (n, [t]) => t.value in n.properties()],
							"filter-has-id": [
								Ft,
								[],
								(n) => n.id() !== null && n.id() !== void 0,
							],
							"filter-type-in": [
								Ft,
								[tn(At)],
								(n, [t]) => t.value.indexOf(n.geometryType()) >= 0,
							],
							"filter-id-in": [
								Ft,
								[tn(ur)],
								(n, [t]) => t.value.indexOf(n.id()) >= 0,
							],
							"filter-in-small": [
								Ft,
								[At, tn(ur)],
								(n, [t, r]) => r.value.indexOf(n.properties()[t.value]) >= 0,
							],
							"filter-in-large": [
								Ft,
								[At, tn(ur)],
								(n, [t, r]) =>
									(function (o, c, f, _) {
										for (; f <= _; ) {
											const v = (f + _) >> 1;
											if (c[v] === o) return !0;
											c[v] > o ? (_ = v - 1) : (f = v + 1);
										}
										return !1;
									})(n.properties()[t.value], r.value, 0, r.value.length - 1),
							],
							all: {
								type: Ft,
								overloads: [
									[[Ft, Ft], (n, [t, r]) => t.evaluate(n) && r.evaluate(n)],
									[
										Do(Ft),
										(n, t) => {
											for (const r of t) if (!r.evaluate(n)) return !1;
											return !0;
										},
									],
								],
							},
							any: {
								type: Ft,
								overloads: [
									[[Ft, Ft], (n, [t, r]) => t.evaluate(n) || r.evaluate(n)],
									[
										Do(Ft),
										(n, t) => {
											for (const r of t) if (r.evaluate(n)) return !0;
											return !1;
										},
									],
								],
							},
							"!": [Ft, [Ft], (n, [t]) => !t.evaluate(n)],
							"is-supported-script": [
								Ft,
								[At],
								(n, [t]) => {
									const r = n.globals && n.globals.isSupportedScript;
									return !r || r(t.evaluate(n));
								},
							],
							upcase: [At, [At], (n, [t]) => t.evaluate(n).toUpperCase()],
							downcase: [At, [At], (n, [t]) => t.evaluate(n).toLowerCase()],
							concat: [
								At,
								Do(ur),
								(n, t) => t.map((r) => Gr(r.evaluate(n))).join(""),
							],
							"resolved-locale": [
								At,
								[rn],
								(n, [t]) => t.evaluate(n).resolvedLocale(),
							],
						});
						class Wc {
							constructor(t, r) {
								(this.expression = t),
									(this._warningHistory = {}),
									(this._evaluator = new Ms()),
									(this._defaultValue = r
										? (function (o) {
												if (o.type === "color" && Vs(o.default))
													return new Mr(0, 0, 0, 0);
												switch (o.type) {
													case "color":
														return Mr.parse(o.default) || null;
													case "padding":
														return kn.parse(o.default) || null;
													case "numberArray":
														return vn.parse(o.default) || null;
													case "colorArray":
														return fn.parse(o.default) || null;
													case "variableAnchorOffsetCollection":
														return fi.parse(o.default) || null;
													case "projectionDefinition":
														return jn.parse(o.default) || null;
													default:
														return o.default === void 0 ? null : o.default;
												}
										  })(r)
										: null),
									(this._enumValues = r && r.type === "enum" ? r.values : null);
							}
							evaluateWithoutErrorHandling(t, r, o, c, f, _) {
								return (
									(this._evaluator.globals = t),
									(this._evaluator.feature = r),
									(this._evaluator.featureState = o),
									(this._evaluator.canonical = c),
									(this._evaluator.availableImages = f || null),
									(this._evaluator.formattedSection = _),
									this.expression.evaluate(this._evaluator)
								);
							}
							evaluate(t, r, o, c, f, _) {
								(this._evaluator.globals = t),
									(this._evaluator.feature = r || null),
									(this._evaluator.featureState = o || null),
									(this._evaluator.canonical = c),
									(this._evaluator.availableImages = f || null),
									(this._evaluator.formattedSection = _ || null);
								try {
									const v = this.expression.evaluate(this._evaluator);
									if (v == null || (typeof v == "number" && v != v))
										return this._defaultValue;
									if (this._enumValues && !(v in this._enumValues))
										throw new on(
											`Expected value to be one of ${Object.keys(
												this._enumValues
											)
												.map((b) => JSON.stringify(b))
												.join(", ")}, but found ${JSON.stringify(v)} instead.`
										);
									return v;
								} catch (v) {
									return (
										this._warningHistory[v.message] ||
											((this._warningHistory[v.message] = !0),
											typeof console < "u" && console.warn(v.message)),
										this._defaultValue
									);
								}
							}
						}
						function zl(n) {
							return (
								Array.isArray(n) &&
								n.length > 0 &&
								typeof n[0] == "string" &&
								n[0] in ts
							);
						}
						function qs(n, t) {
							const r = new Ca(
									ts,
									kl,
									[],
									t
										? (function (c) {
												const f = {
													color: Jt,
													string: At,
													number: He,
													enum: At,
													boolean: Ft,
													formatted: pn,
													padding: gn,
													numberArray: En,
													colorArray: ln,
													projectionDefinition: Cr,
													resolvedImage: pr,
													variableAnchorOffsetCollection: In,
												};
												return c.type === "array"
													? tn(f[c.value] || ur, c.length)
													: f[c.type];
										  })(t)
										: void 0
								),
								o = r.parse(
									n,
									void 0,
									void 0,
									void 0,
									t && t.type === "string"
										? { typeAnnotation: "coerce" }
										: void 0
								);
							return o ? Qh(new Wc(o, t)) : rs(r.errors);
						}
						class Zs {
							constructor(t, r) {
								(this.kind = t),
									(this._styleExpression = r),
									(this.isStateDependent =
										t !== "constant" && !js(r.expression)),
									(this.globalStateRefs = Gs(r.expression));
							}
							evaluateWithoutErrorHandling(t, r, o, c, f, _) {
								return this._styleExpression.evaluateWithoutErrorHandling(
									t,
									r,
									o,
									c,
									f,
									_
								);
							}
							evaluate(t, r, o, c, f, _) {
								return this._styleExpression.evaluate(t, r, o, c, f, _);
							}
						}
						class Xc {
							constructor(t, r, o, c) {
								(this.kind = t),
									(this.zoomStops = o),
									(this._styleExpression = r),
									(this.isStateDependent = t !== "camera" && !js(r.expression)),
									(this.globalStateRefs = Gs(r.expression)),
									(this.interpolationType = c);
							}
							evaluateWithoutErrorHandling(t, r, o, c, f, _) {
								return this._styleExpression.evaluateWithoutErrorHandling(
									t,
									r,
									o,
									c,
									f,
									_
								);
							}
							evaluate(t, r, o, c, f, _) {
								return this._styleExpression.evaluate(t, r, o, c, f, _);
							}
							interpolationFactor(t, r, o) {
								return this.interpolationType
									? Di.interpolationFactor(this.interpolationType, t, r, o)
									: 0;
							}
						}
						function id(n, t) {
							const r = qs(n, t);
							if (r.result === "error") return r;
							const o = r.value.expression,
								c = Al(o);
							if (!c && !fo(t))
								return rs([new Yr("", "data expressions not supported")]);
							const f = El(o, ["zoom"]);
							if (!f && !ed(t))
								return rs([new Yr("", "zoom expressions not supported")]);
							const _ = $s(o);
							return _ || f
								? _ instanceof Yr
									? rs([_])
									: _ instanceof Di && !Hc(t)
									? rs([
											new Yr(
												"",
												'"interpolate" expressions cannot be used with this property'
											),
									  ])
									: Qh(
											_
												? new Xc(
														c ? "camera" : "composite",
														r.value,
														_.labels,
														_ instanceof Di ? _.interpolation : void 0
												  )
												: new Zs(c ? "constant" : "source", r.value)
									  )
								: rs([
										new Yr(
											"",
											'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
										),
								  ]);
						}
						class Us {
							constructor(t, r) {
								(this._parameters = t),
									(this._specification = r),
									Xr(this, td(this._parameters, this._specification));
							}
							static deserialize(t) {
								return new Us(t._parameters, t._specification);
							}
							static serialize(t) {
								return {
									_parameters: t._parameters,
									_specification: t._specification,
								};
							}
						}
						function $s(n) {
							let t = null;
							if (n instanceof Qa) t = $s(n.result);
							else if (n instanceof zs) {
								for (const r of n.args) if (((t = $s(r)), t)) break;
							} else
								(n instanceof ei || n instanceof Di) &&
									n.input instanceof va &&
									n.input.name === "zoom" &&
									(t = n);
							return (
								t instanceof Yr ||
									n.eachChild((r) => {
										const o = $s(r);
										o instanceof Yr
											? (t = o)
											: !t && o
											? (t = new Yr(
													"",
													'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
											  ))
											: t &&
											  o &&
											  t !== o &&
											  (t = new Yr(
													"",
													'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
											  ));
									}),
								t
							);
						}
						function Gs(n, t = new Set()) {
							return (
								n instanceof Ns && t.add(n.key),
								n.eachChild((r) => {
									Gs(r, t);
								}),
								t
							);
						}
						function Ll(n) {
							if (n === !0 || n === !1) return !0;
							if (!Array.isArray(n) || n.length === 0) return !1;
							switch (n[0]) {
								case "has":
									return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
								case "in":
									return (
										n.length >= 3 &&
										(typeof n[1] != "string" || Array.isArray(n[2]))
									);
								case "!in":
								case "!has":
								case "none":
									return !1;
								case "==":
								case "!=":
								case ">":
								case ">=":
								case "<":
								case "<=":
									return (
										n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2])
									);
								case "any":
								case "all":
									for (const t of n.slice(1))
										if (!Ll(t) && typeof t != "boolean") return !1;
									return !0;
								default:
									return !0;
							}
						}
						const Yc = {
							type: "boolean",
							default: !1,
							transition: !1,
							"property-type": "data-driven",
							expression: { interpolated: !1, parameters: ["zoom", "feature"] },
						};
						function Ro(n) {
							if (n == null)
								return {
									filter: () => !0,
									needGeometry: !1,
									getGlobalStateRefs: () => new Set(),
								};
							Ll(n) || (n = Bo(n));
							const t = qs(n, Yc);
							if (t.result === "error")
								throw new Error(
									t.value.map((r) => `${r.key}: ${r.message}`).join(", ")
								);
							return {
								filter: (r, o, c) => t.value.evaluate(r, o, {}, c),
								needGeometry: Dl(n),
								getGlobalStateRefs: () => Gs(t.value.expression),
							};
						}
						function Kc(n, t) {
							return n < t ? -1 : n > t ? 1 : 0;
						}
						function Dl(n) {
							if (!Array.isArray(n)) return !1;
							if (n[0] === "within" || n[0] === "distance") return !0;
							for (let t = 1; t < n.length; t++) if (Dl(n[t])) return !0;
							return !1;
						}
						function Bo(n) {
							if (!n) return !0;
							const t = n[0];
							return n.length <= 1
								? t !== "any"
								: t === "=="
								? Jc(n[1], n[2], "==")
								: t === "!="
								? Rl(Jc(n[1], n[2], "=="))
								: t === "<" || t === ">" || t === "<=" || t === ">="
								? Jc(n[1], n[2], t)
								: t === "any"
								? ((r = n.slice(1)), ["any"].concat(r.map(Bo)))
								: t === "all"
								? ["all"].concat(n.slice(1).map(Bo))
								: t === "none"
								? ["all"].concat(n.slice(1).map(Bo).map(Rl))
								: t === "in"
								? ad(n[1], n.slice(2))
								: t === "!in"
								? Rl(ad(n[1], n.slice(2)))
								: t === "has"
								? od(n[1])
								: t !== "!has" || Rl(od(n[1]));
							var r;
						}
						function Jc(n, t, r) {
							switch (n) {
								case "$type":
									return [`filter-type-${r}`, t];
								case "$id":
									return [`filter-id-${r}`, t];
								default:
									return [`filter-${r}`, n, t];
							}
						}
						function ad(n, t) {
							if (t.length === 0) return !1;
							switch (n) {
								case "$type":
									return ["filter-type-in", ["literal", t]];
								case "$id":
									return ["filter-id-in", ["literal", t]];
								default:
									return t.length > 200 &&
										!t.some((r) => typeof r != typeof t[0])
										? ["filter-in-large", n, ["literal", t.sort(Kc)]]
										: ["filter-in-small", n, ["literal", t]];
							}
						}
						function od(n) {
							switch (n) {
								case "$type":
									return !0;
								case "$id":
									return ["filter-has-id"];
								default:
									return ["filter-has", n];
							}
						}
						function Rl(n) {
							return ["!", n];
						}
						function Qc(n) {
							const t = typeof n;
							if (
								t === "number" ||
								t === "boolean" ||
								t === "string" ||
								n == null
							)
								return JSON.stringify(n);
							if (Array.isArray(n)) {
								let c = "[";
								for (const f of n) c += `${Qc(f)},`;
								return `${c}]`;
							}
							const r = Object.keys(n).sort();
							let o = "{";
							for (let c = 0; c < r.length; c++)
								o += `${JSON.stringify(r[c])}:${Qc(n[r[c]])},`;
							return `${o}}`;
						}
						function Np(n) {
							let t = "";
							for (const r of Bt) t += `/${Qc(n[r])}`;
							return t;
						}
						function eu(n) {
							const t = n.value;
							return t
								? [new ht(n.key, t, "constants have been deprecated as of v8")]
								: [];
						}
						function Kn(n) {
							return n instanceof Number ||
								n instanceof String ||
								n instanceof Boolean
								? n.valueOf()
								: n;
						}
						function Ua(n) {
							if (Array.isArray(n)) return n.map(Ua);
							if (
								n instanceof Object &&
								!(
									n instanceof Number ||
									n instanceof String ||
									n instanceof Boolean
								)
							) {
								const t = {};
								for (const r in n) t[r] = Ua(n[r]);
								return t;
							}
							return Kn(n);
						}
						function ya(n) {
							const t = n.key,
								r = n.value,
								o = n.valueSpec || {},
								c = n.objectElementValidators || {},
								f = n.style,
								_ = n.styleSpec,
								v = n.validateSpec;
							let b = [];
							const S = sn(r);
							if (S !== "object")
								return [new ht(t, r, `object expected, ${S} found`)];
							for (const I in r) {
								const L = I.split(".")[0],
									F = sr(o, L) || o["*"];
								let q;
								if (sr(c, L)) q = c[L];
								else if (sr(o, L)) q = v;
								else if (c["*"]) q = c["*"];
								else {
									if (!o["*"]) {
										b.push(new ht(t, r[I], `unknown property "${I}"`));
										continue;
									}
									q = v;
								}
								b = b.concat(
									q(
										{
											key: (t && `${t}.`) + I,
											value: r[I],
											valueSpec: F,
											style: f,
											styleSpec: _,
											object: r,
											objectKey: I,
											validateSpec: v,
										},
										r
									)
								);
							}
							for (const I in o)
								c[I] ||
									(o[I].required &&
										o[I].default === void 0 &&
										r[I] === void 0 &&
										b.push(new ht(t, r, `missing required property "${I}"`)));
							return b;
						}
						function Bl(n) {
							const t = n.value,
								r = n.valueSpec,
								o = n.style,
								c = n.styleSpec,
								f = n.key,
								_ = n.arrayElementValidator || n.validateSpec;
							if (sn(t) !== "array")
								return [new ht(f, t, `array expected, ${sn(t)} found`)];
							if (r.length && t.length !== r.length)
								return [
									new ht(
										f,
										t,
										`array length ${r.length} expected, length ${t.length} found`
									),
								];
							if (r["min-length"] && t.length < r["min-length"])
								return [
									new ht(
										f,
										t,
										`array length at least ${r["min-length"]} expected, length ${t.length} found`
									),
								];
							let v = { type: r.value, values: r.values };
							c.$version < 7 && (v.function = r.function),
								sn(r.value) === "object" && (v = r.value);
							let b = [];
							for (let S = 0; S < t.length; S++)
								b = b.concat(
									_({
										array: t,
										arrayIndex: S,
										value: t[S],
										valueSpec: v,
										validateSpec: n.validateSpec,
										style: o,
										styleSpec: c,
										key: `${f}[${S}]`,
									})
								);
							return b;
						}
						function Hs(n) {
							const t = n.key,
								r = n.value,
								o = n.valueSpec;
							let c = sn(r);
							return (
								c === "number" && r != r && (c = "NaN"),
								c !== "number"
									? [new ht(t, r, `number expected, ${c} found`)]
									: "minimum" in o && r < o.minimum
									? [
											new ht(
												t,
												r,
												`${r} is less than the minimum value ${o.minimum}`
											),
									  ]
									: "maximum" in o && r > o.maximum
									? [
											new ht(
												t,
												r,
												`${r} is greater than the maximum value ${o.maximum}`
											),
									  ]
									: []
							);
						}
						function sd(n) {
							const t = n.valueSpec,
								r = Kn(n.value.type);
							let o,
								c,
								f,
								_ = {};
							const v = r !== "categorical" && n.value.property === void 0,
								b = !v,
								S =
									sn(n.value.stops) === "array" &&
									sn(n.value.stops[0]) === "array" &&
									sn(n.value.stops[0][0]) === "object",
								I = ya({
									key: n.key,
									value: n.value,
									valueSpec: n.styleSpec.function,
									validateSpec: n.validateSpec,
									style: n.style,
									styleSpec: n.styleSpec,
									objectElementValidators: {
										stops: function (q) {
											if (r === "identity")
												return [
													new ht(
														q.key,
														q.value,
														'identity function may not have a "stops" property'
													),
												];
											let Z = [];
											const W = q.value;
											return (
												(Z = Z.concat(
													Bl({
														key: q.key,
														value: W,
														valueSpec: q.valueSpec,
														validateSpec: q.validateSpec,
														style: q.style,
														styleSpec: q.styleSpec,
														arrayElementValidator: L,
													})
												)),
												sn(W) === "array" &&
													W.length === 0 &&
													Z.push(
														new ht(
															q.key,
															W,
															"array must have at least one stop"
														)
													),
												Z
											);
										},
										default: function (q) {
											return q.validateSpec({
												key: q.key,
												value: q.value,
												valueSpec: t,
												validateSpec: q.validateSpec,
												style: q.style,
												styleSpec: q.styleSpec,
											});
										},
									},
								});
							return (
								r === "identity" &&
									v &&
									I.push(
										new ht(
											n.key,
											n.value,
											'missing required property "property"'
										)
									),
								r === "identity" ||
									n.value.stops ||
									I.push(
										new ht(n.key, n.value, 'missing required property "stops"')
									),
								r === "exponential" &&
									n.valueSpec.expression &&
									!Hc(n.valueSpec) &&
									I.push(
										new ht(
											n.key,
											n.value,
											"exponential functions not supported"
										)
									),
								n.styleSpec.$version >= 8 &&
									(b && !fo(n.valueSpec)
										? I.push(
												new ht(
													n.key,
													n.value,
													"property functions not supported"
												)
										  )
										: v &&
										  !ed(n.valueSpec) &&
										  I.push(
												new ht(n.key, n.value, "zoom functions not supported")
										  )),
								(r !== "categorical" && !S) ||
									n.value.property !== void 0 ||
									I.push(
										new ht(n.key, n.value, '"property" property is required')
									),
								I
							);
							function L(q) {
								let Z = [];
								const W = q.value,
									J = q.key;
								if (sn(W) !== "array")
									return [new ht(J, W, `array expected, ${sn(W)} found`)];
								if (W.length !== 2)
									return [
										new ht(
											J,
											W,
											`array length 2 expected, length ${W.length} found`
										),
									];
								if (S) {
									if (sn(W[0]) !== "object")
										return [new ht(J, W, `object expected, ${sn(W[0])} found`)];
									if (W[0].zoom === void 0)
										return [new ht(J, W, "object stop key must have zoom")];
									if (W[0].value === void 0)
										return [new ht(J, W, "object stop key must have value")];
									if (f && f > Kn(W[0].zoom))
										return [
											new ht(
												J,
												W[0].zoom,
												"stop zoom values must appear in ascending order"
											),
										];
									Kn(W[0].zoom) !== f &&
										((f = Kn(W[0].zoom)), (c = void 0), (_ = {})),
										(Z = Z.concat(
											ya({
												key: `${J}[0]`,
												value: W[0],
												valueSpec: { zoom: {} },
												validateSpec: q.validateSpec,
												style: q.style,
												styleSpec: q.styleSpec,
												objectElementValidators: { zoom: Hs, value: F },
											})
										));
								} else Z = Z.concat(F({ key: `${J}[0]`, value: W[0], validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec }, W));
								return zl(Ua(W[1]))
									? Z.concat([
											new ht(
												`${J}[1]`,
												W[1],
												"expressions are not allowed in function stops."
											),
									  ])
									: Z.concat(
											q.validateSpec({
												key: `${J}[1]`,
												value: W[1],
												valueSpec: t,
												validateSpec: q.validateSpec,
												style: q.style,
												styleSpec: q.styleSpec,
											})
									  );
							}
							function F(q, Z) {
								const W = sn(q.value),
									J = Kn(q.value),
									le = q.value !== null ? q.value : Z;
								if (o) {
									if (W !== o)
										return [
											new ht(
												q.key,
												le,
												`${W} stop domain type must match previous stop domain type ${o}`
											),
										];
								} else o = W;
								if (W !== "number" && W !== "string" && W !== "boolean")
									return [
										new ht(
											q.key,
											le,
											"stop domain value must be a number, string, or boolean"
										),
									];
								if (W !== "number" && r !== "categorical") {
									let Re = `number expected, ${W} found`;
									return (
										fo(t) &&
											r === void 0 &&
											(Re +=
												'\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
										[new ht(q.key, le, Re)]
									);
								}
								return r !== "categorical" ||
									W !== "number" ||
									(isFinite(J) && Math.floor(J) === J)
									? r !== "categorical" &&
									  W === "number" &&
									  c !== void 0 &&
									  J < c
										? [
												new ht(
													q.key,
													le,
													"stop domain values must appear in ascending order"
												),
										  ]
										: ((c = J),
										  r === "categorical" && J in _
												? [
														new ht(
															q.key,
															le,
															"stop domain values must be unique"
														),
												  ]
												: ((_[J] = !0), []))
									: [new ht(q.key, le, `integer expected, found ${J}`)];
							}
						}
						function Fo(n) {
							const t = (n.expressionContext === "property" ? id : qs)(
								Ua(n.value),
								n.valueSpec
							);
							if (t.result === "error")
								return t.value.map(
									(o) => new ht(`${n.key}${o.key}`, n.value, o.message)
								);
							const r =
								t.value.expression || t.value._styleExpression.expression;
							if (
								n.expressionContext === "property" &&
								n.propertyKey === "text-font" &&
								!r.outputDefined()
							)
								return [
									new ht(
										n.key,
										n.value,
										`Invalid data expression for "${n.propertyKey}". Output values must be contained as literals within the expression.`
									),
								];
							if (
								n.expressionContext === "property" &&
								n.propertyType === "layout" &&
								!js(r)
							)
								return [
									new ht(
										n.key,
										n.value,
										'"feature-state" data expressions are not supported with layout properties.'
									),
								];
							if (n.expressionContext === "filter" && !js(r))
								return [
									new ht(
										n.key,
										n.value,
										'"feature-state" data expressions are not supported with filters.'
									),
								];
							if (
								n.expressionContext &&
								n.expressionContext.indexOf("cluster") === 0
							) {
								if (!El(r, ["zoom", "feature-state"]))
									return [
										new ht(
											n.key,
											n.value,
											'"zoom" and "feature-state" expressions are not supported with cluster properties.'
										),
									];
								if (n.expressionContext === "cluster-initial" && !Al(r))
									return [
										new ht(
											n.key,
											n.value,
											"Feature data expressions are not supported with initial expression part of cluster properties."
										),
									];
							}
							return [];
						}
						function Fl(n) {
							const t = n.key,
								r = n.value,
								o = sn(r);
							return o !== "string"
								? [new ht(t, r, `color expected, ${o} found`)]
								: Mr.parse(String(r))
								? []
								: [new ht(t, r, `color expected, "${r}" found`)];
						}
						function to(n) {
							const t = n.key,
								r = n.value,
								o = n.valueSpec,
								c = [];
							return (
								Array.isArray(o.values)
									? o.values.indexOf(Kn(r)) === -1 &&
									  c.push(
											new ht(
												t,
												r,
												`expected one of [${o.values.join(
													", "
												)}], ${JSON.stringify(r)} found`
											)
									  )
									: Object.keys(o.values).indexOf(Kn(r)) === -1 &&
									  c.push(
											new ht(
												t,
												r,
												`expected one of [${Object.keys(o.values).join(
													", "
												)}], ${JSON.stringify(r)} found`
											)
									  ),
								c
							);
						}
						function tu(n) {
							return Ll(Ua(n.value))
								? Fo(
										Xr({}, n, {
											expressionContext: "filter",
											valueSpec: { value: "boolean" },
										})
								  )
								: ld(n);
						}
						function ld(n) {
							const t = n.value,
								r = n.key;
							if (sn(t) !== "array")
								return [new ht(r, t, `array expected, ${sn(t)} found`)];
							const o = n.styleSpec;
							let c,
								f = [];
							if (t.length < 1)
								return [
									new ht(r, t, "filter array must have at least 1 element"),
								];
							switch (
								((f = f.concat(
									to({
										key: `${r}[0]`,
										value: t[0],
										valueSpec: o.filter_operator,
										style: n.style,
										styleSpec: n.styleSpec,
									})
								)),
								Kn(t[0]))
							) {
								case "<":
								case "<=":
								case ">":
								case ">=":
									t.length >= 2 &&
										Kn(t[1]) === "$type" &&
										f.push(
											new ht(
												r,
												t,
												`"$type" cannot be use with operator "${t[0]}"`
											)
										);
								case "==":
								case "!=":
									t.length !== 3 &&
										f.push(
											new ht(
												r,
												t,
												`filter array for operator "${t[0]}" must have 3 elements`
											)
										);
								case "in":
								case "!in":
									t.length >= 2 &&
										((c = sn(t[1])),
										c !== "string" &&
											f.push(
												new ht(`${r}[1]`, t[1], `string expected, ${c} found`)
											));
									for (let _ = 2; _ < t.length; _++)
										(c = sn(t[_])),
											Kn(t[1]) === "$type"
												? (f = f.concat(
														to({
															key: `${r}[${_}]`,
															value: t[_],
															valueSpec: o.geometry_type,
															style: n.style,
															styleSpec: n.styleSpec,
														})
												  ))
												: c !== "string" &&
												  c !== "number" &&
												  c !== "boolean" &&
												  f.push(
														new ht(
															`${r}[${_}]`,
															t[_],
															`string, number, or boolean expected, ${c} found`
														)
												  );
									break;
								case "any":
								case "all":
								case "none":
									for (let _ = 1; _ < t.length; _++)
										f = f.concat(
											ld({
												key: `${r}[${_}]`,
												value: t[_],
												style: n.style,
												styleSpec: n.styleSpec,
											})
										);
									break;
								case "has":
								case "!has":
									(c = sn(t[1])),
										t.length !== 2
											? f.push(
													new ht(
														r,
														t,
														`filter array for "${t[0]}" operator must have 2 elements`
													)
											  )
											: c !== "string" &&
											  f.push(
													new ht(`${r}[1]`, t[1], `string expected, ${c} found`)
											  );
							}
							return f;
						}
						function cd(n, t) {
							const r = n.key,
								o = n.validateSpec,
								c = n.style,
								f = n.styleSpec,
								_ = n.value,
								v = n.objectKey,
								b = f[`${t}_${n.layerType}`];
							if (!b) return [];
							const S = v.match(/^(.*)-transition$/);
							if (t === "paint" && S && b[S[1]] && b[S[1]].transition)
								return o({
									key: r,
									value: _,
									valueSpec: f.transition,
									style: c,
									styleSpec: f,
								});
							const I = n.valueSpec || b[v];
							if (!I) return [new ht(r, _, `unknown property "${v}"`)];
							let L;
							if (
								sn(_) === "string" &&
								fo(I) &&
								!I.tokens &&
								(L = /^{([^}]+)}$/.exec(_))
							)
								return [
									new ht(
										r,
										_,
										`"${v}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
											L[1]
										)} }\`.`
									),
								];
							const F = [];
							return (
								n.layerType === "symbol" &&
									(v === "text-field" &&
										c &&
										!c.glyphs &&
										F.push(
											new ht(
												r,
												_,
												'use of "text-field" requires a style "glyphs" property'
											)
										),
									v === "text-font" &&
										Vs(Ua(_)) &&
										Kn(_.type) === "identity" &&
										F.push(
											new ht(
												r,
												_,
												'"text-font" does not support identity functions'
											)
										)),
								F.concat(
									o({
										key: n.key,
										value: _,
										valueSpec: I,
										style: c,
										styleSpec: f,
										expressionContext: "property",
										propertyType: t,
										propertyKey: v,
									})
								)
							);
						}
						function ud(n) {
							return cd(n, "paint");
						}
						function hd(n) {
							return cd(n, "layout");
						}
						function dd(n) {
							let t = [];
							const r = n.value,
								o = n.key,
								c = n.style,
								f = n.styleSpec;
							if (sn(r) !== "object")
								return [new ht(o, r, `object expected, ${sn(r)} found`)];
							r.type ||
								r.ref ||
								t.push(new ht(o, r, 'either "type" or "ref" is required'));
							let _ = Kn(r.type);
							const v = Kn(r.ref);
							if (r.id) {
								const b = Kn(r.id);
								for (let S = 0; S < n.arrayIndex; S++) {
									const I = c.layers[S];
									Kn(I.id) === b &&
										t.push(
											new ht(
												o,
												r.id,
												`duplicate layer id "${r.id}", previously used at line ${I.id.__line__}`
											)
										);
								}
							}
							if ("ref" in r) {
								let b;
								["type", "source", "source-layer", "filter", "layout"].forEach(
									(S) => {
										S in r &&
											t.push(
												new ht(o, r[S], `"${S}" is prohibited for ref layers`)
											);
									}
								),
									c.layers.forEach((S) => {
										Kn(S.id) === v && (b = S);
									}),
									b
										? b.ref
											? t.push(
													new ht(
														o,
														r.ref,
														"ref cannot reference another ref layer"
													)
											  )
											: (_ = Kn(b.type))
										: t.push(new ht(o, r.ref, `ref layer "${v}" not found`));
							} else if (_ !== "background")
								if (r.source) {
									const b = c.sources && c.sources[r.source],
										S = b && Kn(b.type);
									b
										? S === "vector" && _ === "raster"
											? t.push(
													new ht(
														o,
														r.source,
														`layer "${r.id}" requires a raster source`
													)
											  )
											: (S !== "raster-dem" && _ === "hillshade") ||
											  (S !== "raster-dem" && _ === "color-relief")
											? t.push(
													new ht(
														o,
														r.source,
														`layer "${r.id}" requires a raster-dem source`
													)
											  )
											: S === "raster" && _ !== "raster"
											? t.push(
													new ht(
														o,
														r.source,
														`layer "${r.id}" requires a vector source`
													)
											  )
											: S !== "vector" || r["source-layer"]
											? S === "raster-dem" &&
											  _ !== "hillshade" &&
											  _ !== "color-relief"
												? t.push(
														new ht(
															o,
															r.source,
															"raster-dem source can only be used with layer type 'hillshade' or 'color-relief'."
														)
												  )
												: _ !== "line" ||
												  !r.paint ||
												  !r.paint["line-gradient"] ||
												  (S === "geojson" && b.lineMetrics) ||
												  t.push(
														new ht(
															o,
															r,
															`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
														)
												  )
											: t.push(
													new ht(
														o,
														r,
														`layer "${r.id}" must specify a "source-layer"`
													)
											  )
										: t.push(
												new ht(o, r.source, `source "${r.source}" not found`)
										  );
								} else
									t.push(new ht(o, r, 'missing required property "source"'));
							return (
								(t = t.concat(
									ya({
										key: o,
										value: r,
										valueSpec: f.layer,
										style: n.style,
										styleSpec: n.styleSpec,
										validateSpec: n.validateSpec,
										objectElementValidators: {
											"*": () => [],
											type: () =>
												n.validateSpec({
													key: `${o}.type`,
													value: r.type,
													valueSpec: f.layer.type,
													style: n.style,
													styleSpec: n.styleSpec,
													validateSpec: n.validateSpec,
													object: r,
													objectKey: "type",
												}),
											filter: tu,
											layout: (b) =>
												ya({
													layer: r,
													key: b.key,
													value: b.value,
													style: b.style,
													styleSpec: b.styleSpec,
													validateSpec: b.validateSpec,
													objectElementValidators: {
														"*": (S) => hd(Xr({ layerType: _ }, S)),
													},
												}),
											paint: (b) =>
												ya({
													layer: r,
													key: b.key,
													value: b.value,
													style: b.style,
													styleSpec: b.styleSpec,
													validateSpec: b.validateSpec,
													objectElementValidators: {
														"*": (S) => ud(Xr({ layerType: _ }, S)),
													},
												}),
										},
									})
								)),
								t
							);
						}
						function Ia(n) {
							const t = n.value,
								r = n.key,
								o = sn(t);
							return o !== "string"
								? [new ht(r, t, `string expected, ${o} found`)]
								: [];
						}
						const ns = {
							promoteId: function ({ key: n, value: t }) {
								if (sn(t) === "string") return Ia({ key: n, value: t });
								{
									const r = [];
									for (const o in t)
										r.push(...Ia({ key: `${n}.${o}`, value: t[o] }));
									return r;
								}
							},
						};
						function Qi(n) {
							const t = n.value,
								r = n.key,
								o = n.styleSpec,
								c = n.style,
								f = n.validateSpec;
							if (!t.type) return [new ht(r, t, '"type" is required')];
							const _ = Kn(t.type);
							let v;
							switch (_) {
								case "vector":
								case "raster":
									return (
										(v = ya({
											key: r,
											value: t,
											valueSpec: o[`source_${_.replace("-", "_")}`],
											style: n.style,
											styleSpec: o,
											objectElementValidators: ns,
											validateSpec: f,
										})),
										v
									);
								case "raster-dem":
									return (
										(v = (function (b) {
											var S;
											const I =
													(S = b.sourceName) !== null && S !== void 0 ? S : "",
												L = b.value,
												F = b.styleSpec,
												q = F.source_raster_dem,
												Z = b.style;
											let W = [];
											const J = sn(L);
											if (L === void 0) return W;
											if (J !== "object")
												return (
													W.push(
														new ht(
															"source_raster_dem",
															L,
															`object expected, ${J} found`
														)
													),
													W
												);
											const le = Kn(L.encoding) === "custom",
												Re = [
													"redFactor",
													"greenFactor",
													"blueFactor",
													"baseShift",
												],
												xe = b.value.encoding
													? `"${b.value.encoding}"`
													: "Default";
											for (const Ce in L)
												!le && Re.includes(Ce)
													? W.push(
															new ht(
																Ce,
																L[Ce],
																`In "${I}": "${Ce}" is only valid when "encoding" is set to "custom". ${xe} encoding found`
															)
													  )
													: q[Ce]
													? (W = W.concat(
															b.validateSpec({
																key: Ce,
																value: L[Ce],
																valueSpec: q[Ce],
																validateSpec: b.validateSpec,
																style: Z,
																styleSpec: F,
															})
													  ))
													: W.push(
															new ht(Ce, L[Ce], `unknown property "${Ce}"`)
													  );
											return W;
										})({
											sourceName: r,
											value: t,
											style: n.style,
											styleSpec: o,
											validateSpec: f,
										})),
										v
									);
								case "geojson":
									if (
										((v = ya({
											key: r,
											value: t,
											valueSpec: o.source_geojson,
											style: c,
											styleSpec: o,
											validateSpec: f,
											objectElementValidators: ns,
										})),
										t.cluster)
									)
										for (const b in t.clusterProperties) {
											const [S, I] = t.clusterProperties[b],
												L =
													typeof S == "string"
														? [S, ["accumulated"], ["get", b]]
														: S;
											v.push(
												...Fo({
													key: `${r}.${b}.map`,
													value: I,
													expressionContext: "cluster-map",
												})
											),
												v.push(
													...Fo({
														key: `${r}.${b}.reduce`,
														value: L,
														expressionContext: "cluster-reduce",
													})
												);
										}
									return v;
								case "video":
									return ya({
										key: r,
										value: t,
										valueSpec: o.source_video,
										style: c,
										validateSpec: f,
										styleSpec: o,
									});
								case "image":
									return ya({
										key: r,
										value: t,
										valueSpec: o.source_image,
										style: c,
										validateSpec: f,
										styleSpec: o,
									});
								case "canvas":
									return [
										new ht(
											r,
											null,
											"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
											"source.canvas"
										),
									];
								default:
									return to({
										key: `${r}.type`,
										value: t.type,
										valueSpec: {
											values: [
												"vector",
												"raster",
												"raster-dem",
												"geojson",
												"video",
												"image",
											],
										},
									});
							}
						}
						function is(n) {
							const t = n.value,
								r = n.styleSpec,
								o = r.light,
								c = n.style;
							let f = [];
							const _ = sn(t);
							if (t === void 0) return f;
							if (_ !== "object")
								return (
									(f = f.concat([
										new ht("light", t, `object expected, ${_} found`),
									])),
									f
								);
							for (const v in t) {
								const b = v.match(/^(.*)-transition$/);
								f = f.concat(
									b && o[b[1]] && o[b[1]].transition
										? n.validateSpec({
												key: v,
												value: t[v],
												valueSpec: r.transition,
												validateSpec: n.validateSpec,
												style: c,
												styleSpec: r,
										  })
										: o[v]
										? n.validateSpec({
												key: v,
												value: t[v],
												valueSpec: o[v],
												validateSpec: n.validateSpec,
												style: c,
												styleSpec: r,
										  })
										: [new ht(v, t[v], `unknown property "${v}"`)]
								);
							}
							return f;
						}
						function ru(n) {
							const t = n.value,
								r = n.styleSpec,
								o = r.sky,
								c = n.style,
								f = sn(t);
							if (t === void 0) return [];
							if (f !== "object")
								return [new ht("sky", t, `object expected, ${f} found`)];
							let _ = [];
							for (const v in t)
								_ = _.concat(
									o[v]
										? n.validateSpec({
												key: v,
												value: t[v],
												valueSpec: o[v],
												style: c,
												styleSpec: r,
										  })
										: [new ht(v, t[v], `unknown property "${v}"`)]
								);
							return _;
						}
						function pd(n) {
							const t = n.value,
								r = n.styleSpec,
								o = r.terrain,
								c = n.style;
							let f = [];
							const _ = sn(t);
							if (t === void 0) return f;
							if (_ !== "object")
								return (
									(f = f.concat([
										new ht("terrain", t, `object expected, ${_} found`),
									])),
									f
								);
							for (const v in t)
								f = f.concat(
									o[v]
										? n.validateSpec({
												key: v,
												value: t[v],
												valueSpec: o[v],
												validateSpec: n.validateSpec,
												style: c,
												styleSpec: r,
										  })
										: [new ht(v, t[v], `unknown property "${v}"`)]
								);
							return f;
						}
						function fd(n) {
							let t = [];
							const r = n.value,
								o = n.key;
							if (Array.isArray(r)) {
								const c = [],
									f = [];
								for (const _ in r)
									r[_].id &&
										c.includes(r[_].id) &&
										t.push(
											new ht(
												o,
												r,
												`all the sprites' ids must be unique, but ${r[_].id} is duplicated`
											)
										),
										c.push(r[_].id),
										r[_].url &&
											f.includes(r[_].url) &&
											t.push(
												new ht(
													o,
													r,
													`all the sprites' URLs must be unique, but ${r[_].url} is duplicated`
												)
											),
										f.push(r[_].url),
										(t = t.concat(
											ya({
												key: `${o}[${_}]`,
												value: r[_],
												valueSpec: {
													id: { type: "string", required: !0 },
													url: { type: "string", required: !0 },
												},
												validateSpec: n.validateSpec,
											})
										));
								return t;
							}
							return Ia({ key: o, value: r });
						}
						function as(n) {
							return (
								(t = n.value),
								t && t.constructor === Object
									? []
									: [
											new ht(
												n.key,
												n.value,
												`object expected, ${sn(n.value)} found`
											),
									  ]
							);
							var t;
						}
						const nu = {
							"*": () => [],
							array: Bl,
							boolean: function (n) {
								const t = n.value,
									r = n.key,
									o = sn(t);
								return o !== "boolean"
									? [new ht(r, t, `boolean expected, ${o} found`)]
									: [];
							},
							number: Hs,
							color: Fl,
							constants: eu,
							enum: to,
							filter: tu,
							function: sd,
							layer: dd,
							object: ya,
							source: Qi,
							light: is,
							sky: ru,
							terrain: pd,
							projection: function (n) {
								const t = n.value,
									r = n.styleSpec,
									o = r.projection,
									c = n.style,
									f = sn(t);
								if (t === void 0) return [];
								if (f !== "object")
									return [
										new ht("projection", t, `object expected, ${f} found`),
									];
								let _ = [];
								for (const v in t)
									_ = _.concat(
										o[v]
											? n.validateSpec({
													key: v,
													value: t[v],
													valueSpec: o[v],
													style: c,
													styleSpec: r,
											  })
											: [new ht(v, t[v], `unknown property "${v}"`)]
									);
								return _;
							},
							projectionDefinition: function (n) {
								const t = n.key;
								let r = n.value;
								r = r instanceof String ? r.valueOf() : r;
								const o = sn(r);
								return o !== "array" ||
									(function (c) {
										return (
											Array.isArray(c) &&
											c.length === 3 &&
											typeof c[0] == "string" &&
											typeof c[1] == "string" &&
											typeof c[2] == "number"
										);
									})(r) ||
									(function (c) {
										return !!["interpolate", "step", "literal"].includes(c[0]);
									})(r)
									? ["array", "string"].includes(o)
										? []
										: [
												new ht(
													t,
													r,
													`projection expected, invalid type "${o}" found`
												),
										  ]
									: [
											new ht(
												t,
												r,
												`projection expected, invalid array ${JSON.stringify(
													r
												)} found`
											),
									  ];
							},
							string: Ia,
							formatted: function (n) {
								return Ia(n).length === 0 ? [] : Fo(n);
							},
							resolvedImage: function (n) {
								return Ia(n).length === 0 ? [] : Fo(n);
							},
							padding: function (n) {
								const t = n.key,
									r = n.value;
								if (sn(r) === "array") {
									if (r.length < 1 || r.length > 4)
										return [
											new ht(
												t,
												r,
												`padding requires 1 to 4 values; ${r.length} values found`
											),
										];
									const o = { type: "number" };
									let c = [];
									for (let f = 0; f < r.length; f++)
										c = c.concat(
											n.validateSpec({
												key: `${t}[${f}]`,
												value: r[f],
												validateSpec: n.validateSpec,
												valueSpec: o,
											})
										);
									return c;
								}
								return Hs({ key: t, value: r, valueSpec: {} });
							},
							numberArray: function (n) {
								const t = n.key,
									r = n.value;
								if (sn(r) === "array") {
									const o = { type: "number" };
									if (r.length < 1)
										return [
											new ht(
												t,
												r,
												"array length at least 1 expected, length 0 found"
											),
										];
									let c = [];
									for (let f = 0; f < r.length; f++)
										c = c.concat(
											n.validateSpec({
												key: `${t}[${f}]`,
												value: r[f],
												validateSpec: n.validateSpec,
												valueSpec: o,
											})
										);
									return c;
								}
								return Hs({ key: t, value: r, valueSpec: {} });
							},
							colorArray: function (n) {
								const t = n.key,
									r = n.value;
								if (sn(r) === "array") {
									if (r.length < 1)
										return [
											new ht(
												t,
												r,
												"array length at least 1 expected, length 0 found"
											),
										];
									let o = [];
									for (let c = 0; c < r.length; c++)
										o = o.concat(Fl({ key: `${t}[${c}]`, value: r[c] }));
									return o;
								}
								return Fl({ key: t, value: r });
							},
							variableAnchorOffsetCollection: function (n) {
								const t = n.key,
									r = n.value,
									o = sn(r),
									c = n.styleSpec;
								if (o !== "array" || r.length < 1 || r.length % 2 != 0)
									return [
										new ht(
											t,
											r,
											"variableAnchorOffsetCollection requires a non-empty array of even length"
										),
									];
								let f = [];
								for (let _ = 0; _ < r.length; _ += 2)
									(f = f.concat(
										to({
											key: `${t}[${_}]`,
											value: r[_],
											valueSpec: c.layout_symbol["text-anchor"],
										})
									)),
										(f = f.concat(
											Bl({
												key: `${t}[${_ + 1}]`,
												value: r[_ + 1],
												valueSpec: { length: 2, value: "number" },
												validateSpec: n.validateSpec,
												style: n.style,
												styleSpec: c,
											})
										));
								return f;
							},
							sprite: fd,
							state: as,
						};
						function os(n) {
							const t = n.value,
								r = n.valueSpec,
								o = n.styleSpec;
							return (
								(n.validateSpec = os),
								r.expression && Vs(Kn(t))
									? sd(n)
									: r.expression && zl(Ua(t))
									? Fo(n)
									: r.type && nu[r.type]
									? nu[r.type](n)
									: ya(Xr({}, n, { valueSpec: r.type ? o[r.type] : r }))
							);
						}
						function md(n) {
							const t = n.value,
								r = n.key,
								o = Ia(n);
							return (
								o.length ||
									(t.indexOf("{fontstack}") === -1 &&
										o.push(
											new ht(
												r,
												t,
												'"glyphs" url must include a "{fontstack}" token'
											)
										),
									t.indexOf("{range}") === -1 &&
										o.push(
											new ht(
												r,
												t,
												'"glyphs" url must include a "{range}" token'
											)
										)),
								o
							);
						}
						function ea(n, t = ye) {
							let r = [];
							return (
								(r = r.concat(
									os({
										key: "",
										value: n,
										valueSpec: t.$root,
										styleSpec: t,
										style: n,
										validateSpec: os,
										objectElementValidators: { glyphs: md, "*": () => [] },
									})
								)),
								n.constants &&
									(r = r.concat(eu({ key: "constants", value: n.constants }))),
								ss(r)
							);
						}
						function Ma(n) {
							return function (t) {
								return n({ ...t, validateSpec: os });
							};
						}
						function ss(n) {
							return [].concat(n).sort((t, r) => t.line - r.line);
						}
						function ka(n) {
							return function (...t) {
								return ss(n.apply(this, t));
							};
						}
						(ea.source = ka(Ma(Qi))),
							(ea.sprite = ka(Ma(fd))),
							(ea.glyphs = ka(Ma(md))),
							(ea.light = ka(Ma(is))),
							(ea.sky = ka(Ma(ru))),
							(ea.terrain = ka(Ma(pd))),
							(ea.state = ka(Ma(as))),
							(ea.layer = ka(Ma(dd))),
							(ea.filter = ka(Ma(tu))),
							(ea.paintProperty = ka(Ma(ud))),
							(ea.layoutProperty = ka(Ma(hd)));
						const ls = ea,
							jp = ls.light,
							Ws = ls.sky,
							Vp = ls.paintProperty,
							qp = ls.layoutProperty;
						function Xs(n, t) {
							let r = !1;
							if (t && t.length)
								for (const o of t)
									n.fire(new Ke(new Error(o.message))), (r = !0);
							return r;
						}
						class Ys {
							constructor(t, r, o) {
								const c = (this.cells = []);
								if (t instanceof ArrayBuffer) {
									this.arrayBuffer = t;
									const _ = new Int32Array(this.arrayBuffer);
									(t = _[0]), (this.d = (r = _[1]) + 2 * (o = _[2]));
									for (let b = 0; b < this.d * this.d; b++) {
										const S = _[3 + b],
											I = _[3 + b + 1];
										c.push(S === I ? null : _.subarray(S, I));
									}
									const v = _[3 + c.length + 1];
									(this.keys = _.subarray(_[3 + c.length], v)),
										(this.bboxes = _.subarray(v)),
										(this.insert = this._insertReadonly);
								} else {
									this.d = r + 2 * o;
									for (let _ = 0; _ < this.d * this.d; _++) c.push([]);
									(this.keys = []), (this.bboxes = []);
								}
								(this.n = r),
									(this.extent = t),
									(this.padding = o),
									(this.scale = r / t),
									(this.uid = 0);
								const f = (o / r) * t;
								(this.min = -f), (this.max = t + f);
							}
							insert(t, r, o, c, f) {
								this._forEachCell(
									r,
									o,
									c,
									f,
									this._insertCell,
									this.uid++,
									void 0,
									void 0
								),
									this.keys.push(t),
									this.bboxes.push(r),
									this.bboxes.push(o),
									this.bboxes.push(c),
									this.bboxes.push(f);
							}
							_insertReadonly() {
								throw new Error(
									"Cannot insert into a GridIndex created from an ArrayBuffer."
								);
							}
							_insertCell(t, r, o, c, f, _) {
								this.cells[f].push(_);
							}
							query(t, r, o, c, f) {
								const _ = this.min,
									v = this.max;
								if (t <= _ && r <= _ && v <= o && v <= c && !f)
									return Array.prototype.slice.call(this.keys);
								{
									const b = [];
									return (
										this._forEachCell(t, r, o, c, this._queryCell, b, {}, f), b
									);
								}
							}
							_queryCell(t, r, o, c, f, _, v, b) {
								const S = this.cells[f];
								if (S !== null) {
									const I = this.keys,
										L = this.bboxes;
									for (let F = 0; F < S.length; F++) {
										const q = S[F];
										if (v[q] === void 0) {
											const Z = 4 * q;
											(
												b
													? b(L[Z + 0], L[Z + 1], L[Z + 2], L[Z + 3])
													: t <= L[Z + 2] &&
													  r <= L[Z + 3] &&
													  o >= L[Z + 0] &&
													  c >= L[Z + 1]
											)
												? ((v[q] = !0), _.push(I[q]))
												: (v[q] = !1);
										}
									}
								}
							}
							_forEachCell(t, r, o, c, f, _, v, b) {
								const S = this._convertToCellCoord(t),
									I = this._convertToCellCoord(r),
									L = this._convertToCellCoord(o),
									F = this._convertToCellCoord(c);
								for (let q = S; q <= L; q++)
									for (let Z = I; Z <= F; Z++) {
										const W = this.d * Z + q;
										if (
											(!b ||
												b(
													this._convertFromCellCoord(q),
													this._convertFromCellCoord(Z),
													this._convertFromCellCoord(q + 1),
													this._convertFromCellCoord(Z + 1)
												)) &&
											f.call(this, t, r, o, c, W, _, v, b)
										)
											return;
									}
							}
							_convertFromCellCoord(t) {
								return (t - this.padding) / this.scale;
							}
							_convertToCellCoord(t) {
								return Math.max(
									0,
									Math.min(
										this.d - 1,
										Math.floor(t * this.scale) + this.padding
									)
								);
							}
							toArrayBuffer() {
								if (this.arrayBuffer) return this.arrayBuffer;
								const t = this.cells,
									r = 3 + this.cells.length + 1 + 1;
								let o = 0;
								for (let _ = 0; _ < this.cells.length; _++)
									o += this.cells[_].length;
								const c = new Int32Array(
									r + o + this.keys.length + this.bboxes.length
								);
								(c[0] = this.extent), (c[1] = this.n), (c[2] = this.padding);
								let f = r;
								for (let _ = 0; _ < t.length; _++) {
									const v = t[_];
									(c[3 + _] = f), c.set(v, f), (f += v.length);
								}
								return (
									(c[3 + t.length] = f),
									c.set(this.keys, f),
									(f += this.keys.length),
									(c[3 + t.length + 1] = f),
									c.set(this.bboxes, f),
									(f += this.bboxes.length),
									c.buffer
								);
							}
							static serialize(t, r) {
								const o = t.toArrayBuffer();
								return r && r.push(o), { buffer: o };
							}
							static deserialize(t) {
								return new Ys(t.buffer);
							}
						}
						const Aa = {};
						function ir(n, t, r = {}) {
							if (Aa[n]) throw new Error(`${n} is already registered.`);
							Object.defineProperty(t, "_classRegistryKey", {
								value: n,
								writeable: !1,
							}),
								(Aa[n] = {
									klass: t,
									omit: r.omit || [],
									shallow: r.shallow || [],
								});
						}
						ir("Object", Object),
							ir("Set", Set),
							ir("TransferableGridIndex", Ys),
							ir("Color", Mr),
							ir("Error", Error),
							ir("AJAXError", ie),
							ir("ResolvedImage", Hn),
							ir("StylePropertyFunction", Us),
							ir("StyleExpression", Wc, { omit: ["_evaluator"] }),
							ir("ZoomDependentExpression", Xc),
							ir("ZoomConstantExpression", Zs),
							ir("CompoundExpression", va, { omit: ["_evaluate"] });
						for (const n in ts)
							ts[n]._classRegistryKey || ir(`Expression_${n}`, ts[n]);
						function iu(n) {
							return (
								n &&
								typeof ArrayBuffer < "u" &&
								(n instanceof ArrayBuffer ||
									(n.constructor && n.constructor.name === "ArrayBuffer"))
							);
						}
						function Ol(n) {
							return n.$name || n.constructor._classRegistryKey;
						}
						function au(n) {
							return (
								!(function (t) {
									if (t === null || typeof t != "object") return !1;
									const r = Ol(t);
									return !(!r || r === "Object");
								})(n) &&
								(n == null ||
									typeof n == "boolean" ||
									typeof n == "number" ||
									typeof n == "string" ||
									n instanceof Boolean ||
									n instanceof Number ||
									n instanceof String ||
									n instanceof Date ||
									n instanceof RegExp ||
									n instanceof Blob ||
									n instanceof Error ||
									iu(n) ||
									Qt(n) ||
									ArrayBuffer.isView(n) ||
									n instanceof ImageData)
							);
						}
						function cs(n, t) {
							if (au(n))
								return (
									(iu(n) || Qt(n)) && t && t.push(n),
									ArrayBuffer.isView(n) && t && t.push(n.buffer),
									n instanceof ImageData && t && t.push(n.data.buffer),
									n
								);
							if (Array.isArray(n)) {
								const f = [];
								for (const _ of n) f.push(cs(_, t));
								return f;
							}
							if (typeof n != "object")
								throw new Error("can't serialize object of type " + typeof n);
							const r = Ol(n);
							if (!r)
								throw new Error(
									`can't serialize object of unregistered class ${n.constructor.name}`
								);
							if (!Aa[r]) throw new Error(`${r} is not registered.`);
							const { klass: o } = Aa[r],
								c = o.serialize ? o.serialize(n, t) : {};
							if (o.serialize) {
								if (t && c === t[t.length - 1])
									throw new Error(
										"statically serialized object won't survive transfer of $name property"
									);
							} else {
								for (const f in n) {
									if (!n.hasOwnProperty(f) || Aa[r].omit.indexOf(f) >= 0)
										continue;
									const _ = n[f];
									c[f] = Aa[r].shallow.indexOf(f) >= 0 ? _ : cs(_, t);
								}
								n instanceof Error && (c.message = n.message);
							}
							if (c.$name)
								throw new Error(
									"$name property is reserved for worker serialization logic."
								);
							return r !== "Object" && (c.$name = r), c;
						}
						function Oo(n) {
							if (au(n)) return n;
							if (Array.isArray(n)) return n.map(Oo);
							if (typeof n != "object")
								throw new Error("can't deserialize object of type " + typeof n);
							const t = Ol(n) || "Object";
							if (!Aa[t])
								throw new Error(`can't deserialize unregistered class ${t}`);
							const { klass: r } = Aa[t];
							if (!r)
								throw new Error(`can't deserialize unregistered class ${t}`);
							if (r.deserialize) return r.deserialize(n);
							const o = Object.create(r.prototype);
							for (const c of Object.keys(n)) {
								if (c === "$name") continue;
								const f = n[c];
								o[c] = Aa[t].shallow.indexOf(c) >= 0 ? f : Oo(f);
							}
							return o;
						}
						class Nl {
							constructor() {
								this.first = !0;
							}
							update(t, r) {
								const o = Math.floor(t);
								return this.first
									? ((this.first = !1),
									  (this.lastIntegerZoom = o),
									  (this.lastIntegerZoomTime = 0),
									  (this.lastZoom = t),
									  (this.lastFloorZoom = o),
									  !0)
									: (this.lastFloorZoom > o
											? ((this.lastIntegerZoom = o + 1),
											  (this.lastIntegerZoomTime = r))
											: this.lastFloorZoom < o &&
											  ((this.lastIntegerZoom = o),
											  (this.lastIntegerZoomTime = r)),
									  t !== this.lastZoom &&
											((this.lastZoom = t), (this.lastFloorZoom = o), !0));
							}
						}
						const hn = {
							"Latin-1 Supplement": (n) => n >= 128 && n <= 255,
							"Hangul Jamo": (n) => n >= 4352 && n <= 4607,
							Khmer: (n) => n >= 6016 && n <= 6143,
							"General Punctuation": (n) => n >= 8192 && n <= 8303,
							"Letterlike Symbols": (n) => n >= 8448 && n <= 8527,
							"Number Forms": (n) => n >= 8528 && n <= 8591,
							"Miscellaneous Technical": (n) => n >= 8960 && n <= 9215,
							"Control Pictures": (n) => n >= 9216 && n <= 9279,
							"Optical Character Recognition": (n) => n >= 9280 && n <= 9311,
							"Enclosed Alphanumerics": (n) => n >= 9312 && n <= 9471,
							"Geometric Shapes": (n) => n >= 9632 && n <= 9727,
							"Miscellaneous Symbols": (n) => n >= 9728 && n <= 9983,
							"Miscellaneous Symbols and Arrows": (n) =>
								n >= 11008 && n <= 11263,
							"Ideographic Description Characters": (n) =>
								n >= 12272 && n <= 12287,
							"CJK Symbols and Punctuation": (n) => n >= 12288 && n <= 12351,
							Hiragana: (n) => n >= 12352 && n <= 12447,
							Katakana: (n) => n >= 12448 && n <= 12543,
							Kanbun: (n) => n >= 12688 && n <= 12703,
							"CJK Strokes": (n) => n >= 12736 && n <= 12783,
							"Enclosed CJK Letters and Months": (n) =>
								n >= 12800 && n <= 13055,
							"CJK Compatibility": (n) => n >= 13056 && n <= 13311,
							"Yijing Hexagram Symbols": (n) => n >= 19904 && n <= 19967,
							"CJK Unified Ideographs": (n) => n >= 19968 && n <= 40959,
							"Hangul Syllables": (n) => n >= 44032 && n <= 55215,
							"Private Use Area": (n) => n >= 57344 && n <= 63743,
							"Vertical Forms": (n) => n >= 65040 && n <= 65055,
							"CJK Compatibility Forms": (n) => n >= 65072 && n <= 65103,
							"Small Form Variants": (n) => n >= 65104 && n <= 65135,
							"Halfwidth and Fullwidth Forms": (n) => n >= 65280 && n <= 65519,
						};
						function jl(n) {
							for (const t of n) if (su(t.charCodeAt(0))) return !0;
							return !1;
						}
						function Zp(n) {
							for (const t of n) if (!_d(t.charCodeAt(0))) return !1;
							return !0;
						}
						function Vl(n) {
							const t = n
								.map((r) => {
									try {
										return new RegExp(`\\p{sc=${r}}`, "u").source;
									} catch {
										return null;
									}
								})
								.filter((r) => r);
							return new RegExp(t.join("|"), "u");
						}
						const Up = Vl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
						function _d(n) {
							return !Up.test(String.fromCodePoint(n));
						}
						const ou = Vl([
							"Bopo",
							"Hani",
							"Hira",
							"Kana",
							"Kits",
							"Nshu",
							"Tang",
							"Yiii",
						]);
						function su(n) {
							return !(
								n !== 746 &&
								n !== 747 &&
								(n < 4352 ||
									!(
										(hn["CJK Compatibility Forms"](n) &&
											!(n >= 65097 && n <= 65103)) ||
										hn["CJK Compatibility"](n) ||
										hn["CJK Strokes"](n) ||
										!(
											!hn["CJK Symbols and Punctuation"](n) ||
											(n >= 12296 && n <= 12305) ||
											(n >= 12308 && n <= 12319) ||
											n === 12336
										) ||
										hn["Enclosed CJK Letters and Months"](n) ||
										hn["Ideographic Description Characters"](n) ||
										hn.Kanbun(n) ||
										(hn.Katakana(n) && n !== 12540) ||
										!(
											!hn["Halfwidth and Fullwidth Forms"](n) ||
											n === 65288 ||
											n === 65289 ||
											n === 65293 ||
											(n >= 65306 && n <= 65310) ||
											n === 65339 ||
											n === 65341 ||
											n === 65343 ||
											(n >= 65371 && n <= 65503) ||
											n === 65507 ||
											(n >= 65512 && n <= 65519)
										) ||
										!(
											!hn["Small Form Variants"](n) ||
											(n >= 65112 && n <= 65118) ||
											(n >= 65123 && n <= 65126)
										) ||
										hn["Vertical Forms"](n) ||
										hn["Yijing Hexagram Symbols"](n) ||
										new RegExp("\\p{sc=Cans}", "u").test(
											String.fromCodePoint(n)
										) ||
										new RegExp("\\p{sc=Hang}", "u").test(
											String.fromCodePoint(n)
										) ||
										ou.test(String.fromCodePoint(n))
									))
							);
						}
						function gd(n) {
							return !(
								su(n) ||
								(function (t) {
									return !!(
										(hn["Latin-1 Supplement"](t) &&
											(t === 167 ||
												t === 169 ||
												t === 174 ||
												t === 177 ||
												t === 188 ||
												t === 189 ||
												t === 190 ||
												t === 215 ||
												t === 247)) ||
										(hn["General Punctuation"](t) &&
											(t === 8214 ||
												t === 8224 ||
												t === 8225 ||
												t === 8240 ||
												t === 8241 ||
												t === 8251 ||
												t === 8252 ||
												t === 8258 ||
												t === 8263 ||
												t === 8264 ||
												t === 8265 ||
												t === 8273)) ||
										hn["Letterlike Symbols"](t) ||
										hn["Number Forms"](t) ||
										(hn["Miscellaneous Technical"](t) &&
											((t >= 8960 && t <= 8967) ||
												(t >= 8972 && t <= 8991) ||
												(t >= 8996 && t <= 9e3) ||
												t === 9003 ||
												(t >= 9085 && t <= 9114) ||
												(t >= 9150 && t <= 9165) ||
												t === 9167 ||
												(t >= 9169 && t <= 9179) ||
												(t >= 9186 && t <= 9215))) ||
										(hn["Control Pictures"](t) && t !== 9251) ||
										hn["Optical Character Recognition"](t) ||
										hn["Enclosed Alphanumerics"](t) ||
										hn["Geometric Shapes"](t) ||
										(hn["Miscellaneous Symbols"](t) &&
											!(t >= 9754 && t <= 9759)) ||
										(hn["Miscellaneous Symbols and Arrows"](t) &&
											((t >= 11026 && t <= 11055) ||
												(t >= 11088 && t <= 11097) ||
												(t >= 11192 && t <= 11243))) ||
										hn["CJK Symbols and Punctuation"](t) ||
										hn.Katakana(t) ||
										hn["Private Use Area"](t) ||
										hn["CJK Compatibility Forms"](t) ||
										hn["Small Form Variants"](t) ||
										hn["Halfwidth and Fullwidth Forms"](t) ||
										t === 8734 ||
										t === 8756 ||
										t === 8757 ||
										(t >= 9984 && t <= 10087) ||
										(t >= 10102 && t <= 10131) ||
										t === 65532 ||
										t === 65533
									);
								})(n)
							);
						}
						const vd = Vl([
							"Adlm",
							"Arab",
							"Armi",
							"Avst",
							"Chrs",
							"Cprt",
							"Egyp",
							"Elym",
							"Gara",
							"Hatr",
							"Hebr",
							"Hung",
							"Khar",
							"Lydi",
							"Mand",
							"Mani",
							"Mend",
							"Merc",
							"Mero",
							"Narb",
							"Nbat",
							"Nkoo",
							"Orkh",
							"Palm",
							"Phli",
							"Phlp",
							"Phnx",
							"Prti",
							"Rohg",
							"Samr",
							"Sarb",
							"Sogo",
							"Syrc",
							"Thaa",
							"Todr",
							"Yezi",
						]);
						function lu(n) {
							return vd.test(String.fromCodePoint(n));
						}
						function yd(n, t) {
							return !(
								(!t && lu(n)) ||
								(n >= 2304 && n <= 3583) ||
								(n >= 3840 && n <= 4255) ||
								hn.Khmer(n)
							);
						}
						function xd(n) {
							for (const t of n) if (lu(t.charCodeAt(0))) return !0;
							return !1;
						}
						const Ea = new (class {
							constructor() {
								(this.TIMEOUT = 5e3),
									(this.applyArabicShaping = null),
									(this.processBidirectionalText = null),
									(this.processStyledBidirectionalText = null),
									(this.pluginStatus = "unavailable"),
									(this.pluginURL = null),
									(this.loadScriptResolve = () => {});
							}
							setState(n) {
								(this.pluginStatus = n.pluginStatus),
									(this.pluginURL = n.pluginURL);
							}
							getState() {
								return {
									pluginStatus: this.pluginStatus,
									pluginURL: this.pluginURL,
								};
							}
							setMethods(n) {
								if (Ea.isParsed())
									throw new Error("RTL text plugin already registered.");
								(this.applyArabicShaping = n.applyArabicShaping),
									(this.processBidirectionalText = n.processBidirectionalText),
									(this.processStyledBidirectionalText =
										n.processStyledBidirectionalText),
									this.loadScriptResolve();
							}
							isParsed() {
								return (
									this.applyArabicShaping != null &&
									this.processBidirectionalText != null &&
									this.processStyledBidirectionalText != null
								);
							}
							getRTLTextPluginStatus() {
								return this.pluginStatus;
							}
							syncState(n, t) {
								return s(this, void 0, void 0, function* () {
									if (this.isParsed()) return this.getState();
									if (n.pluginStatus !== "loading") return this.setState(n), n;
									const r = n.pluginURL,
										o = new Promise((f) => {
											this.loadScriptResolve = f;
										});
									t(r);
									const c = new Promise((f) =>
										setTimeout(() => f(), this.TIMEOUT)
									);
									if ((yield Promise.race([o, c]), this.isParsed())) {
										const f = { pluginStatus: "loaded", pluginURL: r };
										return this.setState(f), f;
									}
									throw (
										(this.setState({ pluginStatus: "error", pluginURL: "" }),
										new Error(
											`RTL Text Plugin failed to import scripts from ${r}`
										))
									);
								});
							}
						})();
						class Un {
							constructor(t, r) {
								(this.zoom = t),
									r
										? ((this.now = r.now || 0),
										  (this.fadeDuration = r.fadeDuration || 0),
										  (this.zoomHistory = r.zoomHistory || new Nl()),
										  (this.transition = r.transition || {}),
										  (this.globalState = r.globalState || {}))
										: ((this.now = 0),
										  (this.fadeDuration = 0),
										  (this.zoomHistory = new Nl()),
										  (this.transition = {}),
										  (this.globalState = {}));
							}
							isSupportedScript(t) {
								return (function (r, o) {
									for (const c of r) if (!yd(c.charCodeAt(0), o)) return !1;
									return !0;
								})(t, Ea.getRTLTextPluginStatus() === "loaded");
							}
							crossFadingFactor() {
								return this.fadeDuration === 0
									? 1
									: Math.min(
											(this.now - this.zoomHistory.lastIntegerZoomTime) /
												this.fadeDuration,
											1
									  );
							}
							getCrossfadeParameters() {
								const t = this.zoom,
									r = t - Math.floor(t),
									o = this.crossFadingFactor();
								return t > this.zoomHistory.lastIntegerZoom
									? { fromScale: 2, toScale: 1, t: r + (1 - r) * o }
									: { fromScale: 0.5, toScale: 1, t: 1 - (1 - o) * r };
							}
						}
						class us {
							constructor(t, r) {
								(this.property = t),
									(this.value = r),
									(this.expression = (function (o, c) {
										if (Vs(o)) return new Us(o, c);
										if (zl(o)) {
											const f = id(o, c);
											if (f.result === "error")
												throw new Error(
													f.value
														.map((_) => `${_.key}: ${_.message}`)
														.join(", ")
												);
											return f.value;
										}
										{
											let f = o;
											return (
												c.type === "color" && typeof o == "string"
													? (f = Mr.parse(o))
													: c.type !== "padding" ||
													  (typeof o != "number" && !Array.isArray(o))
													? c.type !== "numberArray" ||
													  (typeof o != "number" && !Array.isArray(o))
														? c.type !== "colorArray" ||
														  (typeof o != "string" && !Array.isArray(o))
															? c.type === "variableAnchorOffsetCollection" &&
															  Array.isArray(o)
																? (f = fi.parse(o))
																: c.type === "projectionDefinition" &&
																  typeof o == "string" &&
																  (f = jn.parse(o))
															: (f = fn.parse(o))
														: (f = vn.parse(o))
													: (f = kn.parse(o)),
												{
													globalStateRefs: new Set(),
													kind: "constant",
													evaluate: () => f,
												}
											);
										}
									})(
										r === void 0 ? t.specification.default : r,
										t.specification
									));
							}
							isDataDriven() {
								return (
									this.expression.kind === "source" ||
									this.expression.kind === "composite"
								);
							}
							getGlobalStateRefs() {
								return this.expression.globalStateRefs || new Set();
							}
							possiblyEvaluate(t, r, o) {
								return this.property.possiblyEvaluate(this, t, r, o);
							}
						}
						class cu {
							constructor(t) {
								(this.property = t), (this.value = new us(t, void 0));
							}
							transitioned(t, r) {
								return new uu(
									this.property,
									this.value,
									r,
									dt({}, t.transition, this.transition),
									t.now
								);
							}
							untransitioned() {
								return new uu(this.property, this.value, null, {}, 0);
							}
						}
						class bd {
							constructor(t) {
								(this._properties = t),
									(this._values = Object.create(
										t.defaultTransitionablePropertyValues
									));
							}
							getValue(t) {
								return wt(this._values[t].value.value);
							}
							setValue(t, r) {
								Object.prototype.hasOwnProperty.call(this._values, t) ||
									(this._values[t] = new cu(this._values[t].property)),
									(this._values[t].value = new us(
										this._values[t].property,
										r === null ? void 0 : wt(r)
									));
							}
							getTransition(t) {
								return wt(this._values[t].transition);
							}
							setTransition(t, r) {
								Object.prototype.hasOwnProperty.call(this._values, t) ||
									(this._values[t] = new cu(this._values[t].property)),
									(this._values[t].transition = wt(r) || void 0);
							}
							serialize() {
								const t = {};
								for (const r of Object.keys(this._values)) {
									const o = this.getValue(r);
									o !== void 0 && (t[r] = o);
									const c = this.getTransition(r);
									c !== void 0 && (t[`${r}-transition`] = c);
								}
								return t;
							}
							transitioned(t, r) {
								const o = new hu(this._properties);
								for (const c of Object.keys(this._values))
									o._values[c] = this._values[c].transitioned(t, r._values[c]);
								return o;
							}
							untransitioned() {
								const t = new hu(this._properties);
								for (const r of Object.keys(this._values))
									t._values[r] = this._values[r].untransitioned();
								return t;
							}
						}
						class uu {
							constructor(t, r, o, c, f) {
								(this.property = t),
									(this.value = r),
									(this.begin = f + c.delay || 0),
									(this.end = this.begin + c.duration || 0),
									t.specification.transition &&
										(c.delay || c.duration) &&
										(this.prior = o);
							}
							possiblyEvaluate(t, r, o) {
								const c = t.now || 0,
									f = this.value.possiblyEvaluate(t, r, o),
									_ = this.prior;
								if (_) {
									if (c > this.end) return (this.prior = null), f;
									if (this.value.isDataDriven()) return (this.prior = null), f;
									if (c < this.begin) return _.possiblyEvaluate(t, r, o);
									{
										const v = (c - this.begin) / (this.end - this.begin);
										return this.property.interpolate(
											_.possiblyEvaluate(t, r, o),
											f,
											it(v)
										);
									}
								}
								return f;
							}
						}
						class hu {
							constructor(t) {
								(this._properties = t),
									(this._values = Object.create(
										t.defaultTransitioningPropertyValues
									));
							}
							possiblyEvaluate(t, r, o) {
								const c = new ql(this._properties);
								for (const f of Object.keys(this._values))
									c._values[f] = this._values[f].possiblyEvaluate(t, r, o);
								return c;
							}
							hasTransition() {
								for (const t of Object.keys(this._values))
									if (this._values[t].prior) return !0;
								return !1;
							}
						}
						class wd {
							constructor(t) {
								(this._properties = t),
									(this._values = Object.create(t.defaultPropertyValues));
							}
							hasValue(t) {
								return this._values[t].value !== void 0;
							}
							getValue(t) {
								return wt(this._values[t].value);
							}
							setValue(t, r) {
								this._values[t] = new us(
									this._values[t].property,
									r === null ? void 0 : wt(r)
								);
							}
							serialize() {
								const t = {};
								for (const r of Object.keys(this._values)) {
									const o = this.getValue(r);
									o !== void 0 && (t[r] = o);
								}
								return t;
							}
							possiblyEvaluate(t, r, o) {
								const c = new ql(this._properties);
								for (const f of Object.keys(this._values))
									c._values[f] = this._values[f].possiblyEvaluate(t, r, o);
								return c;
							}
						}
						class $a {
							constructor(t, r, o) {
								(this.property = t), (this.value = r), (this.parameters = o);
							}
							isConstant() {
								return this.value.kind === "constant";
							}
							constantOr(t) {
								return this.value.kind === "constant" ? this.value.value : t;
							}
							evaluate(t, r, o, c) {
								return this.property.evaluate(
									this.value,
									this.parameters,
									t,
									r,
									o,
									c
								);
							}
						}
						class ql {
							constructor(t) {
								(this._properties = t),
									(this._values = Object.create(
										t.defaultPossiblyEvaluatedValues
									));
							}
							get(t) {
								return this._values[t];
							}
						}
						class wr {
							constructor(t) {
								this.specification = t;
							}
							possiblyEvaluate(t, r) {
								if (t.isDataDriven())
									throw new Error("Value should not be data driven");
								return t.expression.evaluate(r);
							}
							interpolate(t, r, o) {
								const c = Za[this.specification.type];
								return c ? c(t, r, o) : t;
							}
						}
						class Or {
							constructor(t, r) {
								(this.specification = t), (this.overrides = r);
							}
							possiblyEvaluate(t, r, o, c) {
								return new $a(
									this,
									t.expression.kind === "constant" ||
									t.expression.kind === "camera"
										? {
												kind: "constant",
												value: t.expression.evaluate(r, null, {}, o, c),
										  }
										: t.expression,
									r
								);
							}
							interpolate(t, r, o) {
								if (t.value.kind !== "constant" || r.value.kind !== "constant")
									return t;
								if (t.value.value === void 0 || r.value.value === void 0)
									return new $a(
										this,
										{ kind: "constant", value: void 0 },
										t.parameters
									);
								const c = Za[this.specification.type];
								if (c) {
									const f = c(t.value.value, r.value.value, o);
									return new $a(
										this,
										{ kind: "constant", value: f },
										t.parameters
									);
								}
								return t;
							}
							evaluate(t, r, o, c, f, _) {
								return t.kind === "constant"
									? t.value
									: t.evaluate(r, o, c, f, _);
							}
						}
						class Zl extends Or {
							possiblyEvaluate(t, r, o, c) {
								if (t.value === void 0)
									return new $a(this, { kind: "constant", value: void 0 }, r);
								if (t.expression.kind === "constant") {
									const f = t.expression.evaluate(r, null, {}, o, c),
										_ =
											t.property.specification.type === "resolvedImage" &&
											typeof f != "string"
												? f.name
												: f,
										v = this._calculate(_, _, _, r);
									return new $a(this, { kind: "constant", value: v }, r);
								}
								if (t.expression.kind === "camera") {
									const f = this._calculate(
										t.expression.evaluate({ zoom: r.zoom - 1 }),
										t.expression.evaluate({ zoom: r.zoom }),
										t.expression.evaluate({ zoom: r.zoom + 1 }),
										r
									);
									return new $a(this, { kind: "constant", value: f }, r);
								}
								return new $a(this, t.expression, r);
							}
							evaluate(t, r, o, c, f, _) {
								if (t.kind === "source") {
									const v = t.evaluate(r, o, c, f, _);
									return this._calculate(v, v, v, r);
								}
								return t.kind === "composite"
									? this._calculate(
											t.evaluate({ zoom: Math.floor(r.zoom) - 1 }, o, c),
											t.evaluate({ zoom: Math.floor(r.zoom) }, o, c),
											t.evaluate({ zoom: Math.floor(r.zoom) + 1 }, o, c),
											r
									  )
									: t.value;
							}
							_calculate(t, r, o, c) {
								return c.zoom > c.zoomHistory.lastIntegerZoom
									? { from: t, to: r }
									: { from: o, to: r };
							}
							interpolate(t) {
								return t;
							}
						}
						class _o {
							constructor(t) {
								this.specification = t;
							}
							possiblyEvaluate(t, r, o, c) {
								if (t.value !== void 0) {
									if (t.expression.kind === "constant") {
										const f = t.expression.evaluate(r, null, {}, o, c);
										return this._calculate(f, f, f, r);
									}
									return this._calculate(
										t.expression.evaluate(new Un(Math.floor(r.zoom - 1), r)),
										t.expression.evaluate(new Un(Math.floor(r.zoom), r)),
										t.expression.evaluate(new Un(Math.floor(r.zoom + 1), r)),
										r
									);
								}
							}
							_calculate(t, r, o, c) {
								return c.zoom > c.zoomHistory.lastIntegerZoom
									? { from: t, to: r }
									: { from: o, to: r };
							}
							interpolate(t) {
								return t;
							}
						}
						class Ul {
							constructor(t) {
								this.specification = t;
							}
							possiblyEvaluate(t, r, o, c) {
								return !!t.expression.evaluate(r, null, {}, o, c);
							}
							interpolate() {
								return !1;
							}
						}
						class Ui {
							constructor(t) {
								(this.properties = t),
									(this.defaultPropertyValues = {}),
									(this.defaultTransitionablePropertyValues = {}),
									(this.defaultTransitioningPropertyValues = {}),
									(this.defaultPossiblyEvaluatedValues = {}),
									(this.overridableProperties = []);
								for (const r in t) {
									const o = t[r];
									o.specification.overridable &&
										this.overridableProperties.push(r);
									const c = (this.defaultPropertyValues[r] = new us(o, void 0)),
										f = (this.defaultTransitionablePropertyValues[r] = new cu(
											o
										));
									(this.defaultTransitioningPropertyValues[r] =
										f.untransitioned()),
										(this.defaultPossiblyEvaluatedValues[r] =
											c.possiblyEvaluate({}));
								}
							}
						}
						ir("DataDrivenProperty", Or),
							ir("DataConstantProperty", wr),
							ir("CrossFadedDataDrivenProperty", Zl),
							ir("CrossFadedProperty", _o),
							ir("ColorRampProperty", Ul);
						const Td = "-transition";
						class xa extends kt {
							constructor(t, r) {
								if (
									(super(),
									(this.id = t.id),
									(this.type = t.type),
									(this._featureFilter = {
										filter: () => !0,
										needGeometry: !1,
										getGlobalStateRefs: () => new Set(),
									}),
									t.type !== "custom" &&
										((this.metadata = t.metadata),
										(this.minzoom = t.minzoom),
										(this.maxzoom = t.maxzoom),
										t.type !== "background" &&
											((this.source = t.source),
											(this.sourceLayer = t["source-layer"]),
											(this.filter = t.filter),
											(this._featureFilter = Ro(t.filter))),
										r.layout && (this._unevaluatedLayout = new wd(r.layout)),
										r.paint))
								) {
									this._transitionablePaint = new bd(r.paint);
									for (const o in t.paint)
										this.setPaintProperty(o, t.paint[o], { validate: !1 });
									for (const o in t.layout)
										this.setLayoutProperty(o, t.layout[o], { validate: !1 });
									(this._transitioningPaint =
										this._transitionablePaint.untransitioned()),
										(this.paint = new ql(r.paint));
								}
							}
							setFilter(t) {
								(this.filter = t), (this._featureFilter = Ro(t));
							}
							getCrossfadeParameters() {
								return this._crossfadeParameters;
							}
							getLayoutProperty(t) {
								return t === "visibility"
									? this.visibility
									: this._unevaluatedLayout.getValue(t);
							}
							getLayoutAffectingGlobalStateRefs() {
								const t = new Set();
								if (this._unevaluatedLayout)
									for (const r in this._unevaluatedLayout._values) {
										const o = this._unevaluatedLayout._values[r];
										for (const c of o.getGlobalStateRefs()) t.add(c);
									}
								for (const r of this._featureFilter.getGlobalStateRefs())
									t.add(r);
								return t;
							}
							setLayoutProperty(t, r, o = {}) {
								(r != null &&
									this._validate(
										qp,
										`layers.${this.id}.layout.${t}`,
										t,
										r,
										o
									)) ||
									(t !== "visibility"
										? this._unevaluatedLayout.setValue(t, r)
										: (this.visibility = r));
							}
							getPaintProperty(t) {
								return t.endsWith(Td)
									? this._transitionablePaint.getTransition(t.slice(0, -11))
									: this._transitionablePaint.getValue(t);
							}
							setPaintProperty(t, r, o = {}) {
								if (
									r != null &&
									this._validate(Vp, `layers.${this.id}.paint.${t}`, t, r, o)
								)
									return !1;
								if (t.endsWith(Td))
									return (
										this._transitionablePaint.setTransition(
											t.slice(0, -11),
											r || void 0
										),
										!1
									);
								{
									const c = this._transitionablePaint._values[t],
										f =
											c.property.specification["property-type"] ===
											"cross-faded-data-driven",
										_ = c.value.isDataDriven(),
										v = c.value;
									this._transitionablePaint.setValue(t, r),
										this._handleSpecialPaintPropertyUpdate(t);
									const b = this._transitionablePaint._values[t].value;
									return (
										b.isDataDriven() ||
										_ ||
										f ||
										this._handleOverridablePaintPropertyUpdate(t, v, b)
									);
								}
							}
							_handleSpecialPaintPropertyUpdate(t) {}
							_handleOverridablePaintPropertyUpdate(t, r, o) {
								return !1;
							}
							isHidden(t) {
								return (
									!!(this.minzoom && t < this.minzoom) ||
									!!(this.maxzoom && t >= this.maxzoom) ||
									this.visibility === "none"
								);
							}
							updateTransitions(t) {
								this._transitioningPaint =
									this._transitionablePaint.transitioned(
										t,
										this._transitioningPaint
									);
							}
							hasTransition() {
								return this._transitioningPaint.hasTransition();
							}
							recalculate(t, r) {
								t.getCrossfadeParameters &&
									(this._crossfadeParameters = t.getCrossfadeParameters()),
									this._unevaluatedLayout &&
										(this.layout = this._unevaluatedLayout.possiblyEvaluate(
											t,
											void 0,
											r
										)),
									(this.paint = this._transitioningPaint.possiblyEvaluate(
										t,
										void 0,
										r
									));
							}
							serialize() {
								const t = {
									id: this.id,
									type: this.type,
									source: this.source,
									"source-layer": this.sourceLayer,
									metadata: this.metadata,
									minzoom: this.minzoom,
									maxzoom: this.maxzoom,
									filter: this.filter,
									layout:
										this._unevaluatedLayout &&
										this._unevaluatedLayout.serialize(),
									paint:
										this._transitionablePaint &&
										this._transitionablePaint.serialize(),
								};
								return (
									this.visibility &&
										((t.layout = t.layout || {}),
										(t.layout.visibility = this.visibility)),
									St(
										t,
										(r, o) =>
											!(
												r === void 0 ||
												(o === "layout" && !Object.keys(r).length) ||
												(o === "paint" && !Object.keys(r).length)
											)
									)
								);
							}
							_validate(t, r, o, c, f = {}) {
								return (
									(!f || f.validate !== !1) &&
									Xs(
										this,
										t.call(ls, {
											key: r,
											layerType: this.type,
											objectKey: o,
											value: c,
											styleSpec: ye,
											style: { glyphs: !0, sprite: !0 },
										})
									)
								);
							}
							is3D() {
								return !1;
							}
							isTileClipped() {
								return !1;
							}
							hasOffscreenPass() {
								return !1;
							}
							resize() {}
							isStateDependent() {
								for (const t in this.paint._values) {
									const r = this.paint.get(t);
									if (
										r instanceof $a &&
										fo(r.property.specification) &&
										(r.value.kind === "source" ||
											r.value.kind === "composite") &&
										r.value.isStateDependent
									)
										return !0;
								}
								return !1;
							}
						}
						const $p = {
							Int8: Int8Array,
							Uint8: Uint8Array,
							Int16: Int16Array,
							Uint16: Uint16Array,
							Int32: Int32Array,
							Uint32: Uint32Array,
							Float32: Float32Array,
						};
						class Ks {
							constructor(t, r) {
								(this._structArray = t),
									(this._pos1 = r * this.size),
									(this._pos2 = this._pos1 / 2),
									(this._pos4 = this._pos1 / 4),
									(this._pos8 = this._pos1 / 8);
							}
						}
						class Dn {
							constructor() {
								(this.isTransferred = !1), (this.capacity = -1), this.resize(0);
							}
							static serialize(t, r) {
								return (
									t._trim(),
									r && ((t.isTransferred = !0), r.push(t.arrayBuffer)),
									{ length: t.length, arrayBuffer: t.arrayBuffer }
								);
							}
							static deserialize(t) {
								const r = Object.create(this.prototype);
								return (
									(r.arrayBuffer = t.arrayBuffer),
									(r.length = t.length),
									(r.capacity = t.arrayBuffer.byteLength / r.bytesPerElement),
									r._refreshViews(),
									r
								);
							}
							_trim() {
								this.length !== this.capacity &&
									((this.capacity = this.length),
									(this.arrayBuffer = this.arrayBuffer.slice(
										0,
										this.length * this.bytesPerElement
									)),
									this._refreshViews());
							}
							clear() {
								this.length = 0;
							}
							resize(t) {
								this.reserve(t), (this.length = t);
							}
							reserve(t) {
								if (t > this.capacity) {
									(this.capacity = Math.max(
										t,
										Math.floor(5 * this.capacity),
										128
									)),
										(this.arrayBuffer = new ArrayBuffer(
											this.capacity * this.bytesPerElement
										));
									const r = this.uint8;
									this._refreshViews(), r && this.uint8.set(r);
								}
							}
							_refreshViews() {
								throw new Error(
									"_refreshViews() must be implemented by each concrete StructArray layout"
								);
							}
						}
						function ti(n, t = 1) {
							let r = 0,
								o = 0;
							return {
								members: n.map((c) => {
									const f = $p[c.type].BYTES_PER_ELEMENT,
										_ = (r = $l(r, Math.max(t, f))),
										v = c.components || 1;
									return (
										(o = Math.max(o, f)),
										(r += f * v),
										{ name: c.name, type: c.type, components: v, offset: _ }
									);
								}),
								size: $l(r, Math.max(o, t)),
								alignment: t,
							};
						}
						function $l(n, t) {
							return Math.ceil(n / t) * t;
						}
						class hs extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r) {
								const o = this.length;
								return this.resize(o + 1), this.emplace(o, t, r);
							}
							emplace(t, r, o) {
								const c = 2 * t;
								return (this.int16[c + 0] = r), (this.int16[c + 1] = o), t;
							}
						}
						(hs.prototype.bytesPerElement = 4), ir("StructArrayLayout2i4", hs);
						class ds extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o) {
								const c = this.length;
								return this.resize(c + 1), this.emplace(c, t, r, o);
							}
							emplace(t, r, o, c) {
								const f = 3 * t;
								return (
									(this.int16[f + 0] = r),
									(this.int16[f + 1] = o),
									(this.int16[f + 2] = c),
									t
								);
							}
						}
						(ds.prototype.bytesPerElement = 6), ir("StructArrayLayout3i6", ds);
						class du extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c) {
								const f = this.length;
								return this.resize(f + 1), this.emplace(f, t, r, o, c);
							}
							emplace(t, r, o, c, f) {
								const _ = 4 * t;
								return (
									(this.int16[_ + 0] = r),
									(this.int16[_ + 1] = o),
									(this.int16[_ + 2] = c),
									(this.int16[_ + 3] = f),
									t
								);
							}
						}
						(du.prototype.bytesPerElement = 8), ir("StructArrayLayout4i8", du);
						class ps extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _) {
								const v = this.length;
								return this.resize(v + 1), this.emplace(v, t, r, o, c, f, _);
							}
							emplace(t, r, o, c, f, _, v) {
								const b = 6 * t;
								return (
									(this.int16[b + 0] = r),
									(this.int16[b + 1] = o),
									(this.int16[b + 2] = c),
									(this.int16[b + 3] = f),
									(this.int16[b + 4] = _),
									(this.int16[b + 5] = v),
									t
								);
							}
						}
						(ps.prototype.bytesPerElement = 12),
							ir("StructArrayLayout2i4i12", ps);
						class No extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _) {
								const v = this.length;
								return this.resize(v + 1), this.emplace(v, t, r, o, c, f, _);
							}
							emplace(t, r, o, c, f, _, v) {
								const b = 4 * t,
									S = 8 * t;
								return (
									(this.int16[b + 0] = r),
									(this.int16[b + 1] = o),
									(this.uint8[S + 4] = c),
									(this.uint8[S + 5] = f),
									(this.uint8[S + 6] = _),
									(this.uint8[S + 7] = v),
									t
								);
							}
						}
						(No.prototype.bytesPerElement = 8),
							ir("StructArrayLayout2i4ub8", No);
						class Js extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t, r) {
								const o = this.length;
								return this.resize(o + 1), this.emplace(o, t, r);
							}
							emplace(t, r, o) {
								const c = 2 * t;
								return (this.float32[c + 0] = r), (this.float32[c + 1] = o), t;
							}
						}
						(Js.prototype.bytesPerElement = 8), ir("StructArrayLayout2f8", Js);
						class Gl extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _, v, b, S, I) {
								const L = this.length;
								return (
									this.resize(L + 1),
									this.emplace(L, t, r, o, c, f, _, v, b, S, I)
								);
							}
							emplace(t, r, o, c, f, _, v, b, S, I, L) {
								const F = 10 * t;
								return (
									(this.uint16[F + 0] = r),
									(this.uint16[F + 1] = o),
									(this.uint16[F + 2] = c),
									(this.uint16[F + 3] = f),
									(this.uint16[F + 4] = _),
									(this.uint16[F + 5] = v),
									(this.uint16[F + 6] = b),
									(this.uint16[F + 7] = S),
									(this.uint16[F + 8] = I),
									(this.uint16[F + 9] = L),
									t
								);
							}
						}
						(Gl.prototype.bytesPerElement = 20),
							ir("StructArrayLayout10ui20", Gl);
						class jo extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _, v, b, S, I, L, F) {
								const q = this.length;
								return (
									this.resize(q + 1),
									this.emplace(q, t, r, o, c, f, _, v, b, S, I, L, F)
								);
							}
							emplace(t, r, o, c, f, _, v, b, S, I, L, F, q) {
								const Z = 12 * t;
								return (
									(this.int16[Z + 0] = r),
									(this.int16[Z + 1] = o),
									(this.int16[Z + 2] = c),
									(this.int16[Z + 3] = f),
									(this.uint16[Z + 4] = _),
									(this.uint16[Z + 5] = v),
									(this.uint16[Z + 6] = b),
									(this.uint16[Z + 7] = S),
									(this.int16[Z + 8] = I),
									(this.int16[Z + 9] = L),
									(this.int16[Z + 10] = F),
									(this.int16[Z + 11] = q),
									t
								);
							}
						}
						(jo.prototype.bytesPerElement = 24),
							ir("StructArrayLayout4i4ui4i24", jo);
						class pu extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o) {
								const c = this.length;
								return this.resize(c + 1), this.emplace(c, t, r, o);
							}
							emplace(t, r, o, c) {
								const f = 3 * t;
								return (
									(this.float32[f + 0] = r),
									(this.float32[f + 1] = o),
									(this.float32[f + 2] = c),
									t
								);
							}
						}
						(pu.prototype.bytesPerElement = 12),
							ir("StructArrayLayout3f12", pu);
						class fu extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint32 = new Uint32Array(this.arrayBuffer));
							}
							emplaceBack(t) {
								const r = this.length;
								return this.resize(r + 1), this.emplace(r, t);
							}
							emplace(t, r) {
								return (this.uint32[1 * t + 0] = r), t;
							}
						}
						(fu.prototype.bytesPerElement = 4), ir("StructArrayLayout1ul4", fu);
						class Hl extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer)),
									(this.uint32 = new Uint32Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _, v, b, S) {
								const I = this.length;
								return (
									this.resize(I + 1), this.emplace(I, t, r, o, c, f, _, v, b, S)
								);
							}
							emplace(t, r, o, c, f, _, v, b, S, I) {
								const L = 10 * t,
									F = 5 * t;
								return (
									(this.int16[L + 0] = r),
									(this.int16[L + 1] = o),
									(this.int16[L + 2] = c),
									(this.int16[L + 3] = f),
									(this.int16[L + 4] = _),
									(this.int16[L + 5] = v),
									(this.uint32[F + 3] = b),
									(this.uint16[L + 8] = S),
									(this.uint16[L + 9] = I),
									t
								);
							}
						}
						(Hl.prototype.bytesPerElement = 20),
							ir("StructArrayLayout6i1ul2ui20", Hl);
						class mu extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _) {
								const v = this.length;
								return this.resize(v + 1), this.emplace(v, t, r, o, c, f, _);
							}
							emplace(t, r, o, c, f, _, v) {
								const b = 6 * t;
								return (
									(this.int16[b + 0] = r),
									(this.int16[b + 1] = o),
									(this.int16[b + 2] = c),
									(this.int16[b + 3] = f),
									(this.int16[b + 4] = _),
									(this.int16[b + 5] = v),
									t
								);
							}
						}
						(mu.prototype.bytesPerElement = 12),
							ir("StructArrayLayout2i2i2i12", mu);
						class h extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f) {
								const _ = this.length;
								return this.resize(_ + 1), this.emplace(_, t, r, o, c, f);
							}
							emplace(t, r, o, c, f, _) {
								const v = 4 * t,
									b = 8 * t;
								return (
									(this.float32[v + 0] = r),
									(this.float32[v + 1] = o),
									(this.float32[v + 2] = c),
									(this.int16[b + 6] = f),
									(this.int16[b + 7] = _),
									t
								);
							}
						}
						(h.prototype.bytesPerElement = 16),
							ir("StructArrayLayout2f1f2i16", h);
						class e extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _) {
								const v = this.length;
								return this.resize(v + 1), this.emplace(v, t, r, o, c, f, _);
							}
							emplace(t, r, o, c, f, _, v) {
								const b = 16 * t,
									S = 4 * t,
									I = 8 * t;
								return (
									(this.uint8[b + 0] = r),
									(this.uint8[b + 1] = o),
									(this.float32[S + 1] = c),
									(this.float32[S + 2] = f),
									(this.int16[I + 6] = _),
									(this.int16[I + 7] = v),
									t
								);
							}
						}
						(e.prototype.bytesPerElement = 16),
							ir("StructArrayLayout2ub2f2i16", e);
						class i extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o) {
								const c = this.length;
								return this.resize(c + 1), this.emplace(c, t, r, o);
							}
							emplace(t, r, o, c) {
								const f = 3 * t;
								return (
									(this.uint16[f + 0] = r),
									(this.uint16[f + 1] = o),
									(this.uint16[f + 2] = c),
									t
								);
							}
						}
						(i.prototype.bytesPerElement = 6), ir("StructArrayLayout3ui6", i);
						class l extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer)),
									(this.uint32 = new Uint32Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c, f, _, v, b, S, I, L, F, q, Z, W, J, le) {
								const Re = this.length;
								return (
									this.resize(Re + 1),
									this.emplace(
										Re,
										t,
										r,
										o,
										c,
										f,
										_,
										v,
										b,
										S,
										I,
										L,
										F,
										q,
										Z,
										W,
										J,
										le
									)
								);
							}
							emplace(t, r, o, c, f, _, v, b, S, I, L, F, q, Z, W, J, le, Re) {
								const xe = 24 * t,
									Ce = 12 * t,
									Ye = 48 * t;
								return (
									(this.int16[xe + 0] = r),
									(this.int16[xe + 1] = o),
									(this.uint16[xe + 2] = c),
									(this.uint16[xe + 3] = f),
									(this.uint32[Ce + 2] = _),
									(this.uint32[Ce + 3] = v),
									(this.uint32[Ce + 4] = b),
									(this.uint16[xe + 10] = S),
									(this.uint16[xe + 11] = I),
									(this.uint16[xe + 12] = L),
									(this.float32[Ce + 7] = F),
									(this.float32[Ce + 8] = q),
									(this.uint8[Ye + 36] = Z),
									(this.uint8[Ye + 37] = W),
									(this.uint8[Ye + 38] = J),
									(this.uint32[Ce + 10] = le),
									(this.int16[xe + 22] = Re),
									t
								);
							}
						}
						(l.prototype.bytesPerElement = 48),
							ir("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", l);
						class u extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.int16 = new Int16Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer)),
									(this.uint32 = new Uint32Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(
								t,
								r,
								o,
								c,
								f,
								_,
								v,
								b,
								S,
								I,
								L,
								F,
								q,
								Z,
								W,
								J,
								le,
								Re,
								xe,
								Ce,
								Ye,
								lt,
								Pt,
								Yt,
								qt,
								Ht,
								Sr,
								Gt
							) {
								const Wt = this.length;
								return (
									this.resize(Wt + 1),
									this.emplace(
										Wt,
										t,
										r,
										o,
										c,
										f,
										_,
										v,
										b,
										S,
										I,
										L,
										F,
										q,
										Z,
										W,
										J,
										le,
										Re,
										xe,
										Ce,
										Ye,
										lt,
										Pt,
										Yt,
										qt,
										Ht,
										Sr,
										Gt
									)
								);
							}
							emplace(
								t,
								r,
								o,
								c,
								f,
								_,
								v,
								b,
								S,
								I,
								L,
								F,
								q,
								Z,
								W,
								J,
								le,
								Re,
								xe,
								Ce,
								Ye,
								lt,
								Pt,
								Yt,
								qt,
								Ht,
								Sr,
								Gt,
								Wt
							) {
								const gt = 32 * t,
									Nr = 16 * t;
								return (
									(this.int16[gt + 0] = r),
									(this.int16[gt + 1] = o),
									(this.int16[gt + 2] = c),
									(this.int16[gt + 3] = f),
									(this.int16[gt + 4] = _),
									(this.int16[gt + 5] = v),
									(this.int16[gt + 6] = b),
									(this.int16[gt + 7] = S),
									(this.uint16[gt + 8] = I),
									(this.uint16[gt + 9] = L),
									(this.uint16[gt + 10] = F),
									(this.uint16[gt + 11] = q),
									(this.uint16[gt + 12] = Z),
									(this.uint16[gt + 13] = W),
									(this.uint16[gt + 14] = J),
									(this.uint16[gt + 15] = le),
									(this.uint16[gt + 16] = Re),
									(this.uint16[gt + 17] = xe),
									(this.uint16[gt + 18] = Ce),
									(this.uint16[gt + 19] = Ye),
									(this.uint16[gt + 20] = lt),
									(this.uint16[gt + 21] = Pt),
									(this.uint16[gt + 22] = Yt),
									(this.uint32[Nr + 12] = qt),
									(this.float32[Nr + 13] = Ht),
									(this.float32[Nr + 14] = Sr),
									(this.uint16[gt + 30] = Gt),
									(this.uint16[gt + 31] = Wt),
									t
								);
							}
						}
						(u.prototype.bytesPerElement = 64),
							ir("StructArrayLayout8i15ui1ul2f2ui64", u);
						class d extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t) {
								const r = this.length;
								return this.resize(r + 1), this.emplace(r, t);
							}
							emplace(t, r) {
								return (this.float32[1 * t + 0] = r), t;
							}
						}
						(d.prototype.bytesPerElement = 4), ir("StructArrayLayout1f4", d);
						class g extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o) {
								const c = this.length;
								return this.resize(c + 1), this.emplace(c, t, r, o);
							}
							emplace(t, r, o, c) {
								const f = 3 * t;
								return (
									(this.uint16[6 * t + 0] = r),
									(this.float32[f + 1] = o),
									(this.float32[f + 2] = c),
									t
								);
							}
						}
						(g.prototype.bytesPerElement = 12),
							ir("StructArrayLayout1ui2f12", g);
						class w extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint32 = new Uint32Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o) {
								const c = this.length;
								return this.resize(c + 1), this.emplace(c, t, r, o);
							}
							emplace(t, r, o, c) {
								const f = 4 * t;
								return (
									(this.uint32[2 * t + 0] = r),
									(this.uint16[f + 2] = o),
									(this.uint16[f + 3] = c),
									t
								);
							}
						}
						(w.prototype.bytesPerElement = 8),
							ir("StructArrayLayout1ul2ui8", w);
						class C extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t, r) {
								const o = this.length;
								return this.resize(o + 1), this.emplace(o, t, r);
							}
							emplace(t, r, o) {
								const c = 2 * t;
								return (this.uint16[c + 0] = r), (this.uint16[c + 1] = o), t;
							}
						}
						(C.prototype.bytesPerElement = 4), ir("StructArrayLayout2ui4", C);
						class P extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.uint16 = new Uint16Array(this.arrayBuffer));
							}
							emplaceBack(t) {
								const r = this.length;
								return this.resize(r + 1), this.emplace(r, t);
							}
							emplace(t, r) {
								return (this.uint16[1 * t + 0] = r), t;
							}
						}
						(P.prototype.bytesPerElement = 2), ir("StructArrayLayout1ui2", P);
						class E extends Dn {
							_refreshViews() {
								(this.uint8 = new Uint8Array(this.arrayBuffer)),
									(this.float32 = new Float32Array(this.arrayBuffer));
							}
							emplaceBack(t, r, o, c) {
								const f = this.length;
								return this.resize(f + 1), this.emplace(f, t, r, o, c);
							}
							emplace(t, r, o, c, f) {
								const _ = 4 * t;
								return (
									(this.float32[_ + 0] = r),
									(this.float32[_ + 1] = o),
									(this.float32[_ + 2] = c),
									(this.float32[_ + 3] = f),
									t
								);
							}
						}
						(E.prototype.bytesPerElement = 16), ir("StructArrayLayout4f16", E);
						class R extends Ks {
							get anchorPointX() {
								return this._structArray.int16[this._pos2 + 0];
							}
							get anchorPointY() {
								return this._structArray.int16[this._pos2 + 1];
							}
							get x1() {
								return this._structArray.int16[this._pos2 + 2];
							}
							get y1() {
								return this._structArray.int16[this._pos2 + 3];
							}
							get x2() {
								return this._structArray.int16[this._pos2 + 4];
							}
							get y2() {
								return this._structArray.int16[this._pos2 + 5];
							}
							get featureIndex() {
								return this._structArray.uint32[this._pos4 + 3];
							}
							get sourceLayerIndex() {
								return this._structArray.uint16[this._pos2 + 8];
							}
							get bucketIndex() {
								return this._structArray.uint16[this._pos2 + 9];
							}
							get anchorPoint() {
								return new B(this.anchorPointX, this.anchorPointY);
							}
						}
						R.prototype.size = 20;
						class D extends Hl {
							get(t) {
								return new R(this, t);
							}
						}
						ir("CollisionBoxArray", D);
						class N extends Ks {
							get anchorX() {
								return this._structArray.int16[this._pos2 + 0];
							}
							get anchorY() {
								return this._structArray.int16[this._pos2 + 1];
							}
							get glyphStartIndex() {
								return this._structArray.uint16[this._pos2 + 2];
							}
							get numGlyphs() {
								return this._structArray.uint16[this._pos2 + 3];
							}
							get vertexStartIndex() {
								return this._structArray.uint32[this._pos4 + 2];
							}
							get lineStartIndex() {
								return this._structArray.uint32[this._pos4 + 3];
							}
							get lineLength() {
								return this._structArray.uint32[this._pos4 + 4];
							}
							get segment() {
								return this._structArray.uint16[this._pos2 + 10];
							}
							get lowerSize() {
								return this._structArray.uint16[this._pos2 + 11];
							}
							get upperSize() {
								return this._structArray.uint16[this._pos2 + 12];
							}
							get lineOffsetX() {
								return this._structArray.float32[this._pos4 + 7];
							}
							get lineOffsetY() {
								return this._structArray.float32[this._pos4 + 8];
							}
							get writingMode() {
								return this._structArray.uint8[this._pos1 + 36];
							}
							get placedOrientation() {
								return this._structArray.uint8[this._pos1 + 37];
							}
							set placedOrientation(t) {
								this._structArray.uint8[this._pos1 + 37] = t;
							}
							get hidden() {
								return this._structArray.uint8[this._pos1 + 38];
							}
							set hidden(t) {
								this._structArray.uint8[this._pos1 + 38] = t;
							}
							get crossTileID() {
								return this._structArray.uint32[this._pos4 + 10];
							}
							set crossTileID(t) {
								this._structArray.uint32[this._pos4 + 10] = t;
							}
							get associatedIconIndex() {
								return this._structArray.int16[this._pos2 + 22];
							}
						}
						N.prototype.size = 48;
						class G extends l {
							get(t) {
								return new N(this, t);
							}
						}
						ir("PlacedSymbolArray", G);
						class te extends Ks {
							get anchorX() {
								return this._structArray.int16[this._pos2 + 0];
							}
							get anchorY() {
								return this._structArray.int16[this._pos2 + 1];
							}
							get rightJustifiedTextSymbolIndex() {
								return this._structArray.int16[this._pos2 + 2];
							}
							get centerJustifiedTextSymbolIndex() {
								return this._structArray.int16[this._pos2 + 3];
							}
							get leftJustifiedTextSymbolIndex() {
								return this._structArray.int16[this._pos2 + 4];
							}
							get verticalPlacedTextSymbolIndex() {
								return this._structArray.int16[this._pos2 + 5];
							}
							get placedIconSymbolIndex() {
								return this._structArray.int16[this._pos2 + 6];
							}
							get verticalPlacedIconSymbolIndex() {
								return this._structArray.int16[this._pos2 + 7];
							}
							get key() {
								return this._structArray.uint16[this._pos2 + 8];
							}
							get textBoxStartIndex() {
								return this._structArray.uint16[this._pos2 + 9];
							}
							get textBoxEndIndex() {
								return this._structArray.uint16[this._pos2 + 10];
							}
							get verticalTextBoxStartIndex() {
								return this._structArray.uint16[this._pos2 + 11];
							}
							get verticalTextBoxEndIndex() {
								return this._structArray.uint16[this._pos2 + 12];
							}
							get iconBoxStartIndex() {
								return this._structArray.uint16[this._pos2 + 13];
							}
							get iconBoxEndIndex() {
								return this._structArray.uint16[this._pos2 + 14];
							}
							get verticalIconBoxStartIndex() {
								return this._structArray.uint16[this._pos2 + 15];
							}
							get verticalIconBoxEndIndex() {
								return this._structArray.uint16[this._pos2 + 16];
							}
							get featureIndex() {
								return this._structArray.uint16[this._pos2 + 17];
							}
							get numHorizontalGlyphVertices() {
								return this._structArray.uint16[this._pos2 + 18];
							}
							get numVerticalGlyphVertices() {
								return this._structArray.uint16[this._pos2 + 19];
							}
							get numIconVertices() {
								return this._structArray.uint16[this._pos2 + 20];
							}
							get numVerticalIconVertices() {
								return this._structArray.uint16[this._pos2 + 21];
							}
							get useRuntimeCollisionCircles() {
								return this._structArray.uint16[this._pos2 + 22];
							}
							get crossTileID() {
								return this._structArray.uint32[this._pos4 + 12];
							}
							set crossTileID(t) {
								this._structArray.uint32[this._pos4 + 12] = t;
							}
							get textBoxScale() {
								return this._structArray.float32[this._pos4 + 13];
							}
							get collisionCircleDiameter() {
								return this._structArray.float32[this._pos4 + 14];
							}
							get textAnchorOffsetStartIndex() {
								return this._structArray.uint16[this._pos2 + 30];
							}
							get textAnchorOffsetEndIndex() {
								return this._structArray.uint16[this._pos2 + 31];
							}
						}
						te.prototype.size = 64;
						class Q extends u {
							get(t) {
								return new te(this, t);
							}
						}
						ir("SymbolInstanceArray", Q);
						class ae extends d {
							getoffsetX(t) {
								return this.float32[1 * t + 0];
							}
						}
						ir("GlyphOffsetArray", ae);
						class ce extends ds {
							getx(t) {
								return this.int16[3 * t + 0];
							}
							gety(t) {
								return this.int16[3 * t + 1];
							}
							gettileUnitDistanceFromAnchor(t) {
								return this.int16[3 * t + 2];
							}
						}
						ir("SymbolLineVertexArray", ce);
						class ve extends Ks {
							get textAnchor() {
								return this._structArray.uint16[this._pos2 + 0];
							}
							get textOffset0() {
								return this._structArray.float32[this._pos4 + 1];
							}
							get textOffset1() {
								return this._structArray.float32[this._pos4 + 2];
							}
						}
						ve.prototype.size = 12;
						class me extends g {
							get(t) {
								return new ve(this, t);
							}
						}
						ir("TextAnchorOffsetArray", me);
						class be extends Ks {
							get featureIndex() {
								return this._structArray.uint32[this._pos4 + 0];
							}
							get sourceLayerIndex() {
								return this._structArray.uint16[this._pos2 + 2];
							}
							get bucketIndex() {
								return this._structArray.uint16[this._pos2 + 3];
							}
						}
						be.prototype.size = 8;
						class Pe extends w {
							get(t) {
								return new be(this, t);
							}
						}
						ir("FeatureIndexArray", Pe);
						class _e extends hs {}
						class Be extends hs {}
						class rt extends hs {}
						class Ge extends ps {}
						class Xe extends No {}
						class tt extends Js {}
						class jt extends Gl {}
						class Zt extends jo {}
						class Tt extends pu {}
						class vr extends fu {}
						class Jr extends mu {}
						class An extends e {}
						class Rn extends i {}
						class Ln extends C {}
						const Wn = ti([{ name: "a_pos", components: 2, type: "Int16" }], 4),
							{ members: Jn } = Wn;
						class Kr {
							constructor(t = []) {
								(this._forceNewSegmentOnNextPrepare = !1), (this.segments = t);
							}
							prepareSegment(t, r, o, c) {
								const f = this.segments[this.segments.length - 1];
								return (
									t > Kr.MAX_VERTEX_ARRAY_LENGTH &&
										Lt(
											`Max vertices per segment is ${Kr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Kr.MAX_VERTEX_ARRAY_LENGTH} vertices.`
										),
									this._forceNewSegmentOnNextPrepare ||
									!f ||
									f.vertexLength + t > Kr.MAX_VERTEX_ARRAY_LENGTH ||
									f.sortKey !== c
										? this.createNewSegment(r, o, c)
										: f
								);
							}
							createNewSegment(t, r, o) {
								const c = {
									vertexOffset: t.length,
									primitiveOffset: r.length,
									vertexLength: 0,
									primitiveLength: 0,
									vaos: {},
								};
								return (
									o !== void 0 && (c.sortKey = o),
									(this._forceNewSegmentOnNextPrepare = !1),
									this.segments.push(c),
									c
								);
							}
							getOrCreateLatestSegment(t, r, o) {
								return this.prepareSegment(0, t, r, o);
							}
							forceNewSegmentOnNextPrepare() {
								this._forceNewSegmentOnNextPrepare = !0;
							}
							get() {
								return this.segments;
							}
							destroy() {
								for (const t of this.segments)
									for (const r in t.vaos) t.vaos[r].destroy();
							}
							static simpleSegment(t, r, o, c) {
								return new Kr([
									{
										vertexOffset: t,
										primitiveOffset: r,
										vertexLength: o,
										primitiveLength: c,
										vaos: {},
										sortKey: 0,
									},
								]);
							}
						}
						function Bn(n, t) {
							return (
								256 * (n = Dt(Math.floor(n), 0, 255)) +
								Dt(Math.floor(t), 0, 255)
							);
						}
						(Kr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
							ir("SegmentVector", Kr);
						const si = ti([
							{ name: "a_pattern_from", components: 4, type: "Uint16" },
							{ name: "a_pattern_to", components: 4, type: "Uint16" },
							{ name: "a_pixel_ratio_from", components: 1, type: "Uint16" },
							{ name: "a_pixel_ratio_to", components: 1, type: "Uint16" },
						]);
						var mi,
							Ci,
							$i,
							za = { exports: {} },
							go = { exports: {} },
							vo = { exports: {} },
							fs = (function () {
								if ($i) return za.exports;
								$i = 1;
								var n =
										(mi ||
											((mi = 1),
											(go.exports = function (r, o) {
												var c, f, _, v, b, S, I, L;
												for (
													f = r.length - (c = 3 & r.length),
														_ = o,
														b = 3432918353,
														S = 461845907,
														L = 0;
													L < f;

												)
													(I =
														(255 & r.charCodeAt(L)) |
														((255 & r.charCodeAt(++L)) << 8) |
														((255 & r.charCodeAt(++L)) << 16) |
														((255 & r.charCodeAt(++L)) << 24)),
														++L,
														(_ =
															27492 +
															(65535 &
																(v =
																	(5 *
																		(65535 &
																			(_ =
																				((_ ^= I =
																					((65535 &
																						(I =
																							((I =
																								((65535 & I) * b +
																									((((I >>> 16) * b) & 65535) <<
																										16)) &
																								4294967295) <<
																								15) |
																							(I >>> 17))) *
																						S +
																						((((I >>> 16) * S) & 65535) <<
																							16)) &
																					4294967295) <<
																					13) |
																				(_ >>> 19))) +
																		(((5 * (_ >>> 16)) & 65535) << 16)) &
																	4294967295)) +
															(((58964 + (v >>> 16)) & 65535) << 16));
												switch (((I = 0), c)) {
													case 3:
														I ^= (255 & r.charCodeAt(L + 2)) << 16;
													case 2:
														I ^= (255 & r.charCodeAt(L + 1)) << 8;
													case 1:
														_ ^= I =
															((65535 &
																(I =
																	((I =
																		((65535 & (I ^= 255 & r.charCodeAt(L))) *
																			b +
																			((((I >>> 16) * b) & 65535) << 16)) &
																		4294967295) <<
																		15) |
																	(I >>> 17))) *
																S +
																((((I >>> 16) * S) & 65535) << 16)) &
															4294967295;
												}
												return (
													(_ ^= r.length),
													(_ =
														(2246822507 * (65535 & (_ ^= _ >>> 16)) +
															(((2246822507 * (_ >>> 16)) & 65535) << 16)) &
														4294967295),
													(_ =
														(3266489909 * (65535 & (_ ^= _ >>> 13)) +
															(((3266489909 * (_ >>> 16)) & 65535) << 16)) &
														4294967295),
													(_ ^= _ >>> 16) >>> 0
												);
											})),
										go.exports),
									t =
										(Ci ||
											((Ci = 1),
											(vo.exports = function (r, o) {
												for (var c, f = r.length, _ = o ^ f, v = 0; f >= 4; )
													(c =
														1540483477 *
															(65535 &
																(c =
																	(255 & r.charCodeAt(v)) |
																	((255 & r.charCodeAt(++v)) << 8) |
																	((255 & r.charCodeAt(++v)) << 16) |
																	((255 & r.charCodeAt(++v)) << 24))) +
														(((1540483477 * (c >>> 16)) & 65535) << 16)),
														(_ =
															(1540483477 * (65535 & _) +
																(((1540483477 * (_ >>> 16)) & 65535) << 16)) ^
															(c =
																1540483477 * (65535 & (c ^= c >>> 24)) +
																(((1540483477 * (c >>> 16)) & 65535) << 16))),
														(f -= 4),
														++v;
												switch (f) {
													case 3:
														_ ^= (255 & r.charCodeAt(v + 2)) << 16;
													case 2:
														_ ^= (255 & r.charCodeAt(v + 1)) << 8;
													case 1:
														_ =
															1540483477 *
																(65535 & (_ ^= 255 & r.charCodeAt(v))) +
															(((1540483477 * (_ >>> 16)) & 65535) << 16);
												}
												return (
													(_ =
														1540483477 * (65535 & (_ ^= _ >>> 13)) +
														(((1540483477 * (_ >>> 16)) & 65535) << 16)),
													(_ ^= _ >>> 15) >>> 0
												);
											})),
										vo.exports);
								return (
									(za.exports = n),
									(za.exports.murmur3 = n),
									(za.exports.murmur2 = t),
									za.exports
								);
							})(),
							ms = O(fs);
						class Vo {
							constructor() {
								(this.ids = []), (this.positions = []), (this.indexed = !1);
							}
							add(t, r, o, c) {
								this.ids.push(qo(t)), this.positions.push(r, o, c);
							}
							getPositions(t) {
								if (!this.indexed)
									throw new Error(
										"Trying to get index, but feature positions are not indexed"
									);
								const r = qo(t);
								let o = 0,
									c = this.ids.length - 1;
								for (; o < c; ) {
									const _ = (o + c) >> 1;
									this.ids[_] >= r ? (c = _) : (o = _ + 1);
								}
								const f = [];
								for (; this.ids[o] === r; )
									f.push({
										index: this.positions[3 * o],
										start: this.positions[3 * o + 1],
										end: this.positions[3 * o + 2],
									}),
										o++;
								return f;
							}
							static serialize(t, r) {
								const o = new Float64Array(t.ids),
									c = new Uint32Array(t.positions);
								return (
									ta(o, c, 0, o.length - 1),
									r && r.push(o.buffer, c.buffer),
									{ ids: o, positions: c }
								);
							}
							static deserialize(t) {
								const r = new Vo();
								return (
									(r.ids = t.ids),
									(r.positions = t.positions),
									(r.indexed = !0),
									r
								);
							}
						}
						function qo(n) {
							const t = +n;
							return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER
								? t
								: ms(String(n));
						}
						function ta(n, t, r, o) {
							for (; r < o; ) {
								const c = n[(r + o) >> 1];
								let f = r - 1,
									_ = o + 1;
								for (;;) {
									do f++;
									while (n[f] < c);
									do _--;
									while (n[_] > c);
									if (f >= _) break;
									La(n, f, _),
										La(t, 3 * f, 3 * _),
										La(t, 3 * f + 1, 3 * _ + 1),
										La(t, 3 * f + 2, 3 * _ + 2);
								}
								_ - r < o - _
									? (ta(n, t, r, _), (r = _ + 1))
									: (ta(n, t, _ + 1, o), (o = _));
							}
						}
						function La(n, t, r) {
							const o = n[t];
							(n[t] = n[r]), (n[r] = o);
						}
						ir("FeaturePositionMap", Vo);
						class Gi {
							constructor(t, r) {
								(this.gl = t.gl), (this.location = r);
							}
						}
						class yo extends Gi {
							constructor(t, r) {
								super(t, r), (this.current = 0);
							}
							set(t) {
								this.current !== t &&
									((this.current = t), this.gl.uniform1f(this.location, t));
							}
						}
						class li extends Gi {
							constructor(t, r) {
								super(t, r), (this.current = [0, 0, 0, 0]);
							}
							set(t) {
								(t[0] === this.current[0] &&
									t[1] === this.current[1] &&
									t[2] === this.current[2] &&
									t[3] === this.current[3]) ||
									((this.current = t),
									this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
							}
						}
						class _i extends Gi {
							constructor(t, r) {
								super(t, r), (this.current = Mr.transparent);
							}
							set(t) {
								(t.r === this.current.r &&
									t.g === this.current.g &&
									t.b === this.current.b &&
									t.a === this.current.a) ||
									((this.current = t),
									this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
							}
						}
						const ba = new Float32Array(16);
						function ci(n) {
							return [Bn(255 * n.r, 255 * n.g), Bn(255 * n.b, 255 * n.a)];
						}
						class Qs {
							constructor(t, r, o) {
								(this.value = t),
									(this.uniformNames = r.map((c) => `u_${c}`)),
									(this.type = o);
							}
							setUniform(t, r, o) {
								t.set(o.constantOr(this.value));
							}
							getBinding(t, r, o) {
								return this.type === "color" ? new _i(t, r) : new yo(t, r);
							}
						}
						class _s {
							constructor(t, r) {
								(this.uniformNames = r.map((o) => `u_${o}`)),
									(this.patternFrom = null),
									(this.patternTo = null),
									(this.pixelRatioFrom = 1),
									(this.pixelRatioTo = 1);
							}
							setConstantPatternPositions(t, r) {
								(this.pixelRatioFrom = r.pixelRatio),
									(this.pixelRatioTo = t.pixelRatio),
									(this.patternFrom = r.tlbr),
									(this.patternTo = t.tlbr);
							}
							setUniform(t, r, o, c) {
								const f =
									c === "u_pattern_to"
										? this.patternTo
										: c === "u_pattern_from"
										? this.patternFrom
										: c === "u_pixel_ratio_to"
										? this.pixelRatioTo
										: c === "u_pixel_ratio_from"
										? this.pixelRatioFrom
										: null;
								f && t.set(f);
							}
							getBinding(t, r, o) {
								return o.substr(0, 9) === "u_pattern"
									? new li(t, r)
									: new yo(t, r);
							}
						}
						class ro {
							constructor(t, r, o, c) {
								(this.expression = t),
									(this.type = o),
									(this.maxValue = 0),
									(this.paintVertexAttributes = r.map((f) => ({
										name: `a_${f}`,
										type: "Float32",
										components: o === "color" ? 2 : 1,
										offset: 0,
									}))),
									(this.paintVertexArray = new c());
							}
							populatePaintArray(t, r, o, c, f) {
								const _ = this.paintVertexArray.length,
									v = this.expression.evaluate(new Un(0), r, {}, c, [], f);
								this.paintVertexArray.resize(t), this._setPaintValue(_, t, v);
							}
							updatePaintArray(t, r, o, c) {
								const f = this.expression.evaluate({ zoom: 0 }, o, c);
								this._setPaintValue(t, r, f);
							}
							_setPaintValue(t, r, o) {
								if (this.type === "color") {
									const c = ci(o);
									for (let f = t; f < r; f++)
										this.paintVertexArray.emplace(f, c[0], c[1]);
								} else {
									for (let c = t; c < r; c++)
										this.paintVertexArray.emplace(c, o);
									this.maxValue = Math.max(this.maxValue, Math.abs(o));
								}
							}
							upload(t) {
								this.paintVertexArray &&
									this.paintVertexArray.arrayBuffer &&
									(this.paintVertexBuffer && this.paintVertexBuffer.buffer
										? this.paintVertexBuffer.updateData(this.paintVertexArray)
										: (this.paintVertexBuffer = t.createVertexBuffer(
												this.paintVertexArray,
												this.paintVertexAttributes,
												this.expression.isStateDependent
										  )));
							}
							destroy() {
								this.paintVertexBuffer && this.paintVertexBuffer.destroy();
							}
						}
						class Da {
							constructor(t, r, o, c, f, _) {
								(this.expression = t),
									(this.uniformNames = r.map((v) => `u_${v}_t`)),
									(this.type = o),
									(this.useIntegerZoom = c),
									(this.zoom = f),
									(this.maxValue = 0),
									(this.paintVertexAttributes = r.map((v) => ({
										name: `a_${v}`,
										type: "Float32",
										components: o === "color" ? 4 : 2,
										offset: 0,
									}))),
									(this.paintVertexArray = new _());
							}
							populatePaintArray(t, r, o, c, f) {
								const _ = this.expression.evaluate(
										new Un(this.zoom),
										r,
										{},
										c,
										[],
										f
									),
									v = this.expression.evaluate(
										new Un(this.zoom + 1),
										r,
										{},
										c,
										[],
										f
									),
									b = this.paintVertexArray.length;
								this.paintVertexArray.resize(t),
									this._setPaintValue(b, t, _, v);
							}
							updatePaintArray(t, r, o, c) {
								const f = this.expression.evaluate({ zoom: this.zoom }, o, c),
									_ = this.expression.evaluate({ zoom: this.zoom + 1 }, o, c);
								this._setPaintValue(t, r, f, _);
							}
							_setPaintValue(t, r, o, c) {
								if (this.type === "color") {
									const f = ci(o),
										_ = ci(c);
									for (let v = t; v < r; v++)
										this.paintVertexArray.emplace(v, f[0], f[1], _[0], _[1]);
								} else {
									for (let f = t; f < r; f++)
										this.paintVertexArray.emplace(f, o, c);
									this.maxValue = Math.max(
										this.maxValue,
										Math.abs(o),
										Math.abs(c)
									);
								}
							}
							upload(t) {
								this.paintVertexArray &&
									this.paintVertexArray.arrayBuffer &&
									(this.paintVertexBuffer && this.paintVertexBuffer.buffer
										? this.paintVertexBuffer.updateData(this.paintVertexArray)
										: (this.paintVertexBuffer = t.createVertexBuffer(
												this.paintVertexArray,
												this.paintVertexAttributes,
												this.expression.isStateDependent
										  )));
							}
							destroy() {
								this.paintVertexBuffer && this.paintVertexBuffer.destroy();
							}
							setUniform(t, r) {
								const o = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
									c = Dt(
										this.expression.interpolationFactor(
											o,
											this.zoom,
											this.zoom + 1
										),
										0,
										1
									);
								t.set(c);
							}
							getBinding(t, r, o) {
								return new yo(t, r);
							}
						}
						class xo {
							constructor(t, r, o, c, f, _) {
								(this.expression = t),
									(this.type = r),
									(this.useIntegerZoom = o),
									(this.zoom = c),
									(this.layerId = _),
									(this.zoomInPaintVertexArray = new f()),
									(this.zoomOutPaintVertexArray = new f());
							}
							populatePaintArray(t, r, o) {
								const c = this.zoomInPaintVertexArray.length;
								this.zoomInPaintVertexArray.resize(t),
									this.zoomOutPaintVertexArray.resize(t),
									this._setPaintValues(
										c,
										t,
										r.patterns && r.patterns[this.layerId],
										o
									);
							}
							updatePaintArray(t, r, o, c, f) {
								this._setPaintValues(
									t,
									r,
									o.patterns && o.patterns[this.layerId],
									f
								);
							}
							_setPaintValues(t, r, o, c) {
								if (!c || !o) return;
								const { min: f, mid: _, max: v } = o,
									b = c[f],
									S = c[_],
									I = c[v];
								if (b && S && I)
									for (let L = t; L < r; L++)
										this.zoomInPaintVertexArray.emplace(
											L,
											S.tl[0],
											S.tl[1],
											S.br[0],
											S.br[1],
											b.tl[0],
											b.tl[1],
											b.br[0],
											b.br[1],
											S.pixelRatio,
											b.pixelRatio
										),
											this.zoomOutPaintVertexArray.emplace(
												L,
												S.tl[0],
												S.tl[1],
												S.br[0],
												S.br[1],
												I.tl[0],
												I.tl[1],
												I.br[0],
												I.br[1],
												S.pixelRatio,
												I.pixelRatio
											);
							}
							upload(t) {
								this.zoomInPaintVertexArray &&
									this.zoomInPaintVertexArray.arrayBuffer &&
									this.zoomOutPaintVertexArray &&
									this.zoomOutPaintVertexArray.arrayBuffer &&
									((this.zoomInPaintVertexBuffer = t.createVertexBuffer(
										this.zoomInPaintVertexArray,
										si.members,
										this.expression.isStateDependent
									)),
									(this.zoomOutPaintVertexBuffer = t.createVertexBuffer(
										this.zoomOutPaintVertexArray,
										si.members,
										this.expression.isStateDependent
									)));
							}
							destroy() {
								this.zoomOutPaintVertexBuffer &&
									this.zoomOutPaintVertexBuffer.destroy(),
									this.zoomInPaintVertexBuffer &&
										this.zoomInPaintVertexBuffer.destroy();
							}
						}
						class Cd {
							constructor(t, r, o) {
								(this.binders = {}), (this._buffers = []);
								const c = [];
								for (const f in t.paint._values) {
									if (!o(f)) continue;
									const _ = t.paint.get(f);
									if (!(_ instanceof $a && fo(_.property.specification)))
										continue;
									const v = Sd(f, t.type),
										b = _.value,
										S = _.property.specification.type,
										I = _.property.useIntegerZoom,
										L = _.property.specification["property-type"],
										F = L === "cross-faded" || L === "cross-faded-data-driven";
									if (b.kind === "constant")
										(this.binders[f] = F
											? new _s(b.value, v)
											: new Qs(b.value, v, S)),
											c.push(`/u_${f}`);
									else if (b.kind === "source" || F) {
										const q = _u(f, S, "source");
										(this.binders[f] = F
											? new xo(b, S, I, r, q, t.id)
											: new ro(b, v, S, q)),
											c.push(`/a_${f}`);
									} else {
										const q = _u(f, S, "composite");
										(this.binders[f] = new Da(b, v, S, I, r, q)),
											c.push(`/z_${f}`);
									}
								}
								this.cacheKey = c.sort().join("");
							}
							getMaxValue(t) {
								const r = this.binders[t];
								return r instanceof ro || r instanceof Da ? r.maxValue : 0;
							}
							populatePaintArrays(t, r, o, c, f) {
								for (const _ in this.binders) {
									const v = this.binders[_];
									(v instanceof ro || v instanceof Da || v instanceof xo) &&
										v.populatePaintArray(t, r, o, c, f);
								}
							}
							setConstantPatternPositions(t, r) {
								for (const o in this.binders) {
									const c = this.binders[o];
									c instanceof _s && c.setConstantPatternPositions(t, r);
								}
							}
							updatePaintArrays(t, r, o, c, f) {
								let _ = !1;
								for (const v in t) {
									const b = r.getPositions(v);
									for (const S of b) {
										const I = o.feature(S.index);
										for (const L in this.binders) {
											const F = this.binders[L];
											if (
												(F instanceof ro ||
													F instanceof Da ||
													F instanceof xo) &&
												F.expression.isStateDependent === !0
											) {
												const q = c.paint.get(L);
												(F.expression = q.value),
													F.updatePaintArray(S.start, S.end, I, t[v], f),
													(_ = !0);
											}
										}
									}
								}
								return _;
							}
							defines() {
								const t = [];
								for (const r in this.binders) {
									const o = this.binders[r];
									(o instanceof Qs || o instanceof _s) &&
										t.push(
											...o.uniformNames.map((c) => `#define HAS_UNIFORM_${c}`)
										);
								}
								return t;
							}
							getBinderAttributes() {
								const t = [];
								for (const r in this.binders) {
									const o = this.binders[r];
									if (o instanceof ro || o instanceof Da)
										for (let c = 0; c < o.paintVertexAttributes.length; c++)
											t.push(o.paintVertexAttributes[c].name);
									else if (o instanceof xo)
										for (let c = 0; c < si.members.length; c++)
											t.push(si.members[c].name);
								}
								return t;
							}
							getBinderUniforms() {
								const t = [];
								for (const r in this.binders) {
									const o = this.binders[r];
									if (o instanceof Qs || o instanceof _s || o instanceof Da)
										for (const c of o.uniformNames) t.push(c);
								}
								return t;
							}
							getPaintVertexBuffers() {
								return this._buffers;
							}
							getUniforms(t, r) {
								const o = [];
								for (const c in this.binders) {
									const f = this.binders[c];
									if (f instanceof Qs || f instanceof _s || f instanceof Da) {
										for (const _ of f.uniformNames)
											if (r[_]) {
												const v = f.getBinding(t, r[_], _);
												o.push({ name: _, property: c, binding: v });
											}
									}
								}
								return o;
							}
							setUniforms(t, r, o, c) {
								for (const { name: f, property: _, binding: v } of r)
									this.binders[_].setUniform(v, c, o.get(_), f);
							}
							updatePaintBuffers(t) {
								this._buffers = [];
								for (const r in this.binders) {
									const o = this.binders[r];
									if (t && o instanceof xo) {
										const c =
											t.fromScale === 2
												? o.zoomInPaintVertexBuffer
												: o.zoomOutPaintVertexBuffer;
										c && this._buffers.push(c);
									} else
										(o instanceof ro || o instanceof Da) &&
											o.paintVertexBuffer &&
											this._buffers.push(o.paintVertexBuffer);
								}
							}
							upload(t) {
								for (const r in this.binders) {
									const o = this.binders[r];
									(o instanceof ro || o instanceof Da || o instanceof xo) &&
										o.upload(t);
								}
								this.updatePaintBuffers();
							}
							destroy() {
								for (const t in this.binders) {
									const r = this.binders[t];
									(r instanceof ro || r instanceof Da || r instanceof xo) &&
										r.destroy();
								}
							}
						}
						class la {
							constructor(t, r, o = () => !0) {
								this.programConfigurations = {};
								for (const c of t)
									this.programConfigurations[c.id] = new Cd(c, r, o);
								(this.needsUpload = !1),
									(this._featureMap = new Vo()),
									(this._bufferOffset = 0);
							}
							populatePaintArrays(t, r, o, c, f, _) {
								for (const v in this.programConfigurations)
									this.programConfigurations[v].populatePaintArrays(
										t,
										r,
										c,
										f,
										_
									);
								r.id !== void 0 &&
									this._featureMap.add(r.id, o, this._bufferOffset, t),
									(this._bufferOffset = t),
									(this.needsUpload = !0);
							}
							updatePaintArrays(t, r, o, c) {
								for (const f of o)
									this.needsUpload =
										this.programConfigurations[f.id].updatePaintArrays(
											t,
											this._featureMap,
											r,
											f,
											c
										) || this.needsUpload;
							}
							get(t) {
								return this.programConfigurations[t];
							}
							upload(t) {
								if (this.needsUpload) {
									for (const r in this.programConfigurations)
										this.programConfigurations[r].upload(t);
									this.needsUpload = !1;
								}
							}
							destroy() {
								for (const t in this.programConfigurations)
									this.programConfigurations[t].destroy();
							}
						}
						function Sd(n, t) {
							return (
								{
									"text-opacity": ["opacity"],
									"icon-opacity": ["opacity"],
									"text-color": ["fill_color"],
									"icon-color": ["fill_color"],
									"text-halo-color": ["halo_color"],
									"icon-halo-color": ["halo_color"],
									"text-halo-blur": ["halo_blur"],
									"icon-halo-blur": ["halo_blur"],
									"text-halo-width": ["halo_width"],
									"icon-halo-width": ["halo_width"],
									"line-gap-width": ["gapwidth"],
									"line-pattern": [
										"pattern_to",
										"pattern_from",
										"pixel_ratio_to",
										"pixel_ratio_from",
									],
									"fill-pattern": [
										"pattern_to",
										"pattern_from",
										"pixel_ratio_to",
										"pixel_ratio_from",
									],
									"fill-extrusion-pattern": [
										"pattern_to",
										"pattern_from",
										"pixel_ratio_to",
										"pixel_ratio_from",
									],
								}[n] || [n.replace(`${t}-`, "").replace(/-/g, "_")]
							);
						}
						function _u(n, t, r) {
							const o = {
									color: { source: Js, composite: E },
									number: { source: d, composite: Js },
								},
								c = (function (f) {
									return {
										"line-pattern": { source: jt, composite: jt },
										"fill-pattern": { source: jt, composite: jt },
										"fill-extrusion-pattern": { source: jt, composite: jt },
									}[f];
								})(n);
							return (c && c[r]) || o[t][r];
						}
						ir("ConstantBinder", Qs),
							ir("CrossFadedConstantBinder", _s),
							ir("SourceExpressionBinder", ro),
							ir("CrossFadedCompositeBinder", xo),
							ir("CompositeExpressionBinder", Da),
							ir("ProgramConfiguration", Cd, { omit: ["_buffers"] }),
							ir("ProgramConfigurationSet", la);
						const Wl = Math.pow(2, 14) - 1,
							Xl = -Wl - 1;
						function bo(n) {
							const t = oe / n.extent,
								r = n.loadGeometry();
							for (let o = 0; o < r.length; o++) {
								const c = r[o];
								for (let f = 0; f < c.length; f++) {
									const _ = c[f],
										v = Math.round(_.x * t),
										b = Math.round(_.y * t);
									(_.x = Dt(v, Xl, Wl)),
										(_.y = Dt(b, Xl, Wl)),
										(v < _.x || v > _.x + 1 || b < _.y || b > _.y + 1) &&
											Lt(
												"Geometry exceeds allowed extent, reduce your vector tile buffer size"
											);
								}
							}
							return r;
						}
						function no(n, t) {
							return {
								type: n.type,
								id: n.id,
								properties: n.properties,
								geometry: t ? bo(n) : [],
							};
						}
						const h_ = -32768;
						function K0(n, t, r, o, c) {
							n.emplaceBack(h_ + 8 * t + o, h_ + 8 * r + c);
						}
						class Gp {
							constructor(t) {
								(this.zoom = t.zoom),
									(this.globalState = t.globalState),
									(this.overscaling = t.overscaling),
									(this.layers = t.layers),
									(this.layerIds = this.layers.map((r) => r.id)),
									(this.index = t.index),
									(this.hasPattern = !1),
									(this.layoutVertexArray = new Be()),
									(this.indexArray = new Rn()),
									(this.segments = new Kr()),
									(this.programConfigurations = new la(t.layers, t.zoom)),
									(this.stateDependentLayerIds = this.layers
										.filter((r) => r.isStateDependent())
										.map((r) => r.id));
							}
							populate(t, r, o) {
								const c = this.layers[0],
									f = [];
								let _ = null,
									v = !1,
									b = c.type === "heatmap";
								if (c.type === "circle") {
									const I = c;
									(_ = I.layout.get("circle-sort-key")),
										(v = !_.isConstant()),
										(b = b || I.paint.get("circle-pitch-alignment") === "map");
								}
								const S = b ? r.subdivisionGranularity.circle : 1;
								for (const {
									feature: I,
									id: L,
									index: F,
									sourceLayerIndex: q,
								} of t) {
									const Z = this.layers[0]._featureFilter.needGeometry,
										W = no(I, Z);
									if (
										!this.layers[0]._featureFilter.filter(
											new Un(this.zoom, { globalState: this.globalState }),
											W,
											o
										)
									)
										continue;
									const J = v ? _.evaluate(W, {}, o) : void 0,
										le = {
											id: L,
											properties: I.properties,
											type: I.type,
											sourceLayerIndex: q,
											index: F,
											geometry: Z ? W.geometry : bo(I),
											patterns: {},
											sortKey: J,
										};
									f.push(le);
								}
								v && f.sort((I, L) => I.sortKey - L.sortKey);
								for (const I of f) {
									const { geometry: L, index: F, sourceLayerIndex: q } = I,
										Z = t[F].feature;
									this.addFeature(I, L, F, o, S),
										r.featureIndex.insert(Z, L, F, q, this.index);
								}
							}
							update(t, r, o) {
								this.stateDependentLayers.length &&
									this.programConfigurations.updatePaintArrays(
										t,
										r,
										this.stateDependentLayers,
										o
									);
							}
							isEmpty() {
								return this.layoutVertexArray.length === 0;
							}
							uploadPending() {
								return !this.uploaded || this.programConfigurations.needsUpload;
							}
							upload(t) {
								this.uploaded ||
									((this.layoutVertexBuffer = t.createVertexBuffer(
										this.layoutVertexArray,
										Jn
									)),
									(this.indexBuffer = t.createIndexBuffer(this.indexArray))),
									this.programConfigurations.upload(t),
									(this.uploaded = !0);
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.programConfigurations.destroy(),
									this.segments.destroy());
							}
							addFeature(t, r, o, c, f = 1) {
								let _;
								switch (f) {
									case 1:
										_ = [0, 7];
										break;
									case 3:
										_ = [0, 2, 5, 7];
										break;
									case 5:
										_ = [0, 1, 3, 4, 6, 7];
										break;
									case 7:
										_ = [0, 1, 2, 3, 4, 5, 6, 7];
										break;
									default:
										throw new Error(
											`Invalid circle bucket granularity: ${f}; valid values are 1, 3, 5, 7.`
										);
								}
								const v = _.length;
								for (const b of r)
									for (const S of b) {
										const I = S.x,
											L = S.y;
										if (I < 0 || I >= oe || L < 0 || L >= oe) continue;
										const F = this.segments.prepareSegment(
												v * v,
												this.layoutVertexArray,
												this.indexArray,
												t.sortKey
											),
											q = F.vertexLength;
										for (let Z = 0; Z < v; Z++)
											for (let W = 0; W < v; W++)
												K0(this.layoutVertexArray, I, L, _[W], _[Z]);
										for (let Z = 0; Z < v - 1; Z++)
											for (let W = 0; W < v - 1; W++) {
												const J = q + Z * v + W,
													le = q + (Z + 1) * v + W;
												this.indexArray.emplaceBack(J, le + 1, J + 1),
													this.indexArray.emplaceBack(J, le, le + 1);
											}
										(F.vertexLength += v * v),
											(F.primitiveLength += (v - 1) * (v - 1) * 2);
									}
								this.programConfigurations.populatePaintArrays(
									this.layoutVertexArray.length,
									t,
									o,
									{},
									c
								);
							}
						}
						function d_(n, t) {
							for (let r = 0; r < n.length; r++) if (Yl(t, n[r])) return !0;
							for (let r = 0; r < t.length; r++) if (Yl(n, t[r])) return !0;
							return !!Hp(n, t);
						}
						function J0(n, t, r) {
							return !!Yl(n, t) || !!Wp(t, n, r);
						}
						function p_(n, t) {
							if (n.length === 1) return m_(t, n[0]);
							for (let r = 0; r < t.length; r++) {
								const o = t[r];
								for (let c = 0; c < o.length; c++) if (Yl(n, o[c])) return !0;
							}
							for (let r = 0; r < n.length; r++) if (m_(t, n[r])) return !0;
							for (let r = 0; r < t.length; r++) if (Hp(n, t[r])) return !0;
							return !1;
						}
						function Q0(n, t, r) {
							if (n.length > 1) {
								if (Hp(n, t)) return !0;
								for (let o = 0; o < t.length; o++)
									if (Wp(t[o], n, r)) return !0;
							}
							for (let o = 0; o < n.length; o++) if (Wp(n[o], t, r)) return !0;
							return !1;
						}
						function Hp(n, t) {
							if (n.length === 0 || t.length === 0) return !1;
							for (let r = 0; r < n.length - 1; r++) {
								const o = n[r],
									c = n[r + 1];
								for (let f = 0; f < t.length - 1; f++)
									if (ey(o, c, t[f], t[f + 1])) return !0;
							}
							return !1;
						}
						function ey(n, t, r, o) {
							return Rt(n, r, o) !== Rt(t, r, o) && Rt(n, t, r) !== Rt(n, t, o);
						}
						function Wp(n, t, r) {
							const o = r * r;
							if (t.length === 1) return n.distSqr(t[0]) < o;
							for (let c = 1; c < t.length; c++)
								if (f_(n, t[c - 1], t[c]) < o) return !0;
							return !1;
						}
						function f_(n, t, r) {
							const o = t.distSqr(r);
							if (o === 0) return n.distSqr(t);
							const c =
								((n.x - t.x) * (r.x - t.x) + (n.y - t.y) * (r.y - t.y)) / o;
							return n.distSqr(
								c < 0 ? t : c > 1 ? r : r.sub(t)._mult(c)._add(t)
							);
						}
						function m_(n, t) {
							let r,
								o,
								c,
								f = !1;
							for (let _ = 0; _ < n.length; _++) {
								r = n[_];
								for (let v = 0, b = r.length - 1; v < r.length; b = v++)
									(o = r[v]),
										(c = r[b]),
										o.y > t.y != c.y > t.y &&
											t.x < ((c.x - o.x) * (t.y - o.y)) / (c.y - o.y) + o.x &&
											(f = !f);
							}
							return f;
						}
						function Yl(n, t) {
							let r = !1;
							for (let o = 0, c = n.length - 1; o < n.length; c = o++) {
								const f = n[o],
									_ = n[c];
								f.y > t.y != _.y > t.y &&
									t.x < ((_.x - f.x) * (t.y - f.y)) / (_.y - f.y) + f.x &&
									(r = !r);
							}
							return r;
						}
						function ty(n, t, r) {
							const o = r[0],
								c = r[2];
							if (
								(n.x < o.x && t.x < o.x) ||
								(n.x > c.x && t.x > c.x) ||
								(n.y < o.y && t.y < o.y) ||
								(n.y > c.y && t.y > c.y)
							)
								return !1;
							const f = Rt(n, t, r[0]);
							return (
								f !== Rt(n, t, r[1]) ||
								f !== Rt(n, t, r[2]) ||
								f !== Rt(n, t, r[3])
							);
						}
						function gu(n, t, r) {
							const o = t.paint.get(n).value;
							return o.kind === "constant"
								? o.value
								: r.programConfigurations.get(t.id).getMaxValue(n);
						}
						function Pd(n) {
							return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
						}
						function Id(n, t, r, o, c) {
							if (!t[0] && !t[1]) return n;
							const f = B.convert(t)._mult(c);
							r === "viewport" && f._rotate(-o);
							const _ = [];
							for (let v = 0; v < n.length; v++) _.push(n[v].sub(f));
							return _;
						}
						let __, g_;
						ir("CircleBucket", Gp, { omit: ["layers"] });
						var ry = {
							get paint() {
								return (g_ =
									g_ ||
									new Ui({
										"circle-radius": new Or(ye.paint_circle["circle-radius"]),
										"circle-color": new Or(ye.paint_circle["circle-color"]),
										"circle-blur": new Or(ye.paint_circle["circle-blur"]),
										"circle-opacity": new Or(ye.paint_circle["circle-opacity"]),
										"circle-translate": new wr(
											ye.paint_circle["circle-translate"]
										),
										"circle-translate-anchor": new wr(
											ye.paint_circle["circle-translate-anchor"]
										),
										"circle-pitch-scale": new wr(
											ye.paint_circle["circle-pitch-scale"]
										),
										"circle-pitch-alignment": new wr(
											ye.paint_circle["circle-pitch-alignment"]
										),
										"circle-stroke-width": new Or(
											ye.paint_circle["circle-stroke-width"]
										),
										"circle-stroke-color": new Or(
											ye.paint_circle["circle-stroke-color"]
										),
										"circle-stroke-opacity": new Or(
											ye.paint_circle["circle-stroke-opacity"]
										),
									}));
							},
							get layout() {
								return (__ =
									__ ||
									new Ui({
										"circle-sort-key": new Or(
											ye.layout_circle["circle-sort-key"]
										),
									}));
							},
						};
						class ny extends xa {
							constructor(t) {
								super(t, ry);
							}
							createBucket(t) {
								return new Gp(t);
							}
							queryRadius(t) {
								const r = t;
								return (
									gu("circle-radius", this, r) +
									gu("circle-stroke-width", this, r) +
									Pd(this.paint.get("circle-translate"))
								);
							}
							queryIntersectsFeature({
								queryGeometry: t,
								feature: r,
								featureState: o,
								geometry: c,
								transform: f,
								pixelsToTileUnits: _,
								unwrappedTileID: v,
								getElevation: b,
							}) {
								const S = Id(
										t,
										this.paint.get("circle-translate"),
										this.paint.get("circle-translate-anchor"),
										-f.bearingInRadians,
										_
									),
									I =
										this.paint.get("circle-radius").evaluate(r, o) +
										this.paint.get("circle-stroke-width").evaluate(r, o),
									L = this.paint.get("circle-pitch-alignment") === "map",
									F = L
										? S
										: (function (Z, W, J, le) {
												return Z.map((Re) => v_(Re, W, J, le));
										  })(S, f, v, b),
									q = L ? I * _ : I;
								for (const Z of c)
									for (const W of Z) {
										const J = L ? W : v_(W, f, v, b);
										let le = q;
										const Re = f.projectTileCoordinates(
											W.x,
											W.y,
											v,
											b
										).signedDistanceFromCamera;
										if (
											(this.paint.get("circle-pitch-scale") === "viewport" &&
											this.paint.get("circle-pitch-alignment") === "map"
												? (le *= Re / f.cameraToCenterDistance)
												: this.paint.get("circle-pitch-scale") === "map" &&
												  this.paint.get("circle-pitch-alignment") ===
														"viewport" &&
												  (le *= f.cameraToCenterDistance / Re),
											J0(F, J, le))
										)
											return !0;
									}
								return !1;
							}
						}
						function v_(n, t, r, o) {
							const c = t.projectTileCoordinates(n.x, n.y, r, o).point;
							return new B(
								(0.5 * c.x + 0.5) * t.width,
								(0.5 * -c.y + 0.5) * t.height
							);
						}
						class y_ extends Gp {}
						let x_;
						ir("HeatmapBucket", y_, { omit: ["layers"] });
						var iy = {
							get paint() {
								return (x_ =
									x_ ||
									new Ui({
										"heatmap-radius": new Or(
											ye.paint_heatmap["heatmap-radius"]
										),
										"heatmap-weight": new Or(
											ye.paint_heatmap["heatmap-weight"]
										),
										"heatmap-intensity": new wr(
											ye.paint_heatmap["heatmap-intensity"]
										),
										"heatmap-color": new Ul(ye.paint_heatmap["heatmap-color"]),
										"heatmap-opacity": new wr(
											ye.paint_heatmap["heatmap-opacity"]
										),
									}));
							},
						};
						function Xp(n, { width: t, height: r }, o, c) {
							if (c) {
								if (c instanceof Uint8ClampedArray)
									c = new Uint8Array(c.buffer);
								else if (c.length !== t * r * o)
									throw new RangeError(
										`mismatched image size. expected: ${c.length} but got: ${
											t * r * o
										}`
									);
							} else c = new Uint8Array(t * r * o);
							return (n.width = t), (n.height = r), (n.data = c), n;
						}
						function b_(n, { width: t, height: r }, o) {
							if (t === n.width && r === n.height) return;
							const c = Xp({}, { width: t, height: r }, o);
							Yp(
								n,
								c,
								{ x: 0, y: 0 },
								{ x: 0, y: 0 },
								{ width: Math.min(n.width, t), height: Math.min(n.height, r) },
								o
							),
								(n.width = t),
								(n.height = r),
								(n.data = c.data);
						}
						function Yp(n, t, r, o, c, f) {
							if (c.width === 0 || c.height === 0) return t;
							if (
								c.width > n.width ||
								c.height > n.height ||
								r.x > n.width - c.width ||
								r.y > n.height - c.height
							)
								throw new RangeError(
									"out of range source coordinates for image copy"
								);
							if (
								c.width > t.width ||
								c.height > t.height ||
								o.x > t.width - c.width ||
								o.y > t.height - c.height
							)
								throw new RangeError(
									"out of range destination coordinates for image copy"
								);
							const _ = n.data,
								v = t.data;
							if (_ === v)
								throw new Error(
									"srcData equals dstData, so image is already copied"
								);
							for (let b = 0; b < c.height; b++) {
								const S = ((r.y + b) * n.width + r.x) * f,
									I = ((o.y + b) * t.width + o.x) * f;
								for (let L = 0; L < c.width * f; L++) v[I + L] = _[S + L];
							}
							return t;
						}
						class vu {
							constructor(t, r) {
								Xp(this, t, 1, r);
							}
							resize(t) {
								b_(this, t, 1);
							}
							clone() {
								return new vu(
									{ width: this.width, height: this.height },
									new Uint8Array(this.data)
								);
							}
							static copy(t, r, o, c, f) {
								Yp(t, r, o, c, f, 1);
							}
						}
						class ca {
							constructor(t, r) {
								Xp(this, t, 4, r);
							}
							resize(t) {
								b_(this, t, 4);
							}
							replace(t, r) {
								r
									? this.data.set(t)
									: (this.data =
											t instanceof Uint8ClampedArray
												? new Uint8Array(t.buffer)
												: t);
							}
							clone() {
								return new ca(
									{ width: this.width, height: this.height },
									new Uint8Array(this.data)
								);
							}
							static copy(t, r, o, c, f) {
								Yp(t, r, o, c, f, 4);
							}
							setPixel(t, r, o) {
								const c = 4 * (t * this.width + r);
								(this.data[c + 0] = Math.round((255 * o.r) / o.a)),
									(this.data[c + 1] = Math.round((255 * o.g) / o.a)),
									(this.data[c + 2] = Math.round((255 * o.b) / o.a)),
									(this.data[c + 3] = Math.round(255 * o.a));
							}
						}
						function w_(n) {
							const t = {},
								r = n.resolution || 256,
								o = n.clips ? n.clips.length : 1,
								c = n.image || new ca({ width: r, height: o });
							if ((Math.log(r) / Math.LN2) % 1 != 0)
								throw new Error(`width is not a power of 2 - ${r}`);
							const f = (_, v, b) => {
								t[n.evaluationKey] = b;
								const S = n.expression.evaluate(t);
								c.setPixel(_ / 4 / r, v / 4, S);
							};
							if (n.clips)
								for (let _ = 0, v = 0; _ < o; ++_, v += 4 * r)
									for (let b = 0, S = 0; b < r; b++, S += 4) {
										const I = b / (r - 1),
											{ start: L, end: F } = n.clips[_];
										f(v, S, L * (1 - I) + F * I);
									}
							else
								for (let _ = 0, v = 0; _ < r; _++, v += 4) f(0, v, _ / (r - 1));
							return c;
						}
						ir("AlphaImage", vu), ir("RGBAImage", ca);
						const Kp = "big-fb";
						class ay extends xa {
							createBucket(t) {
								return new y_(t);
							}
							constructor(t) {
								super(t, iy),
									(this.heatmapFbos = new Map()),
									this._updateColorRamp();
							}
							_handleSpecialPaintPropertyUpdate(t) {
								t === "heatmap-color" && this._updateColorRamp();
							}
							_updateColorRamp() {
								(this.colorRamp = w_({
									expression:
										this._transitionablePaint._values["heatmap-color"].value
											.expression,
									evaluationKey: "heatmapDensity",
									image: this.colorRamp,
								})),
									(this.colorRampTexture = null);
							}
							resize() {
								this.heatmapFbos.has(Kp) && this.heatmapFbos.delete(Kp);
							}
							queryRadius() {
								return 0;
							}
							queryIntersectsFeature() {
								return !1;
							}
							hasOffscreenPass() {
								return (
									this.paint.get("heatmap-opacity") !== 0 &&
									this.visibility !== "none"
								);
							}
						}
						let T_;
						var oy = {
							get paint() {
								return (T_ =
									T_ ||
									new Ui({
										"hillshade-illumination-direction": new wr(
											ye.paint_hillshade["hillshade-illumination-direction"]
										),
										"hillshade-illumination-altitude": new wr(
											ye.paint_hillshade["hillshade-illumination-altitude"]
										),
										"hillshade-illumination-anchor": new wr(
											ye.paint_hillshade["hillshade-illumination-anchor"]
										),
										"hillshade-exaggeration": new wr(
											ye.paint_hillshade["hillshade-exaggeration"]
										),
										"hillshade-shadow-color": new wr(
											ye.paint_hillshade["hillshade-shadow-color"]
										),
										"hillshade-highlight-color": new wr(
											ye.paint_hillshade["hillshade-highlight-color"]
										),
										"hillshade-accent-color": new wr(
											ye.paint_hillshade["hillshade-accent-color"]
										),
										"hillshade-method": new wr(
											ye.paint_hillshade["hillshade-method"]
										),
									}));
							},
						};
						class sy extends xa {
							constructor(t) {
								super(t, oy),
									this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
							}
							getIlluminationProperties() {
								let t = this.paint.get(
										"hillshade-illumination-direction"
									).values,
									r = this.paint.get("hillshade-illumination-altitude").values,
									o = this.paint.get("hillshade-highlight-color").values,
									c = this.paint.get("hillshade-shadow-color").values;
								const f = Math.max(t.length, r.length, o.length, c.length);
								(t = t.concat(Array(f - t.length).fill(t.at(-1)))),
									(r = r.concat(Array(f - r.length).fill(r.at(-1)))),
									(o = o.concat(Array(f - o.length).fill(o.at(-1)))),
									(c = c.concat(Array(f - c.length).fill(c.at(-1))));
								const _ = r.map(mr);
								return {
									directionRadians: t.map(mr),
									altitudeRadians: _,
									shadowColor: c,
									highlightColor: o,
								};
							}
							hasOffscreenPass() {
								return (
									this.paint.get("hillshade-exaggeration") !== 0 &&
									this.visibility !== "none"
								);
							}
						}
						let C_;
						var ly = {
							get paint() {
								return (C_ =
									C_ ||
									new Ui({
										"color-relief-opacity": new wr(
											ye["paint_color-relief"]["color-relief-opacity"]
										),
										"color-relief-color": new Ul(
											ye["paint_color-relief"]["color-relief-color"]
										),
									}));
							},
						};
						class Jp {
							constructor(t, r, o, c) {
								(this.context = t),
									(this.format = o),
									(this.texture = t.gl.createTexture()),
									this.update(r, c);
							}
							update(t, r, o) {
								const { width: c, height: f } = t,
									_ = !(
										(this.size && this.size[0] === c && this.size[1] === f) ||
										o
									),
									{ context: v } = this,
									{ gl: b } = v;
								if (
									((this.useMipmap = !!(r && r.useMipmap)),
									b.bindTexture(b.TEXTURE_2D, this.texture),
									v.pixelStoreUnpackFlipY.set(!1),
									v.pixelStoreUnpack.set(1),
									v.pixelStoreUnpackPremultiplyAlpha.set(
										this.format === b.RGBA && (!r || r.premultiply !== !1)
									),
									_)
								)
									(this.size = [c, f]),
										t instanceof HTMLImageElement ||
										t instanceof HTMLCanvasElement ||
										t instanceof HTMLVideoElement ||
										t instanceof ImageData ||
										Qt(t)
											? b.texImage2D(
													b.TEXTURE_2D,
													0,
													this.format,
													this.format,
													b.UNSIGNED_BYTE,
													t
											  )
											: b.texImage2D(
													b.TEXTURE_2D,
													0,
													this.format,
													c,
													f,
													0,
													this.format,
													b.UNSIGNED_BYTE,
													t.data
											  );
								else {
									const { x: S, y: I } = o || { x: 0, y: 0 };
									t instanceof HTMLImageElement ||
									t instanceof HTMLCanvasElement ||
									t instanceof HTMLVideoElement ||
									t instanceof ImageData ||
									Qt(t)
										? b.texSubImage2D(
												b.TEXTURE_2D,
												0,
												S,
												I,
												b.RGBA,
												b.UNSIGNED_BYTE,
												t
										  )
										: b.texSubImage2D(
												b.TEXTURE_2D,
												0,
												S,
												I,
												c,
												f,
												b.RGBA,
												b.UNSIGNED_BYTE,
												t.data
										  );
								}
								this.useMipmap &&
									this.isSizePowerOfTwo() &&
									b.generateMipmap(b.TEXTURE_2D),
									v.pixelStoreUnpackFlipY.setDefault(),
									v.pixelStoreUnpack.setDefault(),
									v.pixelStoreUnpackPremultiplyAlpha.setDefault();
							}
							bind(t, r, o) {
								const { context: c } = this,
									{ gl: f } = c;
								f.bindTexture(f.TEXTURE_2D, this.texture),
									o !== f.LINEAR_MIPMAP_NEAREST ||
										this.isSizePowerOfTwo() ||
										(o = f.LINEAR),
									t !== this.filter &&
										(f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, t),
										f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, o || t),
										(this.filter = t)),
									r !== this.wrap &&
										(f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, r),
										f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, r),
										(this.wrap = r));
							}
							isSizePowerOfTwo() {
								return (
									this.size[0] === this.size[1] &&
									(Math.log(this.size[0]) / Math.LN2) % 1 == 0
								);
							}
							destroy() {
								const { gl: t } = this.context;
								t.deleteTexture(this.texture), (this.texture = null);
							}
						}
						class S_ {
							constructor(t, r, o, c = 1, f = 1, _ = 1, v = 0) {
								if (((this.uid = t), r.height !== r.width))
									throw new RangeError("DEM tiles must be square");
								if (o && !["mapbox", "terrarium", "custom"].includes(o))
									return void Lt(
										`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`
									);
								this.stride = r.height;
								const b = (this.dim = r.height - 2);
								switch (((this.data = new Uint32Array(r.data.buffer)), o)) {
									case "terrarium":
										(this.redFactor = 256),
											(this.greenFactor = 1),
											(this.blueFactor = 1 / 256),
											(this.baseShift = 32768);
										break;
									case "custom":
										(this.redFactor = c),
											(this.greenFactor = f),
											(this.blueFactor = _),
											(this.baseShift = v);
										break;
									default:
										(this.redFactor = 6553.6),
											(this.greenFactor = 25.6),
											(this.blueFactor = 0.1),
											(this.baseShift = 1e4);
								}
								for (let S = 0; S < b; S++)
									(this.data[this._idx(-1, S)] = this.data[this._idx(0, S)]),
										(this.data[this._idx(b, S)] =
											this.data[this._idx(b - 1, S)]),
										(this.data[this._idx(S, -1)] = this.data[this._idx(S, 0)]),
										(this.data[this._idx(S, b)] =
											this.data[this._idx(S, b - 1)]);
								(this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)]),
									(this.data[this._idx(b, -1)] =
										this.data[this._idx(b - 1, 0)]),
									(this.data[this._idx(-1, b)] =
										this.data[this._idx(0, b - 1)]),
									(this.data[this._idx(b, b)] =
										this.data[this._idx(b - 1, b - 1)]),
									(this.min = Number.MAX_SAFE_INTEGER),
									(this.max = Number.MIN_SAFE_INTEGER);
								for (let S = 0; S < b; S++)
									for (let I = 0; I < b; I++) {
										const L = this.get(S, I);
										L > this.max && (this.max = L),
											L < this.min && (this.min = L);
									}
							}
							get(t, r) {
								const o = new Uint8Array(this.data.buffer),
									c = 4 * this._idx(t, r);
								return this.unpack(o[c], o[c + 1], o[c + 2]);
							}
							getUnpackVector() {
								return [
									this.redFactor,
									this.greenFactor,
									this.blueFactor,
									this.baseShift,
								];
							}
							_idx(t, r) {
								if (t < -1 || t >= this.dim + 1 || r < -1 || r >= this.dim + 1)
									throw new RangeError(
										"out of range source coordinates for DEM data"
									);
								return (r + 1) * this.stride + (t + 1);
							}
							unpack(t, r, o) {
								return (
									t * this.redFactor +
									r * this.greenFactor +
									o * this.blueFactor -
									this.baseShift
								);
							}
							pack(t) {
								return P_(t, this.getUnpackVector());
							}
							getPixels() {
								return new ca(
									{ width: this.stride, height: this.stride },
									new Uint8Array(this.data.buffer)
								);
							}
							backfillBorder(t, r, o) {
								if (this.dim !== t.dim)
									throw new Error("dem dimension mismatch");
								let c = r * this.dim,
									f = r * this.dim + this.dim,
									_ = o * this.dim,
									v = o * this.dim + this.dim;
								switch (r) {
									case -1:
										c = f - 1;
										break;
									case 1:
										f = c + 1;
								}
								switch (o) {
									case -1:
										_ = v - 1;
										break;
									case 1:
										v = _ + 1;
								}
								const b = -r * this.dim,
									S = -o * this.dim;
								for (let I = _; I < v; I++)
									for (let L = c; L < f; L++)
										this.data[this._idx(L, I)] =
											t.data[this._idx(L + b, I + S)];
							}
						}
						function P_(n, t) {
							const r = t[0],
								o = t[1],
								c = t[2],
								f = t[3],
								_ = Math.min(r, o, c),
								v = Math.round((n + f) / _);
							return {
								r: Math.floor((v * _) / r) % 256,
								g: Math.floor((v * _) / o) % 256,
								b: Math.floor((v * _) / c) % 256,
							};
						}
						ir("DEMData", S_);
						class cy extends xa {
							constructor(t) {
								super(t, ly);
							}
							_createColorRamp(t) {
								const r = { elevationStops: [], colorStops: [] },
									o =
										this._transitionablePaint._values["color-relief-color"]
											.value.expression;
								if (
									o instanceof Zs &&
									o._styleExpression.expression instanceof Di
								) {
									this.colorRampExpression = o;
									const _ = o._styleExpression.expression;
									(r.elevationStops = _.labels), (r.colorStops = []);
									for (const v of r.elevationStops)
										r.colorStops.push(
											_.evaluate({ globals: { elevation: v } })
										);
								}
								if (
									(r.elevationStops.length < 1 &&
										((r.elevationStops = [0]),
										(r.colorStops = [Mr.transparent])),
									r.elevationStops.length < 2 &&
										(r.elevationStops.push(r.elevationStops[0] + 1),
										r.colorStops.push(r.colorStops[0])),
									r.elevationStops.length <= t)
								)
									return r;
								const c = { elevationStops: [], colorStops: [] },
									f = (r.elevationStops.length - 1) / (t - 1);
								for (let _ = 0; _ < r.elevationStops.length - 0.5; _ += f)
									c.elevationStops.push(r.elevationStops[Math.round(_)]),
										c.colorStops.push(r.colorStops[Math.round(_)]);
								return (
									Lt(
										`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`
									),
									c
								);
							}
							_colorRampChanged() {
								return (
									this.colorRampExpression !=
									this._transitionablePaint._values["color-relief-color"].value
										.expression
								);
							}
							getColorRampTextures(t, r, o) {
								if (this.colorRampTextures && !this._colorRampChanged())
									return this.colorRampTextures;
								const c = this._createColorRamp(r),
									f = new ca({ width: c.colorStops.length, height: 1 }),
									_ = new ca({ width: c.colorStops.length, height: 1 });
								for (let v = 0; v < c.elevationStops.length; v++) {
									const b = P_(c.elevationStops[v], o);
									_.setPixel(0, v, new Mr(b.r / 255, b.g / 255, b.b / 255, 1)),
										f.setPixel(0, v, c.colorStops[v]);
								}
								return (
									(this.colorRampTextures = {
										elevationTexture: new Jp(t, _, t.gl.RGBA),
										colorTexture: new Jp(t, f, t.gl.RGBA),
									}),
									this.colorRampTextures
								);
							}
							hasOffscreenPass() {
								return this.visibility !== "none" && !!this.colorRampTextures;
							}
						}
						const uy = ti([{ name: "a_pos", components: 2, type: "Int16" }], 4),
							{ members: hy } = uy;
						function Qp(n, t, r) {
							const o = r.patternDependencies;
							let c = !1;
							for (const f of t) {
								const _ = f.paint.get(`${n}-pattern`);
								_.isConstant() || (c = !0);
								const v = _.constantOr(null);
								v && ((c = !0), (o[v.to] = !0), (o[v.from] = !0));
							}
							return c;
						}
						function ef(n, t, r, o, c) {
							const f = c.patternDependencies;
							for (const _ of t) {
								const v = _.paint.get(`${n}-pattern`).value;
								if (v.kind !== "constant") {
									let b = v.evaluate({ zoom: o - 1 }, r, {}, c.availableImages),
										S = v.evaluate({ zoom: o }, r, {}, c.availableImages),
										I = v.evaluate({ zoom: o + 1 }, r, {}, c.availableImages);
									(b = b && b.name ? b.name : b),
										(S = S && S.name ? S.name : S),
										(I = I && I.name ? I.name : I),
										(f[b] = !0),
										(f[S] = !0),
										(f[I] = !0),
										(r.patterns[_.id] = { min: b, mid: S, max: I });
								}
							}
							return r;
						}
						function I_(n, t, r, o, c) {
							let f;
							if (
								c ===
								(function (_, v, b, S) {
									let I = 0;
									for (let L = v, F = b - S; L < b; L += S)
										(I += (_[F] - _[L]) * (_[L + 1] + _[F + 1])), (F = L);
									return I;
								})(n, t, r, o) >
									0
							)
								for (let _ = t; _ < r; _ += o)
									f = E_((_ / o) | 0, n[_], n[_ + 1], f);
							else
								for (let _ = r - o; _ >= t; _ -= o)
									f = E_((_ / o) | 0, n[_], n[_ + 1], f);
							return f && Kl(f, f.next) && (wu(f), (f = f.next)), f;
						}
						function el(n, t) {
							if (!n) return n;
							t || (t = n);
							let r,
								o = n;
							do
								if (
									((r = !1),
									o.steiner || (!Kl(o, o.next) && ii(o.prev, o, o.next) !== 0))
								)
									o = o.next;
								else {
									if ((wu(o), (o = t = o.prev), o === o.next)) break;
									r = !0;
								}
							while (r || o !== t);
							return t;
						}
						function yu(n, t, r, o, c, f, _) {
							if (!n) return;
							!_ &&
								f &&
								(function (b, S, I, L) {
									let F = b;
									do
										F.z === 0 && (F.z = tf(F.x, F.y, S, I, L)),
											(F.prevZ = F.prev),
											(F.nextZ = F.next),
											(F = F.next);
									while (F !== b);
									(F.prevZ.nextZ = null),
										(F.prevZ = null),
										(function (q) {
											let Z,
												W = 1;
											do {
												let J,
													le = q;
												q = null;
												let Re = null;
												for (Z = 0; le; ) {
													Z++;
													let xe = le,
														Ce = 0;
													for (
														let lt = 0;
														lt < W && (Ce++, (xe = xe.nextZ), xe);
														lt++
													);
													let Ye = W;
													for (; Ce > 0 || (Ye > 0 && xe); )
														Ce !== 0 && (Ye === 0 || !xe || le.z <= xe.z)
															? ((J = le), (le = le.nextZ), Ce--)
															: ((J = xe), (xe = xe.nextZ), Ye--),
															Re ? (Re.nextZ = J) : (q = J),
															(J.prevZ = Re),
															(Re = J);
													le = xe;
												}
												(Re.nextZ = null), (W *= 2);
											} while (Z > 1);
										})(F);
								})(n, o, c, f);
							let v = n;
							for (; n.prev !== n.next; ) {
								const b = n.prev,
									S = n.next;
								if (f ? py(n, o, c, f) : dy(n))
									t.push(b.i, n.i, S.i), wu(n), (n = S.next), (v = S.next);
								else if ((n = S) === v) {
									_
										? _ === 1
											? yu((n = fy(el(n), t)), t, r, o, c, f, 2)
											: _ === 2 && my(n, t, r, o, c, f)
										: yu(el(n), t, r, o, c, f, 1);
									break;
								}
							}
						}
						function dy(n) {
							const t = n.prev,
								r = n,
								o = n.next;
							if (ii(t, r, o) >= 0) return !1;
							const c = t.x,
								f = r.x,
								_ = o.x,
								v = t.y,
								b = r.y,
								S = o.y,
								I = Math.min(c, f, _),
								L = Math.min(v, b, S),
								F = Math.max(c, f, _),
								q = Math.max(v, b, S);
							let Z = o.next;
							for (; Z !== t; ) {
								if (
									Z.x >= I &&
									Z.x <= F &&
									Z.y >= L &&
									Z.y <= q &&
									xu(c, v, f, b, _, S, Z.x, Z.y) &&
									ii(Z.prev, Z, Z.next) >= 0
								)
									return !1;
								Z = Z.next;
							}
							return !0;
						}
						function py(n, t, r, o) {
							const c = n.prev,
								f = n,
								_ = n.next;
							if (ii(c, f, _) >= 0) return !1;
							const v = c.x,
								b = f.x,
								S = _.x,
								I = c.y,
								L = f.y,
								F = _.y,
								q = Math.min(v, b, S),
								Z = Math.min(I, L, F),
								W = Math.max(v, b, S),
								J = Math.max(I, L, F),
								le = tf(q, Z, t, r, o),
								Re = tf(W, J, t, r, o);
							let xe = n.prevZ,
								Ce = n.nextZ;
							for (; xe && xe.z >= le && Ce && Ce.z <= Re; ) {
								if (
									(xe.x >= q &&
										xe.x <= W &&
										xe.y >= Z &&
										xe.y <= J &&
										xe !== c &&
										xe !== _ &&
										xu(v, I, b, L, S, F, xe.x, xe.y) &&
										ii(xe.prev, xe, xe.next) >= 0) ||
									((xe = xe.prevZ),
									Ce.x >= q &&
										Ce.x <= W &&
										Ce.y >= Z &&
										Ce.y <= J &&
										Ce !== c &&
										Ce !== _ &&
										xu(v, I, b, L, S, F, Ce.x, Ce.y) &&
										ii(Ce.prev, Ce, Ce.next) >= 0)
								)
									return !1;
								Ce = Ce.nextZ;
							}
							for (; xe && xe.z >= le; ) {
								if (
									xe.x >= q &&
									xe.x <= W &&
									xe.y >= Z &&
									xe.y <= J &&
									xe !== c &&
									xe !== _ &&
									xu(v, I, b, L, S, F, xe.x, xe.y) &&
									ii(xe.prev, xe, xe.next) >= 0
								)
									return !1;
								xe = xe.prevZ;
							}
							for (; Ce && Ce.z <= Re; ) {
								if (
									Ce.x >= q &&
									Ce.x <= W &&
									Ce.y >= Z &&
									Ce.y <= J &&
									Ce !== c &&
									Ce !== _ &&
									xu(v, I, b, L, S, F, Ce.x, Ce.y) &&
									ii(Ce.prev, Ce, Ce.next) >= 0
								)
									return !1;
								Ce = Ce.nextZ;
							}
							return !0;
						}
						function fy(n, t) {
							let r = n;
							do {
								const o = r.prev,
									c = r.next.next;
								!Kl(o, c) &&
									k_(o, r, r.next, c) &&
									bu(o, c) &&
									bu(c, o) &&
									(t.push(o.i, r.i, c.i), wu(r), wu(r.next), (r = n = c)),
									(r = r.next);
							} while (r !== n);
							return el(r);
						}
						function my(n, t, r, o, c, f) {
							let _ = n;
							do {
								let v = _.next.next;
								for (; v !== _.prev; ) {
									if (_.i !== v.i && xy(_, v)) {
										let b = A_(_, v);
										return (
											(_ = el(_, _.next)),
											(b = el(b, b.next)),
											yu(_, t, r, o, c, f, 0),
											void yu(b, t, r, o, c, f, 0)
										);
									}
									v = v.next;
								}
								_ = _.next;
							} while (_ !== n);
						}
						function _y(n, t) {
							let r = n.x - t.x;
							return (
								r === 0 &&
									((r = n.y - t.y), r === 0) &&
									(r =
										(n.next.y - n.y) / (n.next.x - n.x) -
										(t.next.y - t.y) / (t.next.x - t.x)),
								r
							);
						}
						function gy(n, t) {
							const r = (function (c, f) {
								let _ = f;
								const v = c.x,
									b = c.y;
								let S,
									I = -1 / 0;
								if (Kl(c, _)) return _;
								do {
									if (Kl(c, _.next)) return _.next;
									if (b <= _.y && b >= _.next.y && _.next.y !== _.y) {
										const W =
											_.x + ((b - _.y) * (_.next.x - _.x)) / (_.next.y - _.y);
										if (
											W <= v &&
											W > I &&
											((I = W), (S = _.x < _.next.x ? _ : _.next), W === v)
										)
											return S;
									}
									_ = _.next;
								} while (_ !== f);
								if (!S) return null;
								const L = S,
									F = S.x,
									q = S.y;
								let Z = 1 / 0;
								_ = S;
								do {
									if (
										v >= _.x &&
										_.x >= F &&
										v !== _.x &&
										M_(b < q ? v : I, b, F, q, b < q ? I : v, b, _.x, _.y)
									) {
										const W = Math.abs(b - _.y) / (v - _.x);
										bu(_, c) &&
											(W < Z ||
												(W === Z &&
													(_.x > S.x || (_.x === S.x && vy(S, _))))) &&
											((S = _), (Z = W));
									}
									_ = _.next;
								} while (_ !== L);
								return S;
							})(n, t);
							if (!r) return t;
							const o = A_(r, n);
							return el(o, o.next), el(r, r.next);
						}
						function vy(n, t) {
							return ii(n.prev, n, t.prev) < 0 && ii(t.next, n, n.next) < 0;
						}
						function tf(n, t, r, o, c) {
							return (
								(n =
									1431655765 &
									((n =
										858993459 &
										((n =
											252645135 &
											((n = 16711935 & ((n = ((n - r) * c) | 0) | (n << 8))) |
												(n << 4))) |
											(n << 2))) |
										(n << 1))) |
								((t =
									1431655765 &
									((t =
										858993459 &
										((t =
											252645135 &
											((t = 16711935 & ((t = ((t - o) * c) | 0) | (t << 8))) |
												(t << 4))) |
											(t << 2))) |
										(t << 1))) <<
									1)
							);
						}
						function yy(n) {
							let t = n,
								r = n;
							do
								(t.x < r.x || (t.x === r.x && t.y < r.y)) && (r = t),
									(t = t.next);
							while (t !== n);
							return r;
						}
						function M_(n, t, r, o, c, f, _, v) {
							return (
								(c - _) * (t - v) >= (n - _) * (f - v) &&
								(n - _) * (o - v) >= (r - _) * (t - v) &&
								(r - _) * (f - v) >= (c - _) * (o - v)
							);
						}
						function xu(n, t, r, o, c, f, _, v) {
							return !(n === _ && t === v) && M_(n, t, r, o, c, f, _, v);
						}
						function xy(n, t) {
							return (
								n.next.i !== t.i &&
								n.prev.i !== t.i &&
								!(function (r, o) {
									let c = r;
									do {
										if (
											c.i !== r.i &&
											c.next.i !== r.i &&
											c.i !== o.i &&
											c.next.i !== o.i &&
											k_(c, c.next, r, o)
										)
											return !0;
										c = c.next;
									} while (c !== r);
									return !1;
								})(n, t) &&
								((bu(n, t) &&
									bu(t, n) &&
									(function (r, o) {
										let c = r,
											f = !1;
										const _ = (r.x + o.x) / 2,
											v = (r.y + o.y) / 2;
										do
											c.y > v != c.next.y > v &&
												c.next.y !== c.y &&
												_ <
													((c.next.x - c.x) * (v - c.y)) / (c.next.y - c.y) +
														c.x &&
												(f = !f),
												(c = c.next);
										while (c !== r);
										return f;
									})(n, t) &&
									(ii(n.prev, n, t.prev) || ii(n, t.prev, t))) ||
									(Kl(n, t) &&
										ii(n.prev, n, n.next) > 0 &&
										ii(t.prev, t, t.next) > 0))
							);
						}
						function ii(n, t, r) {
							return (t.y - n.y) * (r.x - t.x) - (t.x - n.x) * (r.y - t.y);
						}
						function Kl(n, t) {
							return n.x === t.x && n.y === t.y;
						}
						function k_(n, t, r, o) {
							const c = kd(ii(n, t, r)),
								f = kd(ii(n, t, o)),
								_ = kd(ii(r, o, n)),
								v = kd(ii(r, o, t));
							return (
								(c !== f && _ !== v) ||
								!(c !== 0 || !Md(n, r, t)) ||
								!(f !== 0 || !Md(n, o, t)) ||
								!(_ !== 0 || !Md(r, n, o)) ||
								!(v !== 0 || !Md(r, t, o))
							);
						}
						function Md(n, t, r) {
							return (
								t.x <= Math.max(n.x, r.x) &&
								t.x >= Math.min(n.x, r.x) &&
								t.y <= Math.max(n.y, r.y) &&
								t.y >= Math.min(n.y, r.y)
							);
						}
						function kd(n) {
							return n > 0 ? 1 : n < 0 ? -1 : 0;
						}
						function bu(n, t) {
							return ii(n.prev, n, n.next) < 0
								? ii(n, t, n.next) >= 0 && ii(n, n.prev, t) >= 0
								: ii(n, t, n.prev) < 0 || ii(n, n.next, t) < 0;
						}
						function A_(n, t) {
							const r = rf(n.i, n.x, n.y),
								o = rf(t.i, t.x, t.y),
								c = n.next,
								f = t.prev;
							return (
								(n.next = t),
								(t.prev = n),
								(r.next = c),
								(c.prev = r),
								(o.next = r),
								(r.prev = o),
								(f.next = o),
								(o.prev = f),
								o
							);
						}
						function E_(n, t, r, o) {
							const c = rf(n, t, r);
							return (
								o
									? ((c.next = o.next),
									  (c.prev = o),
									  (o.next.prev = c),
									  (o.next = c))
									: ((c.prev = c), (c.next = c)),
								c
							);
						}
						function wu(n) {
							(n.next.prev = n.prev),
								(n.prev.next = n.next),
								n.prevZ && (n.prevZ.nextZ = n.nextZ),
								n.nextZ && (n.nextZ.prevZ = n.prevZ);
						}
						function rf(n, t, r) {
							return {
								i: n,
								x: t,
								y: r,
								prev: null,
								next: null,
								z: 0,
								prevZ: null,
								nextZ: null,
								steiner: !1,
							};
						}
						class Jl {
							constructor(t, r) {
								if (r > t)
									throw new Error(
										"Min granularity must not be greater than base granularity."
									);
								(this._baseZoomGranularity = t), (this._minGranularity = r);
							}
							getGranularityForZoomLevel(t) {
								return Math.max(
									Math.floor(this._baseZoomGranularity / (1 << t)),
									this._minGranularity,
									1
								);
							}
						}
						class Ad {
							constructor(t) {
								(this.fill = t.fill),
									(this.line = t.line),
									(this.tile = t.tile),
									(this.stencil = t.stencil),
									(this.circle = t.circle);
							}
						}
						(Ad.noSubdivision = new Ad({
							fill: new Jl(0, 0),
							line: new Jl(0, 0),
							tile: new Jl(0, 0),
							stencil: new Jl(0, 0),
							circle: 1,
						})),
							ir("SubdivisionGranularityExpression", Jl),
							ir("SubdivisionGranularitySetting", Ad);
						const Ql = -32768,
							Tu = 32767;
						class by {
							constructor(t, r) {
								(this._vertexBuffer = []),
									(this._vertexDictionary = new Map()),
									(this._used = !1),
									(this._granularity = t),
									(this._granularityCellSize = oe / t),
									(this._canonical = r);
							}
							_getKey(t, r) {
								return ((t += 32768) << 16) | (r + 32768);
							}
							_vertexToIndex(t, r) {
								if (t < -32768 || r < -32768 || t > 32767 || r > 32767)
									throw new Error(
										"Vertex coordinates are out of signed 16 bit integer range."
									);
								const o = 0 | Math.round(t),
									c = 0 | Math.round(r),
									f = this._getKey(o, c);
								if (this._vertexDictionary.has(f))
									return this._vertexDictionary.get(f);
								const _ = this._vertexBuffer.length / 2;
								return (
									this._vertexDictionary.set(f, _),
									this._vertexBuffer.push(o, c),
									_
								);
							}
							_subdivideTrianglesScanline(t) {
								if (this._granularity < 2)
									return (function (c, f) {
										const _ = [];
										for (let v = 0; v < f.length; v += 3) {
											const b = f[v],
												S = f[v + 1],
												I = f[v + 2],
												L = c[2 * b],
												F = c[2 * b + 1];
											(c[2 * S] - L) * (c[2 * I + 1] - F) -
												(c[2 * S + 1] - F) * (c[2 * I] - L) >
											0
												? (_.push(b), _.push(I), _.push(S))
												: (_.push(b), _.push(S), _.push(I));
										}
										return _;
									})(this._vertexBuffer, t);
								const r = [],
									o = t.length;
								for (let c = 0; c < o; c += 3) {
									const f = [t[c + 0], t[c + 1], t[c + 2]],
										_ = [
											this._vertexBuffer[2 * t[c + 0] + 0],
											this._vertexBuffer[2 * t[c + 0] + 1],
											this._vertexBuffer[2 * t[c + 1] + 0],
											this._vertexBuffer[2 * t[c + 1] + 1],
											this._vertexBuffer[2 * t[c + 2] + 0],
											this._vertexBuffer[2 * t[c + 2] + 1],
										];
									let v = 1 / 0,
										b = 1 / 0,
										S = -1 / 0,
										I = -1 / 0;
									for (let W = 0; W < 3; W++) {
										const J = _[2 * W],
											le = _[2 * W + 1];
										(v = Math.min(v, J)),
											(S = Math.max(S, J)),
											(b = Math.min(b, le)),
											(I = Math.max(I, le));
									}
									if (v === S || b === I) continue;
									const L = Math.floor(v / this._granularityCellSize),
										F = Math.ceil(S / this._granularityCellSize),
										q = Math.floor(b / this._granularityCellSize),
										Z = Math.ceil(I / this._granularityCellSize);
									if (L !== F || q !== Z)
										for (let W = q; W < Z; W++) {
											const J = this._scanlineGenerateVertexRingForCellRow(
												W,
												_,
												f
											);
											wy(this._vertexBuffer, J, r);
										}
									else r.push(...f);
								}
								return r;
							}
							_scanlineGenerateVertexRingForCellRow(t, r, o) {
								const c = t * this._granularityCellSize,
									f = c + this._granularityCellSize,
									_ = [];
								for (let v = 0; v < 3; v++) {
									const b = r[2 * v],
										S = r[2 * v + 1],
										I = r[(2 * (v + 1)) % 6],
										L = r[(2 * (v + 1) + 1) % 6],
										F = r[(2 * (v + 2)) % 6],
										q = r[(2 * (v + 2) + 1) % 6],
										Z = I - b,
										W = L - S,
										J = Z === 0,
										le = W === 0,
										Re = (c - S) / W,
										xe = (f - S) / W,
										Ce = Math.min(Re, xe),
										Ye = Math.max(Re, xe);
									if (
										(!le && (Ce >= 1 || Ye <= 0)) ||
										(le && (S < c || S > f))
									) {
										L >= c && L <= f && _.push(o[(v + 1) % 3]);
										continue;
									}
									!le &&
										Ce > 0 &&
										_.push(this._vertexToIndex(b + Z * Ce, S + W * Ce));
									const lt = b + Z * Math.max(Ce, 0),
										Pt = b + Z * Math.min(Ye, 1);
									J || this._generateIntraEdgeVertices(_, b, S, I, L, lt, Pt),
										!le &&
											Ye < 1 &&
											_.push(this._vertexToIndex(b + Z * Ye, S + W * Ye)),
										(le || (L >= c && L <= f)) && _.push(o[(v + 1) % 3]),
										!le &&
											(L <= c || L >= f) &&
											this._generateInterEdgeVertices(
												_,
												b,
												S,
												I,
												L,
												F,
												q,
												Pt,
												c,
												f
											);
								}
								return _;
							}
							_generateIntraEdgeVertices(t, r, o, c, f, _, v) {
								const b = c - r,
									S = f - o,
									I = S === 0,
									L = I ? Math.min(r, c) : Math.min(_, v),
									F = I ? Math.max(r, c) : Math.max(_, v),
									q = Math.floor(L / this._granularityCellSize) + 1,
									Z = Math.ceil(F / this._granularityCellSize) - 1;
								if (I ? r < c : _ < v)
									for (let W = q; W <= Z; W++) {
										const J = W * this._granularityCellSize;
										t.push(this._vertexToIndex(J, o + (S * (J - r)) / b));
									}
								else
									for (let W = Z; W >= q; W--) {
										const J = W * this._granularityCellSize;
										t.push(this._vertexToIndex(J, o + (S * (J - r)) / b));
									}
							}
							_generateInterEdgeVertices(t, r, o, c, f, _, v, b, S, I) {
								const L = f - o,
									F = _ - c,
									q = v - f,
									Z = (S - f) / q,
									W = (I - f) / q,
									J = Math.min(Z, W),
									le = Math.max(Z, W),
									Re = c + F * J;
								let xe =
										Math.floor(Math.min(Re, b) / this._granularityCellSize) + 1,
									Ce =
										Math.ceil(Math.max(Re, b) / this._granularityCellSize) - 1,
									Ye = b < Re;
								const lt = q === 0;
								if (lt && (v === S || v === I)) return;
								if (lt || J >= 1 || le <= 0) {
									const Yt = o - v,
										qt = _ + (r - _) * Math.min((S - v) / Yt, (I - v) / Yt);
									(xe =
										Math.floor(Math.min(qt, b) / this._granularityCellSize) +
										1),
										(Ce =
											Math.ceil(Math.max(qt, b) / this._granularityCellSize) -
											1),
										(Ye = b < qt);
								}
								const Pt = L > 0 ? I : S;
								if (Ye)
									for (let Yt = xe; Yt <= Ce; Yt++)
										t.push(
											this._vertexToIndex(Yt * this._granularityCellSize, Pt)
										);
								else
									for (let Yt = Ce; Yt >= xe; Yt--)
										t.push(
											this._vertexToIndex(Yt * this._granularityCellSize, Pt)
										);
							}
							_generateOutline(t) {
								const r = [];
								for (const o of t) {
									const c = tl(o, this._granularity, !0),
										f = this._pointArrayToIndices(c),
										_ = [];
									for (let v = 1; v < f.length; v++)
										_.push(f[v - 1]), _.push(f[v]);
									r.push(_);
								}
								return r;
							}
							_handlePoles(t) {
								let r = !1,
									o = !1;
								this._canonical &&
									(this._canonical.y === 0 && (r = !0),
									this._canonical.y === (1 << this._canonical.z) - 1 &&
										(o = !0)),
									(r || o) && this._fillPoles(t, r, o);
							}
							_ensureNoPoleVertices() {
								const t = this._vertexBuffer;
								for (let r = 0; r < t.length; r += 2) {
									const o = t[r + 1];
									o === Ql && (t[r + 1] = -32767),
										o === Tu && (t[r + 1] = 32766);
								}
							}
							_generatePoleQuad(t, r, o, c, f, _) {
								c > f != (_ === Ql)
									? (t.push(r),
									  t.push(o),
									  t.push(this._vertexToIndex(c, _)),
									  t.push(o),
									  t.push(this._vertexToIndex(f, _)),
									  t.push(this._vertexToIndex(c, _)))
									: (t.push(o),
									  t.push(r),
									  t.push(this._vertexToIndex(c, _)),
									  t.push(this._vertexToIndex(f, _)),
									  t.push(o),
									  t.push(this._vertexToIndex(c, _)));
							}
							_fillPoles(t, r, o) {
								const c = this._vertexBuffer,
									f = oe,
									_ = t.length;
								for (let v = 2; v < _; v += 3) {
									const b = t[v - 2],
										S = t[v - 1],
										I = t[v],
										L = c[2 * b],
										F = c[2 * b + 1],
										q = c[2 * S],
										Z = c[2 * S + 1],
										W = c[2 * I],
										J = c[2 * I + 1];
									r &&
										(F === 0 &&
											Z === 0 &&
											this._generatePoleQuad(t, b, S, L, q, Ql),
										Z === 0 &&
											J === 0 &&
											this._generatePoleQuad(t, S, I, q, W, Ql),
										J === 0 &&
											F === 0 &&
											this._generatePoleQuad(t, I, b, W, L, Ql)),
										o &&
											(F === f &&
												Z === f &&
												this._generatePoleQuad(t, b, S, L, q, Tu),
											Z === f &&
												J === f &&
												this._generatePoleQuad(t, S, I, q, W, Tu),
											J === f &&
												F === f &&
												this._generatePoleQuad(t, I, b, W, L, Tu));
								}
							}
							_initializeVertices(t) {
								for (let r = 0; r < t.length; r += 2)
									this._vertexToIndex(t[r], t[r + 1]);
							}
							subdividePolygonInternal(t, r) {
								if (this._used)
									throw new Error("Subdivision: multiple use not allowed.");
								this._used = !0;
								const { flattened: o, holeIndices: c } = (function (v) {
									const b = [],
										S = [];
									for (const I of v)
										if (I.length !== 0) {
											I !== v[0] && b.push(S.length / 2);
											for (let L = 0; L < I.length; L++)
												S.push(I[L].x), S.push(I[L].y);
										}
									return { flattened: S, holeIndices: b };
								})(t);
								let f;
								this._initializeVertices(o);
								try {
									const v = (function (S, I, L = 2) {
											const F = I && I.length,
												q = F ? I[0] * L : S.length;
											let Z = I_(S, 0, q, L, !0);
											const W = [];
											if (!Z || Z.next === Z.prev) return W;
											let J, le, Re;
											if (
												(F &&
													(Z = (function (xe, Ce, Ye, lt) {
														const Pt = [];
														for (let Yt = 0, qt = Ce.length; Yt < qt; Yt++) {
															const Ht = I_(
																xe,
																Ce[Yt] * lt,
																Yt < qt - 1 ? Ce[Yt + 1] * lt : xe.length,
																lt,
																!1
															);
															Ht === Ht.next && (Ht.steiner = !0),
																Pt.push(yy(Ht));
														}
														Pt.sort(_y);
														for (let Yt = 0; Yt < Pt.length; Yt++)
															Ye = gy(Pt[Yt], Ye);
														return Ye;
													})(S, I, Z, L)),
												S.length > 80 * L)
											) {
												(J = S[0]), (le = S[1]);
												let xe = J,
													Ce = le;
												for (let Ye = L; Ye < q; Ye += L) {
													const lt = S[Ye],
														Pt = S[Ye + 1];
													lt < J && (J = lt),
														Pt < le && (le = Pt),
														lt > xe && (xe = lt),
														Pt > Ce && (Ce = Pt);
												}
												(Re = Math.max(xe - J, Ce - le)),
													(Re = Re !== 0 ? 32767 / Re : 0);
											}
											return yu(Z, W, L, J, le, Re, 0), W;
										})(o, c),
										b = this._convertIndices(o, v);
									f = this._subdivideTrianglesScanline(b);
								} catch (v) {
									console.error(v);
								}
								let _ = [];
								return (
									r && (_ = this._generateOutline(t)),
									this._ensureNoPoleVertices(),
									this._handlePoles(f),
									{
										verticesFlattened: this._vertexBuffer,
										indicesTriangles: f,
										indicesLineList: _,
									}
								);
							}
							_convertIndices(t, r) {
								const o = [];
								for (let c = 0; c < r.length; c++)
									o.push(this._vertexToIndex(t[2 * r[c]], t[2 * r[c] + 1]));
								return o;
							}
							_pointArrayToIndices(t) {
								const r = [];
								for (let o = 0; o < t.length; o++) {
									const c = t[o];
									r.push(this._vertexToIndex(c.x, c.y));
								}
								return r;
							}
						}
						function z_(n, t, r, o = !0) {
							return new by(r, t).subdividePolygonInternal(n, o);
						}
						function tl(n, t, r = !1) {
							if (!n || n.length < 1) return [];
							if (n.length < 2) return [];
							const o = n[0],
								c = n[n.length - 1],
								f = r && (o.x !== c.x || o.y !== c.y);
							if (t < 2) return f ? [...n, n[0]] : [...n];
							const _ = Math.floor(oe / t),
								v = [];
							v.push(new B(n[0].x, n[0].y));
							const b = n.length,
								S = f ? b : b - 1;
							for (let I = 0; I < S; I++) {
								const L = n[I],
									F = I < b - 1 ? n[I + 1] : n[0],
									q = L.x,
									Z = L.y,
									W = F.x,
									J = F.y,
									le = q !== W,
									Re = Z !== J;
								if (!le && !Re) continue;
								const xe = W - q,
									Ce = J - Z,
									Ye = Math.abs(xe),
									lt = Math.abs(Ce);
								let Pt = q,
									Yt = Z;
								for (;;) {
									const Ht =
											xe > 0
												? (Math.floor(Pt / _) + 1) * _
												: (Math.ceil(Pt / _) - 1) * _,
										Sr =
											Ce > 0
												? (Math.floor(Yt / _) + 1) * _
												: (Math.ceil(Yt / _) - 1) * _,
										Gt = Math.abs(Pt - Ht),
										Wt = Math.abs(Yt - Sr),
										gt = Math.abs(Pt - W),
										Nr = Math.abs(Yt - J),
										Hr = le ? Gt / Ye : Number.POSITIVE_INFINITY,
										kr = Re ? Wt / lt : Number.POSITIVE_INFINITY;
									if ((gt <= Gt || !le) && (Nr <= Wt || !Re)) break;
									if ((Hr < kr && le) || !Re) {
										(Pt = Ht), (Yt += Ce * Hr);
										const yr = new B(Pt, Math.round(Yt));
										(v[v.length - 1].x === yr.x &&
											v[v.length - 1].y === yr.y) ||
											v.push(yr);
									} else {
										(Pt += xe * kr), (Yt = Sr);
										const yr = new B(Math.round(Pt), Yt);
										(v[v.length - 1].x === yr.x &&
											v[v.length - 1].y === yr.y) ||
											v.push(yr);
									}
								}
								const qt = new B(W, J);
								(v[v.length - 1].x === qt.x && v[v.length - 1].y === qt.y) ||
									v.push(qt);
							}
							return v;
						}
						function wy(n, t, r) {
							if (t.length === 0)
								throw new Error("Subdivision vertex ring is empty.");
							let o = 0,
								c = n[2 * t[0]];
							for (let b = 1; b < t.length; b++) {
								const S = n[2 * t[b]];
								S < c && ((c = S), (o = b));
							}
							const f = t.length;
							let _ = o,
								v = (_ + 1) % f;
							for (;;) {
								const b = _ - 1 >= 0 ? _ - 1 : f - 1,
									S = (v + 1) % f,
									I = n[2 * t[b]],
									L = n[2 * t[S]],
									F = n[2 * t[_]],
									q = n[2 * t[_] + 1],
									Z = n[2 * t[v] + 1];
								let W = !1;
								if (I < L) W = !0;
								else if (I > L) W = !1;
								else {
									const J = Z - q,
										le = -(n[2 * t[v]] - F),
										Re = q < Z ? 1 : -1;
									((I - F) * J + (n[2 * t[b] + 1] - q) * le) * Re >
										((L - F) * J + (n[2 * t[S] + 1] - q) * le) * Re && (W = !0);
								}
								if (W) {
									const J = t[b],
										le = t[_],
										Re = t[v];
									J !== le && J !== Re && le !== Re && r.push(Re, le, J),
										_--,
										_ < 0 && (_ = f - 1);
								} else {
									const J = t[S],
										le = t[_],
										Re = t[v];
									J !== le && J !== Re && le !== Re && r.push(Re, le, J),
										v++,
										v >= f && (v = 0);
								}
								if (b === S) break;
							}
						}
						function L_(n, t, r, o, c, f, _, v, b) {
							const S = c.length / 2,
								I = _ && v && b;
							if (S < Kr.MAX_VERTEX_ARRAY_LENGTH) {
								const L = t.prepareSegment(S, r, o),
									F = L.vertexLength;
								for (let W = 0; W < f.length; W += 3)
									o.emplaceBack(F + f[W], F + f[W + 1], F + f[W + 2]);
								let q, Z;
								(L.vertexLength += S),
									(L.primitiveLength += f.length / 3),
									I &&
										((Z = _.prepareSegment(S, r, v)),
										(q = Z.vertexLength),
										(Z.vertexLength += S));
								for (let W = 0; W < c.length; W += 2) n(c[W], c[W + 1]);
								if (I)
									for (let W = 0; W < b.length; W++) {
										const J = b[W];
										for (let le = 1; le < J.length; le += 2)
											v.emplaceBack(q + J[le - 1], q + J[le]);
										Z.primitiveLength += J.length / 2;
									}
							} else
								(function (L, F, q, Z, W, J) {
									const le = [];
									for (let lt = 0; lt < Z.length / 2; lt++) le.push(-1);
									const Re = { count: 0 };
									let xe = 0,
										Ce = L.getOrCreateLatestSegment(F, q),
										Ye = Ce.vertexLength;
									for (let lt = 2; lt < W.length; lt += 3) {
										const Pt = W[lt - 2],
											Yt = W[lt - 1],
											qt = W[lt];
										let Ht = le[Pt] < xe,
											Sr = le[Yt] < xe,
											Gt = le[qt] < xe;
										Ce.vertexLength +
											((Ht ? 1 : 0) + (Sr ? 1 : 0) + (Gt ? 1 : 0)) >
											Kr.MAX_VERTEX_ARRAY_LENGTH &&
											((Ce = L.createNewSegment(F, q)),
											(xe = Re.count),
											(Ht = !0),
											(Sr = !0),
											(Gt = !0),
											(Ye = 0));
										const Wt = Cu(le, Z, J, Re, Pt, Ht, Ce),
											gt = Cu(le, Z, J, Re, Yt, Sr, Ce),
											Nr = Cu(le, Z, J, Re, qt, Gt, Ce);
										q.emplaceBack(Ye + Wt - xe, Ye + gt - xe, Ye + Nr - xe),
											Ce.primitiveLength++;
									}
								})(t, r, o, c, f, n),
									I &&
										(function (L, F, q, Z, W, J) {
											const le = [];
											for (let lt = 0; lt < Z.length / 2; lt++) le.push(-1);
											const Re = { count: 0 };
											let xe = 0,
												Ce = L.getOrCreateLatestSegment(F, q),
												Ye = Ce.vertexLength;
											for (let lt = 0; lt < W.length; lt++) {
												const Pt = W[lt];
												for (let Yt = 1; Yt < W[lt].length; Yt += 2) {
													const qt = Pt[Yt - 1],
														Ht = Pt[Yt];
													let Sr = le[qt] < xe,
														Gt = le[Ht] < xe;
													Ce.vertexLength + ((Sr ? 1 : 0) + (Gt ? 1 : 0)) >
														Kr.MAX_VERTEX_ARRAY_LENGTH &&
														((Ce = L.createNewSegment(F, q)),
														(xe = Re.count),
														(Sr = !0),
														(Gt = !0),
														(Ye = 0));
													const Wt = Cu(le, Z, J, Re, qt, Sr, Ce),
														gt = Cu(le, Z, J, Re, Ht, Gt, Ce);
													q.emplaceBack(Ye + Wt - xe, Ye + gt - xe),
														Ce.primitiveLength++;
												}
											}
										})(_, r, v, c, b, n),
									t.forceNewSegmentOnNextPrepare(),
									_ == null || _.forceNewSegmentOnNextPrepare();
						}
						function Cu(n, t, r, o, c, f, _) {
							if (f) {
								const v = o.count;
								return (
									r(t[2 * c], t[2 * c + 1]),
									(n[c] = o.count),
									o.count++,
									_.vertexLength++,
									v
								);
							}
							return n[c];
						}
						class nf {
							constructor(t) {
								(this.zoom = t.zoom),
									(this.globalState = t.globalState),
									(this.overscaling = t.overscaling),
									(this.layers = t.layers),
									(this.layerIds = this.layers.map((r) => r.id)),
									(this.index = t.index),
									(this.hasPattern = !1),
									(this.patternFeatures = []),
									(this.layoutVertexArray = new rt()),
									(this.indexArray = new Rn()),
									(this.indexArray2 = new Ln()),
									(this.programConfigurations = new la(t.layers, t.zoom)),
									(this.segments = new Kr()),
									(this.segments2 = new Kr()),
									(this.stateDependentLayerIds = this.layers
										.filter((r) => r.isStateDependent())
										.map((r) => r.id));
							}
							populate(t, r, o) {
								this.hasPattern = Qp("fill", this.layers, r);
								const c = this.layers[0].layout.get("fill-sort-key"),
									f = !c.isConstant(),
									_ = [];
								for (const {
									feature: v,
									id: b,
									index: S,
									sourceLayerIndex: I,
								} of t) {
									const L = this.layers[0]._featureFilter.needGeometry,
										F = no(v, L);
									if (
										!this.layers[0]._featureFilter.filter(
											new Un(this.zoom, { globalState: this.globalState }),
											F,
											o
										)
									)
										continue;
									const q = f
											? c.evaluate(F, {}, o, r.availableImages)
											: void 0,
										Z = {
											id: b,
											properties: v.properties,
											type: v.type,
											sourceLayerIndex: I,
											index: S,
											geometry: L ? F.geometry : bo(v),
											patterns: {},
											sortKey: q,
										};
									_.push(Z);
								}
								f && _.sort((v, b) => v.sortKey - b.sortKey);
								for (const v of _) {
									const { geometry: b, index: S, sourceLayerIndex: I } = v;
									if (this.hasPattern) {
										const L = ef("fill", this.layers, v, this.zoom, r);
										this.patternFeatures.push(L);
									} else
										this.addFeature(v, b, S, o, {}, r.subdivisionGranularity);
									r.featureIndex.insert(t[S].feature, b, S, I, this.index);
								}
							}
							update(t, r, o) {
								this.stateDependentLayers.length &&
									this.programConfigurations.updatePaintArrays(
										t,
										r,
										this.stateDependentLayers,
										o
									);
							}
							addFeatures(t, r, o) {
								for (const c of this.patternFeatures)
									this.addFeature(
										c,
										c.geometry,
										c.index,
										r,
										o,
										t.subdivisionGranularity
									);
							}
							isEmpty() {
								return this.layoutVertexArray.length === 0;
							}
							uploadPending() {
								return !this.uploaded || this.programConfigurations.needsUpload;
							}
							upload(t) {
								this.uploaded ||
									((this.layoutVertexBuffer = t.createVertexBuffer(
										this.layoutVertexArray,
										hy
									)),
									(this.indexBuffer = t.createIndexBuffer(this.indexArray)),
									(this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))),
									this.programConfigurations.upload(t),
									(this.uploaded = !0);
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.indexBuffer2.destroy(),
									this.programConfigurations.destroy(),
									this.segments.destroy(),
									this.segments2.destroy());
							}
							addFeature(t, r, o, c, f, _) {
								for (const v of Os(r, 500)) {
									const b = z_(v, c, _.fill.getGranularityForZoomLevel(c.z)),
										S = this.layoutVertexArray;
									L_(
										(I, L) => {
											S.emplaceBack(I, L);
										},
										this.segments,
										this.layoutVertexArray,
										this.indexArray,
										b.verticesFlattened,
										b.indicesTriangles,
										this.segments2,
										this.indexArray2,
										b.indicesLineList
									);
								}
								this.programConfigurations.populatePaintArrays(
									this.layoutVertexArray.length,
									t,
									o,
									f,
									c
								);
							}
						}
						let D_, R_;
						ir("FillBucket", nf, { omit: ["layers", "patternFeatures"] });
						var Ty = {
							get paint() {
								return (R_ =
									R_ ||
									new Ui({
										"fill-antialias": new wr(ye.paint_fill["fill-antialias"]),
										"fill-opacity": new Or(ye.paint_fill["fill-opacity"]),
										"fill-color": new Or(ye.paint_fill["fill-color"]),
										"fill-outline-color": new Or(
											ye.paint_fill["fill-outline-color"]
										),
										"fill-translate": new wr(ye.paint_fill["fill-translate"]),
										"fill-translate-anchor": new wr(
											ye.paint_fill["fill-translate-anchor"]
										),
										"fill-pattern": new Zl(ye.paint_fill["fill-pattern"]),
									}));
							},
							get layout() {
								return (D_ =
									D_ ||
									new Ui({
										"fill-sort-key": new Or(ye.layout_fill["fill-sort-key"]),
									}));
							},
						};
						class Cy extends xa {
							constructor(t) {
								super(t, Ty);
							}
							recalculate(t, r) {
								super.recalculate(t, r);
								const o = this.paint._values["fill-outline-color"];
								o.value.kind === "constant" &&
									o.value.value === void 0 &&
									(this.paint._values["fill-outline-color"] =
										this.paint._values["fill-color"]);
							}
							createBucket(t) {
								return new nf(t);
							}
							queryRadius() {
								return Pd(this.paint.get("fill-translate"));
							}
							queryIntersectsFeature({
								queryGeometry: t,
								geometry: r,
								transform: o,
								pixelsToTileUnits: c,
							}) {
								return p_(
									Id(
										t,
										this.paint.get("fill-translate"),
										this.paint.get("fill-translate-anchor"),
										-o.bearingInRadians,
										c
									),
									r
								);
							}
							isTileClipped() {
								return !0;
							}
						}
						const Sy = ti(
								[
									{ name: "a_pos", components: 2, type: "Int16" },
									{ name: "a_normal_ed", components: 4, type: "Int16" },
								],
								4
							),
							Py = ti(
								[{ name: "a_centroid", components: 2, type: "Int16" }],
								4
							),
							{ members: Iy } = Sy;
						class ec {
							constructor(t, r, o, c, f) {
								(this.properties = {}),
									(this.extent = o),
									(this.type = 0),
									(this.id = void 0),
									(this._pbf = t),
									(this._geometry = -1),
									(this._keys = c),
									(this._values = f),
									t.readFields(My, this, r);
							}
							loadGeometry() {
								const t = this._pbf;
								t.pos = this._geometry;
								const r = t.readVarint() + t.pos,
									o = [];
								let c,
									f = 1,
									_ = 0,
									v = 0,
									b = 0;
								for (; t.pos < r; ) {
									if (_ <= 0) {
										const S = t.readVarint();
										(f = 7 & S), (_ = S >> 3);
									}
									if ((_--, f === 1 || f === 2))
										(v += t.readSVarint()),
											(b += t.readSVarint()),
											f === 1 && (c && o.push(c), (c = [])),
											c && c.push(new B(v, b));
									else {
										if (f !== 7) throw new Error(`unknown command ${f}`);
										c && c.push(c[0].clone());
									}
								}
								return c && o.push(c), o;
							}
							bbox() {
								const t = this._pbf;
								t.pos = this._geometry;
								const r = t.readVarint() + t.pos;
								let o = 1,
									c = 0,
									f = 0,
									_ = 0,
									v = 1 / 0,
									b = -1 / 0,
									S = 1 / 0,
									I = -1 / 0;
								for (; t.pos < r; ) {
									if (c <= 0) {
										const L = t.readVarint();
										(o = 7 & L), (c = L >> 3);
									}
									if ((c--, o === 1 || o === 2))
										(f += t.readSVarint()),
											(_ += t.readSVarint()),
											f < v && (v = f),
											f > b && (b = f),
											_ < S && (S = _),
											_ > I && (I = _);
									else if (o !== 7) throw new Error(`unknown command ${o}`);
								}
								return [v, S, b, I];
							}
							toGeoJSON(t, r, o) {
								const c = this.extent * Math.pow(2, o),
									f = this.extent * t,
									_ = this.extent * r,
									v = this.loadGeometry();
								function b(F) {
									return [
										(360 * (F.x + f)) / c - 180,
										(360 / Math.PI) *
											Math.atan(Math.exp((1 - (2 * (F.y + _)) / c) * Math.PI)) -
											90,
									];
								}
								function S(F) {
									return F.map(b);
								}
								let I;
								if (this.type === 1) {
									const F = [];
									for (const Z of v) F.push(Z[0]);
									const q = S(F);
									I =
										F.length === 1
											? { type: "Point", coordinates: q[0] }
											: { type: "MultiPoint", coordinates: q };
								} else if (this.type === 2) {
									const F = v.map(S);
									I =
										F.length === 1
											? { type: "LineString", coordinates: F[0] }
											: { type: "MultiLineString", coordinates: F };
								} else {
									if (this.type !== 3) throw new Error("unknown feature type");
									{
										const F = (function (Z) {
												const W = Z.length;
												if (W <= 1) return [Z];
												const J = [];
												let le, Re;
												for (let xe = 0; xe < W; xe++) {
													const Ce = ky(Z[xe]);
													Ce !== 0 &&
														(Re === void 0 && (Re = Ce < 0),
														Re === Ce < 0
															? (le && J.push(le), (le = [Z[xe]]))
															: le && le.push(Z[xe]));
												}
												return le && J.push(le), J;
											})(v),
											q = [];
										for (const Z of F) q.push(Z.map(S));
										I =
											q.length === 1
												? { type: "Polygon", coordinates: q[0] }
												: { type: "MultiPolygon", coordinates: q };
									}
								}
								const L = {
									type: "Feature",
									geometry: I,
									properties: this.properties,
								};
								return this.id != null && (L.id = this.id), L;
							}
						}
						function My(n, t, r) {
							n === 1
								? (t.id = r.readVarint())
								: n === 2
								? (function (o, c) {
										const f = o.readVarint() + o.pos;
										for (; o.pos < f; ) {
											const _ = c._keys[o.readVarint()],
												v = c._values[o.readVarint()];
											c.properties[_] = v;
										}
								  })(r, t)
								: n === 3
								? (t.type = r.readVarint())
								: n === 4 && (t._geometry = r.pos);
						}
						function ky(n) {
							let t = 0;
							for (let r, o, c = 0, f = n.length, _ = f - 1; c < f; _ = c++)
								(r = n[c]), (o = n[_]), (t += (o.x - r.x) * (r.y + o.y));
							return t;
						}
						ec.types = ["Unknown", "Point", "LineString", "Polygon"];
						class B_ {
							constructor(t, r) {
								(this.version = 1),
									(this.name = ""),
									(this.extent = 4096),
									(this.length = 0),
									(this._pbf = t),
									(this._keys = []),
									(this._values = []),
									(this._features = []),
									t.readFields(Ay, this, r),
									(this.length = this._features.length);
							}
							feature(t) {
								if (t < 0 || t >= this._features.length)
									throw new Error("feature index out of bounds");
								this._pbf.pos = this._features[t];
								const r = this._pbf.readVarint() + this._pbf.pos;
								return new ec(
									this._pbf,
									r,
									this.extent,
									this._keys,
									this._values
								);
							}
						}
						function Ay(n, t, r) {
							n === 15
								? (t.version = r.readVarint())
								: n === 1
								? (t.name = r.readString())
								: n === 5
								? (t.extent = r.readVarint())
								: n === 2
								? t._features.push(r.pos)
								: n === 3
								? t._keys.push(r.readString())
								: n === 4 &&
								  t._values.push(
										(function (o) {
											let c = null;
											const f = o.readVarint() + o.pos;
											for (; o.pos < f; ) {
												const _ = o.readVarint() >> 3;
												c =
													_ === 1
														? o.readString()
														: _ === 2
														? o.readFloat()
														: _ === 3
														? o.readDouble()
														: _ === 4
														? o.readVarint64()
														: _ === 5
														? o.readVarint()
														: _ === 6
														? o.readSVarint()
														: _ === 7
														? o.readBoolean()
														: null;
											}
											if (c == null) throw new Error("unknown feature value");
											return c;
										})(r)
								  );
						}
						class F_ {
							constructor(t, r) {
								this.layers = t.readFields(Ey, {}, r);
							}
						}
						function Ey(n, t, r) {
							if (n === 3) {
								const o = new B_(r, r.readVarint() + r.pos);
								o.length && (t[o.name] = o);
							}
						}
						const af = Math.pow(2, 13);
						function Su(n, t, r, o, c, f, _, v) {
							n.emplaceBack(
								t,
								r,
								2 * Math.floor(o * af) + _,
								c * af * 2,
								f * af * 2,
								Math.round(v)
							);
						}
						class of {
							constructor(t) {
								(this.zoom = t.zoom),
									(this.globalState = t.globalState),
									(this.overscaling = t.overscaling),
									(this.layers = t.layers),
									(this.layerIds = this.layers.map((r) => r.id)),
									(this.index = t.index),
									(this.hasPattern = !1),
									(this.layoutVertexArray = new Ge()),
									(this.centroidVertexArray = new _e()),
									(this.indexArray = new Rn()),
									(this.programConfigurations = new la(t.layers, t.zoom)),
									(this.segments = new Kr()),
									(this.stateDependentLayerIds = this.layers
										.filter((r) => r.isStateDependent())
										.map((r) => r.id));
							}
							populate(t, r, o) {
								(this.features = []),
									(this.hasPattern = Qp("fill-extrusion", this.layers, r));
								for (const {
									feature: c,
									id: f,
									index: _,
									sourceLayerIndex: v,
								} of t) {
									const b = this.layers[0]._featureFilter.needGeometry,
										S = no(c, b);
									if (
										!this.layers[0]._featureFilter.filter(
											new Un(this.zoom, { globalState: this.globalState }),
											S,
											o
										)
									)
										continue;
									const I = {
										id: f,
										sourceLayerIndex: v,
										index: _,
										geometry: b ? S.geometry : bo(c),
										properties: c.properties,
										type: c.type,
										patterns: {},
									};
									this.hasPattern
										? this.features.push(
												ef("fill-extrusion", this.layers, I, this.zoom, r)
										  )
										: this.addFeature(
												I,
												I.geometry,
												_,
												o,
												{},
												r.subdivisionGranularity
										  ),
										r.featureIndex.insert(c, I.geometry, _, v, this.index, !0);
								}
							}
							addFeatures(t, r, o) {
								for (const c of this.features) {
									const { geometry: f } = c;
									this.addFeature(
										c,
										f,
										c.index,
										r,
										o,
										t.subdivisionGranularity
									);
								}
							}
							update(t, r, o) {
								this.stateDependentLayers.length &&
									this.programConfigurations.updatePaintArrays(
										t,
										r,
										this.stateDependentLayers,
										o
									);
							}
							isEmpty() {
								return (
									this.layoutVertexArray.length === 0 &&
									this.centroidVertexArray.length === 0
								);
							}
							uploadPending() {
								return !this.uploaded || this.programConfigurations.needsUpload;
							}
							upload(t) {
								this.uploaded ||
									((this.layoutVertexBuffer = t.createVertexBuffer(
										this.layoutVertexArray,
										Iy
									)),
									(this.centroidVertexBuffer = t.createVertexBuffer(
										this.centroidVertexArray,
										Py.members,
										!0
									)),
									(this.indexBuffer = t.createIndexBuffer(this.indexArray))),
									this.programConfigurations.upload(t),
									(this.uploaded = !0);
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.programConfigurations.destroy(),
									this.segments.destroy(),
									this.centroidVertexBuffer.destroy());
							}
							addFeature(t, r, o, c, f, _) {
								for (const v of Os(r, 500)) {
									const b = { x: 0, y: 0, sampleCount: 0 },
										S = this.layoutVertexArray.length;
									this.processPolygon(b, c, t, v, _);
									const I = this.layoutVertexArray.length - S,
										L = Math.floor(b.x / b.sampleCount),
										F = Math.floor(b.y / b.sampleCount);
									for (let q = 0; q < I; q++)
										this.centroidVertexArray.emplaceBack(L, F);
								}
								this.programConfigurations.populatePaintArrays(
									this.layoutVertexArray.length,
									t,
									o,
									f,
									c
								);
							}
							processPolygon(t, r, o, c, f) {
								if (c.length < 1 || O_(c[0])) return;
								for (const L of c) L.length !== 0 && zy(t, L);
								const _ = {
										segment: this.segments.prepareSegment(
											4,
											this.layoutVertexArray,
											this.indexArray
										),
									},
									v = f.fill.getGranularityForZoomLevel(r.z),
									b = ec.types[o.type] === "Polygon";
								for (const L of c) {
									if (L.length === 0 || O_(L)) continue;
									const F = tl(L, v, b);
									this._generateSideFaces(F, _);
								}
								if (!b) return;
								const S = z_(c, r, v, !1),
									I = this.layoutVertexArray;
								L_(
									(L, F) => {
										Su(I, L, F, 0, 0, 1, 1, 0);
									},
									this.segments,
									this.layoutVertexArray,
									this.indexArray,
									S.verticesFlattened,
									S.indicesTriangles
								);
							}
							_generateSideFaces(t, r) {
								let o = 0;
								for (let c = 1; c < t.length; c++) {
									const f = t[c],
										_ = t[c - 1];
									if (Ly(f, _)) continue;
									r.segment.vertexLength + 4 > Kr.MAX_VERTEX_ARRAY_LENGTH &&
										(r.segment = this.segments.prepareSegment(
											4,
											this.layoutVertexArray,
											this.indexArray
										));
									const v = f.sub(_)._perp()._unit(),
										b = _.dist(f);
									o + b > 32768 && (o = 0),
										Su(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 0, o),
										Su(this.layoutVertexArray, f.x, f.y, v.x, v.y, 0, 1, o),
										(o += b),
										Su(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 0, o),
										Su(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 1, o);
									const S = r.segment.vertexLength;
									this.indexArray.emplaceBack(S, S + 2, S + 1),
										this.indexArray.emplaceBack(S + 1, S + 2, S + 3),
										(r.segment.vertexLength += 4),
										(r.segment.primitiveLength += 2);
								}
							}
						}
						function zy(n, t) {
							for (let r = 0; r < t.length; r++) {
								const o = t[r];
								(r === t.length - 1 && t[0].x === o.x && t[0].y === o.y) ||
									((n.x += o.x), (n.y += o.y), n.sampleCount++);
							}
						}
						function Ly(n, t) {
							return (
								(n.x === t.x && (n.x < 0 || n.x > oe)) ||
								(n.y === t.y && (n.y < 0 || n.y > oe))
							);
						}
						function O_(n) {
							return (
								n.every((t) => t.x < 0) ||
								n.every((t) => t.x > oe) ||
								n.every((t) => t.y < 0) ||
								n.every((t) => t.y > oe)
							);
						}
						let N_;
						ir("FillExtrusionBucket", of, { omit: ["layers", "features"] });
						var Dy = {
							get paint() {
								return (N_ =
									N_ ||
									new Ui({
										"fill-extrusion-opacity": new wr(
											ye["paint_fill-extrusion"]["fill-extrusion-opacity"]
										),
										"fill-extrusion-color": new Or(
											ye["paint_fill-extrusion"]["fill-extrusion-color"]
										),
										"fill-extrusion-translate": new wr(
											ye["paint_fill-extrusion"]["fill-extrusion-translate"]
										),
										"fill-extrusion-translate-anchor": new wr(
											ye["paint_fill-extrusion"][
												"fill-extrusion-translate-anchor"
											]
										),
										"fill-extrusion-pattern": new Zl(
											ye["paint_fill-extrusion"]["fill-extrusion-pattern"]
										),
										"fill-extrusion-height": new Or(
											ye["paint_fill-extrusion"]["fill-extrusion-height"]
										),
										"fill-extrusion-base": new Or(
											ye["paint_fill-extrusion"]["fill-extrusion-base"]
										),
										"fill-extrusion-vertical-gradient": new wr(
											ye["paint_fill-extrusion"][
												"fill-extrusion-vertical-gradient"
											]
										),
									}));
							},
						};
						class Ry extends xa {
							constructor(t) {
								super(t, Dy);
							}
							createBucket(t) {
								return new of(t);
							}
							queryRadius() {
								return Pd(this.paint.get("fill-extrusion-translate"));
							}
							is3D() {
								return !0;
							}
							queryIntersectsFeature({
								queryGeometry: t,
								feature: r,
								featureState: o,
								geometry: c,
								transform: f,
								pixelsToTileUnits: _,
								pixelPosMatrix: v,
							}) {
								const b = Id(
										t,
										this.paint.get("fill-extrusion-translate"),
										this.paint.get("fill-extrusion-translate-anchor"),
										-f.bearingInRadians,
										_
									),
									S = this.paint.get("fill-extrusion-height").evaluate(r, o),
									I = this.paint.get("fill-extrusion-base").evaluate(r, o),
									L = (function (q, Z) {
										const W = [];
										for (const J of q) {
											const le = [J.x, J.y, 0, 1];
											ke(le, le, Z),
												W.push(new B(le[0] / le[3], le[1] / le[3]));
										}
										return W;
									})(b, v),
									F = (function (q, Z, W, J) {
										const le = [],
											Re = [],
											xe = J[8] * Z,
											Ce = J[9] * Z,
											Ye = J[10] * Z,
											lt = J[11] * Z,
											Pt = J[8] * W,
											Yt = J[9] * W,
											qt = J[10] * W,
											Ht = J[11] * W;
										for (const Sr of q) {
											const Gt = [],
												Wt = [];
											for (const gt of Sr) {
												const Nr = gt.x,
													Hr = gt.y,
													kr = J[0] * Nr + J[4] * Hr + J[12],
													yr = J[1] * Nr + J[5] * Hr + J[13],
													dn = J[2] * Nr + J[6] * Hr + J[14],
													Qn = J[3] * Nr + J[7] * Hr + J[15],
													gi = dn + Ye,
													qi = Qn + lt,
													Ba = kr + Pt,
													ua = yr + Yt,
													Ri = dn + qt,
													Xn = Qn + Ht,
													Pi = new B((kr + xe) / qi, (yr + Ce) / qi);
												(Pi.z = gi / qi), Gt.push(Pi);
												const Bi = new B(Ba / Xn, ua / Xn);
												(Bi.z = Ri / Xn), Wt.push(Bi);
											}
											le.push(Gt), Re.push(Wt);
										}
										return [le, Re];
									})(c, I, S, v);
								return (function (q, Z, W) {
									let J = 1 / 0;
									p_(W, Z) && (J = j_(W, Z[0]));
									for (let le = 0; le < Z.length; le++) {
										const Re = Z[le],
											xe = q[le];
										for (let Ce = 0; Ce < Re.length - 1; Ce++) {
											const Ye = Re[Ce],
												lt = [Ye, Re[Ce + 1], xe[Ce + 1], xe[Ce], Ye];
											d_(W, lt) && (J = Math.min(J, j_(W, lt)));
										}
									}
									return J !== 1 / 0 && J;
								})(F[0], F[1], L);
							}
						}
						function Pu(n, t) {
							return n.x * t.x + n.y * t.y;
						}
						function j_(n, t) {
							if (n.length === 1) {
								let r = 0;
								const o = t[r++];
								let c;
								for (; !c || o.equals(c); )
									if (((c = t[r++]), !c)) return 1 / 0;
								for (; r < t.length; r++) {
									const f = t[r],
										_ = n[0],
										v = c.sub(o),
										b = f.sub(o),
										S = _.sub(o),
										I = Pu(v, v),
										L = Pu(v, b),
										F = Pu(b, b),
										q = Pu(S, v),
										Z = Pu(S, b),
										W = I * F - L * L,
										J = (F * q - L * Z) / W,
										le = (I * Z - L * q) / W,
										Re = o.z * (1 - J - le) + c.z * J + f.z * le;
									if (isFinite(Re)) return Re;
								}
								return 1 / 0;
							}
							{
								let r = 1 / 0;
								for (const o of t) r = Math.min(r, o.z);
								return r;
							}
						}
						const By = ti(
								[
									{ name: "a_pos_normal", components: 2, type: "Int16" },
									{ name: "a_data", components: 4, type: "Uint8" },
								],
								4
							),
							{ members: Fy } = By,
							Oy = ti([
								{ name: "a_uv_x", components: 1, type: "Float32" },
								{ name: "a_split_index", components: 1, type: "Float32" },
							]),
							{ members: Ny } = Oy,
							jy = Math.cos((Math.PI / 180) * 37.5),
							V_ = Math.pow(2, 14) / 0.5;
						class sf {
							constructor(t) {
								(this.zoom = t.zoom),
									(this.globalState = t.globalState),
									(this.overscaling = t.overscaling),
									(this.layers = t.layers),
									(this.layerIds = this.layers.map((r) => r.id)),
									(this.index = t.index),
									(this.hasPattern = !1),
									(this.patternFeatures = []),
									(this.lineClipsArray = []),
									(this.gradients = {}),
									this.layers.forEach((r) => {
										this.gradients[r.id] = {};
									}),
									(this.layoutVertexArray = new Xe()),
									(this.layoutVertexArray2 = new tt()),
									(this.indexArray = new Rn()),
									(this.programConfigurations = new la(t.layers, t.zoom)),
									(this.segments = new Kr()),
									(this.maxLineLength = 0),
									(this.stateDependentLayerIds = this.layers
										.filter((r) => r.isStateDependent())
										.map((r) => r.id));
							}
							populate(t, r, o) {
								this.hasPattern = Qp("line", this.layers, r);
								const c = this.layers[0].layout.get("line-sort-key"),
									f = !c.isConstant(),
									_ = [];
								for (const {
									feature: v,
									id: b,
									index: S,
									sourceLayerIndex: I,
								} of t) {
									const L = this.layers[0]._featureFilter.needGeometry,
										F = no(v, L);
									if (
										!this.layers[0]._featureFilter.filter(
											new Un(this.zoom, { globalState: this.globalState }),
											F,
											o
										)
									)
										continue;
									const q = f ? c.evaluate(F, {}, o) : void 0,
										Z = {
											id: b,
											properties: v.properties,
											type: v.type,
											sourceLayerIndex: I,
											index: S,
											geometry: L ? F.geometry : bo(v),
											patterns: {},
											sortKey: q,
										};
									_.push(Z);
								}
								f && _.sort((v, b) => v.sortKey - b.sortKey);
								for (const v of _) {
									const { geometry: b, index: S, sourceLayerIndex: I } = v;
									if (this.hasPattern) {
										const L = ef("line", this.layers, v, this.zoom, r);
										this.patternFeatures.push(L);
									} else
										this.addFeature(v, b, S, o, {}, r.subdivisionGranularity);
									r.featureIndex.insert(t[S].feature, b, S, I, this.index);
								}
							}
							update(t, r, o) {
								this.stateDependentLayers.length &&
									this.programConfigurations.updatePaintArrays(
										t,
										r,
										this.stateDependentLayers,
										o
									);
							}
							addFeatures(t, r, o) {
								for (const c of this.patternFeatures)
									this.addFeature(
										c,
										c.geometry,
										c.index,
										r,
										o,
										t.subdivisionGranularity
									);
							}
							isEmpty() {
								return this.layoutVertexArray.length === 0;
							}
							uploadPending() {
								return !this.uploaded || this.programConfigurations.needsUpload;
							}
							upload(t) {
								this.uploaded ||
									(this.layoutVertexArray2.length !== 0 &&
										(this.layoutVertexBuffer2 = t.createVertexBuffer(
											this.layoutVertexArray2,
											Ny
										)),
									(this.layoutVertexBuffer = t.createVertexBuffer(
										this.layoutVertexArray,
										Fy
									)),
									(this.indexBuffer = t.createIndexBuffer(this.indexArray))),
									this.programConfigurations.upload(t),
									(this.uploaded = !0);
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.programConfigurations.destroy(),
									this.segments.destroy());
							}
							lineFeatureClips(t) {
								if (
									t.properties &&
									Object.prototype.hasOwnProperty.call(
										t.properties,
										"mapbox_clip_start"
									) &&
									Object.prototype.hasOwnProperty.call(
										t.properties,
										"mapbox_clip_end"
									)
								)
									return {
										start: +t.properties.mapbox_clip_start,
										end: +t.properties.mapbox_clip_end,
									};
							}
							addFeature(t, r, o, c, f, _) {
								const v = this.layers[0].layout,
									b = v.get("line-join").evaluate(t, {}),
									S = v.get("line-cap"),
									I = v.get("line-miter-limit"),
									L = v.get("line-round-limit");
								this.lineClips = this.lineFeatureClips(t);
								for (const F of r) this.addLine(F, t, b, S, I, L, c, _);
								this.programConfigurations.populatePaintArrays(
									this.layoutVertexArray.length,
									t,
									o,
									f,
									c
								);
							}
							addLine(t, r, o, c, f, _, v, b) {
								if (
									((this.distance = 0),
									(this.scaledDistance = 0),
									(this.totalDistance = 0),
									(t = tl(t, v ? b.line.getGranularityForZoomLevel(v.z) : 1)),
									this.lineClips)
								) {
									this.lineClipsArray.push(this.lineClips);
									for (let xe = 0; xe < t.length - 1; xe++)
										this.totalDistance += t[xe].dist(t[xe + 1]);
									this.updateScaledDistance(),
										(this.maxLineLength = Math.max(
											this.maxLineLength,
											this.totalDistance
										));
								}
								const S = ec.types[r.type] === "Polygon";
								let I = t.length;
								for (; I >= 2 && t[I - 1].equals(t[I - 2]); ) I--;
								let L = 0;
								for (; L < I - 1 && t[L].equals(t[L + 1]); ) L++;
								if (I < (S ? 3 : 2)) return;
								o === "bevel" && (f = 1.05);
								const F =
										this.overscaling <= 16
											? 122880 / (512 * this.overscaling)
											: 0,
									q = this.segments.prepareSegment(
										10 * I,
										this.layoutVertexArray,
										this.indexArray
									);
								let Z, W, J, le, Re;
								(this.e1 = this.e2 = -1),
									S && ((Z = t[I - 2]), (Re = t[L].sub(Z)._unit()._perp()));
								for (let xe = L; xe < I; xe++) {
									if (
										((J = xe === I - 1 ? (S ? t[L + 1] : void 0) : t[xe + 1]),
										J && t[xe].equals(J))
									)
										continue;
									Re && (le = Re),
										Z && (W = Z),
										(Z = t[xe]),
										(Re = J ? J.sub(Z)._unit()._perp() : le),
										(le = le || Re);
									let Ce = le.add(Re);
									(Ce.x === 0 && Ce.y === 0) || Ce._unit();
									const Ye = le.x * Re.x + le.y * Re.y,
										lt = Ce.x * Re.x + Ce.y * Re.y,
										Pt = lt !== 0 ? 1 / lt : 1 / 0,
										Yt = 2 * Math.sqrt(2 - 2 * lt),
										qt = lt < jy && W && J,
										Ht = le.x * Re.y - le.y * Re.x > 0;
									if (qt && xe > L) {
										const Wt = Z.dist(W);
										if (Wt > 2 * F) {
											const gt = Z.sub(
												Z.sub(W)
													._mult(F / Wt)
													._round()
											);
											this.updateDistance(W, gt),
												this.addCurrentVertex(gt, le, 0, 0, q),
												(W = gt);
										}
									}
									const Sr = W && J;
									let Gt = Sr ? o : S ? "butt" : c;
									if (
										(Sr &&
											Gt === "round" &&
											(Pt < _ ? (Gt = "miter") : Pt <= 2 && (Gt = "fakeround")),
										Gt === "miter" && Pt > f && (Gt = "bevel"),
										Gt === "bevel" &&
											(Pt > 2 && (Gt = "flipbevel"), Pt < f && (Gt = "miter")),
										W && this.updateDistance(W, Z),
										Gt === "miter")
									)
										Ce._mult(Pt), this.addCurrentVertex(Z, Ce, 0, 0, q);
									else if (Gt === "flipbevel") {
										if (Pt > 100) Ce = Re.mult(-1);
										else {
											const Wt = (Pt * le.add(Re).mag()) / le.sub(Re).mag();
											Ce._perp()._mult(Wt * (Ht ? -1 : 1));
										}
										this.addCurrentVertex(Z, Ce, 0, 0, q),
											this.addCurrentVertex(Z, Ce.mult(-1), 0, 0, q);
									} else if (Gt === "bevel" || Gt === "fakeround") {
										const Wt = -Math.sqrt(Pt * Pt - 1),
											gt = Ht ? Wt : 0,
											Nr = Ht ? 0 : Wt;
										if (
											(W && this.addCurrentVertex(Z, le, gt, Nr, q),
											Gt === "fakeround")
										) {
											const Hr = Math.round((180 * Yt) / Math.PI / 20);
											for (let kr = 1; kr < Hr; kr++) {
												let yr = kr / Hr;
												if (yr !== 0.5) {
													const Qn = yr - 0.5;
													yr +=
														yr *
														Qn *
														(yr - 1) *
														((1.0904 +
															Ye * (Ye * (3.55645 - 1.43519 * Ye) - 3.2452)) *
															Qn *
															Qn +
															(0.848013 + Ye * (0.215638 * Ye - 1.06021)));
												}
												const dn = Re.sub(le)
													._mult(yr)
													._add(le)
													._unit()
													._mult(Ht ? -1 : 1);
												this.addHalfVertex(Z, dn.x, dn.y, !1, Ht, 0, q);
											}
										}
										J && this.addCurrentVertex(Z, Re, -gt, -Nr, q);
									} else if (Gt === "butt")
										this.addCurrentVertex(Z, Ce, 0, 0, q);
									else if (Gt === "square") {
										const Wt = W ? 1 : -1;
										this.addCurrentVertex(Z, Ce, Wt, Wt, q);
									} else
										Gt === "round" &&
											(W &&
												(this.addCurrentVertex(Z, le, 0, 0, q),
												this.addCurrentVertex(Z, le, 1, 1, q, !0)),
											J &&
												(this.addCurrentVertex(Z, Re, -1, -1, q, !0),
												this.addCurrentVertex(Z, Re, 0, 0, q)));
									if (qt && xe < I - 1) {
										const Wt = Z.dist(J);
										if (Wt > 2 * F) {
											const gt = Z.add(
												J.sub(Z)
													._mult(F / Wt)
													._round()
											);
											this.updateDistance(Z, gt),
												this.addCurrentVertex(gt, Re, 0, 0, q),
												(Z = gt);
										}
									}
								}
							}
							addCurrentVertex(t, r, o, c, f, _ = !1) {
								const v = r.y * c - r.x,
									b = -r.y - r.x * c;
								this.addHalfVertex(
									t,
									r.x + r.y * o,
									r.y - r.x * o,
									_,
									!1,
									o,
									f
								),
									this.addHalfVertex(t, v, b, _, !0, -c, f),
									this.distance > V_ / 2 &&
										this.totalDistance === 0 &&
										((this.distance = 0),
										this.updateScaledDistance(),
										this.addCurrentVertex(t, r, o, c, f, _));
							}
							addHalfVertex({ x: t, y: r }, o, c, f, _, v, b) {
								const S =
									0.5 *
									(this.lineClips
										? this.scaledDistance * (V_ - 1)
										: this.scaledDistance);
								this.layoutVertexArray.emplaceBack(
									(t << 1) + (f ? 1 : 0),
									(r << 1) + (_ ? 1 : 0),
									Math.round(63 * o) + 128,
									Math.round(63 * c) + 128,
									(1 + (v === 0 ? 0 : v < 0 ? -1 : 1)) | ((63 & S) << 2),
									S >> 6
								),
									this.lineClips &&
										this.layoutVertexArray2.emplaceBack(
											(this.scaledDistance - this.lineClips.start) /
												(this.lineClips.end - this.lineClips.start),
											this.lineClipsArray.length
										);
								const I = b.vertexLength++;
								this.e1 >= 0 &&
									this.e2 >= 0 &&
									(this.indexArray.emplaceBack(this.e1, I, this.e2),
									b.primitiveLength++),
									_ ? (this.e2 = I) : (this.e1 = I);
							}
							updateScaledDistance() {
								this.scaledDistance = this.lineClips
									? this.lineClips.start +
									  ((this.lineClips.end - this.lineClips.start) *
											this.distance) /
											this.totalDistance
									: this.distance;
							}
							updateDistance(t, r) {
								(this.distance += t.dist(r)), this.updateScaledDistance();
							}
						}
						let q_, Z_;
						ir("LineBucket", sf, { omit: ["layers", "patternFeatures"] });
						var U_ = {
							get paint() {
								return (Z_ =
									Z_ ||
									new Ui({
										"line-opacity": new Or(ye.paint_line["line-opacity"]),
										"line-color": new Or(ye.paint_line["line-color"]),
										"line-translate": new wr(ye.paint_line["line-translate"]),
										"line-translate-anchor": new wr(
											ye.paint_line["line-translate-anchor"]
										),
										"line-width": new Or(ye.paint_line["line-width"]),
										"line-gap-width": new Or(ye.paint_line["line-gap-width"]),
										"line-offset": new Or(ye.paint_line["line-offset"]),
										"line-blur": new Or(ye.paint_line["line-blur"]),
										"line-dasharray": new _o(ye.paint_line["line-dasharray"]),
										"line-pattern": new Zl(ye.paint_line["line-pattern"]),
										"line-gradient": new Ul(ye.paint_line["line-gradient"]),
									}));
							},
							get layout() {
								return (q_ =
									q_ ||
									new Ui({
										"line-cap": new wr(ye.layout_line["line-cap"]),
										"line-join": new Or(ye.layout_line["line-join"]),
										"line-miter-limit": new wr(
											ye.layout_line["line-miter-limit"]
										),
										"line-round-limit": new wr(
											ye.layout_line["line-round-limit"]
										),
										"line-sort-key": new Or(ye.layout_line["line-sort-key"]),
									}));
							},
						};
						class Vy extends Or {
							possiblyEvaluate(t, r) {
								return (
									(r = new Un(Math.floor(r.zoom), {
										now: r.now,
										fadeDuration: r.fadeDuration,
										zoomHistory: r.zoomHistory,
										transition: r.transition,
									})),
									super.possiblyEvaluate(t, r)
								);
							}
							evaluate(t, r, o, c) {
								return (
									(r = dt({}, r, { zoom: Math.floor(r.zoom) })),
									super.evaluate(t, r, o, c)
								);
							}
						}
						let Ed;
						class qy extends xa {
							constructor(t) {
								super(t, U_),
									(this.gradientVersion = 0),
									Ed ||
										((Ed = new Vy(
											U_.paint.properties["line-width"].specification
										)),
										(Ed.useIntegerZoom = !0));
							}
							_handleSpecialPaintPropertyUpdate(t) {
								if (t === "line-gradient") {
									const r = this.gradientExpression();
									(this.stepInterpolant =
										!!(function (o) {
											return o._styleExpression !== void 0;
										})(r) && r._styleExpression.expression instanceof ei),
										(this.gradientVersion =
											(this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
								}
							}
							gradientExpression() {
								return this
									._transitionablePaint._values["line-gradient"].value.expression;
							}
							recalculate(t, r) {
								super.recalculate(t, r),
									(this.paint._values["line-floorwidth"] = Ed.possiblyEvaluate(
										this._transitioningPaint._values["line-width"].value,
										t
									));
							}
							createBucket(t) {
								return new sf(t);
							}
							queryRadius(t) {
								const r = t,
									o = $_(
										gu("line-width", this, r),
										gu("line-gap-width", this, r)
									),
									c = gu("line-offset", this, r);
								return (
									o / 2 + Math.abs(c) + Pd(this.paint.get("line-translate"))
								);
							}
							queryIntersectsFeature({
								queryGeometry: t,
								feature: r,
								featureState: o,
								geometry: c,
								transform: f,
								pixelsToTileUnits: _,
							}) {
								const v = Id(
										t,
										this.paint.get("line-translate"),
										this.paint.get("line-translate-anchor"),
										-f.bearingInRadians,
										_
									),
									b =
										(_ / 2) *
										$_(
											this.paint.get("line-width").evaluate(r, o),
											this.paint.get("line-gap-width").evaluate(r, o)
										),
									S = this.paint.get("line-offset").evaluate(r, o);
								return (
									S &&
										(c = (function (I, L) {
											const F = [];
											for (let q = 0; q < I.length; q++) {
												const Z = I[q],
													W = [];
												for (let J = 0; J < Z.length; J++) {
													const le = Z[J - 1],
														Re = Z[J],
														xe = Z[J + 1],
														Ce =
															J === 0
																? new B(0, 0)
																: Re.sub(le)._unit()._perp(),
														Ye =
															J === Z.length - 1
																? new B(0, 0)
																: xe.sub(Re)._unit()._perp(),
														lt = Ce._add(Ye)._unit(),
														Pt = lt.x * Ye.x + lt.y * Ye.y;
													Pt !== 0 && lt._mult(1 / Pt),
														W.push(lt._mult(L)._add(Re));
												}
												F.push(W);
											}
											return F;
										})(c, S * _)),
									(function (I, L, F) {
										for (let q = 0; q < L.length; q++) {
											const Z = L[q];
											if (I.length >= 3) {
												for (let W = 0; W < Z.length; W++)
													if (Yl(I, Z[W])) return !0;
											}
											if (Q0(I, Z, F)) return !0;
										}
										return !1;
									})(v, c, b)
								);
							}
							isTileClipped() {
								return !0;
							}
						}
						function $_(n, t) {
							return t > 0 ? t + 2 * n : n;
						}
						const Zy = ti(
								[
									{ name: "a_pos_offset", components: 4, type: "Int16" },
									{ name: "a_data", components: 4, type: "Uint16" },
									{ name: "a_pixeloffset", components: 4, type: "Int16" },
								],
								4
							),
							Uy = ti(
								[{ name: "a_projected_pos", components: 3, type: "Float32" }],
								4
							);
						ti([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
						const $y = ti([
							{ name: "a_placed", components: 2, type: "Uint8" },
							{ name: "a_shift", components: 2, type: "Float32" },
							{ name: "a_box_real", components: 2, type: "Int16" },
						]);
						ti([
							{ type: "Int16", name: "anchorPointX" },
							{ type: "Int16", name: "anchorPointY" },
							{ type: "Int16", name: "x1" },
							{ type: "Int16", name: "y1" },
							{ type: "Int16", name: "x2" },
							{ type: "Int16", name: "y2" },
							{ type: "Uint32", name: "featureIndex" },
							{ type: "Uint16", name: "sourceLayerIndex" },
							{ type: "Uint16", name: "bucketIndex" },
						]);
						const G_ = ti(
								[
									{ name: "a_pos", components: 2, type: "Int16" },
									{ name: "a_anchor_pos", components: 2, type: "Int16" },
									{ name: "a_extrude", components: 2, type: "Int16" },
								],
								4
							),
							Gy = ti(
								[
									{ name: "a_pos", components: 2, type: "Float32" },
									{ name: "a_radius", components: 1, type: "Float32" },
									{ name: "a_flags", components: 2, type: "Int16" },
								],
								4
							);
						function Hy(n, t, r) {
							return (
								n.sections.forEach((o) => {
									o.text = (function (c, f, _) {
										const v = f.layout.get("text-transform").evaluate(_, {});
										return (
											v === "uppercase"
												? (c = c.toLocaleUpperCase())
												: v === "lowercase" && (c = c.toLocaleLowerCase()),
											Ea.applyArabicShaping && (c = Ea.applyArabicShaping(c)),
											c
										);
									})(o.text, t, r);
								}),
								n
							);
						}
						ti([{ name: "triangle", components: 3, type: "Uint16" }]),
							ti([
								{ type: "Int16", name: "anchorX" },
								{ type: "Int16", name: "anchorY" },
								{ type: "Uint16", name: "glyphStartIndex" },
								{ type: "Uint16", name: "numGlyphs" },
								{ type: "Uint32", name: "vertexStartIndex" },
								{ type: "Uint32", name: "lineStartIndex" },
								{ type: "Uint32", name: "lineLength" },
								{ type: "Uint16", name: "segment" },
								{ type: "Uint16", name: "lowerSize" },
								{ type: "Uint16", name: "upperSize" },
								{ type: "Float32", name: "lineOffsetX" },
								{ type: "Float32", name: "lineOffsetY" },
								{ type: "Uint8", name: "writingMode" },
								{ type: "Uint8", name: "placedOrientation" },
								{ type: "Uint8", name: "hidden" },
								{ type: "Uint32", name: "crossTileID" },
								{ type: "Int16", name: "associatedIconIndex" },
							]),
							ti([
								{ type: "Int16", name: "anchorX" },
								{ type: "Int16", name: "anchorY" },
								{ type: "Int16", name: "rightJustifiedTextSymbolIndex" },
								{ type: "Int16", name: "centerJustifiedTextSymbolIndex" },
								{ type: "Int16", name: "leftJustifiedTextSymbolIndex" },
								{ type: "Int16", name: "verticalPlacedTextSymbolIndex" },
								{ type: "Int16", name: "placedIconSymbolIndex" },
								{ type: "Int16", name: "verticalPlacedIconSymbolIndex" },
								{ type: "Uint16", name: "key" },
								{ type: "Uint16", name: "textBoxStartIndex" },
								{ type: "Uint16", name: "textBoxEndIndex" },
								{ type: "Uint16", name: "verticalTextBoxStartIndex" },
								{ type: "Uint16", name: "verticalTextBoxEndIndex" },
								{ type: "Uint16", name: "iconBoxStartIndex" },
								{ type: "Uint16", name: "iconBoxEndIndex" },
								{ type: "Uint16", name: "verticalIconBoxStartIndex" },
								{ type: "Uint16", name: "verticalIconBoxEndIndex" },
								{ type: "Uint16", name: "featureIndex" },
								{ type: "Uint16", name: "numHorizontalGlyphVertices" },
								{ type: "Uint16", name: "numVerticalGlyphVertices" },
								{ type: "Uint16", name: "numIconVertices" },
								{ type: "Uint16", name: "numVerticalIconVertices" },
								{ type: "Uint16", name: "useRuntimeCollisionCircles" },
								{ type: "Uint32", name: "crossTileID" },
								{ type: "Float32", name: "textBoxScale" },
								{ type: "Float32", name: "collisionCircleDiameter" },
								{ type: "Uint16", name: "textAnchorOffsetStartIndex" },
								{ type: "Uint16", name: "textAnchorOffsetEndIndex" },
							]),
							ti([{ type: "Float32", name: "offsetX" }]),
							ti([
								{ type: "Int16", name: "x" },
								{ type: "Int16", name: "y" },
								{ type: "Int16", name: "tileUnitDistanceFromAnchor" },
							]),
							ti([
								{ type: "Uint16", name: "textAnchor" },
								{ type: "Float32", components: 2, name: "textOffset" },
							]);
						const Iu = {
							"!": "︕",
							"#": "＃",
							$: "＄",
							"%": "％",
							"&": "＆",
							"(": "︵",
							")": "︶",
							"*": "＊",
							"+": "＋",
							",": "︐",
							"-": "︲",
							".": "・",
							"/": "／",
							":": "︓",
							";": "︔",
							"<": "︿",
							"=": "＝",
							">": "﹀",
							"?": "︖",
							"@": "＠",
							"[": "﹇",
							"\\": "＼",
							"]": "﹈",
							"^": "＾",
							_: "︳",
							"`": "｀",
							"{": "︷",
							"|": "―",
							"}": "︸",
							"~": "～",
							"¢": "￠",
							"£": "￡",
							"¥": "￥",
							"¦": "￤",
							"¬": "￢",
							"¯": "￣",
							"–": "︲",
							"—": "︱",
							"‘": "﹃",
							"’": "﹄",
							"“": "﹁",
							"”": "﹂",
							"…": "︙",
							"‧": "・",
							"₩": "￦",
							"、": "︑",
							"。": "︒",
							"〈": "︿",
							"〉": "﹀",
							"《": "︽",
							"》": "︾",
							"「": "﹁",
							"」": "﹂",
							"『": "﹃",
							"』": "﹄",
							"【": "︻",
							"】": "︼",
							"〔": "︹",
							"〕": "︺",
							"〖": "︗",
							"〗": "︘",
							"！": "︕",
							"（": "︵",
							"）": "︶",
							"，": "︐",
							"－": "︲",
							"．": "・",
							"：": "︓",
							"；": "︔",
							"＜": "︿",
							"＞": "﹀",
							"？": "︖",
							"［": "﹇",
							"］": "﹈",
							"＿": "︳",
							"｛": "︷",
							"｜": "―",
							"｝": "︸",
							"｟": "︵",
							"｠": "︶",
							"｡": "︒",
							"｢": "﹁",
							"｣": "﹂",
						};
						var Si = 24;
						const lf = 4294967296,
							H_ = 1 / lf,
							W_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
						class cf {
							constructor(t = new Uint8Array(16)) {
								(this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t)),
									(this.dataView = new DataView(this.buf.buffer)),
									(this.pos = 0),
									(this.type = 0),
									(this.length = this.buf.length);
							}
							readFields(t, r, o = this.length) {
								for (; this.pos < o; ) {
									const c = this.readVarint(),
										f = c >> 3,
										_ = this.pos;
									(this.type = 7 & c),
										t(f, r, this),
										this.pos === _ && this.skip(c);
								}
								return r;
							}
							readMessage(t, r) {
								return this.readFields(t, r, this.readVarint() + this.pos);
							}
							readFixed32() {
								const t = this.dataView.getUint32(this.pos, !0);
								return (this.pos += 4), t;
							}
							readSFixed32() {
								const t = this.dataView.getInt32(this.pos, !0);
								return (this.pos += 4), t;
							}
							readFixed64() {
								const t =
									this.dataView.getUint32(this.pos, !0) +
									this.dataView.getUint32(this.pos + 4, !0) * lf;
								return (this.pos += 8), t;
							}
							readSFixed64() {
								const t =
									this.dataView.getUint32(this.pos, !0) +
									this.dataView.getInt32(this.pos + 4, !0) * lf;
								return (this.pos += 8), t;
							}
							readFloat() {
								const t = this.dataView.getFloat32(this.pos, !0);
								return (this.pos += 4), t;
							}
							readDouble() {
								const t = this.dataView.getFloat64(this.pos, !0);
								return (this.pos += 8), t;
							}
							readVarint(t) {
								const r = this.buf;
								let o, c;
								return (
									(c = r[this.pos++]),
									(o = 127 & c),
									c < 128
										? o
										: ((c = r[this.pos++]),
										  (o |= (127 & c) << 7),
										  c < 128
												? o
												: ((c = r[this.pos++]),
												  (o |= (127 & c) << 14),
												  c < 128
														? o
														: ((c = r[this.pos++]),
														  (o |= (127 & c) << 21),
														  c < 128
																? o
																: ((c = r[this.pos]),
																  (o |= (15 & c) << 28),
																  (function (f, _, v) {
																		const b = v.buf;
																		let S, I;
																		if (
																			((I = b[v.pos++]),
																			(S = (112 & I) >> 4),
																			I < 128 ||
																				((I = b[v.pos++]),
																				(S |= (127 & I) << 3),
																				I < 128) ||
																				((I = b[v.pos++]),
																				(S |= (127 & I) << 10),
																				I < 128) ||
																				((I = b[v.pos++]),
																				(S |= (127 & I) << 17),
																				I < 128) ||
																				((I = b[v.pos++]),
																				(S |= (127 & I) << 24),
																				I < 128) ||
																				((I = b[v.pos++]),
																				(S |= (1 & I) << 31),
																				I < 128))
																		)
																			return tc(f, S, _);
																		throw new Error(
																			"Expected varint not more than 10 bytes"
																		);
																  })(o, t, this)))))
								);
							}
							readVarint64() {
								return this.readVarint(!0);
							}
							readSVarint() {
								const t = this.readVarint();
								return t % 2 == 1 ? (t + 1) / -2 : t / 2;
							}
							readBoolean() {
								return !!this.readVarint();
							}
							readString() {
								const t = this.readVarint() + this.pos,
									r = this.pos;
								return (
									(this.pos = t),
									t - r >= 12 && W_
										? W_.decode(this.buf.subarray(r, t))
										: (function (o, c, f) {
												let _ = "",
													v = c;
												for (; v < f; ) {
													const b = o[v];
													let S,
														I,
														L,
														F = null,
														q = b > 239 ? 4 : b > 223 ? 3 : b > 191 ? 2 : 1;
													if (v + q > f) break;
													q === 1
														? b < 128 && (F = b)
														: q === 2
														? ((S = o[v + 1]),
														  (192 & S) == 128 &&
																((F = ((31 & b) << 6) | (63 & S)),
																F <= 127 && (F = null)))
														: q === 3
														? ((S = o[v + 1]),
														  (I = o[v + 2]),
														  (192 & S) == 128 &&
																(192 & I) == 128 &&
																((F =
																	((15 & b) << 12) |
																	((63 & S) << 6) |
																	(63 & I)),
																(F <= 2047 || (F >= 55296 && F <= 57343)) &&
																	(F = null)))
														: q === 4 &&
														  ((S = o[v + 1]),
														  (I = o[v + 2]),
														  (L = o[v + 3]),
														  (192 & S) == 128 &&
																(192 & I) == 128 &&
																(192 & L) == 128 &&
																((F =
																	((15 & b) << 18) |
																	((63 & S) << 12) |
																	((63 & I) << 6) |
																	(63 & L)),
																(F <= 65535 || F >= 1114112) && (F = null))),
														F === null
															? ((F = 65533), (q = 1))
															: F > 65535 &&
															  ((F -= 65536),
															  (_ += String.fromCharCode(
																	((F >>> 10) & 1023) | 55296
															  )),
															  (F = 56320 | (1023 & F))),
														(_ += String.fromCharCode(F)),
														(v += q);
												}
												return _;
										  })(this.buf, r, t)
								);
							}
							readBytes() {
								const t = this.readVarint() + this.pos,
									r = this.buf.subarray(this.pos, t);
								return (this.pos = t), r;
							}
							readPackedVarint(t = [], r) {
								const o = this.readPackedEnd();
								for (; this.pos < o; ) t.push(this.readVarint(r));
								return t;
							}
							readPackedSVarint(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readSVarint());
								return t;
							}
							readPackedBoolean(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readBoolean());
								return t;
							}
							readPackedFloat(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readFloat());
								return t;
							}
							readPackedDouble(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readDouble());
								return t;
							}
							readPackedFixed32(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readFixed32());
								return t;
							}
							readPackedSFixed32(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readSFixed32());
								return t;
							}
							readPackedFixed64(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readFixed64());
								return t;
							}
							readPackedSFixed64(t = []) {
								const r = this.readPackedEnd();
								for (; this.pos < r; ) t.push(this.readSFixed64());
								return t;
							}
							readPackedEnd() {
								return this.type === 2
									? this.readVarint() + this.pos
									: this.pos + 1;
							}
							skip(t) {
								const r = 7 & t;
								if (r === 0) for (; this.buf[this.pos++] > 127; );
								else if (r === 2) this.pos = this.readVarint() + this.pos;
								else if (r === 5) this.pos += 4;
								else {
									if (r !== 1) throw new Error(`Unimplemented type: ${r}`);
									this.pos += 8;
								}
							}
							writeTag(t, r) {
								this.writeVarint((t << 3) | r);
							}
							realloc(t) {
								let r = this.length || 16;
								for (; r < this.pos + t; ) r *= 2;
								if (r !== this.length) {
									const o = new Uint8Array(r);
									o.set(this.buf),
										(this.buf = o),
										(this.dataView = new DataView(o.buffer)),
										(this.length = r);
								}
							}
							finish() {
								return (
									(this.length = this.pos),
									(this.pos = 0),
									this.buf.subarray(0, this.length)
								);
							}
							writeFixed32(t) {
								this.realloc(4),
									this.dataView.setInt32(this.pos, t, !0),
									(this.pos += 4);
							}
							writeSFixed32(t) {
								this.realloc(4),
									this.dataView.setInt32(this.pos, t, !0),
									(this.pos += 4);
							}
							writeFixed64(t) {
								this.realloc(8),
									this.dataView.setInt32(this.pos, -1 & t, !0),
									this.dataView.setInt32(this.pos + 4, Math.floor(t * H_), !0),
									(this.pos += 8);
							}
							writeSFixed64(t) {
								this.realloc(8),
									this.dataView.setInt32(this.pos, -1 & t, !0),
									this.dataView.setInt32(this.pos + 4, Math.floor(t * H_), !0),
									(this.pos += 8);
							}
							writeVarint(t) {
								(t = +t || 0) > 268435455 || t < 0
									? (function (r, o) {
											let c, f;
											if (
												(r >= 0
													? ((c = r % 4294967296 | 0),
													  (f = (r / 4294967296) | 0))
													: ((c = ~(-r % 4294967296)),
													  (f = ~(-r / 4294967296)),
													  4294967295 ^ c
															? (c = (c + 1) | 0)
															: ((c = 0), (f = (f + 1) | 0))),
												r >= 18446744073709552e3 || r < -18446744073709552e3)
											)
												throw new Error(
													"Given varint doesn't fit into 10 bytes"
												);
											o.realloc(10),
												(function (_, v, b) {
													(b.buf[b.pos++] = (127 & _) | 128),
														(_ >>>= 7),
														(b.buf[b.pos++] = (127 & _) | 128),
														(_ >>>= 7),
														(b.buf[b.pos++] = (127 & _) | 128),
														(_ >>>= 7),
														(b.buf[b.pos++] = (127 & _) | 128),
														(b.buf[b.pos] = 127 & (_ >>>= 7));
												})(c, 0, o),
												(function (_, v) {
													const b = (7 & _) << 4;
													(v.buf[v.pos++] |= b | ((_ >>>= 3) ? 128 : 0)),
														_ &&
															((v.buf[v.pos++] =
																(127 & _) | ((_ >>>= 7) ? 128 : 0)),
															_ &&
																((v.buf[v.pos++] =
																	(127 & _) | ((_ >>>= 7) ? 128 : 0)),
																_ &&
																	((v.buf[v.pos++] =
																		(127 & _) | ((_ >>>= 7) ? 128 : 0)),
																	_ &&
																		((v.buf[v.pos++] =
																			(127 & _) | ((_ >>>= 7) ? 128 : 0)),
																		_ && (v.buf[v.pos++] = 127 & _)))));
												})(f, o);
									  })(t, this)
									: (this.realloc(4),
									  (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
									  t <= 127 ||
											((this.buf[this.pos++] =
												(127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
											t <= 127 ||
												((this.buf[this.pos++] =
													(127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
												t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
							}
							writeSVarint(t) {
								this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
							}
							writeBoolean(t) {
								this.writeVarint(+t);
							}
							writeString(t) {
								(t = String(t)), this.realloc(4 * t.length), this.pos++;
								const r = this.pos;
								this.pos = (function (c, f, _) {
									for (let v, b, S = 0; S < f.length; S++) {
										if (((v = f.charCodeAt(S)), v > 55295 && v < 57344)) {
											if (!b) {
												v > 56319 || S + 1 === f.length
													? ((c[_++] = 239), (c[_++] = 191), (c[_++] = 189))
													: (b = v);
												continue;
											}
											if (v < 56320) {
												(c[_++] = 239), (c[_++] = 191), (c[_++] = 189), (b = v);
												continue;
											}
											(v = ((b - 55296) << 10) | (v - 56320) | 65536),
												(b = null);
										} else
											b &&
												((c[_++] = 239),
												(c[_++] = 191),
												(c[_++] = 189),
												(b = null));
										v < 128
											? (c[_++] = v)
											: (v < 2048
													? (c[_++] = (v >> 6) | 192)
													: (v < 65536
															? (c[_++] = (v >> 12) | 224)
															: ((c[_++] = (v >> 18) | 240),
															  (c[_++] = ((v >> 12) & 63) | 128)),
													  (c[_++] = ((v >> 6) & 63) | 128)),
											  (c[_++] = (63 & v) | 128));
									}
									return _;
								})(this.buf, t, this.pos);
								const o = this.pos - r;
								o >= 128 && X_(r, o, this),
									(this.pos = r - 1),
									this.writeVarint(o),
									(this.pos += o);
							}
							writeFloat(t) {
								this.realloc(4),
									this.dataView.setFloat32(this.pos, t, !0),
									(this.pos += 4);
							}
							writeDouble(t) {
								this.realloc(8),
									this.dataView.setFloat64(this.pos, t, !0),
									(this.pos += 8);
							}
							writeBytes(t) {
								const r = t.length;
								this.writeVarint(r), this.realloc(r);
								for (let o = 0; o < r; o++) this.buf[this.pos++] = t[o];
							}
							writeRawMessage(t, r) {
								this.pos++;
								const o = this.pos;
								t(r, this);
								const c = this.pos - o;
								c >= 128 && X_(o, c, this),
									(this.pos = o - 1),
									this.writeVarint(c),
									(this.pos += c);
							}
							writeMessage(t, r, o) {
								this.writeTag(t, 2), this.writeRawMessage(r, o);
							}
							writePackedVarint(t, r) {
								r.length && this.writeMessage(t, Wy, r);
							}
							writePackedSVarint(t, r) {
								r.length && this.writeMessage(t, Xy, r);
							}
							writePackedBoolean(t, r) {
								r.length && this.writeMessage(t, Jy, r);
							}
							writePackedFloat(t, r) {
								r.length && this.writeMessage(t, Yy, r);
							}
							writePackedDouble(t, r) {
								r.length && this.writeMessage(t, Ky, r);
							}
							writePackedFixed32(t, r) {
								r.length && this.writeMessage(t, Qy, r);
							}
							writePackedSFixed32(t, r) {
								r.length && this.writeMessage(t, e1, r);
							}
							writePackedFixed64(t, r) {
								r.length && this.writeMessage(t, t1, r);
							}
							writePackedSFixed64(t, r) {
								r.length && this.writeMessage(t, r1, r);
							}
							writeBytesField(t, r) {
								this.writeTag(t, 2), this.writeBytes(r);
							}
							writeFixed32Field(t, r) {
								this.writeTag(t, 5), this.writeFixed32(r);
							}
							writeSFixed32Field(t, r) {
								this.writeTag(t, 5), this.writeSFixed32(r);
							}
							writeFixed64Field(t, r) {
								this.writeTag(t, 1), this.writeFixed64(r);
							}
							writeSFixed64Field(t, r) {
								this.writeTag(t, 1), this.writeSFixed64(r);
							}
							writeVarintField(t, r) {
								this.writeTag(t, 0), this.writeVarint(r);
							}
							writeSVarintField(t, r) {
								this.writeTag(t, 0), this.writeSVarint(r);
							}
							writeStringField(t, r) {
								this.writeTag(t, 2), this.writeString(r);
							}
							writeFloatField(t, r) {
								this.writeTag(t, 5), this.writeFloat(r);
							}
							writeDoubleField(t, r) {
								this.writeTag(t, 1), this.writeDouble(r);
							}
							writeBooleanField(t, r) {
								this.writeVarintField(t, +r);
							}
						}
						function tc(n, t, r) {
							return r
								? 4294967296 * t + (n >>> 0)
								: 4294967296 * (t >>> 0) + (n >>> 0);
						}
						function X_(n, t, r) {
							const o =
								t <= 16383
									? 1
									: t <= 2097151
									? 2
									: t <= 268435455
									? 3
									: Math.floor(Math.log(t) / (7 * Math.LN2));
							r.realloc(o);
							for (let c = r.pos - 1; c >= n; c--) r.buf[c + o] = r.buf[c];
						}
						function Wy(n, t) {
							for (let r = 0; r < n.length; r++) t.writeVarint(n[r]);
						}
						function Xy(n, t) {
							for (let r = 0; r < n.length; r++) t.writeSVarint(n[r]);
						}
						function Yy(n, t) {
							for (let r = 0; r < n.length; r++) t.writeFloat(n[r]);
						}
						function Ky(n, t) {
							for (let r = 0; r < n.length; r++) t.writeDouble(n[r]);
						}
						function Jy(n, t) {
							for (let r = 0; r < n.length; r++) t.writeBoolean(n[r]);
						}
						function Qy(n, t) {
							for (let r = 0; r < n.length; r++) t.writeFixed32(n[r]);
						}
						function e1(n, t) {
							for (let r = 0; r < n.length; r++) t.writeSFixed32(n[r]);
						}
						function t1(n, t) {
							for (let r = 0; r < n.length; r++) t.writeFixed64(n[r]);
						}
						function r1(n, t) {
							for (let r = 0; r < n.length; r++) t.writeSFixed64(n[r]);
						}
						function n1(n, t, r) {
							n === 1 && r.readMessage(i1, t);
						}
						function i1(n, t, r) {
							if (n === 3) {
								const {
									id: o,
									bitmap: c,
									width: f,
									height: _,
									left: v,
									top: b,
									advance: S,
								} = r.readMessage(a1, {});
								t.push({
									id: o,
									bitmap: new vu({ width: f + 6, height: _ + 6 }, c),
									metrics: { width: f, height: _, left: v, top: b, advance: S },
								});
							}
						}
						function a1(n, t, r) {
							n === 1
								? (t.id = r.readVarint())
								: n === 2
								? (t.bitmap = r.readBytes())
								: n === 3
								? (t.width = r.readVarint())
								: n === 4
								? (t.height = r.readVarint())
								: n === 5
								? (t.left = r.readSVarint())
								: n === 6
								? (t.top = r.readSVarint())
								: n === 7 && (t.advance = r.readVarint());
						}
						function Y_(n) {
							let t = 0,
								r = 0;
							for (const _ of n) (t += _.w * _.h), (r = Math.max(r, _.w));
							n.sort((_, v) => v.h - _.h);
							const o = [
								{
									x: 0,
									y: 0,
									w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), r),
									h: 1 / 0,
								},
							];
							let c = 0,
								f = 0;
							for (const _ of n)
								for (let v = o.length - 1; v >= 0; v--) {
									const b = o[v];
									if (!(_.w > b.w || _.h > b.h)) {
										if (
											((_.x = b.x),
											(_.y = b.y),
											(f = Math.max(f, _.y + _.h)),
											(c = Math.max(c, _.x + _.w)),
											_.w === b.w && _.h === b.h)
										) {
											const S = o.pop();
											S && v < o.length && (o[v] = S);
										} else
											_.h === b.h
												? ((b.x += _.w), (b.w -= _.w))
												: _.w === b.w
												? ((b.y += _.h), (b.h -= _.h))
												: (o.push({
														x: b.x + _.w,
														y: b.y,
														w: b.w - _.w,
														h: _.h,
												  }),
												  (b.y += _.h),
												  (b.h -= _.h));
										break;
									}
								}
							return { w: c, h: f, fill: t / (c * f) || 0 };
						}
						class uf {
							constructor(
								t,
								{
									pixelRatio: r,
									version: o,
									stretchX: c,
									stretchY: f,
									content: _,
									textFitWidth: v,
									textFitHeight: b,
								}
							) {
								(this.paddedRect = t),
									(this.pixelRatio = r),
									(this.stretchX = c),
									(this.stretchY = f),
									(this.content = _),
									(this.version = o),
									(this.textFitWidth = v),
									(this.textFitHeight = b);
							}
							get tl() {
								return [this.paddedRect.x + 1, this.paddedRect.y + 1];
							}
							get br() {
								return [
									this.paddedRect.x + this.paddedRect.w - 1,
									this.paddedRect.y + this.paddedRect.h - 1,
								];
							}
							get tlbr() {
								return this.tl.concat(this.br);
							}
							get displaySize() {
								return [
									(this.paddedRect.w - 2) / this.pixelRatio,
									(this.paddedRect.h - 2) / this.pixelRatio,
								];
							}
						}
						class K_ {
							constructor(t, r) {
								const o = {},
									c = {};
								this.haveRenderCallbacks = [];
								const f = [];
								this.addImages(t, o, f), this.addImages(r, c, f);
								const { w: _, h: v } = Y_(f),
									b = new ca({ width: _ || 1, height: v || 1 });
								for (const S in t) {
									const I = t[S],
										L = o[S].paddedRect;
									ca.copy(
										I.data,
										b,
										{ x: 0, y: 0 },
										{ x: L.x + 1, y: L.y + 1 },
										I.data
									);
								}
								for (const S in r) {
									const I = r[S],
										L = c[S].paddedRect,
										F = L.x + 1,
										q = L.y + 1,
										Z = I.data.width,
										W = I.data.height;
									ca.copy(I.data, b, { x: 0, y: 0 }, { x: F, y: q }, I.data),
										ca.copy(
											I.data,
											b,
											{ x: 0, y: W - 1 },
											{ x: F, y: q - 1 },
											{ width: Z, height: 1 }
										),
										ca.copy(
											I.data,
											b,
											{ x: 0, y: 0 },
											{ x: F, y: q + W },
											{ width: Z, height: 1 }
										),
										ca.copy(
											I.data,
											b,
											{ x: Z - 1, y: 0 },
											{ x: F - 1, y: q },
											{ width: 1, height: W }
										),
										ca.copy(
											I.data,
											b,
											{ x: 0, y: 0 },
											{ x: F + Z, y: q },
											{ width: 1, height: W }
										);
								}
								(this.image = b),
									(this.iconPositions = o),
									(this.patternPositions = c);
							}
							addImages(t, r, o) {
								for (const c in t) {
									const f = t[c],
										_ = {
											x: 0,
											y: 0,
											w: f.data.width + 2,
											h: f.data.height + 2,
										};
									o.push(_),
										(r[c] = new uf(_, f)),
										f.hasRenderCallback && this.haveRenderCallbacks.push(c);
								}
							}
							patchUpdatedImages(t, r) {
								t.dispatchRenderCallbacks(this.haveRenderCallbacks);
								for (const o in t.updatedImages)
									this.patchUpdatedImage(
										this.iconPositions[o],
										t.getImage(o),
										r
									),
										this.patchUpdatedImage(
											this.patternPositions[o],
											t.getImage(o),
											r
										);
							}
							patchUpdatedImage(t, r, o) {
								if (!t || !r || t.version === r.version) return;
								t.version = r.version;
								const [c, f] = t.tl;
								o.update(r.data, void 0, { x: c, y: f });
							}
						}
						var gs;
						ir("ImagePosition", uf),
							ir("ImageAtlas", K_),
							(T.ao = void 0),
							((gs = T.ao || (T.ao = {}))[(gs.none = 0)] = "none"),
							(gs[(gs.horizontal = 1)] = "horizontal"),
							(gs[(gs.vertical = 2)] = "vertical"),
							(gs[(gs.horizontalOnly = 3)] = "horizontalOnly");
						class Mu {
							constructor() {
								(this.scale = 1),
									(this.fontStack = ""),
									(this.imageName = null),
									(this.verticalAlign = "bottom");
							}
							static forText(t, r, o) {
								const c = new Mu();
								return (
									(c.scale = t || 1),
									(c.fontStack = r),
									(c.verticalAlign = o || "bottom"),
									c
								);
							}
							static forImage(t, r) {
								const o = new Mu();
								return (o.imageName = t), (o.verticalAlign = r || "bottom"), o;
							}
						}
						class rc {
							constructor() {
								(this.text = ""),
									(this.sectionIndex = []),
									(this.sections = []),
									(this.imageSectionID = null);
							}
							static fromFeature(t, r) {
								const o = new rc();
								for (let c = 0; c < t.sections.length; c++) {
									const f = t.sections[c];
									f.image ? o.addImageSection(f) : o.addTextSection(f, r);
								}
								return o;
							}
							length() {
								return this.text.length;
							}
							getSection(t) {
								return this.sections[this.sectionIndex[t]];
							}
							getSectionIndex(t) {
								return this.sectionIndex[t];
							}
							getCharCode(t) {
								return this.text.charCodeAt(t);
							}
							verticalizePunctuation() {
								this.text = (function (t) {
									let r = "";
									for (let o = 0; o < t.length; o++) {
										const c = t.charCodeAt(o + 1) || null,
											f = t.charCodeAt(o - 1) || null;
										r +=
											(c && gd(c) && !Iu[t[o + 1]]) ||
											(f && gd(f) && !Iu[t[o - 1]]) ||
											!Iu[t[o]]
												? t[o]
												: Iu[t[o]];
									}
									return r;
								})(this.text);
							}
							trim() {
								let t = 0;
								for (
									let o = 0;
									o < this.text.length && Ld[this.text.charCodeAt(o)];
									o++
								)
									t++;
								let r = this.text.length;
								for (
									let o = this.text.length - 1;
									o >= 0 && o >= t && Ld[this.text.charCodeAt(o)];
									o--
								)
									r--;
								(this.text = this.text.substring(t, r)),
									(this.sectionIndex = this.sectionIndex.slice(t, r));
							}
							substring(t, r) {
								const o = new rc();
								return (
									(o.text = this.text.substring(t, r)),
									(o.sectionIndex = this.sectionIndex.slice(t, r)),
									(o.sections = this.sections),
									o
								);
							}
							toString() {
								return this.text;
							}
							getMaxScale() {
								return this.sectionIndex.reduce(
									(t, r) => Math.max(t, this.sections[r].scale),
									0
								);
							}
							getMaxImageSize(t) {
								let r = 0,
									o = 0;
								for (let c = 0; c < this.length(); c++) {
									const f = this.getSection(c);
									if (f.imageName) {
										const _ = t[f.imageName];
										if (!_) continue;
										const v = _.displaySize;
										(r = Math.max(r, v[0])), (o = Math.max(o, v[1]));
									}
								}
								return { maxImageWidth: r, maxImageHeight: o };
							}
							addTextSection(t, r) {
								(this.text += t.text),
									this.sections.push(
										Mu.forText(t.scale, t.fontStack || r, t.verticalAlign)
									);
								const o = this.sections.length - 1;
								for (let c = 0; c < t.text.length; ++c)
									this.sectionIndex.push(o);
							}
							addImageSection(t) {
								const r = t.image ? t.image.name : "";
								if (r.length === 0)
									return void Lt(
										"Can't add FormattedSection with an empty image."
									);
								const o = this.getNextImageSectionCharCode();
								o
									? ((this.text += String.fromCharCode(o)),
									  this.sections.push(Mu.forImage(r, t.verticalAlign)),
									  this.sectionIndex.push(this.sections.length - 1))
									: Lt("Reached maximum number of images 6401");
							}
							getNextImageSectionCharCode() {
								return this.imageSectionID
									? this.imageSectionID >= 63743
										? null
										: ++this.imageSectionID
									: ((this.imageSectionID = 57344), this.imageSectionID);
							}
						}
						function zd(n, t, r, o, c, f, _, v, b, S, I, L, F, q, Z) {
							const W = rc.fromFeature(n, c);
							let J;
							L === T.ao.vertical && W.verticalizePunctuation();
							const {
								processBidirectionalText: le,
								processStyledBidirectionalText: Re,
							} = Ea;
							if (le && W.sections.length === 1) {
								J = [];
								const Ye = le(W.toString(), hf(W, S, f, t, o, q));
								for (const lt of Ye) {
									const Pt = new rc();
									(Pt.text = lt), (Pt.sections = W.sections);
									for (let Yt = 0; Yt < lt.length; Yt++)
										Pt.sectionIndex.push(0);
									J.push(Pt);
								}
							} else if (Re) {
								J = [];
								const Ye = Re(W.text, W.sectionIndex, hf(W, S, f, t, o, q));
								for (const lt of Ye) {
									const Pt = new rc();
									(Pt.text = lt[0]),
										(Pt.sectionIndex = lt[1]),
										(Pt.sections = W.sections),
										J.push(Pt);
								}
							} else
								J = (function (Ye, lt) {
									const Pt = [],
										Yt = Ye.text;
									let qt = 0;
									for (const Ht of lt) Pt.push(Ye.substring(qt, Ht)), (qt = Ht);
									return (
										qt < Yt.length && Pt.push(Ye.substring(qt, Yt.length)), Pt
									);
								})(W, hf(W, S, f, t, o, q));
							const xe = [],
								Ce = {
									positionedLines: xe,
									text: W.toString(),
									top: I[1],
									bottom: I[1],
									left: I[0],
									right: I[0],
									writingMode: L,
									iconsInText: !1,
									verticalizable: !1,
								};
							return (
								(function (Ye, lt, Pt, Yt, qt, Ht, Sr, Gt, Wt, gt, Nr, Hr) {
									let kr = 0,
										yr = 0,
										dn = 0,
										Qn = 0;
									const gi = Gt === "right" ? 1 : Gt === "left" ? 0 : 0.5,
										qi = Si / Hr;
									let Ba = 0;
									for (const Xn of qt) {
										Xn.trim();
										const Pi = Xn.getMaxScale(),
											Bi = { positionedGlyphs: [], lineOffset: 0 };
										Ye.positionedLines[Ba] = Bi;
										const Fi = Bi.positionedGlyphs;
										let ra = 0;
										if (!Xn.length()) {
											(yr += Ht), ++Ba;
											continue;
										}
										const Fa = c1(Yt, Xn, qi);
										for (let ha = 0; ha < Xn.length(); ha++) {
											const vi = Xn.getSection(ha),
												Mi = Xn.getSectionIndex(ha),
												ki = Xn.getCharCode(ha),
												ui = u1(Wt, Nr, ki);
											let qn;
											if (vi.imageName) {
												if (
													((Ye.iconsInText = !0),
													(vi.scale = vi.scale * qi),
													(qn = d1(vi, ui, Pi, Fa, Yt)),
													!qn)
												)
													continue;
												ra = Math.max(ra, qn.imageOffset);
											} else if (((qn = h1(vi, ki, ui, Fa, lt, Pt)), !qn))
												continue;
											const { rect: io, metrics: oc, baselineOffset: ao } = qn;
											Fi.push({
												glyph: ki,
												imageName: vi.imageName,
												x: kr,
												y: yr + ao + -17,
												vertical: ui,
												scale: vi.scale,
												fontStack: vi.fontStack,
												sectionIndex: Mi,
												metrics: oc,
												rect: io,
											}),
												ui
													? ((Ye.verticalizable = !0),
													  (kr +=
															(vi.imageName ? oc.advance : Si) * vi.scale + gt))
													: (kr += oc.advance * vi.scale + gt);
										}
										Fi.length !== 0 &&
											((dn = Math.max(kr - gt, dn)),
											p1(Fi, 0, Fi.length - 1, gi)),
											(kr = 0),
											(Bi.lineOffset = Math.max(ra, (Pi - 1) * Si));
										const Ii = Ht * Pi + ra;
										(yr += Ii), (Qn = Math.max(Ii, Qn)), ++Ba;
									}
									const { horizontalAlign: ua, verticalAlign: Ri } = df(Sr);
									(function (Xn, Pi, Bi, Fi, ra, Fa, Ii, ha, vi) {
										const Mi = (Pi - Bi) * ra;
										let ki = 0;
										ki = Fa !== Ii ? -ha * Fi - -17 : -Fi * vi * Ii + 0.5 * Ii;
										for (const ui of Xn)
											for (const qn of ui.positionedGlyphs)
												(qn.x += Mi), (qn.y += ki);
									})(Ye.positionedLines, gi, ua, Ri, dn, Qn, Ht, yr, qt.length),
										(Ye.top += -Ri * yr),
										(Ye.bottom = Ye.top + yr),
										(Ye.left += -ua * dn),
										(Ye.right = Ye.left + dn);
								})(Ce, t, r, o, J, _, v, b, L, S, F, Z),
								!(function (Ye) {
									for (const lt of Ye)
										if (lt.positionedGlyphs.length !== 0) return !1;
									return !0;
								})(xe) && Ce
							);
						}
						const Ld = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
							o1 = {
								10: !0,
								32: !0,
								38: !0,
								41: !0,
								43: !0,
								45: !0,
								47: !0,
								173: !0,
								183: !0,
								8203: !0,
								8208: !0,
								8211: !0,
								8231: !0,
							},
							s1 = { 40: !0 };
						function J_(n, t, r, o, c, f) {
							if (t.imageName) {
								const _ = o[t.imageName];
								return _ ? (_.displaySize[0] * t.scale * Si) / f + c : 0;
							}
							{
								const _ = r[t.fontStack],
									v = _ && _[n];
								return v ? v.metrics.advance * t.scale + c : 0;
							}
						}
						function Q_(n, t, r, o) {
							const c = Math.pow(n - t, 2);
							return o ? (n < t ? c / 2 : 2 * c) : c + Math.abs(r) * r;
						}
						function l1(n, t, r) {
							let o = 0;
							return (
								n === 10 && (o -= 1e4),
								r && (o += 150),
								(n !== 40 && n !== 65288) || (o += 50),
								(t !== 41 && t !== 65289) || (o += 50),
								o
							);
						}
						function eg(n, t, r, o, c, f) {
							let _ = null,
								v = Q_(t, r, c, f);
							for (const b of o) {
								const S = Q_(t - b.x, r, c, f) + b.badness;
								S <= v && ((_ = b), (v = S));
							}
							return { index: n, x: t, priorBreak: _, badness: v };
						}
						function tg(n) {
							return n ? tg(n.priorBreak).concat(n.index) : [];
						}
						function hf(n, t, r, o, c, f) {
							if (!n) return [];
							const _ = [],
								v = (function (L, F, q, Z, W, J) {
									let le = 0;
									for (let Re = 0; Re < L.length(); Re++) {
										const xe = L.getSection(Re);
										le += J_(L.getCharCode(Re), xe, Z, W, F, J);
									}
									return le / Math.max(1, Math.ceil(le / q));
								})(n, t, r, o, c, f),
								b = n.text.indexOf("​") >= 0;
							let S = 0;
							for (let L = 0; L < n.length(); L++) {
								const F = n.getSection(L),
									q = n.getCharCode(L);
								if (
									(Ld[q] || (S += J_(q, F, o, c, t, f)), L < n.length() - 1)
								) {
									const Z =
										!((I = q) < 11904) &&
										(!!hn["CJK Compatibility Forms"](I) ||
											!!hn["CJK Compatibility"](I) ||
											!!hn["CJK Strokes"](I) ||
											!!hn["CJK Symbols and Punctuation"](I) ||
											!!hn["Enclosed CJK Letters and Months"](I) ||
											!!hn["Halfwidth and Fullwidth Forms"](I) ||
											!!hn["Ideographic Description Characters"](I) ||
											!!hn["Vertical Forms"](I) ||
											ou.test(String.fromCodePoint(I)));
									(o1[q] ||
										Z ||
										F.imageName ||
										(L !== n.length() - 2 && s1[n.getCharCode(L + 1)])) &&
										_.push(
											eg(
												L + 1,
												S,
												v,
												_,
												l1(q, n.getCharCode(L + 1), Z && b),
												!1
											)
										);
								}
							}
							var I;
							return tg(eg(n.length(), S, v, _, 0, !0));
						}
						function df(n) {
							let t = 0.5,
								r = 0.5;
							switch (n) {
								case "right":
								case "top-right":
								case "bottom-right":
									t = 1;
									break;
								case "left":
								case "top-left":
								case "bottom-left":
									t = 0;
							}
							switch (n) {
								case "bottom":
								case "bottom-right":
								case "bottom-left":
									r = 1;
									break;
								case "top":
								case "top-right":
								case "top-left":
									r = 0;
							}
							return { horizontalAlign: t, verticalAlign: r };
						}
						function c1(n, t, r) {
							const o = t.getMaxScale() * Si,
								{ maxImageWidth: c, maxImageHeight: f } = t.getMaxImageSize(n),
								_ = Math.max(o, f * r);
							return {
								verticalLineContentWidth: Math.max(o, c * r),
								horizontalLineContentHeight: _,
							};
						}
						function rg(n) {
							switch (n) {
								case "top":
									return 0;
								case "center":
									return 0.5;
								default:
									return 1;
							}
						}
						function u1(n, t, r) {
							return !(
								n === T.ao.horizontal ||
								(!t && !su(r)) ||
								(t &&
									(Ld[r] ||
										((o = r),
										new RegExp("\\p{sc=Arab}", "u").test(
											String.fromCodePoint(o)
										))))
							);
							var o;
						}
						function h1(n, t, r, o, c, f) {
							const _ = f[n.fontStack],
								v = (function (S, I, L, F) {
									if (S && S.rect) return S;
									const q = I[L.fontStack],
										Z = q && q[F];
									return Z ? { rect: null, metrics: Z.metrics } : null;
								})(_ && _[t], c, n, t);
							if (v === null) return null;
							let b;
							if (r) b = o.verticalLineContentWidth - n.scale * Si;
							else {
								const S = rg(n.verticalAlign);
								b = (o.horizontalLineContentHeight - n.scale * Si) * S;
							}
							return { rect: v.rect, metrics: v.metrics, baselineOffset: b };
						}
						function d1(n, t, r, o, c) {
							const f = c[n.imageName];
							if (!f) return null;
							const _ = f.paddedRect,
								v = f.displaySize,
								b = {
									width: v[0],
									height: v[1],
									left: 1,
									top: -3,
									advance: t ? v[1] : v[0],
								};
							let S;
							if (t) S = o.verticalLineContentWidth - v[1] * n.scale;
							else {
								const I = rg(n.verticalAlign);
								S = (o.horizontalLineContentHeight - v[1] * n.scale) * I;
							}
							return {
								rect: _,
								metrics: b,
								baselineOffset: S,
								imageOffset: (t ? v[0] : v[1]) * n.scale - Si * r,
							};
						}
						function p1(n, t, r, o) {
							if (o === 0) return;
							const c = n[r],
								f = (n[r].x + c.metrics.advance * c.scale) * o;
							for (let _ = t; _ <= r; _++) n[_].x -= f;
						}
						function f1(n, t, r) {
							const { horizontalAlign: o, verticalAlign: c } = df(r),
								f = t[0] - n.displaySize[0] * o,
								_ = t[1] - n.displaySize[1] * c;
							return {
								image: n,
								top: _,
								bottom: _ + n.displaySize[1],
								left: f,
								right: f + n.displaySize[0],
							};
						}
						function ng(n) {
							var t, r;
							let o = n.left,
								c = n.top,
								f = n.right - o,
								_ = n.bottom - c;
							const v =
									(t = n.image.textFitWidth) !== null && t !== void 0
										? t
										: "stretchOrShrink",
								b =
									(r = n.image.textFitHeight) !== null && r !== void 0
										? r
										: "stretchOrShrink",
								S =
									(n.image.content[2] - n.image.content[0]) /
									(n.image.content[3] - n.image.content[1]);
							if (b === "proportional") {
								if (
									(v === "stretchOnly" && f / _ < S) ||
									v === "proportional"
								) {
									const I = Math.ceil(_ * S);
									(o *= I / f), (f = I);
								}
							} else if (
								v === "proportional" &&
								b === "stretchOnly" &&
								S !== 0 &&
								f / _ > S
							) {
								const I = Math.ceil(f / S);
								(c *= I / _), (_ = I);
							}
							return { x1: o, y1: c, x2: o + f, y2: c + _ };
						}
						function ig(n, t, r, o, c, f) {
							const _ = n.image;
							let v;
							if (_.content) {
								const J = _.content,
									le = _.pixelRatio || 1;
								v = [
									J[0] / le,
									J[1] / le,
									_.displaySize[0] - J[2] / le,
									_.displaySize[1] - J[3] / le,
								];
							}
							const b = t.left * f,
								S = t.right * f;
							let I, L, F, q;
							r === "width" || r === "both"
								? ((q = c[0] + b - o[3]), (L = c[0] + S + o[1]))
								: ((q = c[0] + (b + S - _.displaySize[0]) / 2),
								  (L = q + _.displaySize[0]));
							const Z = t.top * f,
								W = t.bottom * f;
							return (
								r === "height" || r === "both"
									? ((I = c[1] + Z - o[0]), (F = c[1] + W + o[2]))
									: ((I = c[1] + (Z + W - _.displaySize[1]) / 2),
									  (F = I + _.displaySize[1])),
								{
									image: _,
									top: I,
									right: L,
									bottom: F,
									left: q,
									collisionPadding: v,
								}
							);
						}
						const Zo = 128,
							vs = 32640;
						function ag(n, t) {
							const { expression: r } = t;
							if (r.kind === "constant")
								return {
									kind: "constant",
									layoutSize: r.evaluate(new Un(n + 1)),
								};
							if (r.kind === "source") return { kind: "source" };
							{
								const { zoomStops: o, interpolationType: c } = r;
								let f = 0;
								for (; f < o.length && o[f] <= n; ) f++;
								f = Math.max(0, f - 1);
								let _ = f;
								for (; _ < o.length && o[_] < n + 1; ) _++;
								_ = Math.min(o.length - 1, _);
								const v = o[f],
									b = o[_];
								return r.kind === "composite"
									? {
											kind: "composite",
											minZoom: v,
											maxZoom: b,
											interpolationType: c,
									  }
									: {
											kind: "camera",
											minZoom: v,
											maxZoom: b,
											minSize: r.evaluate(new Un(v)),
											maxSize: r.evaluate(new Un(b)),
											interpolationType: c,
									  };
							}
						}
						function pf(n, t, r) {
							let o = "never";
							const c = n.get(t);
							return c ? (o = c) : n.get(r) && (o = "always"), o;
						}
						const m1 = [
							{
								name: "a_fade_opacity",
								components: 1,
								type: "Uint8",
								offset: 0,
							},
						];
						function Dd(n, t, r, o, c, f, _, v, b, S, I, L, F) {
							const q = v ? Math.min(vs, Math.round(v[0])) : 0,
								Z = v ? Math.min(vs, Math.round(v[1])) : 0;
							n.emplaceBack(
								t,
								r,
								Math.round(32 * o),
								Math.round(32 * c),
								f,
								_,
								(q << 1) + (b ? 1 : 0),
								Z,
								16 * S,
								16 * I,
								256 * L,
								256 * F
							);
						}
						function ff(n, t, r) {
							n.emplaceBack(t.x, t.y, r),
								n.emplaceBack(t.x, t.y, r),
								n.emplaceBack(t.x, t.y, r),
								n.emplaceBack(t.x, t.y, r);
						}
						function _1(n) {
							for (const t of n.sections) if (xd(t.text)) return !0;
							return !1;
						}
						class mf {
							constructor(t) {
								(this.layoutVertexArray = new Zt()),
									(this.indexArray = new Rn()),
									(this.programConfigurations = t),
									(this.segments = new Kr()),
									(this.dynamicLayoutVertexArray = new Tt()),
									(this.opacityVertexArray = new vr()),
									(this.hasVisibleVertices = !1),
									(this.placedSymbolArray = new G());
							}
							isEmpty() {
								return (
									this.layoutVertexArray.length === 0 &&
									this.indexArray.length === 0 &&
									this.dynamicLayoutVertexArray.length === 0 &&
									this.opacityVertexArray.length === 0
								);
							}
							upload(t, r, o, c) {
								this.isEmpty() ||
									(o &&
										((this.layoutVertexBuffer = t.createVertexBuffer(
											this.layoutVertexArray,
											Zy.members
										)),
										(this.indexBuffer = t.createIndexBuffer(
											this.indexArray,
											r
										)),
										(this.dynamicLayoutVertexBuffer = t.createVertexBuffer(
											this.dynamicLayoutVertexArray,
											Uy.members,
											!0
										)),
										(this.opacityVertexBuffer = t.createVertexBuffer(
											this.opacityVertexArray,
											m1,
											!0
										)),
										(this.opacityVertexBuffer.itemSize = 1)),
									(o || c) && this.programConfigurations.upload(t));
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.programConfigurations.destroy(),
									this.segments.destroy(),
									this.dynamicLayoutVertexBuffer.destroy(),
									this.opacityVertexBuffer.destroy());
							}
						}
						ir("SymbolBuffers", mf);
						class _f {
							constructor(t, r, o) {
								(this.layoutVertexArray = new t()),
									(this.layoutAttributes = r),
									(this.indexArray = new o()),
									(this.segments = new Kr()),
									(this.collisionVertexArray = new An());
							}
							upload(t) {
								(this.layoutVertexBuffer = t.createVertexBuffer(
									this.layoutVertexArray,
									this.layoutAttributes
								)),
									(this.indexBuffer = t.createIndexBuffer(this.indexArray)),
									(this.collisionVertexBuffer = t.createVertexBuffer(
										this.collisionVertexArray,
										$y.members,
										!0
									));
							}
							destroy() {
								this.layoutVertexBuffer &&
									(this.layoutVertexBuffer.destroy(),
									this.indexBuffer.destroy(),
									this.segments.destroy(),
									this.collisionVertexBuffer.destroy());
							}
						}
						ir("CollisionBuffers", _f);
						class nc {
							constructor(t) {
								(this.collisionBoxArray = t.collisionBoxArray),
									(this.zoom = t.zoom),
									(this.globalState = t.globalState),
									(this.overscaling = t.overscaling),
									(this.layers = t.layers),
									(this.layerIds = this.layers.map((_) => _.id)),
									(this.index = t.index),
									(this.pixelRatio = t.pixelRatio),
									(this.sourceLayerIndex = t.sourceLayerIndex),
									(this.hasPattern = !1),
									(this.hasRTLText = !1),
									(this.sortKeyRanges = []),
									(this.collisionCircleArray = []);
								const r = this.layers[0]._unevaluatedLayout._values;
								(this.textSizeData = ag(this.zoom, r["text-size"])),
									(this.iconSizeData = ag(this.zoom, r["icon-size"]));
								const o = this.layers[0].layout,
									c = o.get("symbol-sort-key"),
									f = o.get("symbol-z-order");
								(this.canOverlap =
									pf(o, "text-overlap", "text-allow-overlap") !== "never" ||
									pf(o, "icon-overlap", "icon-allow-overlap") !== "never" ||
									o.get("text-ignore-placement") ||
									o.get("icon-ignore-placement")),
									(this.sortFeaturesByKey =
										f !== "viewport-y" && !c.isConstant()),
									(this.sortFeaturesByY =
										(f === "viewport-y" ||
											(f === "auto" && !this.sortFeaturesByKey)) &&
										this.canOverlap),
									o.get("symbol-placement") === "point" &&
										(this.writingModes = o
											.get("text-writing-mode")
											.map((_) => T.ao[_])),
									(this.stateDependentLayerIds = this.layers
										.filter((_) => _.isStateDependent())
										.map((_) => _.id)),
									(this.sourceID = t.sourceID);
							}
							createArrays() {
								(this.text = new mf(
									new la(this.layers, this.zoom, (t) => /^text/.test(t))
								)),
									(this.icon = new mf(
										new la(this.layers, this.zoom, (t) => /^icon/.test(t))
									)),
									(this.glyphOffsetArray = new ae()),
									(this.lineVertexArray = new ce()),
									(this.symbolInstances = new Q()),
									(this.textAnchorOffsets = new me());
							}
							calculateGlyphDependencies(t, r, o, c, f) {
								for (let _ = 0; _ < t.length; _++)
									if (((r[t.charCodeAt(_)] = !0), (o || c) && f)) {
										const v = Iu[t.charAt(_)];
										v && (r[v.charCodeAt(0)] = !0);
									}
							}
							populate(t, r, o) {
								const c = this.layers[0],
									f = c.layout,
									_ = f.get("text-font"),
									v = f.get("text-field"),
									b = f.get("icon-image"),
									S =
										(v.value.kind !== "constant" ||
											(v.value.value instanceof Sn &&
												!v.value.value.isEmpty()) ||
											v.value.value.toString().length > 0) &&
										(_.value.kind !== "constant" || _.value.value.length > 0),
									I =
										b.value.kind !== "constant" ||
										!!b.value.value ||
										Object.keys(b.parameters).length > 0,
									L = f.get("symbol-sort-key");
								if (((this.features = []), !S && !I)) return;
								const F = r.iconDependencies,
									q = r.glyphDependencies,
									Z = r.availableImages,
									W = new Un(this.zoom, { globalState: this.globalState });
								for (const {
									feature: J,
									id: le,
									index: Re,
									sourceLayerIndex: xe,
								} of t) {
									const Ce = c._featureFilter.needGeometry,
										Ye = no(J, Ce);
									if (!c._featureFilter.filter(W, Ye, o)) continue;
									let lt, Pt;
									if ((Ce || (Ye.geometry = bo(J)), S)) {
										const qt = c.getValueAndResolveTokens(
												"text-field",
												Ye,
												o,
												Z
											),
											Ht = Sn.factory(qt),
											Sr = (this.hasRTLText = this.hasRTLText || _1(Ht));
										(!Sr ||
											Ea.getRTLTextPluginStatus() === "unavailable" ||
											(Sr && Ea.isParsed())) &&
											(lt = Hy(Ht, c, Ye));
									}
									if (I) {
										const qt = c.getValueAndResolveTokens(
											"icon-image",
											Ye,
											o,
											Z
										);
										Pt = qt instanceof Hn ? qt : Hn.fromString(qt);
									}
									if (!lt && !Pt) continue;
									const Yt = this.sortFeaturesByKey
										? L.evaluate(Ye, {}, o)
										: void 0;
									if (
										(this.features.push({
											id: le,
											text: lt,
											icon: Pt,
											index: Re,
											sourceLayerIndex: xe,
											geometry: Ye.geometry,
											properties: J.properties,
											type: ec.types[J.type],
											sortKey: Yt,
										}),
										Pt && (F[Pt.name] = !0),
										lt)
									) {
										const qt = _.evaluate(Ye, {}, o).join(","),
											Ht =
												f.get("text-rotation-alignment") !== "viewport" &&
												f.get("symbol-placement") !== "point";
										this.allowVerticalPlacement =
											this.writingModes &&
											this.writingModes.indexOf(T.ao.vertical) >= 0;
										for (const Sr of lt.sections)
											if (Sr.image) F[Sr.image.name] = !0;
											else {
												const Gt = jl(lt.toString()),
													Wt = Sr.fontStack || qt,
													gt = (q[Wt] = q[Wt] || {});
												this.calculateGlyphDependencies(
													Sr.text,
													gt,
													Ht,
													this.allowVerticalPlacement,
													Gt
												);
											}
									}
								}
								f.get("symbol-placement") === "line" &&
									(this.features = (function (J) {
										const le = {},
											Re = {},
											xe = [];
										let Ce = 0;
										function Ye(qt) {
											xe.push(J[qt]), Ce++;
										}
										function lt(qt, Ht, Sr) {
											const Gt = Re[qt];
											return (
												delete Re[qt],
												(Re[Ht] = Gt),
												xe[Gt].geometry[0].pop(),
												(xe[Gt].geometry[0] = xe[Gt].geometry[0].concat(Sr[0])),
												Gt
											);
										}
										function Pt(qt, Ht, Sr) {
											const Gt = le[Ht];
											return (
												delete le[Ht],
												(le[qt] = Gt),
												xe[Gt].geometry[0].shift(),
												(xe[Gt].geometry[0] = Sr[0].concat(xe[Gt].geometry[0])),
												Gt
											);
										}
										function Yt(qt, Ht, Sr) {
											const Gt = Sr ? Ht[0][Ht[0].length - 1] : Ht[0][0];
											return `${qt}:${Gt.x}:${Gt.y}`;
										}
										for (let qt = 0; qt < J.length; qt++) {
											const Ht = J[qt],
												Sr = Ht.geometry,
												Gt = Ht.text ? Ht.text.toString() : null;
											if (!Gt) {
												Ye(qt);
												continue;
											}
											const Wt = Yt(Gt, Sr),
												gt = Yt(Gt, Sr, !0);
											if (Wt in Re && gt in le && Re[Wt] !== le[gt]) {
												const Nr = Pt(Wt, gt, Sr),
													Hr = lt(Wt, gt, xe[Nr].geometry);
												delete le[Wt],
													delete Re[gt],
													(Re[Yt(Gt, xe[Hr].geometry, !0)] = Hr),
													(xe[Nr].geometry = null);
											} else
												Wt in Re
													? lt(Wt, gt, Sr)
													: gt in le
													? Pt(Wt, gt, Sr)
													: (Ye(qt), (le[Wt] = Ce - 1), (Re[gt] = Ce - 1));
										}
										return xe.filter((qt) => qt.geometry);
									})(this.features)),
									this.sortFeaturesByKey &&
										this.features.sort((J, le) => J.sortKey - le.sortKey);
							}
							update(t, r, o) {
								this.stateDependentLayers.length &&
									(this.text.programConfigurations.updatePaintArrays(
										t,
										r,
										this.layers,
										o
									),
									this.icon.programConfigurations.updatePaintArrays(
										t,
										r,
										this.layers,
										o
									));
							}
							isEmpty() {
								return this.symbolInstances.length === 0 && !this.hasRTLText;
							}
							uploadPending() {
								return (
									!this.uploaded ||
									this.text.programConfigurations.needsUpload ||
									this.icon.programConfigurations.needsUpload
								);
							}
							upload(t) {
								!this.uploaded &&
									this.hasDebugData() &&
									(this.textCollisionBox.upload(t),
									this.iconCollisionBox.upload(t)),
									this.text.upload(
										t,
										this.sortFeaturesByY,
										!this.uploaded,
										this.text.programConfigurations.needsUpload
									),
									this.icon.upload(
										t,
										this.sortFeaturesByY,
										!this.uploaded,
										this.icon.programConfigurations.needsUpload
									),
									(this.uploaded = !0);
							}
							destroyDebugData() {
								this.textCollisionBox.destroy(),
									this.iconCollisionBox.destroy();
							}
							destroy() {
								this.text.destroy(),
									this.icon.destroy(),
									this.hasDebugData() && this.destroyDebugData();
							}
							addToLineVertexArray(t, r) {
								const o = this.lineVertexArray.length;
								if (t.segment !== void 0) {
									let c = t.dist(r[t.segment + 1]),
										f = t.dist(r[t.segment]);
									const _ = {};
									for (let v = t.segment + 1; v < r.length; v++)
										(_[v] = {
											x: r[v].x,
											y: r[v].y,
											tileUnitDistanceFromAnchor: c,
										}),
											v < r.length - 1 && (c += r[v + 1].dist(r[v]));
									for (let v = t.segment || 0; v >= 0; v--)
										(_[v] = {
											x: r[v].x,
											y: r[v].y,
											tileUnitDistanceFromAnchor: f,
										}),
											v > 0 && (f += r[v - 1].dist(r[v]));
									for (let v = 0; v < r.length; v++) {
										const b = _[v];
										this.lineVertexArray.emplaceBack(
											b.x,
											b.y,
											b.tileUnitDistanceFromAnchor
										);
									}
								}
								return {
									lineStartIndex: o,
									lineLength: this.lineVertexArray.length - o,
								};
							}
							addSymbols(t, r, o, c, f, _, v, b, S, I, L, F) {
								const q = t.indexArray,
									Z = t.layoutVertexArray,
									W = t.segments.prepareSegment(
										4 * r.length,
										Z,
										q,
										this.canOverlap ? _.sortKey : void 0
									),
									J = this.glyphOffsetArray.length,
									le = W.vertexLength,
									Re =
										this.allowVerticalPlacement && v === T.ao.vertical
											? Math.PI / 2
											: 0,
									xe = _.text && _.text.sections;
								for (let Ce = 0; Ce < r.length; Ce++) {
									const {
											tl: Ye,
											tr: lt,
											bl: Pt,
											br: Yt,
											tex: qt,
											pixelOffsetTL: Ht,
											pixelOffsetBR: Sr,
											minFontScaleX: Gt,
											minFontScaleY: Wt,
											glyphOffset: gt,
											isSDF: Nr,
											sectionIndex: Hr,
										} = r[Ce],
										kr = W.vertexLength,
										yr = gt[1];
									Dd(
										Z,
										b.x,
										b.y,
										Ye.x,
										yr + Ye.y,
										qt.x,
										qt.y,
										o,
										Nr,
										Ht.x,
										Ht.y,
										Gt,
										Wt
									),
										Dd(
											Z,
											b.x,
											b.y,
											lt.x,
											yr + lt.y,
											qt.x + qt.w,
											qt.y,
											o,
											Nr,
											Sr.x,
											Ht.y,
											Gt,
											Wt
										),
										Dd(
											Z,
											b.x,
											b.y,
											Pt.x,
											yr + Pt.y,
											qt.x,
											qt.y + qt.h,
											o,
											Nr,
											Ht.x,
											Sr.y,
											Gt,
											Wt
										),
										Dd(
											Z,
											b.x,
											b.y,
											Yt.x,
											yr + Yt.y,
											qt.x + qt.w,
											qt.y + qt.h,
											o,
											Nr,
											Sr.x,
											Sr.y,
											Gt,
											Wt
										),
										ff(t.dynamicLayoutVertexArray, b, Re),
										q.emplaceBack(kr, kr + 2, kr + 1),
										q.emplaceBack(kr + 1, kr + 2, kr + 3),
										(W.vertexLength += 4),
										(W.primitiveLength += 2),
										this.glyphOffsetArray.emplaceBack(gt[0]),
										(Ce !== r.length - 1 && Hr === r[Ce + 1].sectionIndex) ||
											t.programConfigurations.populatePaintArrays(
												Z.length,
												_,
												_.index,
												{},
												F,
												xe && xe[Hr]
											);
								}
								t.placedSymbolArray.emplaceBack(
									b.x,
									b.y,
									J,
									this.glyphOffsetArray.length - J,
									le,
									S,
									I,
									b.segment,
									o ? o[0] : 0,
									o ? o[1] : 0,
									c[0],
									c[1],
									v,
									0,
									!1,
									0,
									L
								);
							}
							_addCollisionDebugVertex(t, r, o, c, f, _) {
								return (
									r.emplaceBack(0, 0),
									t.emplaceBack(
										o.x,
										o.y,
										c,
										f,
										Math.round(_.x),
										Math.round(_.y)
									)
								);
							}
							addCollisionDebugVertices(t, r, o, c, f, _, v) {
								const b = f.segments.prepareSegment(
										4,
										f.layoutVertexArray,
										f.indexArray
									),
									S = b.vertexLength,
									I = f.layoutVertexArray,
									L = f.collisionVertexArray,
									F = v.anchorX,
									q = v.anchorY;
								this._addCollisionDebugVertex(I, L, _, F, q, new B(t, r)),
									this._addCollisionDebugVertex(I, L, _, F, q, new B(o, r)),
									this._addCollisionDebugVertex(I, L, _, F, q, new B(o, c)),
									this._addCollisionDebugVertex(I, L, _, F, q, new B(t, c)),
									(b.vertexLength += 4);
								const Z = f.indexArray;
								Z.emplaceBack(S, S + 1),
									Z.emplaceBack(S + 1, S + 2),
									Z.emplaceBack(S + 2, S + 3),
									Z.emplaceBack(S + 3, S),
									(b.primitiveLength += 4);
							}
							addDebugCollisionBoxes(t, r, o, c) {
								for (let f = t; f < r; f++) {
									const _ = this.collisionBoxArray.get(f);
									this.addCollisionDebugVertices(
										_.x1,
										_.y1,
										_.x2,
										_.y2,
										c ? this.textCollisionBox : this.iconCollisionBox,
										_.anchorPoint,
										o
									);
								}
							}
							generateCollisionDebugBuffers() {
								this.hasDebugData() && this.destroyDebugData(),
									(this.textCollisionBox = new _f(Jr, G_.members, Ln)),
									(this.iconCollisionBox = new _f(Jr, G_.members, Ln));
								for (let t = 0; t < this.symbolInstances.length; t++) {
									const r = this.symbolInstances.get(t);
									this.addDebugCollisionBoxes(
										r.textBoxStartIndex,
										r.textBoxEndIndex,
										r,
										!0
									),
										this.addDebugCollisionBoxes(
											r.verticalTextBoxStartIndex,
											r.verticalTextBoxEndIndex,
											r,
											!0
										),
										this.addDebugCollisionBoxes(
											r.iconBoxStartIndex,
											r.iconBoxEndIndex,
											r,
											!1
										),
										this.addDebugCollisionBoxes(
											r.verticalIconBoxStartIndex,
											r.verticalIconBoxEndIndex,
											r,
											!1
										);
								}
							}
							_deserializeCollisionBoxesForSymbol(t, r, o, c, f, _, v, b, S) {
								const I = {};
								for (let L = r; L < o; L++) {
									const F = t.get(L);
									(I.textBox = {
										x1: F.x1,
										y1: F.y1,
										x2: F.x2,
										y2: F.y2,
										anchorPointX: F.anchorPointX,
										anchorPointY: F.anchorPointY,
									}),
										(I.textFeatureIndex = F.featureIndex);
									break;
								}
								for (let L = c; L < f; L++) {
									const F = t.get(L);
									(I.verticalTextBox = {
										x1: F.x1,
										y1: F.y1,
										x2: F.x2,
										y2: F.y2,
										anchorPointX: F.anchorPointX,
										anchorPointY: F.anchorPointY,
									}),
										(I.verticalTextFeatureIndex = F.featureIndex);
									break;
								}
								for (let L = _; L < v; L++) {
									const F = t.get(L);
									(I.iconBox = {
										x1: F.x1,
										y1: F.y1,
										x2: F.x2,
										y2: F.y2,
										anchorPointX: F.anchorPointX,
										anchorPointY: F.anchorPointY,
									}),
										(I.iconFeatureIndex = F.featureIndex);
									break;
								}
								for (let L = b; L < S; L++) {
									const F = t.get(L);
									(I.verticalIconBox = {
										x1: F.x1,
										y1: F.y1,
										x2: F.x2,
										y2: F.y2,
										anchorPointX: F.anchorPointX,
										anchorPointY: F.anchorPointY,
									}),
										(I.verticalIconFeatureIndex = F.featureIndex);
									break;
								}
								return I;
							}
							deserializeCollisionBoxes(t) {
								this.collisionArrays = [];
								for (let r = 0; r < this.symbolInstances.length; r++) {
									const o = this.symbolInstances.get(r);
									this.collisionArrays.push(
										this._deserializeCollisionBoxesForSymbol(
											t,
											o.textBoxStartIndex,
											o.textBoxEndIndex,
											o.verticalTextBoxStartIndex,
											o.verticalTextBoxEndIndex,
											o.iconBoxStartIndex,
											o.iconBoxEndIndex,
											o.verticalIconBoxStartIndex,
											o.verticalIconBoxEndIndex
										)
									);
								}
							}
							hasTextData() {
								return this.text.segments.get().length > 0;
							}
							hasIconData() {
								return this.icon.segments.get().length > 0;
							}
							hasDebugData() {
								return this.textCollisionBox && this.iconCollisionBox;
							}
							hasTextCollisionBoxData() {
								return (
									this.hasDebugData() &&
									this.textCollisionBox.segments.get().length > 0
								);
							}
							hasIconCollisionBoxData() {
								return (
									this.hasDebugData() &&
									this.iconCollisionBox.segments.get().length > 0
								);
							}
							addIndicesForPlacedSymbol(t, r) {
								const o = t.placedSymbolArray.get(r),
									c = o.vertexStartIndex + 4 * o.numGlyphs;
								for (let f = o.vertexStartIndex; f < c; f += 4)
									t.indexArray.emplaceBack(f, f + 2, f + 1),
										t.indexArray.emplaceBack(f + 1, f + 2, f + 3);
							}
							getSortedSymbolIndexes(t) {
								if (
									this.sortedAngle === t &&
									this.symbolInstanceIndexes !== void 0
								)
									return this.symbolInstanceIndexes;
								const r = Math.sin(t),
									o = Math.cos(t),
									c = [],
									f = [],
									_ = [];
								for (let v = 0; v < this.symbolInstances.length; ++v) {
									_.push(v);
									const b = this.symbolInstances.get(v);
									c.push(0 | Math.round(r * b.anchorX + o * b.anchorY)),
										f.push(b.featureIndex);
								}
								return _.sort((v, b) => c[v] - c[b] || f[b] - f[v]), _;
							}
							addToSortKeyRanges(t, r) {
								const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
								o && o.sortKey === r
									? (o.symbolInstanceEnd = t + 1)
									: this.sortKeyRanges.push({
											sortKey: r,
											symbolInstanceStart: t,
											symbolInstanceEnd: t + 1,
									  });
							}
							sortFeatures(t) {
								if (
									this.sortFeaturesByY &&
									this.sortedAngle !== t &&
									!(
										this.text.segments.get().length > 1 ||
										this.icon.segments.get().length > 1
									)
								) {
									(this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)),
										(this.sortedAngle = t),
										this.text.indexArray.clear(),
										this.icon.indexArray.clear(),
										(this.featureSortOrder = []);
									for (const r of this.symbolInstanceIndexes) {
										const o = this.symbolInstances.get(r);
										this.featureSortOrder.push(o.featureIndex),
											[
												o.rightJustifiedTextSymbolIndex,
												o.centerJustifiedTextSymbolIndex,
												o.leftJustifiedTextSymbolIndex,
											].forEach((c, f, _) => {
												c >= 0 &&
													_.indexOf(c) === f &&
													this.addIndicesForPlacedSymbol(this.text, c);
											}),
											o.verticalPlacedTextSymbolIndex >= 0 &&
												this.addIndicesForPlacedSymbol(
													this.text,
													o.verticalPlacedTextSymbolIndex
												),
											o.placedIconSymbolIndex >= 0 &&
												this.addIndicesForPlacedSymbol(
													this.icon,
													o.placedIconSymbolIndex
												),
											o.verticalPlacedIconSymbolIndex >= 0 &&
												this.addIndicesForPlacedSymbol(
													this.icon,
													o.verticalPlacedIconSymbolIndex
												);
									}
									this.text.indexBuffer &&
										this.text.indexBuffer.updateData(this.text.indexArray),
										this.icon.indexBuffer &&
											this.icon.indexBuffer.updateData(this.icon.indexArray);
								}
							}
						}
						let og, sg;
						ir("SymbolBucket", nc, {
							omit: ["layers", "collisionBoxArray", "features", "compareText"],
						}),
							(nc.MAX_GLYPHS = 65535),
							(nc.addDynamicAttributes = ff);
						var gf = {
							get paint() {
								return (sg =
									sg ||
									new Ui({
										"icon-opacity": new Or(ye.paint_symbol["icon-opacity"]),
										"icon-color": new Or(ye.paint_symbol["icon-color"]),
										"icon-halo-color": new Or(
											ye.paint_symbol["icon-halo-color"]
										),
										"icon-halo-width": new Or(
											ye.paint_symbol["icon-halo-width"]
										),
										"icon-halo-blur": new Or(ye.paint_symbol["icon-halo-blur"]),
										"icon-translate": new wr(ye.paint_symbol["icon-translate"]),
										"icon-translate-anchor": new wr(
											ye.paint_symbol["icon-translate-anchor"]
										),
										"text-opacity": new Or(ye.paint_symbol["text-opacity"]),
										"text-color": new Or(ye.paint_symbol["text-color"], {
											runtimeType: Jt,
											getOverride: (n) => n.textColor,
											hasOverride: (n) => !!n.textColor,
										}),
										"text-halo-color": new Or(
											ye.paint_symbol["text-halo-color"]
										),
										"text-halo-width": new Or(
											ye.paint_symbol["text-halo-width"]
										),
										"text-halo-blur": new Or(ye.paint_symbol["text-halo-blur"]),
										"text-translate": new wr(ye.paint_symbol["text-translate"]),
										"text-translate-anchor": new wr(
											ye.paint_symbol["text-translate-anchor"]
										),
									}));
							},
							get layout() {
								return (og =
									og ||
									new Ui({
										"symbol-placement": new wr(
											ye.layout_symbol["symbol-placement"]
										),
										"symbol-spacing": new wr(
											ye.layout_symbol["symbol-spacing"]
										),
										"symbol-avoid-edges": new wr(
											ye.layout_symbol["symbol-avoid-edges"]
										),
										"symbol-sort-key": new Or(
											ye.layout_symbol["symbol-sort-key"]
										),
										"symbol-z-order": new wr(
											ye.layout_symbol["symbol-z-order"]
										),
										"icon-allow-overlap": new wr(
											ye.layout_symbol["icon-allow-overlap"]
										),
										"icon-overlap": new wr(ye.layout_symbol["icon-overlap"]),
										"icon-ignore-placement": new wr(
											ye.layout_symbol["icon-ignore-placement"]
										),
										"icon-optional": new wr(ye.layout_symbol["icon-optional"]),
										"icon-rotation-alignment": new wr(
											ye.layout_symbol["icon-rotation-alignment"]
										),
										"icon-size": new Or(ye.layout_symbol["icon-size"]),
										"icon-text-fit": new wr(ye.layout_symbol["icon-text-fit"]),
										"icon-text-fit-padding": new wr(
											ye.layout_symbol["icon-text-fit-padding"]
										),
										"icon-image": new Or(ye.layout_symbol["icon-image"]),
										"icon-rotate": new Or(ye.layout_symbol["icon-rotate"]),
										"icon-padding": new Or(ye.layout_symbol["icon-padding"]),
										"icon-keep-upright": new wr(
											ye.layout_symbol["icon-keep-upright"]
										),
										"icon-offset": new Or(ye.layout_symbol["icon-offset"]),
										"icon-anchor": new Or(ye.layout_symbol["icon-anchor"]),
										"icon-pitch-alignment": new wr(
											ye.layout_symbol["icon-pitch-alignment"]
										),
										"text-pitch-alignment": new wr(
											ye.layout_symbol["text-pitch-alignment"]
										),
										"text-rotation-alignment": new wr(
											ye.layout_symbol["text-rotation-alignment"]
										),
										"text-field": new Or(ye.layout_symbol["text-field"]),
										"text-font": new Or(ye.layout_symbol["text-font"]),
										"text-size": new Or(ye.layout_symbol["text-size"]),
										"text-max-width": new Or(
											ye.layout_symbol["text-max-width"]
										),
										"text-line-height": new wr(
											ye.layout_symbol["text-line-height"]
										),
										"text-letter-spacing": new Or(
											ye.layout_symbol["text-letter-spacing"]
										),
										"text-justify": new Or(ye.layout_symbol["text-justify"]),
										"text-radial-offset": new Or(
											ye.layout_symbol["text-radial-offset"]
										),
										"text-variable-anchor": new wr(
											ye.layout_symbol["text-variable-anchor"]
										),
										"text-variable-anchor-offset": new Or(
											ye.layout_symbol["text-variable-anchor-offset"]
										),
										"text-anchor": new Or(ye.layout_symbol["text-anchor"]),
										"text-max-angle": new wr(
											ye.layout_symbol["text-max-angle"]
										),
										"text-writing-mode": new wr(
											ye.layout_symbol["text-writing-mode"]
										),
										"text-rotate": new Or(ye.layout_symbol["text-rotate"]),
										"text-padding": new wr(ye.layout_symbol["text-padding"]),
										"text-keep-upright": new wr(
											ye.layout_symbol["text-keep-upright"]
										),
										"text-transform": new Or(
											ye.layout_symbol["text-transform"]
										),
										"text-offset": new Or(ye.layout_symbol["text-offset"]),
										"text-allow-overlap": new wr(
											ye.layout_symbol["text-allow-overlap"]
										),
										"text-overlap": new wr(ye.layout_symbol["text-overlap"]),
										"text-ignore-placement": new wr(
											ye.layout_symbol["text-ignore-placement"]
										),
										"text-optional": new wr(ye.layout_symbol["text-optional"]),
									}));
							},
						};
						class lg {
							constructor(t) {
								if (t.property.overrides === void 0)
									throw new Error(
										"overrides must be provided to instantiate FormatSectionOverride class"
									);
								(this.type = t.property.overrides
									? t.property.overrides.runtimeType
									: mt),
									(this.defaultValue = t);
							}
							evaluate(t) {
								if (t.formattedSection) {
									const r = this.defaultValue.property.overrides;
									if (r && r.hasOverride(t.formattedSection))
										return r.getOverride(t.formattedSection);
								}
								return t.feature && t.featureState
									? this.defaultValue.evaluate(t.feature, t.featureState)
									: this.defaultValue.property.specification.default;
							}
							eachChild(t) {
								this.defaultValue.isConstant() ||
									t(this.defaultValue.value._styleExpression.expression);
							}
							outputDefined() {
								return !1;
							}
							serialize() {
								return null;
							}
						}
						ir("FormatSectionOverride", lg, { omit: ["defaultValue"] });
						class Rd extends xa {
							constructor(t) {
								super(t, gf);
							}
							recalculate(t, r) {
								if (
									(super.recalculate(t, r),
									this.layout.get("icon-rotation-alignment") === "auto" &&
										(this.layout._values["icon-rotation-alignment"] =
											this.layout.get("symbol-placement") !== "point"
												? "map"
												: "viewport"),
									this.layout.get("text-rotation-alignment") === "auto" &&
										(this.layout._values["text-rotation-alignment"] =
											this.layout.get("symbol-placement") !== "point"
												? "map"
												: "viewport"),
									this.layout.get("text-pitch-alignment") === "auto" &&
										(this.layout._values["text-pitch-alignment"] =
											this.layout.get("text-rotation-alignment") === "map"
												? "map"
												: "viewport"),
									this.layout.get("icon-pitch-alignment") === "auto" &&
										(this.layout._values["icon-pitch-alignment"] =
											this.layout.get("icon-rotation-alignment")),
									this.layout.get("symbol-placement") === "point")
								) {
									const o = this.layout.get("text-writing-mode");
									if (o) {
										const c = [];
										for (const f of o) c.indexOf(f) < 0 && c.push(f);
										this.layout._values["text-writing-mode"] = c;
									} else
										this.layout._values["text-writing-mode"] = ["horizontal"];
								}
								this._setPaintOverrides();
							}
							getValueAndResolveTokens(t, r, o, c) {
								const f = this.layout.get(t).evaluate(r, {}, o, c),
									_ = this._unevaluatedLayout._values[t];
								return _.isDataDriven() || zl(_.value) || !f
									? f
									: (function (v, b) {
											return b.replace(/{([^{}]+)}/g, (S, I) =>
												v && I in v ? String(v[I]) : ""
											);
									  })(r.properties, f);
							}
							createBucket(t) {
								return new nc(t);
							}
							queryRadius() {
								return 0;
							}
							queryIntersectsFeature() {
								throw new Error("Should take a different path in FeatureIndex");
							}
							_setPaintOverrides() {
								for (const t of gf.paint.overridableProperties) {
									if (!Rd.hasPaintOverride(this.layout, t)) continue;
									const r = this.paint.get(t),
										o = new lg(r),
										c = new Wc(o, r.property.specification);
									let f = null;
									(f =
										r.value.kind === "constant" || r.value.kind === "source"
											? new Zs("source", c)
											: new Xc("composite", c, r.value.zoomStops)),
										(this.paint._values[t] = new $a(
											r.property,
											f,
											r.parameters
										));
								}
							}
							_handleOverridablePaintPropertyUpdate(t, r, o) {
								return (
									!(!this.layout || r.isDataDriven() || o.isDataDriven()) &&
									Rd.hasPaintOverride(this.layout, t)
								);
							}
							static hasPaintOverride(t, r) {
								const o = t.get("text-field"),
									c = gf.paint.properties[r];
								let f = !1;
								const _ = (v) => {
									for (const b of v)
										if (c.overrides && c.overrides.hasOverride(b))
											return void (f = !0);
								};
								if (o.value.kind === "constant" && o.value.value instanceof Sn)
									_(o.value.value.sections);
								else if (o.value.kind === "source") {
									const v = (S) => {
											f ||
												(S instanceof _a && Rr(S.value) === pn
													? _(S.value.sections)
													: S instanceof ko
													? _(S.sections)
													: S.eachChild(v));
										},
										b = o.value;
									b._styleExpression && v(b._styleExpression.expression);
								}
								return f;
							}
						}
						let cg;
						var g1 = {
							get paint() {
								return (cg =
									cg ||
									new Ui({
										"background-color": new wr(
											ye.paint_background["background-color"]
										),
										"background-pattern": new _o(
											ye.paint_background["background-pattern"]
										),
										"background-opacity": new wr(
											ye.paint_background["background-opacity"]
										),
									}));
							},
						};
						class v1 extends xa {
							constructor(t) {
								super(t, g1);
							}
						}
						let ug;
						var y1 = {
							get paint() {
								return (ug =
									ug ||
									new Ui({
										"raster-opacity": new wr(ye.paint_raster["raster-opacity"]),
										"raster-hue-rotate": new wr(
											ye.paint_raster["raster-hue-rotate"]
										),
										"raster-brightness-min": new wr(
											ye.paint_raster["raster-brightness-min"]
										),
										"raster-brightness-max": new wr(
											ye.paint_raster["raster-brightness-max"]
										),
										"raster-saturation": new wr(
											ye.paint_raster["raster-saturation"]
										),
										"raster-contrast": new wr(
											ye.paint_raster["raster-contrast"]
										),
										"raster-resampling": new wr(
											ye.paint_raster["raster-resampling"]
										),
										"raster-fade-duration": new wr(
											ye.paint_raster["raster-fade-duration"]
										),
									}));
							},
						};
						class x1 extends xa {
							constructor(t) {
								super(t, y1);
							}
						}
						class b1 extends xa {
							constructor(t) {
								super(t, {}),
									(this.onAdd = (r) => {
										this.implementation.onAdd &&
											this.implementation.onAdd(r, r.painter.context.gl);
									}),
									(this.onRemove = (r) => {
										this.implementation.onRemove &&
											this.implementation.onRemove(r, r.painter.context.gl);
									}),
									(this.implementation = t);
							}
							is3D() {
								return this.implementation.renderingMode === "3d";
							}
							hasOffscreenPass() {
								return this.implementation.prerender !== void 0;
							}
							recalculate() {}
							updateTransitions() {}
							hasTransition() {
								return !1;
							}
							serialize() {
								throw new Error("Custom layers cannot be serialized");
							}
						}
						class w1 {
							constructor(t) {
								(this._methodToThrottle = t),
									(this._triggered = !1),
									typeof MessageChannel < "u" &&
										((this._channel = new MessageChannel()),
										(this._channel.port2.onmessage = () => {
											(this._triggered = !1), this._methodToThrottle();
										}));
							}
							trigger() {
								this._triggered ||
									((this._triggered = !0),
									this._channel
										? this._channel.port1.postMessage(!0)
										: setTimeout(() => {
												(this._triggered = !1), this._methodToThrottle();
										  }, 0));
							}
							remove() {
								delete this._channel, (this._methodToThrottle = () => {});
							}
						}
						const T1 = { once: !0 },
							vf = 63710088e-1;
						class ys {
							constructor(t, r) {
								if (isNaN(t) || isNaN(r))
									throw new Error(`Invalid LngLat object: (${t}, ${r})`);
								if (
									((this.lng = +t),
									(this.lat = +r),
									this.lat > 90 || this.lat < -90)
								)
									throw new Error(
										"Invalid LngLat latitude value: must be between -90 and 90"
									);
							}
							wrap() {
								return new ys(at(this.lng, -180, 180), this.lat);
							}
							toArray() {
								return [this.lng, this.lat];
							}
							toString() {
								return `LngLat(${this.lng}, ${this.lat})`;
							}
							distanceTo(t) {
								const r = Math.PI / 180,
									o = this.lat * r,
									c = t.lat * r,
									f =
										Math.sin(o) * Math.sin(c) +
										Math.cos(o) *
											Math.cos(c) *
											Math.cos((t.lng - this.lng) * r);
								return vf * Math.acos(Math.min(f, 1));
							}
							static convert(t) {
								if (t instanceof ys) return t;
								if (Array.isArray(t) && (t.length === 2 || t.length === 3))
									return new ys(Number(t[0]), Number(t[1]));
								if (!Array.isArray(t) && typeof t == "object" && t !== null)
									return new ys(
										Number("lng" in t ? t.lng : t.lon),
										Number(t.lat)
									);
								throw new Error(
									"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
								);
							}
						}
						const hg = 2 * Math.PI * vf;
						function dg(n) {
							return hg * Math.cos((n * Math.PI) / 180);
						}
						function pg(n) {
							return (180 + n) / 360;
						}
						function fg(n) {
							return (
								(180 -
									(180 / Math.PI) *
										Math.log(Math.tan(Math.PI / 4 + (n * Math.PI) / 360))) /
								360
							);
						}
						function mg(n, t) {
							return n / dg(t);
						}
						function yf(n) {
							return (
								(360 / Math.PI) *
									Math.atan(Math.exp(((180 - 360 * n) * Math.PI) / 180)) -
								90
							);
						}
						function _g(n, t) {
							return n * dg(yf(t));
						}
						class ku {
							constructor(t, r, o = 0) {
								(this.x = +t), (this.y = +r), (this.z = +o);
							}
							static fromLngLat(t, r = 0) {
								const o = ys.convert(t);
								return new ku(pg(o.lng), fg(o.lat), mg(r, o.lat));
							}
							toLngLat() {
								return new ys(360 * this.x - 180, yf(this.y));
							}
							toAltitude() {
								return _g(this.z, this.y);
							}
							meterInMercatorCoordinateUnits() {
								return (
									(1 / hg) *
									((t = yf(this.y)), 1 / Math.cos((t * Math.PI) / 180))
								);
								var t;
							}
						}
						function gg(n, t, r) {
							var o = (2 * Math.PI * 6378137) / 256 / Math.pow(2, r);
							return [
								n * o - (2 * Math.PI * 6378137) / 2,
								t * o - (2 * Math.PI * 6378137) / 2,
							];
						}
						class xf {
							constructor(t, r, o) {
								if (
									!(function (c, f, _) {
										return !(
											c < 0 ||
											c > 25 ||
											_ < 0 ||
											_ >= Math.pow(2, c) ||
											f < 0 ||
											f >= Math.pow(2, c)
										);
									})(t, r, o)
								)
									throw new Error(
										`x=${r}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(
											2,
											t
										)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `
									);
								(this.z = t),
									(this.x = r),
									(this.y = o),
									(this.key = ic(0, t, t, r, o));
							}
							equals(t) {
								return this.z === t.z && this.x === t.x && this.y === t.y;
							}
							url(t, r, o) {
								const c =
									((_ = this.y),
									(v = this.z),
									(b = gg(
										256 * (f = this.x),
										256 * (_ = Math.pow(2, v) - _ - 1),
										v
									)),
									(S = gg(256 * (f + 1), 256 * (_ + 1), v)),
									b[0] + "," + b[1] + "," + S[0] + "," + S[1]);
								var f, _, v, b, S;
								const I = (function (L, F, q) {
									let Z,
										W = "";
									for (let J = L; J > 0; J--)
										(Z = 1 << (J - 1)),
											(W += (F & Z ? 1 : 0) + (q & Z ? 2 : 0));
									return W;
								})(this.z, this.x, this.y);
								return t[(this.x + this.y) % t.length]
									.replace(
										/{prefix}/g,
										(this.x % 16).toString(16) + (this.y % 16).toString(16)
									)
									.replace(/{z}/g, String(this.z))
									.replace(/{x}/g, String(this.x))
									.replace(
										/{y}/g,
										String(
											o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y
										)
									)
									.replace(/{ratio}/g, r > 1 ? "@2x" : "")
									.replace(/{quadkey}/g, I)
									.replace(/{bbox-epsg-3857}/g, c);
							}
							isChildOf(t) {
								const r = this.z - t.z;
								return r > 0 && t.x === this.x >> r && t.y === this.y >> r;
							}
							getTilePoint(t) {
								const r = Math.pow(2, this.z);
								return new B((t.x * r - this.x) * oe, (t.y * r - this.y) * oe);
							}
							toString() {
								return `${this.z}/${this.x}/${this.y}`;
							}
						}
						class vg {
							constructor(t, r) {
								(this.wrap = t),
									(this.canonical = r),
									(this.key = ic(t, r.z, r.z, r.x, r.y));
							}
						}
						class Ra {
							constructor(t, r, o, c, f) {
								if (((this.terrainRttPosMatrix32f = null), t < o))
									throw new Error(
										`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`
									);
								(this.overscaledZ = t),
									(this.wrap = r),
									(this.canonical = new xf(o, +c, +f)),
									(this.key = ic(r, t, o, c, f));
							}
							clone() {
								return new Ra(
									this.overscaledZ,
									this.wrap,
									this.canonical.z,
									this.canonical.x,
									this.canonical.y
								);
							}
							equals(t) {
								return (
									this.overscaledZ === t.overscaledZ &&
									this.wrap === t.wrap &&
									this.canonical.equals(t.canonical)
								);
							}
							scaledTo(t) {
								if (t > this.overscaledZ)
									throw new Error(
										`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
									);
								const r = this.canonical.z - t;
								return t > this.canonical.z
									? new Ra(
											t,
											this.wrap,
											this.canonical.z,
											this.canonical.x,
											this.canonical.y
									  )
									: new Ra(
											t,
											this.wrap,
											t,
											this.canonical.x >> r,
											this.canonical.y >> r
									  );
							}
							calculateScaledKey(t, r) {
								if (t > this.overscaledZ)
									throw new Error(
										`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`
									);
								const o = this.canonical.z - t;
								return t > this.canonical.z
									? ic(
											this.wrap * +r,
											t,
											this.canonical.z,
											this.canonical.x,
											this.canonical.y
									  )
									: ic(
											this.wrap * +r,
											t,
											t,
											this.canonical.x >> o,
											this.canonical.y >> o
									  );
							}
							isChildOf(t) {
								if (t.wrap !== this.wrap) return !1;
								const r = this.canonical.z - t.canonical.z;
								return (
									t.overscaledZ === 0 ||
									(t.overscaledZ < this.overscaledZ &&
										t.canonical.x === this.canonical.x >> r &&
										t.canonical.y === this.canonical.y >> r)
								);
							}
							children(t) {
								if (this.overscaledZ >= t)
									return [
										new Ra(
											this.overscaledZ + 1,
											this.wrap,
											this.canonical.z,
											this.canonical.x,
											this.canonical.y
										),
									];
								const r = this.canonical.z + 1,
									o = 2 * this.canonical.x,
									c = 2 * this.canonical.y;
								return [
									new Ra(r, this.wrap, r, o, c),
									new Ra(r, this.wrap, r, o + 1, c),
									new Ra(r, this.wrap, r, o, c + 1),
									new Ra(r, this.wrap, r, o + 1, c + 1),
								];
							}
							isLessThan(t) {
								return (
									this.wrap < t.wrap ||
									(!(this.wrap > t.wrap) &&
										(this.overscaledZ < t.overscaledZ ||
											(!(this.overscaledZ > t.overscaledZ) &&
												(this.canonical.x < t.canonical.x ||
													(!(this.canonical.x > t.canonical.x) &&
														this.canonical.y < t.canonical.y)))))
								);
							}
							wrapped() {
								return new Ra(
									this.overscaledZ,
									0,
									this.canonical.z,
									this.canonical.x,
									this.canonical.y
								);
							}
							unwrapTo(t) {
								return new Ra(
									this.overscaledZ,
									t,
									this.canonical.z,
									this.canonical.x,
									this.canonical.y
								);
							}
							overscaleFactor() {
								return Math.pow(2, this.overscaledZ - this.canonical.z);
							}
							toUnwrapped() {
								return new vg(this.wrap, this.canonical);
							}
							toString() {
								return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
							}
							getTilePoint(t) {
								return this.canonical.getTilePoint(
									new ku(t.x - this.wrap, t.y)
								);
							}
						}
						function ic(n, t, r, o, c) {
							(n *= 2) < 0 && (n = -1 * n - 1);
							const f = 1 << r;
							return (
								(f * f * n + f * c + o).toString(36) +
								r.toString(36) +
								t.toString(36)
							);
						}
						function Au(n, t) {
							return t ? n.properties[t] : n.id;
						}
						ir("CanonicalTileID", xf),
							ir("OverscaledTileID", Ra, { omit: ["terrainRttPosMatrix32f"] });
						class rl {
							constructor() {
								(this.minX = 1 / 0),
									(this.maxX = -1 / 0),
									(this.minY = 1 / 0),
									(this.maxY = -1 / 0);
							}
							extend(t) {
								return (
									(this.minX = Math.min(this.minX, t.x)),
									(this.minY = Math.min(this.minY, t.y)),
									(this.maxX = Math.max(this.maxX, t.x)),
									(this.maxY = Math.max(this.maxY, t.y)),
									this
								);
							}
							expandBy(t) {
								return (
									(this.minX -= t),
									(this.minY -= t),
									(this.maxX += t),
									(this.maxY += t),
									(this.minX > this.maxX || this.minY > this.maxY) &&
										((this.minX = 1 / 0),
										(this.maxX = -1 / 0),
										(this.minY = 1 / 0),
										(this.maxY = -1 / 0)),
									this
								);
							}
							shrinkBy(t) {
								return this.expandBy(-t);
							}
							map(t) {
								const r = new rl();
								return (
									r.extend(t(new B(this.minX, this.minY))),
									r.extend(t(new B(this.maxX, this.minY))),
									r.extend(t(new B(this.minX, this.maxY))),
									r.extend(t(new B(this.maxX, this.maxY))),
									r
								);
							}
							static fromPoints(t) {
								const r = new rl();
								for (const o of t) r.extend(o);
								return r;
							}
							contains(t) {
								return (
									t.x >= this.minX &&
									t.x <= this.maxX &&
									t.y >= this.minY &&
									t.y <= this.maxY
								);
							}
							empty() {
								return this.minX > this.maxX;
							}
							width() {
								return this.maxX - this.minX;
							}
							height() {
								return this.maxY - this.minY;
							}
							covers(t) {
								return (
									!this.empty() &&
									!t.empty() &&
									t.minX >= this.minX &&
									t.maxX <= this.maxX &&
									t.minY >= this.minY &&
									t.maxY <= this.maxY
								);
							}
							intersects(t) {
								return (
									!this.empty() &&
									!t.empty() &&
									t.minX <= this.maxX &&
									t.maxX >= this.minX &&
									t.minY <= this.maxY &&
									t.maxY >= this.minY
								);
							}
						}
						class yg {
							constructor(t) {
								(this._stringToNumber = {}), (this._numberToString = []);
								for (let r = 0; r < t.length; r++) {
									const o = t[r];
									(this._stringToNumber[o] = r), (this._numberToString[r] = o);
								}
							}
							encode(t) {
								return this._stringToNumber[t];
							}
							decode(t) {
								if (t >= this._numberToString.length)
									throw new Error(
										`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`
									);
								return this._numberToString[t];
							}
						}
						class xg {
							constructor(t, r, o, c, f) {
								(this.type = "Feature"),
									(this._vectorTileFeature = t),
									(t._z = r),
									(t._x = o),
									(t._y = c),
									(this.properties = t.properties),
									(this.id = f);
							}
							get geometry() {
								return (
									this._geometry === void 0 &&
										(this._geometry = this._vectorTileFeature.toGeoJSON(
											this._vectorTileFeature._x,
											this._vectorTileFeature._y,
											this._vectorTileFeature._z
										).geometry),
									this._geometry
								);
							}
							set geometry(t) {
								this._geometry = t;
							}
							toJSON() {
								const t = { geometry: this.geometry };
								for (const r in this)
									r !== "_geometry" &&
										r !== "_vectorTileFeature" &&
										(t[r] = this[r]);
								return t;
							}
						}
						class bg {
							constructor(t, r) {
								(this.tileID = t),
									(this.x = t.canonical.x),
									(this.y = t.canonical.y),
									(this.z = t.canonical.z),
									(this.grid = new Ys(oe, 16, 0)),
									(this.grid3D = new Ys(oe, 16, 0)),
									(this.featureIndexArray = new Pe()),
									(this.promoteId = r);
							}
							insert(t, r, o, c, f, _) {
								const v = this.featureIndexArray.length;
								this.featureIndexArray.emplaceBack(o, c, f);
								const b = _ ? this.grid3D : this.grid;
								for (let S = 0; S < r.length; S++) {
									const I = r[S],
										L = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
									for (let F = 0; F < I.length; F++) {
										const q = I[F];
										(L[0] = Math.min(L[0], q.x)),
											(L[1] = Math.min(L[1], q.y)),
											(L[2] = Math.max(L[2], q.x)),
											(L[3] = Math.max(L[3], q.y));
									}
									L[0] < oe &&
										L[1] < oe &&
										L[2] >= 0 &&
										L[3] >= 0 &&
										b.insert(v, L[0], L[1], L[2], L[3]);
								}
							}
							loadVTLayers() {
								return (
									this.vtLayers ||
										((this.vtLayers = new F_(new cf(this.rawTileData)).layers),
										(this.sourceLayerCoder = new yg(
											this.vtLayers
												? Object.keys(this.vtLayers).sort()
												: ["_geojsonTileLayer"]
										))),
									this.vtLayers
								);
							}
							query(t, r, o, c) {
								this.loadVTLayers();
								const f = t.params,
									_ = oe / t.tileSize / t.scale,
									v = Ro(f.filter),
									b = t.queryGeometry,
									S = t.queryPadding * _,
									I = rl.fromPoints(b),
									L = this.grid.query(
										I.minX - S,
										I.minY - S,
										I.maxX + S,
										I.maxY + S
									),
									F = rl.fromPoints(t.cameraQueryGeometry).expandBy(S),
									q = this.grid3D.query(
										F.minX,
										F.minY,
										F.maxX,
										F.maxY,
										(J, le, Re, xe) =>
											(function (Ce, Ye, lt, Pt, Yt) {
												for (const Ht of Ce)
													if (
														Ye <= Ht.x &&
														lt <= Ht.y &&
														Pt >= Ht.x &&
														Yt >= Ht.y
													)
														return !0;
												const qt = [
													new B(Ye, lt),
													new B(Ye, Yt),
													new B(Pt, Yt),
													new B(Pt, lt),
												];
												if (Ce.length > 2) {
													for (const Ht of qt) if (Yl(Ce, Ht)) return !0;
												}
												for (let Ht = 0; Ht < Ce.length - 1; Ht++)
													if (ty(Ce[Ht], Ce[Ht + 1], qt)) return !0;
												return !1;
											})(t.cameraQueryGeometry, J - S, le - S, Re + S, xe + S)
									);
								for (const J of q) L.push(J);
								L.sort(C1);
								const Z = {};
								let W;
								for (let J = 0; J < L.length; J++) {
									const le = L[J];
									if (le === W) continue;
									W = le;
									const Re = this.featureIndexArray.get(le);
									let xe = null;
									this.loadMatchingFeature(
										Z,
										Re.bucketIndex,
										Re.sourceLayerIndex,
										Re.featureIndex,
										v,
										f.layers,
										f.availableImages,
										r,
										o,
										c,
										(Ce, Ye, lt) => (
											xe || (xe = bo(Ce)),
											Ye.queryIntersectsFeature({
												queryGeometry: b,
												feature: Ce,
												featureState: lt,
												geometry: xe,
												zoom: this.z,
												transform: t.transform,
												pixelsToTileUnits: _,
												pixelPosMatrix: t.pixelPosMatrix,
												unwrappedTileID: this.tileID.toUnwrapped(),
												getElevation: t.getElevation,
											})
										)
									);
								}
								return Z;
							}
							loadMatchingFeature(t, r, o, c, f, _, v, b, S, I, L) {
								const F = this.bucketLayerIDs[r];
								if (_ && !F.some((J) => _.has(J))) return;
								const q = this.sourceLayerCoder.decode(o),
									Z = this.vtLayers[q].feature(c);
								if (f.needGeometry) {
									const J = no(Z, !0);
									if (
										!f.filter(
											new Un(this.tileID.overscaledZ),
											J,
											this.tileID.canonical
										)
									)
										return;
								} else if (!f.filter(new Un(this.tileID.overscaledZ), Z)) return;
								const W = this.getId(Z, q);
								for (let J = 0; J < F.length; J++) {
									const le = F[J];
									if (_ && !_.has(le)) continue;
									const Re = b[le];
									if (!Re) continue;
									let xe = {};
									W &&
										I &&
										(xe = I.getState(Re.sourceLayer || "_geojsonTileLayer", W));
									const Ce = dt({}, S[le]);
									(Ce.paint = wg(Ce.paint, Re.paint, Z, xe, v)),
										(Ce.layout = wg(Ce.layout, Re.layout, Z, xe, v));
									const Ye = !L || L(Z, Re, xe);
									if (!Ye) continue;
									const lt = new xg(Z, this.z, this.x, this.y, W);
									lt.layer = Ce;
									let Pt = t[le];
									Pt === void 0 && (Pt = t[le] = []),
										Pt.push({
											featureIndex: c,
											feature: lt,
											intersectionZ: Ye,
										});
								}
							}
							lookupSymbolFeatures(t, r, o, c, f, _, v, b) {
								const S = {};
								this.loadVTLayers();
								const I = Ro(f);
								for (const L of t)
									this.loadMatchingFeature(S, o, c, L, I, _, v, b, r);
								return S;
							}
							hasLayer(t) {
								for (const r of this.bucketLayerIDs)
									for (const o of r) if (t === o) return !0;
								return !1;
							}
							getId(t, r) {
								var o;
								let c = t.id;
								return (
									this.promoteId &&
										((c =
											t.properties[
												typeof this.promoteId == "string"
													? this.promoteId
													: this.promoteId[r]
											]),
										typeof c == "boolean" && (c = Number(c)),
										c === void 0 &&
											!((o = t.properties) === null || o === void 0) &&
											o.cluster &&
											this.promoteId &&
											(c = Number(t.properties.cluster_id))),
									c
								);
							}
						}
						function wg(n, t, r, o, c) {
							return xt(n, (f, _) => {
								const v = t instanceof ql ? t.get(_) : null;
								return v && v.evaluate ? v.evaluate(r, o, c) : v;
							});
						}
						function C1(n, t) {
							return t - n;
						}
						function Tg(n, t, r, o, c) {
							const f = [];
							for (let _ = 0; _ < n.length; _++) {
								const v = n[_];
								let b;
								for (let S = 0; S < v.length - 1; S++) {
									let I = v[S],
										L = v[S + 1];
									(I.x < t && L.x < t) ||
										(I.x < t
											? (I = new B(
													t,
													I.y + ((t - I.x) / (L.x - I.x)) * (L.y - I.y)
											  )._round())
											: L.x < t &&
											  (L = new B(
													t,
													I.y + ((t - I.x) / (L.x - I.x)) * (L.y - I.y)
											  )._round()),
										(I.y < r && L.y < r) ||
											(I.y < r
												? (I = new B(
														I.x + ((r - I.y) / (L.y - I.y)) * (L.x - I.x),
														r
												  )._round())
												: L.y < r &&
												  (L = new B(
														I.x + ((r - I.y) / (L.y - I.y)) * (L.x - I.x),
														r
												  )._round()),
											(I.x >= o && L.x >= o) ||
												(I.x >= o
													? (I = new B(
															o,
															I.y + ((o - I.x) / (L.x - I.x)) * (L.y - I.y)
													  )._round())
													: L.x >= o &&
													  (L = new B(
															o,
															I.y + ((o - I.x) / (L.x - I.x)) * (L.y - I.y)
													  )._round()),
												(I.y >= c && L.y >= c) ||
													(I.y >= c
														? (I = new B(
																I.x + ((c - I.y) / (L.y - I.y)) * (L.x - I.x),
																c
														  )._round())
														: L.y >= c &&
														  (L = new B(
																I.x + ((c - I.y) / (L.y - I.y)) * (L.x - I.x),
																c
														  )._round()),
													(b && I.equals(b[b.length - 1])) ||
														((b = [I]), f.push(b)),
													b.push(L)))));
								}
							}
							return f;
						}
						ir("FeatureIndex", bg, {
							omit: ["rawTileData", "sourceLayerCoder"],
						});
						class xs extends B {
							constructor(t, r, o, c) {
								super(t, r),
									(this.angle = o),
									c !== void 0 && (this.segment = c);
							}
							clone() {
								return new xs(this.x, this.y, this.angle, this.segment);
							}
						}
						function Cg(n, t, r, o, c) {
							if (t.segment === void 0 || r === 0) return !0;
							let f = t,
								_ = t.segment + 1,
								v = 0;
							for (; v > -r / 2; ) {
								if ((_--, _ < 0)) return !1;
								(v -= n[_].dist(f)), (f = n[_]);
							}
							(v += n[_].dist(n[_ + 1])), _++;
							const b = [];
							let S = 0;
							for (; v < r / 2; ) {
								const I = n[_],
									L = n[_ + 1];
								if (!L) return !1;
								let F = n[_ - 1].angleTo(I) - I.angleTo(L);
								for (
									F = Math.abs(((F + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
										b.push({ distance: v, angleDelta: F }),
										S += F;
									v - b[0].distance > o;

								)
									S -= b.shift().angleDelta;
								if (S > c) return !1;
								_++, (v += I.dist(L));
							}
							return !0;
						}
						function Sg(n) {
							let t = 0;
							for (let r = 0; r < n.length - 1; r++) t += n[r].dist(n[r + 1]);
							return t;
						}
						function Pg(n, t, r) {
							return n ? 0.6 * t * r : 0;
						}
						function Ig(n, t) {
							return Math.max(
								n ? n.right - n.left : 0,
								t ? t.right - t.left : 0
							);
						}
						function S1(n, t, r, o, c, f) {
							const _ = Pg(r, c, f),
								v = Ig(r, o) * f;
							let b = 0;
							const S = Sg(n) / 2;
							for (let I = 0; I < n.length - 1; I++) {
								const L = n[I],
									F = n[I + 1],
									q = L.dist(F);
								if (b + q > S) {
									const Z = (S - b) / q,
										W = Za.number(L.x, F.x, Z),
										J = Za.number(L.y, F.y, Z),
										le = new xs(W, J, F.angleTo(L), I);
									return le._round(), !_ || Cg(n, le, v, _, t) ? le : void 0;
								}
								b += q;
							}
						}
						function P1(n, t, r, o, c, f, _, v, b) {
							const S = Pg(o, f, _),
								I = Ig(o, c),
								L = I * _,
								F =
									n[0].x === 0 || n[0].x === b || n[0].y === 0 || n[0].y === b;
							return (
								t - L < t / 4 && (t = L + t / 4),
								Mg(
									n,
									F ? ((t / 2) * v) % t : ((I / 2 + 2 * f) * _ * v) % t,
									t,
									S,
									r,
									L,
									F,
									!1,
									b
								)
							);
						}
						function Mg(n, t, r, o, c, f, _, v, b) {
							const S = f / 2,
								I = Sg(n);
							let L = 0,
								F = t - r,
								q = [];
							for (let Z = 0; Z < n.length - 1; Z++) {
								const W = n[Z],
									J = n[Z + 1],
									le = W.dist(J),
									Re = J.angleTo(W);
								for (; F + r < L + le; ) {
									F += r;
									const xe = (F - L) / le,
										Ce = Za.number(W.x, J.x, xe),
										Ye = Za.number(W.y, J.y, xe);
									if (
										Ce >= 0 &&
										Ce < b &&
										Ye >= 0 &&
										Ye < b &&
										F - S >= 0 &&
										F + S <= I
									) {
										const lt = new xs(Ce, Ye, Re, Z);
										lt._round(), (o && !Cg(n, lt, f, o, c)) || q.push(lt);
									}
								}
								L += le;
							}
							return (
								v || q.length || _ || (q = Mg(n, L / 2, r, o, c, f, _, !0, b)),
								q
							);
						}
						function kg(n, t, r, o) {
							const c = [],
								f = n.image,
								_ = f.pixelRatio,
								v = f.paddedRect.w - 2,
								b = f.paddedRect.h - 2;
							let S = { x1: n.left, y1: n.top, x2: n.right, y2: n.bottom };
							const I = f.stretchX || [[0, v]],
								L = f.stretchY || [[0, b]],
								F = (gt, Nr) => gt + Nr[1] - Nr[0],
								q = I.reduce(F, 0),
								Z = L.reduce(F, 0),
								W = v - q,
								J = b - Z;
							let le = 0,
								Re = q,
								xe = 0,
								Ce = Z,
								Ye = 0,
								lt = W,
								Pt = 0,
								Yt = J;
							if (f.content && o) {
								const gt = f.content,
									Nr = gt[2] - gt[0],
									Hr = gt[3] - gt[1];
								(f.textFitWidth || f.textFitHeight) && (S = ng(n)),
									(le = Bd(I, 0, gt[0])),
									(xe = Bd(L, 0, gt[1])),
									(Re = Bd(I, gt[0], gt[2])),
									(Ce = Bd(L, gt[1], gt[3])),
									(Ye = gt[0] - le),
									(Pt = gt[1] - xe),
									(lt = Nr - Re),
									(Yt = Hr - Ce);
							}
							const qt = S.x1,
								Ht = S.y1,
								Sr = S.x2 - qt,
								Gt = S.y2 - Ht,
								Wt = (gt, Nr, Hr, kr) => {
									const yr = Fd(gt.stretch - le, Re, Sr, qt),
										dn = Od(gt.fixed - Ye, lt, gt.stretch, q),
										Qn = Fd(Nr.stretch - xe, Ce, Gt, Ht),
										gi = Od(Nr.fixed - Pt, Yt, Nr.stretch, Z),
										qi = Fd(Hr.stretch - le, Re, Sr, qt),
										Ba = Od(Hr.fixed - Ye, lt, Hr.stretch, q),
										ua = Fd(kr.stretch - xe, Ce, Gt, Ht),
										Ri = Od(kr.fixed - Pt, Yt, kr.stretch, Z),
										Xn = new B(yr, Qn),
										Pi = new B(qi, Qn),
										Bi = new B(qi, ua),
										Fi = new B(yr, ua),
										ra = new B(dn / _, gi / _),
										Fa = new B(Ba / _, Ri / _),
										Ii = (t * Math.PI) / 180;
									if (Ii) {
										const Mi = Math.sin(Ii),
											ki = Math.cos(Ii),
											ui = [ki, -Mi, Mi, ki];
										Xn._matMult(ui),
											Pi._matMult(ui),
											Fi._matMult(ui),
											Bi._matMult(ui);
									}
									const ha = gt.stretch + gt.fixed,
										vi = Nr.stretch + Nr.fixed;
									return {
										tl: Xn,
										tr: Pi,
										bl: Fi,
										br: Bi,
										tex: {
											x: f.paddedRect.x + 1 + ha,
											y: f.paddedRect.y + 1 + vi,
											w: Hr.stretch + Hr.fixed - ha,
											h: kr.stretch + kr.fixed - vi,
										},
										writingMode: void 0,
										glyphOffset: [0, 0],
										sectionIndex: 0,
										pixelOffsetTL: ra,
										pixelOffsetBR: Fa,
										minFontScaleX: lt / _ / Sr,
										minFontScaleY: Yt / _ / Gt,
										isSDF: r,
									};
								};
							if (o && (f.stretchX || f.stretchY)) {
								const gt = Ag(I, W, q),
									Nr = Ag(L, J, Z);
								for (let Hr = 0; Hr < gt.length - 1; Hr++) {
									const kr = gt[Hr],
										yr = gt[Hr + 1];
									for (let dn = 0; dn < Nr.length - 1; dn++)
										c.push(Wt(kr, Nr[dn], yr, Nr[dn + 1]));
								}
							} else c.push(Wt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: v + 1 }, { fixed: 0, stretch: b + 1 }));
							return c;
						}
						function Bd(n, t, r) {
							let o = 0;
							for (const c of n)
								o +=
									Math.max(t, Math.min(r, c[1])) -
									Math.max(t, Math.min(r, c[0]));
							return o;
						}
						function Ag(n, t, r) {
							const o = [{ fixed: -1, stretch: 0 }];
							for (const [c, f] of n) {
								const _ = o[o.length - 1];
								o.push({ fixed: c - _.stretch, stretch: _.stretch }),
									o.push({
										fixed: c - _.stretch,
										stretch: _.stretch + (f - c),
									});
							}
							return o.push({ fixed: t + 1, stretch: r }), o;
						}
						function Fd(n, t, r, o) {
							return (n / t) * r + o;
						}
						function Od(n, t, r, o) {
							return n - (t * r) / o;
						}
						ir("Anchor", xs);
						class Nd {
							constructor(t, r, o, c, f, _, v, b, S, I) {
								var L;
								if (((this.boxStartIndex = t.length), S)) {
									let F = _.top,
										q = _.bottom;
									const Z = _.collisionPadding;
									Z && ((F -= Z[1]), (q += Z[3]));
									let W = q - F;
									W > 0 && ((W = Math.max(10, W)), (this.circleDiameter = W));
								} else {
									const F =
										!((L = _.image) === null || L === void 0) &&
										L.content &&
										(_.image.textFitWidth || _.image.textFitHeight)
											? ng(_)
											: { x1: _.left, y1: _.top, x2: _.right, y2: _.bottom };
									(F.y1 = F.y1 * v - b[0]),
										(F.y2 = F.y2 * v + b[2]),
										(F.x1 = F.x1 * v - b[3]),
										(F.x2 = F.x2 * v + b[1]);
									const q = _.collisionPadding;
									if (
										(q &&
											((F.x1 -= q[0] * v),
											(F.y1 -= q[1] * v),
											(F.x2 += q[2] * v),
											(F.y2 += q[3] * v)),
										I)
									) {
										const Z = new B(F.x1, F.y1),
											W = new B(F.x2, F.y1),
											J = new B(F.x1, F.y2),
											le = new B(F.x2, F.y2),
											Re = (I * Math.PI) / 180;
										Z._rotate(Re),
											W._rotate(Re),
											J._rotate(Re),
											le._rotate(Re),
											(F.x1 = Math.min(Z.x, W.x, J.x, le.x)),
											(F.x2 = Math.max(Z.x, W.x, J.x, le.x)),
											(F.y1 = Math.min(Z.y, W.y, J.y, le.y)),
											(F.y2 = Math.max(Z.y, W.y, J.y, le.y));
									}
									t.emplaceBack(r.x, r.y, F.x1, F.y1, F.x2, F.y2, o, c, f);
								}
								this.boxEndIndex = t.length;
							}
						}
						class I1 {
							constructor(t = [], r = (o, c) => (o < c ? -1 : o > c ? 1 : 0)) {
								if (
									((this.data = t),
									(this.length = this.data.length),
									(this.compare = r),
									this.length > 0)
								)
									for (let o = (this.length >> 1) - 1; o >= 0; o--)
										this._down(o);
							}
							push(t) {
								this.data.push(t), this._up(this.length++);
							}
							pop() {
								if (this.length === 0) return;
								const t = this.data[0],
									r = this.data.pop();
								return (
									--this.length > 0 && ((this.data[0] = r), this._down(0)), t
								);
							}
							peek() {
								return this.data[0];
							}
							_up(t) {
								const { data: r, compare: o } = this,
									c = r[t];
								for (; t > 0; ) {
									const f = (t - 1) >> 1,
										_ = r[f];
									if (o(c, _) >= 0) break;
									(r[t] = _), (t = f);
								}
								r[t] = c;
							}
							_down(t) {
								const { data: r, compare: o } = this,
									c = this.length >> 1,
									f = r[t];
								for (; t < c; ) {
									let _ = 1 + (t << 1);
									const v = _ + 1;
									if (
										(v < this.length && o(r[v], r[_]) < 0 && (_ = v),
										o(r[_], f) >= 0)
									)
										break;
									(r[t] = r[_]), (t = _);
								}
								r[t] = f;
							}
						}
						function M1(n, t = 1, r = !1) {
							const o = rl.fromPoints(n[0]),
								c = Math.min(o.width(), o.height());
							let f = c / 2;
							const _ = new I1([], k1),
								{ minX: v, minY: b, maxX: S, maxY: I } = o;
							if (c === 0) return new B(v, b);
							for (let q = v; q < S; q += c)
								for (let Z = b; Z < I; Z += c)
									_.push(new ac(q + f, Z + f, f, n));
							let L = (function (q) {
									let Z = 0,
										W = 0,
										J = 0;
									const le = q[0];
									for (
										let Re = 0, xe = le.length, Ce = xe - 1;
										Re < xe;
										Ce = Re++
									) {
										const Ye = le[Re],
											lt = le[Ce],
											Pt = Ye.x * lt.y - lt.x * Ye.y;
										(W += (Ye.x + lt.x) * Pt),
											(J += (Ye.y + lt.y) * Pt),
											(Z += 3 * Pt);
									}
									return new ac(W / Z, J / Z, 0, q);
								})(n),
								F = _.length;
							for (; _.length; ) {
								const q = _.pop();
								(q.d > L.d || !L.d) &&
									((L = q),
									r &&
										console.log(
											"found best %d after %d probes",
											Math.round(1e4 * q.d) / 1e4,
											F
										)),
									q.max - L.d <= t ||
										((f = q.h / 2),
										_.push(new ac(q.p.x - f, q.p.y - f, f, n)),
										_.push(new ac(q.p.x + f, q.p.y - f, f, n)),
										_.push(new ac(q.p.x - f, q.p.y + f, f, n)),
										_.push(new ac(q.p.x + f, q.p.y + f, f, n)),
										(F += 4));
							}
							return (
								r &&
									(console.log(`num probes: ${F}`),
									console.log(`best distance: ${L.d}`)),
								L.p
							);
						}
						function k1(n, t) {
							return t.max - n.max;
						}
						function ac(n, t, r, o) {
							(this.p = new B(n, t)),
								(this.h = r),
								(this.d = (function (c, f) {
									let _ = !1,
										v = 1 / 0;
									for (let b = 0; b < f.length; b++) {
										const S = f[b];
										for (let I = 0, L = S.length, F = L - 1; I < L; F = I++) {
											const q = S[I],
												Z = S[F];
											q.y > c.y != Z.y > c.y &&
												c.x < ((Z.x - q.x) * (c.y - q.y)) / (Z.y - q.y) + q.x &&
												(_ = !_),
												(v = Math.min(v, f_(c, q, Z)));
										}
									}
									return (_ ? 1 : -1) * Math.sqrt(v);
								})(this.p, o)),
								(this.max = this.d + this.h * Math.SQRT2);
						}
						var Vi;
						(T.aE = void 0),
							((Vi = T.aE || (T.aE = {}))[(Vi.center = 1)] = "center"),
							(Vi[(Vi.left = 2)] = "left"),
							(Vi[(Vi.right = 3)] = "right"),
							(Vi[(Vi.top = 4)] = "top"),
							(Vi[(Vi.bottom = 5)] = "bottom"),
							(Vi[(Vi["top-left"] = 6)] = "top-left"),
							(Vi[(Vi["top-right"] = 7)] = "top-right"),
							(Vi[(Vi["bottom-left"] = 8)] = "bottom-left"),
							(Vi[(Vi["bottom-right"] = 9)] = "bottom-right");
						const bf = Number.POSITIVE_INFINITY;
						function Eg(n, t) {
							return t[1] !== bf
								? (function (r, o, c) {
										let f = 0,
											_ = 0;
										switch (((o = Math.abs(o)), (c = Math.abs(c)), r)) {
											case "top-right":
											case "top-left":
											case "top":
												_ = c - 7;
												break;
											case "bottom-right":
											case "bottom-left":
											case "bottom":
												_ = 7 - c;
										}
										switch (r) {
											case "top-right":
											case "bottom-right":
											case "right":
												f = -o;
												break;
											case "top-left":
											case "bottom-left":
											case "left":
												f = o;
										}
										return [f, _];
								  })(n, t[0], t[1])
								: (function (r, o) {
										let c = 0,
											f = 0;
										o < 0 && (o = 0);
										const _ = o / Math.SQRT2;
										switch (r) {
											case "top-right":
											case "top-left":
												f = _ - 7;
												break;
											case "bottom-right":
											case "bottom-left":
												f = 7 - _;
												break;
											case "bottom":
												f = 7 - o;
												break;
											case "top":
												f = o - 7;
										}
										switch (r) {
											case "top-right":
											case "bottom-right":
												c = -_;
												break;
											case "top-left":
											case "bottom-left":
												c = _;
												break;
											case "left":
												c = o;
												break;
											case "right":
												c = -o;
										}
										return [c, f];
								  })(n, t[0]);
						}
						function zg(n, t, r) {
							var o;
							const c = n.layout,
								f =
									(o = c.get("text-variable-anchor-offset")) === null ||
									o === void 0
										? void 0
										: o.evaluate(t, {}, r);
							if (f) {
								const v = f.values,
									b = [];
								for (let S = 0; S < v.length; S += 2) {
									const I = (b[S] = v[S]),
										L = v[S + 1].map((F) => F * Si);
									I.startsWith("top")
										? (L[1] -= 7)
										: I.startsWith("bottom") && (L[1] += 7),
										(b[S + 1] = L);
								}
								return new fi(b);
							}
							const _ = c.get("text-variable-anchor");
							if (_) {
								let v;
								v =
									n._unevaluatedLayout.getValue("text-radial-offset") !== void 0
										? [c.get("text-radial-offset").evaluate(t, {}, r) * Si, bf]
										: c
												.get("text-offset")
												.evaluate(t, {}, r)
												.map((S) => S * Si);
								const b = [];
								for (const S of _) b.push(S, Eg(S, v));
								return new fi(b);
							}
							return null;
						}
						function wf(n) {
							switch (n) {
								case "right":
								case "top-right":
								case "bottom-right":
									return "right";
								case "left":
								case "top-left":
								case "bottom-left":
									return "left";
							}
							return "center";
						}
						function A1(n, t, r, o, c, f, _, v, b, S, I, L) {
							let F = f.textMaxSize.evaluate(t, {});
							F === void 0 && (F = _);
							const q = n.layers[0].layout,
								Z = q.get("icon-offset").evaluate(t, {}, I),
								W = Dg(r.horizontal),
								J = _ / 24,
								le = n.tilePixelRatio * J,
								Re = (n.tilePixelRatio * F) / 24,
								xe = n.tilePixelRatio * v,
								Ce = n.tilePixelRatio * q.get("symbol-spacing"),
								Ye = q.get("text-padding") * n.tilePixelRatio,
								lt = (function (Hr, kr, yr, dn = 1) {
									const Qn = Hr.get("icon-padding").evaluate(kr, {}, yr),
										gi = Qn && Qn.values;
									return [gi[0] * dn, gi[1] * dn, gi[2] * dn, gi[3] * dn];
								})(q, t, I, n.tilePixelRatio),
								Pt = (q.get("text-max-angle") / 180) * Math.PI,
								Yt =
									q.get("text-rotation-alignment") !== "viewport" &&
									q.get("symbol-placement") !== "point",
								qt =
									q.get("icon-rotation-alignment") === "map" &&
									q.get("symbol-placement") !== "point",
								Ht = q.get("symbol-placement"),
								Sr = Ce / 2,
								Gt = q.get("icon-text-fit");
							let Wt;
							o &&
								Gt !== "none" &&
								(n.allowVerticalPlacement &&
									r.vertical &&
									(Wt = ig(
										o,
										r.vertical,
										Gt,
										q.get("icon-text-fit-padding"),
										Z,
										J
									)),
								W && (o = ig(o, W, Gt, q.get("icon-text-fit-padding"), Z, J)));
							const gt = I ? L.line.getGranularityForZoomLevel(I.z) : 1,
								Nr = (Hr, kr) => {
									kr.x < 0 ||
										kr.x >= oe ||
										kr.y < 0 ||
										kr.y >= oe ||
										(function (
											yr,
											dn,
											Qn,
											gi,
											qi,
											Ba,
											ua,
											Ri,
											Xn,
											Pi,
											Bi,
											Fi,
											ra,
											Fa,
											Ii,
											ha,
											vi,
											Mi,
											ki,
											ui,
											qn,
											io,
											oc,
											ao,
											L1
										) {
											const sc = yr.addToLineVertexArray(dn, Qn);
											let nl,
												lc,
												cc,
												uc,
												Og = 0,
												Ng = 0,
												jg = 0,
												Vg = 0,
												Af = -1,
												Ef = -1;
											const Uo = {};
											let qg = ms("");
											if (yr.allowVerticalPlacement && gi.vertical) {
												const Hi =
													Ri.layout.get("text-rotate").evaluate(qn, {}, ao) +
													90;
												(cc = new Nd(
													Xn,
													dn,
													Pi,
													Bi,
													Fi,
													gi.vertical,
													ra,
													Fa,
													Ii,
													Hi
												)),
													ua &&
														(uc = new Nd(
															Xn,
															dn,
															Pi,
															Bi,
															Fi,
															ua,
															vi,
															Mi,
															Ii,
															Hi
														));
											}
											if (qi) {
												const Hi = Ri.layout
														.get("icon-rotate")
														.evaluate(qn, {}),
													Oa = Ri.layout.get("icon-text-fit") !== "none",
													il = kg(qi, Hi, oc, Oa),
													so = ua ? kg(ua, Hi, oc, Oa) : void 0;
												(lc = new Nd(Xn, dn, Pi, Bi, Fi, qi, vi, Mi, !1, Hi)),
													(Og = 4 * il.length);
												const al = yr.iconSizeData;
												let wo = null;
												al.kind === "source"
													? ((wo = [
															Zo * Ri.layout.get("icon-size").evaluate(qn, {}),
													  ]),
													  wo[0] > vs &&
															Lt(
																`${yr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
															))
													: al.kind === "composite" &&
													  ((wo = [
															Zo *
																io.compositeIconSizes[0].evaluate(qn, {}, ao),
															Zo *
																io.compositeIconSizes[1].evaluate(qn, {}, ao),
													  ]),
													  (wo[0] > vs || wo[1] > vs) &&
															Lt(
																`${yr.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`
															)),
													yr.addSymbols(
														yr.icon,
														il,
														wo,
														ui,
														ki,
														qn,
														T.ao.none,
														dn,
														sc.lineStartIndex,
														sc.lineLength,
														-1,
														ao
													),
													(Af = yr.icon.placedSymbolArray.length - 1),
													so &&
														((Ng = 4 * so.length),
														yr.addSymbols(
															yr.icon,
															so,
															wo,
															ui,
															ki,
															qn,
															T.ao.vertical,
															dn,
															sc.lineStartIndex,
															sc.lineLength,
															-1,
															ao
														),
														(Ef = yr.icon.placedSymbolArray.length - 1));
											}
											const Zg = Object.keys(gi.horizontal);
											for (const Hi of Zg) {
												const Oa = gi.horizontal[Hi];
												if (!nl) {
													qg = ms(Oa.text);
													const so = Ri.layout
														.get("text-rotate")
														.evaluate(qn, {}, ao);
													nl = new Nd(Xn, dn, Pi, Bi, Fi, Oa, ra, Fa, Ii, so);
												}
												const il = Oa.positionedLines.length === 1;
												if (
													((jg += Lg(
														yr,
														dn,
														Oa,
														Ba,
														Ri,
														Ii,
														qn,
														ha,
														sc,
														gi.vertical ? T.ao.horizontal : T.ao.horizontalOnly,
														il ? Zg : [Hi],
														Uo,
														Af,
														io,
														ao
													)),
													il)
												)
													break;
											}
											gi.vertical &&
												(Vg += Lg(
													yr,
													dn,
													gi.vertical,
													Ba,
													Ri,
													Ii,
													qn,
													ha,
													sc,
													T.ao.vertical,
													["vertical"],
													Uo,
													Ef,
													io,
													ao
												));
											const D1 = nl
													? nl.boxStartIndex
													: yr.collisionBoxArray.length,
												R1 = nl ? nl.boxEndIndex : yr.collisionBoxArray.length,
												B1 = cc
													? cc.boxStartIndex
													: yr.collisionBoxArray.length,
												F1 = cc ? cc.boxEndIndex : yr.collisionBoxArray.length,
												O1 = lc
													? lc.boxStartIndex
													: yr.collisionBoxArray.length,
												N1 = lc ? lc.boxEndIndex : yr.collisionBoxArray.length,
												j1 = uc
													? uc.boxStartIndex
													: yr.collisionBoxArray.length,
												V1 = uc ? uc.boxEndIndex : yr.collisionBoxArray.length;
											let oo = -1;
											const Vd = (Hi, Oa) =>
												Hi && Hi.circleDiameter
													? Math.max(Hi.circleDiameter, Oa)
													: Oa;
											(oo = Vd(nl, oo)),
												(oo = Vd(cc, oo)),
												(oo = Vd(lc, oo)),
												(oo = Vd(uc, oo));
											const Ug = oo > -1 ? 1 : 0;
											Ug && (oo *= L1 / Si),
												yr.glyphOffsetArray.length >= nc.MAX_GLYPHS &&
													Lt(
														"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"
													),
												qn.sortKey !== void 0 &&
													yr.addToSortKeyRanges(
														yr.symbolInstances.length,
														qn.sortKey
													);
											const q1 = zg(Ri, qn, ao),
												[Z1, U1] = (function (Hi, Oa) {
													const il = Hi.length,
														so = Oa == null ? void 0 : Oa.values;
													if ((so == null ? void 0 : so.length) > 0)
														for (let al = 0; al < so.length; al += 2) {
															const wo = so[al + 1];
															Hi.emplaceBack(T.aE[so[al]], wo[0], wo[1]);
														}
													return [il, Hi.length];
												})(yr.textAnchorOffsets, q1);
											yr.symbolInstances.emplaceBack(
												dn.x,
												dn.y,
												Uo.right >= 0 ? Uo.right : -1,
												Uo.center >= 0 ? Uo.center : -1,
												Uo.left >= 0 ? Uo.left : -1,
												Uo.vertical || -1,
												Af,
												Ef,
												qg,
												D1,
												R1,
												B1,
												F1,
												O1,
												N1,
												j1,
												V1,
												Pi,
												jg,
												Vg,
												Og,
												Ng,
												Ug,
												0,
												ra,
												oo,
												Z1,
												U1
											);
										})(
											n,
											kr,
											Hr,
											r,
											o,
											c,
											Wt,
											n.layers[0],
											n.collisionBoxArray,
											t.index,
											t.sourceLayerIndex,
											n.index,
											le,
											[Ye, Ye, Ye, Ye],
											Yt,
											b,
											xe,
											lt,
											qt,
											Z,
											t,
											f,
											S,
											I,
											_
										);
								};
							if (Ht === "line")
								for (const Hr of Tg(t.geometry, 0, 0, oe, oe)) {
									const kr = tl(Hr, gt),
										yr = P1(
											kr,
											Ce,
											Pt,
											r.vertical || W,
											o,
											24,
											Re,
											n.overscaling,
											oe
										);
									for (const dn of yr)
										(W && E1(n, W.text, Sr, dn)) || Nr(kr, dn);
								}
							else if (Ht === "line-center") {
								for (const Hr of t.geometry)
									if (Hr.length > 1) {
										const kr = tl(Hr, gt),
											yr = S1(kr, Pt, r.vertical || W, o, 24, Re);
										yr && Nr(kr, yr);
									}
							} else if (t.type === "Polygon")
								for (const Hr of Os(t.geometry, 0)) {
									const kr = M1(Hr, 16);
									Nr(tl(Hr[0], gt, !0), new xs(kr.x, kr.y, 0));
								}
							else if (t.type === "LineString")
								for (const Hr of t.geometry) {
									const kr = tl(Hr, gt);
									Nr(kr, new xs(kr[0].x, kr[0].y, 0));
								}
							else if (t.type === "Point")
								for (const Hr of t.geometry)
									for (const kr of Hr) Nr([kr], new xs(kr.x, kr.y, 0));
						}
						function Lg(n, t, r, o, c, f, _, v, b, S, I, L, F, q, Z) {
							const W = (function (Re, xe, Ce, Ye, lt, Pt, Yt, qt) {
									const Ht =
											(Ye.layout.get("text-rotate").evaluate(Pt, {}) *
												Math.PI) /
											180,
										Sr = [];
									for (const Gt of xe.positionedLines)
										for (const Wt of Gt.positionedGlyphs) {
											if (!Wt.rect) continue;
											const gt = Wt.rect || {};
											let Nr = 4,
												Hr = !0,
												kr = 1,
												yr = 0;
											const dn = (lt || qt) && Wt.vertical,
												Qn = (Wt.metrics.advance * Wt.scale) / 2;
											if (
												(qt &&
													xe.verticalizable &&
													(yr =
														Gt.lineOffset / 2 -
														(Wt.imageName
															? -(Si - Wt.metrics.width * Wt.scale) / 2
															: (Wt.scale - 1) * Si)),
												Wt.imageName)
											) {
												const Mi = Yt[Wt.imageName];
												(Hr = Mi.sdf), (kr = Mi.pixelRatio), (Nr = 1 / kr);
											}
											const gi = lt ? [Wt.x + Qn, Wt.y] : [0, 0];
											let qi = lt
													? [0, 0]
													: [Wt.x + Qn + Ce[0], Wt.y + Ce[1] - yr],
												Ba = [0, 0];
											dn && ((Ba = qi), (qi = [0, 0]));
											const ua = Wt.metrics.isDoubleResolution ? 2 : 1,
												Ri = (Wt.metrics.left - Nr) * Wt.scale - Qn + qi[0],
												Xn = (-Wt.metrics.top - Nr) * Wt.scale + qi[1],
												Pi = Ri + ((gt.w / ua) * Wt.scale) / kr,
												Bi = Xn + ((gt.h / ua) * Wt.scale) / kr,
												Fi = new B(Ri, Xn),
												ra = new B(Pi, Xn),
												Fa = new B(Ri, Bi),
												Ii = new B(Pi, Bi);
											if (dn) {
												const Mi = new B(-Qn, Qn - -17),
													ki = -Math.PI / 2,
													ui = 12 - Qn,
													qn = new B(22 - ui, -(Wt.imageName ? ui : 0)),
													io = new B(...Ba);
												Fi._rotateAround(ki, Mi)._add(qn)._add(io),
													ra._rotateAround(ki, Mi)._add(qn)._add(io),
													Fa._rotateAround(ki, Mi)._add(qn)._add(io),
													Ii._rotateAround(ki, Mi)._add(qn)._add(io);
											}
											if (Ht) {
												const Mi = Math.sin(Ht),
													ki = Math.cos(Ht),
													ui = [ki, -Mi, Mi, ki];
												Fi._matMult(ui),
													ra._matMult(ui),
													Fa._matMult(ui),
													Ii._matMult(ui);
											}
											const ha = new B(0, 0),
												vi = new B(0, 0);
											Sr.push({
												tl: Fi,
												tr: ra,
												bl: Fa,
												br: Ii,
												tex: gt,
												writingMode: xe.writingMode,
												glyphOffset: gi,
												sectionIndex: Wt.sectionIndex,
												isSDF: Hr,
												pixelOffsetTL: ha,
												pixelOffsetBR: vi,
												minFontScaleX: 0,
												minFontScaleY: 0,
											});
										}
									return Sr;
								})(0, r, v, c, f, _, o, n.allowVerticalPlacement),
								J = n.textSizeData;
							let le = null;
							J.kind === "source"
								? ((le = [Zo * c.layout.get("text-size").evaluate(_, {})]),
								  le[0] > vs &&
										Lt(
											`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
										))
								: J.kind === "composite" &&
								  ((le = [
										Zo * q.compositeTextSizes[0].evaluate(_, {}, Z),
										Zo * q.compositeTextSizes[1].evaluate(_, {}, Z),
								  ]),
								  (le[0] > vs || le[1] > vs) &&
										Lt(
											`${n.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`
										)),
								n.addSymbols(
									n.text,
									W,
									le,
									v,
									f,
									_,
									S,
									t,
									b.lineStartIndex,
									b.lineLength,
									F,
									Z
								);
							for (const Re of I) L[Re] = n.text.placedSymbolArray.length - 1;
							return 4 * W.length;
						}
						function Dg(n) {
							for (const t in n) return n[t];
							return null;
						}
						function E1(n, t, r, o) {
							const c = n.compareText;
							if (t in c) {
								const f = c[t];
								for (let _ = f.length - 1; _ >= 0; _--)
									if (o.dist(f[_]) < r) return !0;
							} else c[t] = [];
							return c[t].push(o), !1;
						}
						const Rg = [
							Int8Array,
							Uint8Array,
							Uint8ClampedArray,
							Int16Array,
							Uint16Array,
							Int32Array,
							Uint32Array,
							Float32Array,
							Float64Array,
						];
						class Tf {
							static from(t) {
								if (!(t instanceof ArrayBuffer))
									throw new Error("Data must be an instance of ArrayBuffer.");
								const [r, o] = new Uint8Array(t, 0, 2);
								if (r !== 219)
									throw new Error(
										"Data does not appear to be in a KDBush format."
									);
								const c = o >> 4;
								if (c !== 1)
									throw new Error(`Got v${c} data when expected v1.`);
								const f = Rg[15 & o];
								if (!f) throw new Error("Unrecognized array type.");
								const [_] = new Uint16Array(t, 2, 1),
									[v] = new Uint32Array(t, 4, 1);
								return new Tf(v, _, f, t);
							}
							constructor(t, r = 64, o = Float64Array, c) {
								if (isNaN(t) || t < 0)
									throw new Error(`Unpexpected numItems value: ${t}.`);
								(this.numItems = +t),
									(this.nodeSize = Math.min(Math.max(+r, 2), 65535)),
									(this.ArrayType = o),
									(this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array);
								const f = Rg.indexOf(this.ArrayType),
									_ = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
									v = t * this.IndexArrayType.BYTES_PER_ELEMENT,
									b = (8 - (v % 8)) % 8;
								if (f < 0)
									throw new Error(`Unexpected typed array class: ${o}.`);
								c && c instanceof ArrayBuffer
									? ((this.data = c),
									  (this.ids = new this.IndexArrayType(this.data, 8, t)),
									  (this.coords = new this.ArrayType(
											this.data,
											8 + v + b,
											2 * t
									  )),
									  (this._pos = 2 * t),
									  (this._finished = !0))
									: ((this.data = new ArrayBuffer(8 + _ + v + b)),
									  (this.ids = new this.IndexArrayType(this.data, 8, t)),
									  (this.coords = new this.ArrayType(
											this.data,
											8 + v + b,
											2 * t
									  )),
									  (this._pos = 0),
									  (this._finished = !1),
									  new Uint8Array(this.data, 0, 2).set([219, 16 + f]),
									  (new Uint16Array(this.data, 2, 1)[0] = r),
									  (new Uint32Array(this.data, 4, 1)[0] = t));
							}
							add(t, r) {
								const o = this._pos >> 1;
								return (
									(this.ids[o] = o),
									(this.coords[this._pos++] = t),
									(this.coords[this._pos++] = r),
									o
								);
							}
							finish() {
								const t = this._pos >> 1;
								if (t !== this.numItems)
									throw new Error(
										`Added ${t} items when expected ${this.numItems}.`
									);
								return (
									Cf(
										this.ids,
										this.coords,
										this.nodeSize,
										0,
										this.numItems - 1,
										0
									),
									(this._finished = !0),
									this
								);
							}
							range(t, r, o, c) {
								if (!this._finished)
									throw new Error(
										"Data not yet indexed - call index.finish()."
									);
								const { ids: f, coords: _, nodeSize: v } = this,
									b = [0, f.length - 1, 0],
									S = [];
								for (; b.length; ) {
									const I = b.pop() || 0,
										L = b.pop() || 0,
										F = b.pop() || 0;
									if (L - F <= v) {
										for (let J = F; J <= L; J++) {
											const le = _[2 * J],
												Re = _[2 * J + 1];
											le >= t && le <= o && Re >= r && Re <= c && S.push(f[J]);
										}
										continue;
									}
									const q = (F + L) >> 1,
										Z = _[2 * q],
										W = _[2 * q + 1];
									Z >= t && Z <= o && W >= r && W <= c && S.push(f[q]),
										(I === 0 ? t <= Z : r <= W) &&
											(b.push(F), b.push(q - 1), b.push(1 - I)),
										(I === 0 ? o >= Z : c >= W) &&
											(b.push(q + 1), b.push(L), b.push(1 - I));
								}
								return S;
							}
							within(t, r, o) {
								if (!this._finished)
									throw new Error(
										"Data not yet indexed - call index.finish()."
									);
								const { ids: c, coords: f, nodeSize: _ } = this,
									v = [0, c.length - 1, 0],
									b = [],
									S = o * o;
								for (; v.length; ) {
									const I = v.pop() || 0,
										L = v.pop() || 0,
										F = v.pop() || 0;
									if (L - F <= _) {
										for (let J = F; J <= L; J++)
											Fg(f[2 * J], f[2 * J + 1], t, r) <= S && b.push(c[J]);
										continue;
									}
									const q = (F + L) >> 1,
										Z = f[2 * q],
										W = f[2 * q + 1];
									Fg(Z, W, t, r) <= S && b.push(c[q]),
										(I === 0 ? t - o <= Z : r - o <= W) &&
											(v.push(F), v.push(q - 1), v.push(1 - I)),
										(I === 0 ? t + o >= Z : r + o >= W) &&
											(v.push(q + 1), v.push(L), v.push(1 - I));
								}
								return b;
							}
						}
						function Cf(n, t, r, o, c, f) {
							if (c - o <= r) return;
							const _ = (o + c) >> 1;
							Bg(n, t, _, o, c, f),
								Cf(n, t, r, o, _ - 1, 1 - f),
								Cf(n, t, r, _ + 1, c, 1 - f);
						}
						function Bg(n, t, r, o, c, f) {
							for (; c > o; ) {
								if (c - o > 600) {
									const S = c - o + 1,
										I = r - o + 1,
										L = Math.log(S),
										F = 0.5 * Math.exp((2 * L) / 3),
										q =
											0.5 *
											Math.sqrt((L * F * (S - F)) / S) *
											(I - S / 2 < 0 ? -1 : 1);
									Bg(
										n,
										t,
										r,
										Math.max(o, Math.floor(r - (I * F) / S + q)),
										Math.min(c, Math.floor(r + ((S - I) * F) / S + q)),
										f
									);
								}
								const _ = t[2 * r + f];
								let v = o,
									b = c;
								for (
									Eu(n, t, o, r), t[2 * c + f] > _ && Eu(n, t, o, c);
									v < b;

								) {
									for (Eu(n, t, v, b), v++, b--; t[2 * v + f] < _; ) v++;
									for (; t[2 * b + f] > _; ) b--;
								}
								t[2 * o + f] === _ ? Eu(n, t, o, b) : (b++, Eu(n, t, b, c)),
									b <= r && (o = b + 1),
									r <= b && (c = b - 1);
							}
						}
						function Eu(n, t, r, o) {
							Sf(n, r, o), Sf(t, 2 * r, 2 * o), Sf(t, 2 * r + 1, 2 * o + 1);
						}
						function Sf(n, t, r) {
							const o = n[t];
							(n[t] = n[r]), (n[r] = o);
						}
						function Fg(n, t, r, o) {
							const c = n - r,
								f = t - o;
							return c * c + f * f;
						}
						var Pf;
						(T.cx = void 0),
							((Pf = T.cx || (T.cx = {})).create = "create"),
							(Pf.load = "load"),
							(Pf.fullLoad = "fullLoad");
						let jd = null,
							zu = [];
						const If = 1e3 / 60,
							Mf = "loadTime",
							kf = "fullLoadTime",
							z1 = {
								mark(n) {
									performance.mark(n);
								},
								frame(n) {
									const t = n;
									jd != null && zu.push(t - jd), (jd = t);
								},
								clearMetrics() {
									(jd = null),
										(zu = []),
										performance.clearMeasures(Mf),
										performance.clearMeasures(kf);
									for (const n in T.cx) performance.clearMarks(T.cx[n]);
								},
								getPerformanceMetrics() {
									performance.measure(Mf, T.cx.create, T.cx.load),
										performance.measure(kf, T.cx.create, T.cx.fullLoad);
									const n = performance.getEntriesByName(Mf)[0].duration,
										t = performance.getEntriesByName(kf)[0].duration,
										r = zu.length,
										o = 1 / (zu.reduce((f, _) => f + _, 0) / r / 1e3),
										c = zu
											.filter((f) => f > If)
											.reduce((f, _) => f + (_ - If) / If, 0);
									return {
										loadTime: n,
										fullLoadTime: t,
										fps: o,
										percentDroppedFrames: (c / (r + c)) * 100,
										totalFrames: r,
									};
								},
							};
						(T.$ = oe),
							(T.A = Ee),
							(T.B = function ([n, t, r]) {
								return (
									(t += 90),
									(t *= Math.PI / 180),
									(r *= Math.PI / 180),
									{
										x: n * Math.cos(t) * Math.sin(r),
										y: n * Math.sin(t) * Math.sin(r),
										z: n * Math.cos(r),
									}
								);
							}),
							(T.C = Za),
							(T.D = wr),
							(T.E = kt),
							(T.F = Un),
							(T.G = Ws),
							(T.H = function (n) {
								if (tr == null) {
									const t = n.navigator ? n.navigator.userAgent : null;
									tr =
										!!n.safari ||
										!(
											!t ||
											!(
												/\b(iPad|iPhone|iPod)\b/.test(t) ||
												(t.match("Safari") && !t.match("Chrome"))
											)
										);
								}
								return tr;
							}),
							(T.I = uf),
							(T.J = class {
								constructor(n, t) {
									(this.target = n),
										(this.mapId = t),
										(this.resolveRejects = {}),
										(this.tasks = {}),
										(this.taskQueue = []),
										(this.abortControllers = {}),
										(this.messageHandlers = {}),
										(this.invoker = new w1(() => this.process())),
										(this.subscription = Vr(
											this.target,
											"message",
											(r) => this.receive(r),
											!1
										)),
										(this.globalScope = $t(self) ? n : window);
								}
								registerMessageHandler(n, t) {
									this.messageHandlers[n] = t;
								}
								sendAsync(n, t) {
									return new Promise((r, o) => {
										const c = Math.round(1e18 * Math.random())
												.toString(36)
												.substring(0, 10),
											f = t
												? Vr(
														t.signal,
														"abort",
														() => {
															f == null || f.unsubscribe(),
																delete this.resolveRejects[c];
															const b = {
																id: c,
																type: "<cancel>",
																origin: location.origin,
																targetMapId: n.targetMapId,
																sourceMapId: this.mapId,
															};
															this.target.postMessage(b);
														},
														T1
												  )
												: null;
										this.resolveRejects[c] = {
											resolve: (b) => {
												f == null || f.unsubscribe(), r(b);
											},
											reject: (b) => {
												f == null || f.unsubscribe(), o(b);
											},
										};
										const _ = [],
											v = Object.assign(Object.assign({}, n), {
												id: c,
												sourceMapId: this.mapId,
												origin: location.origin,
												data: cs(n.data, _),
											});
										this.target.postMessage(v, { transfer: _ });
									});
								}
								receive(n) {
									const t = n.data,
										r = t.id;
									if (
										!(
											(t.origin !== "file://" &&
												location.origin !== "file://" &&
												t.origin !== "resource://android" &&
												location.origin !== "resource://android" &&
												t.origin !== location.origin) ||
											(t.targetMapId && this.mapId !== t.targetMapId)
										)
									) {
										if (t.type === "<cancel>") {
											delete this.tasks[r];
											const o = this.abortControllers[r];
											return (
												delete this.abortControllers[r], void (o && o.abort())
											);
										}
										if ($t(self) || t.mustQueue)
											return (
												(this.tasks[r] = t),
												this.taskQueue.push(r),
												void this.invoker.trigger()
											);
										this.processTask(r, t);
									}
								}
								process() {
									if (this.taskQueue.length === 0) return;
									const n = this.taskQueue.shift(),
										t = this.tasks[n];
									delete this.tasks[n],
										this.taskQueue.length > 0 && this.invoker.trigger(),
										t && this.processTask(n, t);
								}
								processTask(n, t) {
									return s(this, void 0, void 0, function* () {
										if (t.type === "<response>") {
											const c = this.resolveRejects[n];
											return (
												delete this.resolveRejects[n],
												c
													? void (t.error
															? c.reject(Oo(t.error))
															: c.resolve(Oo(t.data)))
													: void 0
											);
										}
										if (!this.messageHandlers[t.type])
											return void this.completeTask(
												n,
												new Error(
													`Could not find a registered handler for ${
														t.type
													}, map ID: ${
														this.mapId
													}, available handlers: ${Object.keys(
														this.messageHandlers
													).join(", ")}`
												)
											);
										const r = Oo(t.data),
											o = new AbortController();
										this.abortControllers[n] = o;
										try {
											const c = yield this.messageHandlers[t.type](
												t.sourceMapId,
												r,
												o
											);
											this.completeTask(n, null, c);
										} catch (c) {
											this.completeTask(n, c);
										}
									});
								}
								completeTask(n, t, r) {
									const o = [];
									delete this.abortControllers[n];
									const c = {
										id: n,
										type: "<response>",
										sourceMapId: this.mapId,
										origin: location.origin,
										error: t ? cs(t) : null,
										data: cs(r, o),
									};
									this.target.postMessage(c, { transfer: o });
								}
								remove() {
									this.invoker.remove(), this.subscription.unsubscribe();
								}
							}),
							(T.K = Y),
							(T.L = function () {
								var n = new Ee(16);
								return (
									Ee != Float32Array &&
										((n[1] = 0),
										(n[2] = 0),
										(n[3] = 0),
										(n[4] = 0),
										(n[6] = 0),
										(n[7] = 0),
										(n[8] = 0),
										(n[9] = 0),
										(n[11] = 0),
										(n[12] = 0),
										(n[13] = 0),
										(n[14] = 0)),
									(n[0] = 1),
									(n[5] = 1),
									(n[10] = 1),
									(n[15] = 1),
									n
								);
							}),
							(T.M = function (n, t, r) {
								var o,
									c,
									f,
									_,
									v,
									b,
									S,
									I,
									L,
									F,
									q,
									Z,
									W = r[0],
									J = r[1],
									le = r[2];
								return (
									t === n
										? ((n[12] = t[0] * W + t[4] * J + t[8] * le + t[12]),
										  (n[13] = t[1] * W + t[5] * J + t[9] * le + t[13]),
										  (n[14] = t[2] * W + t[6] * J + t[10] * le + t[14]),
										  (n[15] = t[3] * W + t[7] * J + t[11] * le + t[15]))
										: ((c = t[1]),
										  (f = t[2]),
										  (_ = t[3]),
										  (v = t[4]),
										  (b = t[5]),
										  (S = t[6]),
										  (I = t[7]),
										  (L = t[8]),
										  (F = t[9]),
										  (q = t[10]),
										  (Z = t[11]),
										  (n[0] = o = t[0]),
										  (n[1] = c),
										  (n[2] = f),
										  (n[3] = _),
										  (n[4] = v),
										  (n[5] = b),
										  (n[6] = S),
										  (n[7] = I),
										  (n[8] = L),
										  (n[9] = F),
										  (n[10] = q),
										  (n[11] = Z),
										  (n[12] = o * W + v * J + L * le + t[12]),
										  (n[13] = c * W + b * J + F * le + t[13]),
										  (n[14] = f * W + S * J + q * le + t[14]),
										  (n[15] = _ * W + I * J + Z * le + t[15])),
									n
								);
							}),
							(T.N = function (n, t, r) {
								var o = r[0],
									c = r[1],
									f = r[2];
								return (
									(n[0] = t[0] * o),
									(n[1] = t[1] * o),
									(n[2] = t[2] * o),
									(n[3] = t[3] * o),
									(n[4] = t[4] * c),
									(n[5] = t[5] * c),
									(n[6] = t[6] * c),
									(n[7] = t[7] * c),
									(n[8] = t[8] * f),
									(n[9] = t[9] * f),
									(n[10] = t[10] * f),
									(n[11] = t[11] * f),
									(n[12] = t[12]),
									(n[13] = t[13]),
									(n[14] = t[14]),
									(n[15] = t[15]),
									n
								);
							}),
							(T.O = function (n, t, r) {
								var o = t[0],
									c = t[1],
									f = t[2],
									_ = t[3],
									v = t[4],
									b = t[5],
									S = t[6],
									I = t[7],
									L = t[8],
									F = t[9],
									q = t[10],
									Z = t[11],
									W = t[12],
									J = t[13],
									le = t[14],
									Re = t[15],
									xe = r[0],
									Ce = r[1],
									Ye = r[2],
									lt = r[3];
								return (
									(n[0] = xe * o + Ce * v + Ye * L + lt * W),
									(n[1] = xe * c + Ce * b + Ye * F + lt * J),
									(n[2] = xe * f + Ce * S + Ye * q + lt * le),
									(n[3] = xe * _ + Ce * I + Ye * Z + lt * Re),
									(n[4] =
										(xe = r[4]) * o +
										(Ce = r[5]) * v +
										(Ye = r[6]) * L +
										(lt = r[7]) * W),
									(n[5] = xe * c + Ce * b + Ye * F + lt * J),
									(n[6] = xe * f + Ce * S + Ye * q + lt * le),
									(n[7] = xe * _ + Ce * I + Ye * Z + lt * Re),
									(n[8] =
										(xe = r[8]) * o +
										(Ce = r[9]) * v +
										(Ye = r[10]) * L +
										(lt = r[11]) * W),
									(n[9] = xe * c + Ce * b + Ye * F + lt * J),
									(n[10] = xe * f + Ce * S + Ye * q + lt * le),
									(n[11] = xe * _ + Ce * I + Ye * Z + lt * Re),
									(n[12] =
										(xe = r[12]) * o +
										(Ce = r[13]) * v +
										(Ye = r[14]) * L +
										(lt = r[15]) * W),
									(n[13] = xe * c + Ce * b + Ye * F + lt * J),
									(n[14] = xe * f + Ce * S + Ye * q + lt * le),
									(n[15] = xe * _ + Ce * I + Ye * Z + lt * Re),
									n
								);
							}),
							(T.P = B),
							(T.Q = function (n, t) {
								const r = {};
								for (let o = 0; o < t.length; o++) {
									const c = t[o];
									c in n && (r[c] = n[c]);
								}
								return r;
							}),
							(T.R = ca),
							(T.S = ys),
							(T.T = Jp),
							(T.U = fg),
							(T.V = pg),
							(T.W = Ie),
							(T.X = Ae),
							(T.Y = Nt),
							(T.Z = Ra),
							(T._ = s),
							(T.a = V),
							(T.a$ = Ue),
							(T.a0 = function (n, t) {
								var r, o, c, f;
								if (!n) return t ?? {};
								if (!t) return n;
								const _ = Object.assign({}, n);
								if ((t.removeAll && (_.removeAll = !0), t.remove)) {
									const v = new Set(
										_.remove ? _.remove.concat(t.remove) : t.remove
									);
									_.remove = Array.from(v.values());
								}
								if (t.add) {
									const v = _.add ? _.add.concat(t.add) : t.add,
										b = new Map(v.map((S) => [S.id, S]));
									_.add = Array.from(b.values());
								}
								if (t.update) {
									const v = new Map(
										(r = _.update) === null || r === void 0
											? void 0
											: r.map((b) => [b.id, b])
									);
									for (const b of t.update) {
										const S =
											(o = v.get(b.id)) !== null && o !== void 0
												? o
												: { id: b.id };
										b.newGeometry && (S.newGeometry = b.newGeometry),
											b.addOrUpdateProperties &&
												(S.addOrUpdateProperties = (
													(c = S.addOrUpdateProperties) !== null && c !== void 0
														? c
														: []
												).concat(b.addOrUpdateProperties)),
											b.removeProperties &&
												(S.removeProperties = (
													(f = S.removeProperties) !== null && f !== void 0
														? f
														: []
												).concat(b.removeProperties)),
											b.removeAllProperties && (S.removeAllProperties = !0),
											v.set(b.id, S);
									}
									_.update = Array.from(v.values());
								}
								return _;
							}),
							(T.a1 = ku),
							(T.a2 = rl),
							(T.a3 = 25),
							(T.a4 = xf),
							(T.a5 = (n) => {
								const t = window.document.createElement("video");
								return (
									(t.muted = !0),
									new Promise((r) => {
										t.onloadstart = () => {
											r(t);
										};
										for (const o of n) {
											const c = window.document.createElement("source");
											Me(o) || (t.crossOrigin = "Anonymous"),
												(c.src = o),
												t.appendChild(c);
										}
									})
								);
							}),
							(T.a6 = ht),
							(T.a7 = function () {
								return yt++;
							}),
							(T.a8 = D),
							(T.a9 = nc),
							(T.aA = function (n) {
								let t = 1 / 0,
									r = 1 / 0,
									o = -1 / 0,
									c = -1 / 0;
								for (const f of n)
									(t = Math.min(t, f.x)),
										(r = Math.min(r, f.y)),
										(o = Math.max(o, f.x)),
										(c = Math.max(c, f.y));
								return [t, r, o, c];
							}),
							(T.aB = Si),
							(T.aC = ze),
							(T.aD = function (n, t, r, o, c = !1) {
								if (!r[0] && !r[1]) return [0, 0];
								const f = c
									? o === "map"
										? -n.bearingInRadians
										: 0
									: o === "viewport"
									? n.bearingInRadians
									: 0;
								if (f) {
									const _ = Math.sin(f),
										v = Math.cos(f);
									r = [r[0] * v - r[1] * _, r[0] * _ + r[1] * v];
								}
								return [
									c ? r[0] : ze(t, r[0], n.zoom),
									c ? r[1] : ze(t, r[1], n.zoom),
								];
							}),
							(T.aF = pf),
							(T.aG = wf),
							(T.aH = df),
							(T.aI = Tf),
							(T.aJ = ti),
							(T.aK = Ad),
							(T.aL = _e),
							(T.aM = Kr),
							(T.aN = Rn),
							(T.aO = at),
							(T.aP = hr),
							(T.aQ = _g),
							(T.aR = Le),
							(T.aS = Qe),
							(T.aT = function (n) {
								var t = new Ee(3);
								return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), t;
							}),
							(T.aU = function (n, t, r) {
								return (
									(n[0] = t[0] - r[0]),
									(n[1] = t[1] - r[1]),
									(n[2] = t[2] - r[2]),
									n
								);
							}),
							(T.aV = function (n, t) {
								var r = t[0],
									o = t[1],
									c = t[2],
									f = r * r + o * o + c * c;
								return (
									f > 0 && (f = 1 / Math.sqrt(f)),
									(n[0] = t[0] * f),
									(n[1] = t[1] * f),
									(n[2] = t[2] * f),
									n
								);
							}),
							(T.aW = et),
							(T.aX = function (n, t) {
								return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
							}),
							(T.aY = function (n, t, r) {
								return (
									(n[0] = t[0] * r[0]),
									(n[1] = t[1] * r[1]),
									(n[2] = t[2] * r[2]),
									(n[3] = t[3] * r[3]),
									n
								);
							}),
							(T.aZ = qe),
							(T.a_ = function (n, t, r) {
								const o = t[0] * r[0] + t[1] * r[1] + t[2] * r[2];
								return o === 0
									? null
									: (-(n[0] * r[0] + n[1] * r[1] + n[2] * r[2]) - r[3]) / o;
							}),
							(T.aa = Ro),
							(T.ab = no),
							(T.ac = xg),
							(T.ad = function (n) {
								const t = {};
								if (
									(n.replace(
										/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
										(r, o, c, f) => {
											const _ = c || f;
											return (t[o] = !_ || _.toLowerCase()), "";
										}
									),
									t["max-age"])
								) {
									const r = parseInt(t["max-age"], 10);
									isNaN(r) ? delete t["max-age"] : (t["max-age"] = r);
								}
								return t;
							}),
							(T.ae = mr),
							(T.af = function (n) {
								return Math.pow(2, n);
							}),
							(T.ag = $e),
							(T.ah = Dt),
							(T.ai = 85.051129),
							(T.aj = mg),
							(T.ak = function (n) {
								return Math.log(n) / Math.LN2;
							}),
							(T.al = function (n) {
								var t = n[0],
									r = n[1];
								return t * t + r * r;
							}),
							(T.am = function (n, t) {
								const r = [];
								for (const o in n) o in t || r.push(o);
								return r;
							}),
							(T.an = function (n, t) {
								let r = 0,
									o = 0;
								if (n.kind === "constant") o = n.layoutSize;
								else if (n.kind !== "source") {
									const { interpolationType: c, minZoom: f, maxZoom: _ } = n,
										v = c ? Dt(Di.interpolationFactor(c, t, f, _), 0, 1) : 0;
									n.kind === "camera"
										? (o = Za.number(n.minSize, n.maxSize, v))
										: (r = v);
								}
								return { uSizeT: r, uSize: o };
							}),
							(T.ap = function (
								n,
								{ uSize: t, uSizeT: r },
								{ lowerSize: o, upperSize: c }
							) {
								return n.kind === "source"
									? o / Zo
									: n.kind === "composite"
									? Za.number(o / Zo, c / Zo, r)
									: t;
							}),
							(T.aq = function (n, t) {
								var r = t[0],
									o = t[1],
									c = t[2],
									f = t[3],
									_ = t[4],
									v = t[5],
									b = t[6],
									S = t[7],
									I = t[8],
									L = t[9],
									F = t[10],
									q = t[11],
									Z = t[12],
									W = t[13],
									J = t[14],
									le = t[15],
									Re = r * v - o * _,
									xe = r * b - c * _,
									Ce = r * S - f * _,
									Ye = o * b - c * v,
									lt = o * S - f * v,
									Pt = c * S - f * b,
									Yt = I * W - L * Z,
									qt = I * J - F * Z,
									Ht = I * le - q * Z,
									Sr = L * J - F * W,
									Gt = L * le - q * W,
									Wt = F * le - q * J,
									gt =
										Re * Wt - xe * Gt + Ce * Sr + Ye * Ht - lt * qt + Pt * Yt;
								return gt
									? ((n[0] = (v * Wt - b * Gt + S * Sr) * (gt = 1 / gt)),
									  (n[1] = (c * Gt - o * Wt - f * Sr) * gt),
									  (n[2] = (W * Pt - J * lt + le * Ye) * gt),
									  (n[3] = (F * lt - L * Pt - q * Ye) * gt),
									  (n[4] = (b * Ht - _ * Wt - S * qt) * gt),
									  (n[5] = (r * Wt - c * Ht + f * qt) * gt),
									  (n[6] = (J * Ce - Z * Pt - le * xe) * gt),
									  (n[7] = (I * Pt - F * Ce + q * xe) * gt),
									  (n[8] = (_ * Gt - v * Ht + S * Yt) * gt),
									  (n[9] = (o * Ht - r * Gt - f * Yt) * gt),
									  (n[10] = (Z * lt - W * Ce + le * Re) * gt),
									  (n[11] = (L * Ce - I * lt - q * Re) * gt),
									  (n[12] = (v * qt - _ * Sr - b * Yt) * gt),
									  (n[13] = (r * Sr - o * qt + c * Yt) * gt),
									  (n[14] = (W * xe - Z * Ye - J * Re) * gt),
									  (n[15] = (I * Ye - L * xe + F * Re) * gt),
									  n)
									: null;
							}),
							(T.ar = re),
							(T.as = function (n) {
								return Math.hypot(n[0], n[1]);
							}),
							(T.at = function (n) {
								return (n[0] = 0), (n[1] = 0), n;
							}),
							(T.au = function (n, t, r) {
								return (n[0] = t[0] * r), (n[1] = t[1] * r), n;
							}),
							(T.av = ff),
							(T.aw = ke),
							(T.ax = function (n, t, r, o) {
								const c = t.y - n.y,
									f = t.x - n.x,
									_ = o.y - r.y,
									v = o.x - r.x,
									b = _ * f - v * c;
								if (b === 0) return null;
								const S = (v * (n.y - r.y) - _ * (n.x - r.x)) / b;
								return new B(n.x + S * f, n.y + S * c);
							}),
							(T.ay = Tg),
							(T.az = d_),
							(T.b = Qt),
							(T.b$ = class extends h {}),
							(T.b0 = function (n, t, r) {
								return (
									(n[0] = t[0] * r),
									(n[1] = t[1] * r),
									(n[2] = t[2] * r),
									(n[3] = t[3] * r),
									n
								);
							}),
							(T.b1 = function (n, t) {
								return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3];
							}),
							(T.b2 = vg),
							(T.b3 = ic),
							(T.b4 = function (n, t, r, o, c) {
								var f,
									_ = 1 / Math.tan(t / 2);
								return (
									(n[0] = _ / r),
									(n[1] = 0),
									(n[2] = 0),
									(n[3] = 0),
									(n[4] = 0),
									(n[5] = _),
									(n[6] = 0),
									(n[7] = 0),
									(n[8] = 0),
									(n[9] = 0),
									(n[11] = -1),
									(n[12] = 0),
									(n[13] = 0),
									(n[15] = 0),
									c != null && c !== 1 / 0
										? ((n[10] = (c + o) * (f = 1 / (o - c))),
										  (n[14] = 2 * c * o * f))
										: ((n[10] = -1), (n[14] = -2 * o)),
									n
								);
							}),
							(T.b5 = function (n) {
								var t = new Ee(16);
								return (
									(t[0] = n[0]),
									(t[1] = n[1]),
									(t[2] = n[2]),
									(t[3] = n[3]),
									(t[4] = n[4]),
									(t[5] = n[5]),
									(t[6] = n[6]),
									(t[7] = n[7]),
									(t[8] = n[8]),
									(t[9] = n[9]),
									(t[10] = n[10]),
									(t[11] = n[11]),
									(t[12] = n[12]),
									(t[13] = n[13]),
									(t[14] = n[14]),
									(t[15] = n[15]),
									t
								);
							}),
							(T.b6 = function (n, t, r) {
								var o = Math.sin(r),
									c = Math.cos(r),
									f = t[0],
									_ = t[1],
									v = t[2],
									b = t[3],
									S = t[4],
									I = t[5],
									L = t[6],
									F = t[7];
								return (
									t !== n &&
										((n[8] = t[8]),
										(n[9] = t[9]),
										(n[10] = t[10]),
										(n[11] = t[11]),
										(n[12] = t[12]),
										(n[13] = t[13]),
										(n[14] = t[14]),
										(n[15] = t[15])),
									(n[0] = f * c + S * o),
									(n[1] = _ * c + I * o),
									(n[2] = v * c + L * o),
									(n[3] = b * c + F * o),
									(n[4] = S * c - f * o),
									(n[5] = I * c - _ * o),
									(n[6] = L * c - v * o),
									(n[7] = F * c - b * o),
									n
								);
							}),
							(T.b7 = function (n, t, r) {
								var o = Math.sin(r),
									c = Math.cos(r),
									f = t[4],
									_ = t[5],
									v = t[6],
									b = t[7],
									S = t[8],
									I = t[9],
									L = t[10],
									F = t[11];
								return (
									t !== n &&
										((n[0] = t[0]),
										(n[1] = t[1]),
										(n[2] = t[2]),
										(n[3] = t[3]),
										(n[12] = t[12]),
										(n[13] = t[13]),
										(n[14] = t[14]),
										(n[15] = t[15])),
									(n[4] = f * c + S * o),
									(n[5] = _ * c + I * o),
									(n[6] = v * c + L * o),
									(n[7] = b * c + F * o),
									(n[8] = S * c - f * o),
									(n[9] = I * c - _ * o),
									(n[10] = L * c - v * o),
									(n[11] = F * c - b * o),
									n
								);
							}),
							(T.b8 = function () {
								const n = new Float32Array(16);
								return $e(n), n;
							}),
							(T.b9 = function () {
								const n = new Float64Array(16);
								return $e(n), n;
							}),
							(T.bA = function (n, t) {
								const r = je(n, 360),
									o = je(t, 360),
									c = o - r,
									f = o > r ? c - 360 : c + 360;
								return Math.abs(c) < Math.abs(f) ? c : f;
							}),
							(T.bB = function (n) {
								return (n[0] = 0), (n[1] = 0), (n[2] = 0), n;
							}),
							(T.bC = function (n, t, r, o) {
								const c = Math.sqrt(n * n + t * t),
									f = Math.sqrt(r * r + o * o);
								(n /= c), (t /= c), (r /= f), (o /= f);
								const _ = Math.acos(n * r + t * o);
								return -t * r + n * o > 0 ? _ : -_;
							}),
							(T.bD = function (n, t) {
								const r = je(n, 2 * Math.PI),
									o = je(t, 2 * Math.PI);
								return Math.min(
									Math.abs(r - o),
									Math.abs(r - o + 2 * Math.PI),
									Math.abs(r - o - 2 * Math.PI)
								);
							}),
							(T.bE = function () {
								const n = {},
									t = ye.$version;
								for (const r in ye.$root) {
									const o = ye.$root[r];
									if (o.required) {
										let c = null;
										(c = r === "version" ? t : o.type === "array" ? [] : {}),
											c != null && (n[r] = c);
									}
								}
								return n;
							}),
							(T.bF = Nl),
							(T.bG = pe),
							(T.bH = function n(t, r) {
								if (Array.isArray(t)) {
									if (!Array.isArray(r) || t.length !== r.length) return !1;
									for (let o = 0; o < t.length; o++)
										if (!n(t[o], r[o])) return !1;
									return !0;
								}
								if (typeof t == "object" && t !== null && r !== null) {
									if (
										typeof r != "object" ||
										Object.keys(t).length !== Object.keys(r).length
									)
										return !1;
									for (const o in t) if (!n(t[o], r[o])) return !1;
									return !0;
								}
								return t === r;
							}),
							(T.bI = function (n) {
								n = n.slice();
								const t = Object.create(null);
								for (let r = 0; r < n.length; r++) t[n[r].id] = n[r];
								for (let r = 0; r < n.length; r++)
									"ref" in n[r] && (n[r] = rr(n[r], t[n[r].ref]));
								return n;
							}),
							(T.bJ = function (n) {
								if (n.type === "custom") return new b1(n);
								switch (n.type) {
									case "background":
										return new v1(n);
									case "circle":
										return new ny(n);
									case "color-relief":
										return new cy(n);
									case "fill":
										return new Cy(n);
									case "fill-extrusion":
										return new Ry(n);
									case "heatmap":
										return new ay(n);
									case "hillshade":
										return new sy(n);
									case "line":
										return new qy(n);
									case "raster":
										return new x1(n);
									case "symbol":
										return new Rd(n);
								}
							}),
							(T.bK = wt),
							(T.bL = function (n, t) {
								if (!n) return [{ command: "setStyle", args: [t] }];
								let r = [];
								try {
									if (!Kt(n.version, t.version))
										return [{ command: "setStyle", args: [t] }];
									Kt(n.center, t.center) ||
										r.push({ command: "setCenter", args: [t.center] }),
										Kt(n.state, t.state) ||
											r.push({ command: "setGlobalState", args: [t.state] }),
										Kt(n.centerAltitude, t.centerAltitude) ||
											r.push({
												command: "setCenterAltitude",
												args: [t.centerAltitude],
											}),
										Kt(n.zoom, t.zoom) ||
											r.push({ command: "setZoom", args: [t.zoom] }),
										Kt(n.bearing, t.bearing) ||
											r.push({ command: "setBearing", args: [t.bearing] }),
										Kt(n.pitch, t.pitch) ||
											r.push({ command: "setPitch", args: [t.pitch] }),
										Kt(n.roll, t.roll) ||
											r.push({ command: "setRoll", args: [t.roll] }),
										Kt(n.sprite, t.sprite) ||
											r.push({ command: "setSprite", args: [t.sprite] }),
										Kt(n.glyphs, t.glyphs) ||
											r.push({ command: "setGlyphs", args: [t.glyphs] }),
										Kt(n.transition, t.transition) ||
											r.push({
												command: "setTransition",
												args: [t.transition],
											}),
										Kt(n.light, t.light) ||
											r.push({ command: "setLight", args: [t.light] }),
										Kt(n.terrain, t.terrain) ||
											r.push({ command: "setTerrain", args: [t.terrain] }),
										Kt(n.sky, t.sky) ||
											r.push({ command: "setSky", args: [t.sky] }),
										Kt(n.projection, t.projection) ||
											r.push({
												command: "setProjection",
												args: [t.projection],
											});
									const o = {},
										c = [];
									(function (_, v, b, S) {
										let I;
										for (I in ((v = v || {}), (_ = _ || {})))
											Object.prototype.hasOwnProperty.call(_, I) &&
												(Object.prototype.hasOwnProperty.call(v, I) ||
													nn(I, b, S));
										for (I in v)
											Object.prototype.hasOwnProperty.call(v, I) &&
												(Object.prototype.hasOwnProperty.call(_, I)
													? Kt(_[I], v[I]) ||
													  (_[I].type === "geojson" &&
													  v[I].type === "geojson" &&
													  _n(_, v, I)
															? gr(b, {
																	command: "setGeoJSONSourceData",
																	args: [I, v[I].data],
															  })
															: mn(I, v, b, S))
													: Ur(I, v, b));
									})(n.sources, t.sources, c, o);
									const f = [];
									n.layers &&
										n.layers.forEach((_) => {
											"source" in _ && o[_.source]
												? r.push({ command: "removeLayer", args: [_.id] })
												: f.push(_);
										}),
										(r = r.concat(c)),
										(function (_, v, b) {
											v = v || [];
											const S = (_ = _ || []).map(Et),
												I = v.map(Et),
												L = _.reduce(dr, {}),
												F = v.reduce(dr, {}),
												q = S.slice(),
												Z = Object.create(null);
											let W, J, le, Re, xe;
											for (let Ce = 0, Ye = 0; Ce < S.length; Ce++)
												(W = S[Ce]),
													Object.prototype.hasOwnProperty.call(F, W)
														? Ye++
														: (gr(b, { command: "removeLayer", args: [W] }),
														  q.splice(q.indexOf(W, Ye), 1));
											for (let Ce = 0, Ye = 0; Ce < I.length; Ce++)
												(W = I[I.length - 1 - Ce]),
													q[q.length - 1 - Ce] !== W &&
														(Object.prototype.hasOwnProperty.call(L, W)
															? (gr(b, { command: "removeLayer", args: [W] }),
															  q.splice(q.lastIndexOf(W, q.length - Ye), 1))
															: Ye++,
														(Re = q[q.length - Ce]),
														gr(b, { command: "addLayer", args: [F[W], Re] }),
														q.splice(q.length - Ce, 0, W),
														(Z[W] = !0));
											for (let Ce = 0; Ce < I.length; Ce++)
												if (
													((W = I[Ce]),
													(J = L[W]),
													(le = F[W]),
													!Z[W] && !Kt(J, le))
												)
													if (
														Kt(J.source, le.source) &&
														Kt(J["source-layer"], le["source-layer"]) &&
														Kt(J.type, le.type)
													) {
														for (xe in (Vt(
															J.layout,
															le.layout,
															b,
															W,
															null,
															"setLayoutProperty"
														),
														Vt(
															J.paint,
															le.paint,
															b,
															W,
															null,
															"setPaintProperty"
														),
														Kt(J.filter, le.filter) ||
															gr(b, {
																command: "setFilter",
																args: [W, le.filter],
															}),
														(Kt(J.minzoom, le.minzoom) &&
															Kt(J.maxzoom, le.maxzoom)) ||
															gr(b, {
																command: "setLayerZoomRange",
																args: [W, le.minzoom, le.maxzoom],
															}),
														J))
															Object.prototype.hasOwnProperty.call(J, xe) &&
																xe !== "layout" &&
																xe !== "paint" &&
																xe !== "filter" &&
																xe !== "metadata" &&
																xe !== "minzoom" &&
																xe !== "maxzoom" &&
																(xe.indexOf("paint.") === 0
																	? Vt(
																			J[xe],
																			le[xe],
																			b,
																			W,
																			xe.slice(6),
																			"setPaintProperty"
																	  )
																	: Kt(J[xe], le[xe]) ||
																	  gr(b, {
																			command: "setLayerProperty",
																			args: [W, xe, le[xe]],
																	  }));
														for (xe in le)
															Object.prototype.hasOwnProperty.call(le, xe) &&
																!Object.prototype.hasOwnProperty.call(J, xe) &&
																xe !== "layout" &&
																xe !== "paint" &&
																xe !== "filter" &&
																xe !== "metadata" &&
																xe !== "minzoom" &&
																xe !== "maxzoom" &&
																(xe.indexOf("paint.") === 0
																	? Vt(
																			J[xe],
																			le[xe],
																			b,
																			W,
																			xe.slice(6),
																			"setPaintProperty"
																	  )
																	: Kt(J[xe], le[xe]) ||
																	  gr(b, {
																			command: "setLayerProperty",
																			args: [W, xe, le[xe]],
																	  }));
													} else
														gr(b, { command: "removeLayer", args: [W] }),
															(Re = q[q.lastIndexOf(W) + 1]),
															gr(b, { command: "addLayer", args: [le, Re] });
										})(f, t.layers, r);
								} catch (o) {
									console.warn("Unable to compute style diff:", o),
										(r = [{ command: "setStyle", args: [t] }]);
								}
								return r;
							}),
							(T.bM = function (n) {
								const t = [],
									r = n.id;
								return (
									r === void 0 &&
										t.push({
											message: `layers.${r}: missing required property "id"`,
										}),
									n.render === void 0 &&
										t.push({
											message: `layers.${r}: missing required method "render"`,
										}),
									n.renderingMode &&
										n.renderingMode !== "2d" &&
										n.renderingMode !== "3d" &&
										t.push({
											message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`,
										}),
									t
								);
							}),
							(T.bN = xt),
							(T.bO = St),
							(T.bP = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = 0);
								}
								set(n) {
									this.current !== n &&
										((this.current = n), this.gl.uniform1i(this.location, n));
								}
							}),
							(T.bQ = _i),
							(T.bR = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = ba);
								}
								set(n) {
									if (n[12] !== this.current[12] || n[0] !== this.current[0])
										return (
											(this.current = n),
											void this.gl.uniformMatrix4fv(this.location, !1, n)
										);
									for (let t = 1; t < 16; t++)
										if (n[t] !== this.current[t]) {
											(this.current = n),
												this.gl.uniformMatrix4fv(this.location, !1, n);
											break;
										}
								}
							}),
							(T.bS = li),
							(T.bT = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = [0, 0, 0]);
								}
								set(n) {
									(n[0] === this.current[0] &&
										n[1] === this.current[1] &&
										n[2] === this.current[2]) ||
										((this.current = n),
										this.gl.uniform3f(this.location, n[0], n[1], n[2]));
								}
							}),
							(T.bU = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = [0, 0]);
								}
								set(n) {
									(n[0] === this.current[0] && n[1] === this.current[1]) ||
										((this.current = n),
										this.gl.uniform2f(this.location, n[0], n[1]));
								}
							}),
							(T.bV = Fe),
							(T.bW = function (n, t) {
								var r = Math.sin(t),
									o = Math.cos(t);
								return (
									(n[0] = o),
									(n[1] = r),
									(n[2] = 0),
									(n[3] = -r),
									(n[4] = o),
									(n[5] = 0),
									(n[6] = 0),
									(n[7] = 0),
									(n[8] = 1),
									n
								);
							}),
							(T.bX = function (n, t, r) {
								var o = t[0],
									c = t[1],
									f = t[2];
								return (
									(n[0] = o * r[0] + c * r[3] + f * r[6]),
									(n[1] = o * r[1] + c * r[4] + f * r[7]),
									(n[2] = o * r[2] + c * r[5] + f * r[8]),
									n
								);
							}),
							(T.bY = function (n, t, r, o, c, f, _) {
								var v = 1 / (t - r),
									b = 1 / (o - c),
									S = 1 / (f - _);
								return (
									(n[0] = -2 * v),
									(n[1] = 0),
									(n[2] = 0),
									(n[3] = 0),
									(n[4] = 0),
									(n[5] = -2 * b),
									(n[6] = 0),
									(n[7] = 0),
									(n[8] = 0),
									(n[9] = 0),
									(n[10] = 2 * S),
									(n[11] = 0),
									(n[12] = (t + r) * v),
									(n[13] = (c + o) * b),
									(n[14] = (_ + f) * S),
									(n[15] = 1),
									n
								);
							}),
							(T.bZ = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = new Array());
								}
								set(n) {
									if (n != this.current) {
										this.current = n;
										const t = new Float32Array(4 * n.length);
										for (let r = 0; r < n.length; r++)
											(t[4 * r] = n[r].r),
												(t[4 * r + 1] = n[r].g),
												(t[4 * r + 2] = n[r].b),
												(t[4 * r + 3] = n[r].a);
										this.gl.uniform4fv(this.location, t);
									}
								}
							}),
							(T.b_ = class extends Gi {
								constructor(n, t) {
									super(n, t), (this.current = new Array());
								}
								set(n) {
									if (n != this.current) {
										this.current = n;
										const t = new Float32Array(n);
										this.gl.uniform1fv(this.location, t);
									}
								}
							}),
							(T.ba = function () {
								return new Float64Array(16);
							}),
							(T.bb = function (n, t, r) {
								const o = new Float64Array(4);
								return ee(o, n, t - 90, r), o;
							}),
							(T.bc = function (n, t, r, o) {
								var c,
									f,
									_,
									v,
									b,
									S = t[0],
									I = t[1],
									L = t[2],
									F = t[3],
									q = r[0],
									Z = r[1],
									W = r[2],
									J = r[3];
								return (
									(f = S * q + I * Z + L * W + F * J) < 0 &&
										((f = -f), (q = -q), (Z = -Z), (W = -W), (J = -J)),
									1 - f > De
										? ((c = Math.acos(f)),
										  (_ = Math.sin(c)),
										  (v = Math.sin((1 - o) * c) / _),
										  (b = Math.sin(o * c) / _))
										: ((v = 1 - o), (b = o)),
									(n[0] = v * S + b * q),
									(n[1] = v * I + b * Z),
									(n[2] = v * L + b * W),
									(n[3] = v * F + b * J),
									n
								);
							}),
							(T.bd = function (n) {
								const t = new Float64Array(9);
								var r, o, c, f, _, v, b, S, I, L, F, q, Z, W, J, le, Re, xe;
								(L = (c = (o = n)[0]) * (b = c + c)),
									(F = (f = o[1]) * b),
									(Z = (_ = o[2]) * b),
									(W = _ * (S = f + f)),
									(le = (v = o[3]) * b),
									(Re = v * S),
									(xe = v * (I = _ + _)),
									((r = t)[0] = 1 - (q = f * S) - (J = _ * I)),
									(r[3] = F - xe),
									(r[6] = Z + Re),
									(r[1] = F + xe),
									(r[4] = 1 - L - J),
									(r[7] = W - le),
									(r[2] = Z - Re),
									(r[5] = W + le),
									(r[8] = 1 - L - q);
								const Ce = hr(-Math.asin(Dt(t[2], -1, 1)));
								let Ye, lt;
								return (
									Math.hypot(t[5], t[8]) < 0.001
										? ((Ye = 0), (lt = -hr(Math.atan2(t[3], t[4]))))
										: ((Ye = hr(
												t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])
										  )),
										  (lt = hr(
												t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0])
										  ))),
									{ roll: Ye, pitch: Ce + 90, bearing: lt }
								);
							}),
							(T.be = function (n, t) {
								return (
									n.roll == t.roll &&
									n.pitch == t.pitch &&
									n.bearing == t.bearing
								);
							}),
							(T.bf = Mr),
							(T.bg = yo),
							(T.bh = Ql),
							(T.bi = Tu),
							(T.bj = Jl),
							(T.bk = pt),
							(T.bl = it),
							(T.bm = jn),
							(T.bn = function (n, t, r, o, c) {
								return pt(o, c, Dt((n - t) / (r - t), 0, 1));
							}),
							(T.bo = je),
							(T.bp = function () {
								return new Float64Array(3);
							}),
							(T.bq = function (n, t, r, o) {
								return (
									(n[0] = t[0] + r[0] * o),
									(n[1] = t[1] + r[1] * o),
									(n[2] = t[2] + r[2] * o),
									n
								);
							}),
							(T.br = ee),
							(T.bs = function (n, t, r) {
								var o = r[0],
									c = r[1],
									f = r[2],
									_ = t[0],
									v = t[1],
									b = t[2],
									S = c * b - f * v,
									I = f * _ - o * b,
									L = o * v - c * _,
									F = c * L - f * I,
									q = f * S - o * L,
									Z = o * I - c * S,
									W = 2 * r[3];
								return (
									(I *= W),
									(L *= W),
									(q *= 2),
									(Z *= 2),
									(n[0] = _ + (S *= W) + (F *= 2)),
									(n[1] = v + I + q),
									(n[2] = b + L + Z),
									n
								);
							}),
							(T.bt = function (n, t, r) {
								const o =
									(c = [
										n[0],
										n[1],
										n[2],
										t[0],
										t[1],
										t[2],
										r[0],
										r[1],
										r[2],
									])[0] *
										((I = c[8]) * (_ = c[4]) - (v = c[5]) * (S = c[7])) +
									c[1] * (-I * (f = c[3]) + v * (b = c[6])) +
									c[2] * (S * f - _ * b);
								var c, f, _, v, b, S, I;
								if (o === 0) return null;
								const L = et([], [t[0], t[1], t[2]], [r[0], r[1], r[2]]),
									F = et([], [r[0], r[1], r[2]], [n[0], n[1], n[2]]),
									q = et([], [n[0], n[1], n[2]], [t[0], t[1], t[2]]),
									Z = Le([], L, -n[3]);
								return (
									Qe(Z, Z, Le([], F, -t[3])),
									Qe(Z, Z, Le([], q, -r[3])),
									Le(Z, Z, 1 / o),
									Z
								);
							}),
							(T.bu = vf),
							(T.bv = function () {
								return new Float64Array(4);
							}),
							(T.bw = function (n, t, r, o) {
								var c = [],
									f = [];
								return (
									(c[0] = t[0] - r[0]),
									(c[1] = t[1] - r[1]),
									(c[2] = t[2] - r[2]),
									(f[0] = c[0] * Math.cos(o) - c[1] * Math.sin(o)),
									(f[1] = c[0] * Math.sin(o) + c[1] * Math.cos(o)),
									(f[2] = c[2]),
									(n[0] = f[0] + r[0]),
									(n[1] = f[1] + r[1]),
									(n[2] = f[2] + r[2]),
									n
								);
							}),
							(T.bx = function (n, t, r, o) {
								var c = [],
									f = [];
								return (
									(c[0] = t[0] - r[0]),
									(c[1] = t[1] - r[1]),
									(c[2] = t[2] - r[2]),
									(f[0] = c[0]),
									(f[1] = c[1] * Math.cos(o) - c[2] * Math.sin(o)),
									(f[2] = c[1] * Math.sin(o) + c[2] * Math.cos(o)),
									(n[0] = f[0] + r[0]),
									(n[1] = f[1] + r[1]),
									(n[2] = f[2] + r[2]),
									n
								);
							}),
							(T.by = function (n, t, r, o) {
								var c = [],
									f = [];
								return (
									(c[0] = t[0] - r[0]),
									(c[1] = t[1] - r[1]),
									(c[2] = t[2] - r[2]),
									(f[0] = c[2] * Math.sin(o) + c[0] * Math.cos(o)),
									(f[1] = c[1]),
									(f[2] = c[2] * Math.cos(o) - c[0] * Math.sin(o)),
									(n[0] = f[0] + r[0]),
									(n[1] = f[1] + r[1]),
									(n[2] = f[2] + r[2]),
									n
								);
							}),
							(T.bz = function (n, t, r) {
								var o = Math.sin(r),
									c = Math.cos(r),
									f = t[0],
									_ = t[1],
									v = t[2],
									b = t[3],
									S = t[8],
									I = t[9],
									L = t[10],
									F = t[11];
								return (
									t !== n &&
										((n[4] = t[4]),
										(n[5] = t[5]),
										(n[6] = t[6]),
										(n[7] = t[7]),
										(n[12] = t[12]),
										(n[13] = t[13]),
										(n[14] = t[14]),
										(n[15] = t[15])),
									(n[0] = f * c - S * o),
									(n[1] = _ * c - I * o),
									(n[2] = v * c - L * o),
									(n[3] = b * c - F * o),
									(n[8] = f * o + S * c),
									(n[9] = _ * o + I * c),
									(n[10] = v * o + L * c),
									(n[11] = b * o + F * c),
									n
								);
							}),
							(T.c = ue),
							(T.c0 = Gy),
							(T.c1 = class extends i {}),
							(T.c2 = Kp),
							(T.c3 = function (n) {
								return n <= 1
									? 1
									: Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
							}),
							(T.c4 = w_),
							(T.c5 = function (n, t, r) {
								var o = t[0],
									c = t[1],
									f = t[2],
									_ = r[3] * o + r[7] * c + r[11] * f + r[15];
								return (
									(n[0] =
										(r[0] * o + r[4] * c + r[8] * f + r[12]) / (_ = _ || 1)),
									(n[1] = (r[1] * o + r[5] * c + r[9] * f + r[13]) / _),
									(n[2] = (r[2] * o + r[6] * c + r[10] * f + r[14]) / _),
									n
								);
							}),
							(T.c6 = class extends du {}),
							(T.c7 = class extends P {}),
							(T.c8 = function (n, t) {
								return (
									n[0] === t[0] &&
									n[1] === t[1] &&
									n[2] === t[2] &&
									n[3] === t[3] &&
									n[4] === t[4] &&
									n[5] === t[5] &&
									n[6] === t[6] &&
									n[7] === t[7] &&
									n[8] === t[8] &&
									n[9] === t[9] &&
									n[10] === t[10] &&
									n[11] === t[11] &&
									n[12] === t[12] &&
									n[13] === t[13] &&
									n[14] === t[14] &&
									n[15] === t[15]
								);
							}),
							(T.c9 = function (n, t) {
								var r = n[0],
									o = n[1],
									c = n[2],
									f = n[3],
									_ = n[4],
									v = n[5],
									b = n[6],
									S = n[7],
									I = n[8],
									L = n[9],
									F = n[10],
									q = n[11],
									Z = n[12],
									W = n[13],
									J = n[14],
									le = n[15],
									Re = t[0],
									xe = t[1],
									Ce = t[2],
									Ye = t[3],
									lt = t[4],
									Pt = t[5],
									Yt = t[6],
									qt = t[7],
									Ht = t[8],
									Sr = t[9],
									Gt = t[10],
									Wt = t[11],
									gt = t[12],
									Nr = t[13],
									Hr = t[14],
									kr = t[15];
								return (
									Math.abs(r - Re) <=
										De * Math.max(1, Math.abs(r), Math.abs(Re)) &&
									Math.abs(o - xe) <=
										De * Math.max(1, Math.abs(o), Math.abs(xe)) &&
									Math.abs(c - Ce) <=
										De * Math.max(1, Math.abs(c), Math.abs(Ce)) &&
									Math.abs(f - Ye) <=
										De * Math.max(1, Math.abs(f), Math.abs(Ye)) &&
									Math.abs(_ - lt) <=
										De * Math.max(1, Math.abs(_), Math.abs(lt)) &&
									Math.abs(v - Pt) <=
										De * Math.max(1, Math.abs(v), Math.abs(Pt)) &&
									Math.abs(b - Yt) <=
										De * Math.max(1, Math.abs(b), Math.abs(Yt)) &&
									Math.abs(S - qt) <=
										De * Math.max(1, Math.abs(S), Math.abs(qt)) &&
									Math.abs(I - Ht) <=
										De * Math.max(1, Math.abs(I), Math.abs(Ht)) &&
									Math.abs(L - Sr) <=
										De * Math.max(1, Math.abs(L), Math.abs(Sr)) &&
									Math.abs(F - Gt) <=
										De * Math.max(1, Math.abs(F), Math.abs(Gt)) &&
									Math.abs(q - Wt) <=
										De * Math.max(1, Math.abs(q), Math.abs(Wt)) &&
									Math.abs(Z - gt) <=
										De * Math.max(1, Math.abs(Z), Math.abs(gt)) &&
									Math.abs(W - Nr) <=
										De * Math.max(1, Math.abs(W), Math.abs(Nr)) &&
									Math.abs(J - Hr) <=
										De * Math.max(1, Math.abs(J), Math.abs(Hr)) &&
									Math.abs(le - kr) <=
										De * Math.max(1, Math.abs(le), Math.abs(kr))
								);
							}),
							(T.cA = function (n, t) {
								V.REGISTERED_PROTOCOLS[n] = t;
							}),
							(T.cB = function (n) {
								delete V.REGISTERED_PROTOCOLS[n];
							}),
							(T.cC = function (n, t) {
								const r = {};
								for (let c = 0; c < n.length; c++) {
									const f = (t && t[n[c].id]) || Np(n[c]);
									t && (t[n[c].id] = f);
									let _ = r[f];
									_ || (_ = r[f] = []), _.push(n[c]);
								}
								const o = [];
								for (const c in r) o.push(r[c]);
								return o;
							}),
							(T.cD = ir),
							(T.cE = yg),
							(T.cF = bg),
							(T.cG = K_),
							(T.cH = function (n) {
								n.bucket.createArrays(),
									(n.bucket.tilePixelRatio = oe / (512 * n.bucket.overscaling)),
									(n.bucket.compareText = {}),
									(n.bucket.iconsNeedLinear = !1);
								const t = n.bucket.layers[0],
									r = t.layout,
									o = t._unevaluatedLayout._values,
									c = {
										layoutIconSize: o["icon-size"].possiblyEvaluate(
											new Un(n.bucket.zoom + 1),
											n.canonical
										),
										layoutTextSize: o["text-size"].possiblyEvaluate(
											new Un(n.bucket.zoom + 1),
											n.canonical
										),
										textMaxSize: o["text-size"].possiblyEvaluate(new Un(18)),
									};
								if (n.bucket.textSizeData.kind === "composite") {
									const { minZoom: S, maxZoom: I } = n.bucket.textSizeData;
									c.compositeTextSizes = [
										o["text-size"].possiblyEvaluate(new Un(S), n.canonical),
										o["text-size"].possiblyEvaluate(new Un(I), n.canonical),
									];
								}
								if (n.bucket.iconSizeData.kind === "composite") {
									const { minZoom: S, maxZoom: I } = n.bucket.iconSizeData;
									c.compositeIconSizes = [
										o["icon-size"].possiblyEvaluate(new Un(S), n.canonical),
										o["icon-size"].possiblyEvaluate(new Un(I), n.canonical),
									];
								}
								const f = r.get("text-line-height") * Si,
									_ =
										r.get("text-rotation-alignment") !== "viewport" &&
										r.get("symbol-placement") !== "point",
									v = r.get("text-keep-upright"),
									b = r.get("text-size");
								for (const S of n.bucket.features) {
									const I = r
											.get("text-font")
											.evaluate(S, {}, n.canonical)
											.join(","),
										L = b.evaluate(S, {}, n.canonical),
										F = c.layoutTextSize.evaluate(S, {}, n.canonical),
										q = c.layoutIconSize.evaluate(S, {}, n.canonical),
										Z = { horizontal: {}, vertical: void 0 },
										W = S.text;
									let J,
										le = [0, 0];
									if (W) {
										const Ce = W.toString(),
											Ye =
												r
													.get("text-letter-spacing")
													.evaluate(S, {}, n.canonical) * Si,
											lt = Zp(Ce) ? Ye : 0,
											Pt = r.get("text-anchor").evaluate(S, {}, n.canonical),
											Yt = zg(t, S, n.canonical);
										if (!Yt) {
											const Gt = r
												.get("text-radial-offset")
												.evaluate(S, {}, n.canonical);
											le = Gt
												? Eg(Pt, [Gt * Si, bf])
												: r
														.get("text-offset")
														.evaluate(S, {}, n.canonical)
														.map((Wt) => Wt * Si);
										}
										let qt = _
											? "center"
											: r.get("text-justify").evaluate(S, {}, n.canonical);
										const Ht =
												r.get("symbol-placement") === "point"
													? r
															.get("text-max-width")
															.evaluate(S, {}, n.canonical) * Si
													: 1 / 0,
											Sr = () => {
												n.bucket.allowVerticalPlacement &&
													jl(Ce) &&
													(Z.vertical = zd(
														W,
														n.glyphMap,
														n.glyphPositions,
														n.imagePositions,
														I,
														Ht,
														f,
														Pt,
														"left",
														lt,
														le,
														T.ao.vertical,
														!0,
														F,
														L
													));
											};
										if (!_ && Yt) {
											const Gt = new Set();
											if (qt === "auto")
												for (let gt = 0; gt < Yt.values.length; gt += 2)
													Gt.add(wf(Yt.values[gt]));
											else Gt.add(qt);
											let Wt = !1;
											for (const gt of Gt)
												if (!Z.horizontal[gt])
													if (Wt) Z.horizontal[gt] = Z.horizontal[0];
													else {
														const Nr = zd(
															W,
															n.glyphMap,
															n.glyphPositions,
															n.imagePositions,
															I,
															Ht,
															f,
															"center",
															gt,
															lt,
															le,
															T.ao.horizontal,
															!1,
															F,
															L
														);
														Nr &&
															((Z.horizontal[gt] = Nr),
															(Wt = Nr.positionedLines.length === 1));
													}
											Sr();
										} else {
											qt === "auto" && (qt = wf(Pt));
											const Gt = zd(
												W,
												n.glyphMap,
												n.glyphPositions,
												n.imagePositions,
												I,
												Ht,
												f,
												Pt,
												qt,
												lt,
												le,
												T.ao.horizontal,
												!1,
												F,
												L
											);
											Gt && (Z.horizontal[qt] = Gt),
												Sr(),
												jl(Ce) &&
													_ &&
													v &&
													(Z.vertical = zd(
														W,
														n.glyphMap,
														n.glyphPositions,
														n.imagePositions,
														I,
														Ht,
														f,
														Pt,
														qt,
														lt,
														le,
														T.ao.vertical,
														!1,
														F,
														L
													));
										}
									}
									let Re = !1;
									if (S.icon && S.icon.name) {
										const Ce = n.imageMap[S.icon.name];
										Ce &&
											((J = f1(
												n.imagePositions[S.icon.name],
												r.get("icon-offset").evaluate(S, {}, n.canonical),
												r.get("icon-anchor").evaluate(S, {}, n.canonical)
											)),
											(Re = !!Ce.sdf),
											n.bucket.sdfIcons === void 0
												? (n.bucket.sdfIcons = Re)
												: n.bucket.sdfIcons !== Re &&
												  Lt(
														"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"
												  ),
											(Ce.pixelRatio !== n.bucket.pixelRatio ||
												r.get("icon-rotate").constantOr(1) !== 0) &&
												(n.bucket.iconsNeedLinear = !0));
									}
									const xe = Dg(Z.horizontal) || Z.vertical;
									(n.bucket.iconsInText = !!xe && xe.iconsInText),
										(xe || J) &&
											A1(
												n.bucket,
												S,
												Z,
												J,
												n.imageMap,
												c,
												F,
												q,
												le,
												Re,
												n.canonical,
												n.subdivisionGranularity
											);
								}
								n.showCollisionBoxes &&
									n.bucket.generateCollisionDebugBuffers();
							}),
							(T.cI = sf),
							(T.cJ = nf),
							(T.cK = of),
							(T.cL = F_),
							(T.cM = cf),
							(T.cN = class {
								constructor(n) {
									(this._marks = {
										start: [n.url, "start"].join("#"),
										end: [n.url, "end"].join("#"),
										measure: n.url.toString(),
									}),
										performance.mark(this._marks.start);
								}
								finish() {
									performance.mark(this._marks.end);
									let n = performance.getEntriesByName(this._marks.measure);
									return (
										n.length === 0 &&
											(performance.measure(
												this._marks.measure,
												this._marks.start,
												this._marks.end
											),
											(n = performance.getEntriesByName(this._marks.measure)),
											performance.clearMarks(this._marks.start),
											performance.clearMarks(this._marks.end),
											performance.clearMeasures(this._marks.measure)),
										n
									);
								}
							}),
							(T.cO = function (n, t, r, o, c) {
								return s(this, void 0, void 0, function* () {
									if (Ae())
										try {
											return yield Nt(n, t, r, o, c);
										} catch {}
									return (function (f, _, v, b, S) {
										const I = f.width,
											L = f.height;
										(or && cr) ||
											((or = new OffscreenCanvas(I, L)),
											(cr = or.getContext("2d", { willReadFrequently: !0 }))),
											(or.width = I),
											(or.height = L),
											cr.drawImage(f, 0, 0, I, L);
										const F = cr.getImageData(_, v, b, S);
										return cr.clearRect(0, 0, I, L), F.data;
									})(n, t, r, o, c);
								});
							}),
							(T.cP = S_),
							(T.cQ = O),
							(T.cR = B_),
							(T.cS = ec),
							(T.cT = qs),
							(T.cU = function (n, t) {
								const r = new Map();
								if (n != null)
									if (n.type === "Feature") r.set(Au(n, t), n);
									else for (const o of n.features) r.set(Au(o, t), o);
								return r;
							}),
							(T.cV = function (n, t) {
								if (n == null) return !0;
								if (n.type === "Feature") return Au(n, t) != null;
								if (n.type === "FeatureCollection") {
									const r = new Set();
									for (const o of n.features) {
										const c = Au(o, t);
										if (c == null || r.has(c)) return !1;
										r.add(c);
									}
									return !0;
								}
								return !1;
							}),
							(T.cW = function (n, t, r) {
								var o, c, f, _;
								if ((t.removeAll && n.clear(), t.remove))
									for (const v of t.remove) n.delete(v);
								if (t.add)
									for (const v of t.add) {
										const b = Au(v, r);
										b != null && n.set(b, v);
									}
								if (t.update)
									for (const v of t.update) {
										let b = n.get(v.id);
										if (b == null) continue;
										const S =
											!v.removeAllProperties &&
											(((o = v.removeProperties) === null || o === void 0
												? void 0
												: o.length) > 0 ||
												((c = v.addOrUpdateProperties) === null || c === void 0
													? void 0
													: c.length) > 0);
										if (
											((v.newGeometry || v.removeAllProperties || S) &&
												((b = Object.assign({}, b)),
												n.set(v.id, b),
												S && (b.properties = Object.assign({}, b.properties))),
											v.newGeometry && (b.geometry = v.newGeometry),
											v.removeAllProperties)
										)
											b.properties = {};
										else if (
											((f = v.removeProperties) === null || f === void 0
												? void 0
												: f.length) > 0
										)
											for (const I of v.removeProperties)
												Object.prototype.hasOwnProperty.call(b.properties, I) &&
													delete b.properties[I];
										if (
											((_ = v.addOrUpdateProperties) === null || _ === void 0
												? void 0
												: _.length) > 0
										)
											for (const {
												key: I,
												value: L,
											} of v.addOrUpdateProperties)
												b.properties[I] = L;
									}
							}),
							(T.cX = Ea),
							(T.ca = function (n, t) {
								return (
									(n[0] = t[0]),
									(n[1] = t[1]),
									(n[2] = t[2]),
									(n[3] = t[3]),
									(n[4] = t[4]),
									(n[5] = t[5]),
									(n[6] = t[6]),
									(n[7] = t[7]),
									(n[8] = t[8]),
									(n[9] = t[9]),
									(n[10] = t[10]),
									(n[11] = t[11]),
									(n[12] = t[12]),
									(n[13] = t[13]),
									(n[14] = t[14]),
									(n[15] = t[15]),
									n
								);
							}),
							(T.cb = (n) => n.type === "symbol"),
							(T.cc = (n) => n.type === "circle"),
							(T.cd = (n) => n.type === "heatmap"),
							(T.ce = (n) => n.type === "line"),
							(T.cf = (n) => n.type === "fill"),
							(T.cg = (n) => n.type === "fill-extrusion"),
							(T.ch = (n) => n.type === "hillshade"),
							(T.ci = (n) => n.type === "color-relief"),
							(T.cj = (n) => n.type === "raster"),
							(T.ck = (n) => n.type === "background"),
							(T.cl = (n) => n.type === "custom"),
							(T.cm = ct),
							(T.cn = function (n, t, r) {
								const o = he(t.x - r.x, t.y - r.y),
									c = he(n.x - r.x, n.y - r.y);
								var f, _;
								return hr(
									Math.atan2(
										o[0] * c[1] - o[1] * c[0],
										(f = o)[0] * (_ = c)[0] + f[1] * _[1]
									)
								);
							}),
							(T.co = It),
							(T.cp = function (n, t) {
								return (
									Ir[t] && (n instanceof MouseEvent || n instanceof WheelEvent)
								);
							}),
							(T.cq = function (n, t) {
								return _r[t] && "touches" in n;
							}),
							(T.cr = function (n) {
								return _r[n] || Ir[n];
							}),
							(T.cs = function (n, t, r) {
								var o = t[0],
									c = t[1];
								return (
									(n[0] = r[0] * o + r[4] * c + r[12]),
									(n[1] = r[1] * o + r[5] * c + r[13]),
									n
								);
							}),
							(T.ct = function (n, t) {
								const { x: r, y: o } = ku.fromLngLat(t);
								return !(n < 0 || n > 25 || o < 0 || o >= 1 || r < 0 || r >= 1);
							}),
							(T.cu = function (n, t) {
								return (
									(n[0] = t[0]),
									(n[1] = 0),
									(n[2] = 0),
									(n[3] = 0),
									(n[4] = 0),
									(n[5] = t[1]),
									(n[6] = 0),
									(n[7] = 0),
									(n[8] = 0),
									(n[9] = 0),
									(n[10] = t[2]),
									(n[11] = 0),
									(n[12] = 0),
									(n[13] = 0),
									(n[14] = 0),
									(n[15] = 1),
									n
								);
							}),
							(T.cv = class extends ds {}),
							(T.cw = z1),
							(T.cy = function (n) {
								return n.message === qr;
							}),
							(T.cz = ie),
							(T.d = Me),
							(T.e = dt),
							(T.f = (n) =>
								s(void 0, void 0, void 0, function* () {
									if (n.byteLength === 0)
										return createImageBitmap(new ImageData(1, 1));
									const t = new Blob([new Uint8Array(n)], {
										type: "image/png",
									});
									try {
										return createImageBitmap(t);
									} catch (r) {
										throw new Error(
											`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
										);
									}
								})),
							(T.g = U),
							(T.h = (n) =>
								new Promise((t, r) => {
									const o = new Image();
									(o.onload = () => {
										t(o),
											URL.revokeObjectURL(o.src),
											(o.onload = null),
											window.requestAnimationFrame(() => {
												o.src = Ot;
											});
									}),
										(o.onerror = () =>
											r(
												new Error(
													"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
												)
											));
									const c = new Blob([new Uint8Array(n)], {
										type: "image/png",
									});
									o.src = n.byteLength ? URL.createObjectURL(c) : Ot;
								})),
							(T.i = $t),
							(T.j = (n, t) => Se(dt(n, { type: "json" }), t)),
							(T.k = Ke),
							(T.l = ut),
							(T.m = Se),
							(T.n = (n, t) => Se(dt(n, { type: "arrayBuffer" }), t)),
							(T.o = function (n) {
								return new cf(n).readFields(n1, []);
							}),
							(T.p = Y_),
							(T.q = vu),
							(T.r = Ui),
							(T.s = Vr),
							(T.t = bd),
							(T.u = hn),
							(T.v = ye),
							(T.w = Lt),
							(T.x = jp),
							(T.y = Xs),
							(T.z = ls);
					}),
						M("worker", ["./shared"], function (T) {
							class s {
								constructor(V) {
									(this.keyCache = {}), V && this.replace(V);
								}
								replace(V) {
									(this._layerConfigs = {}),
										(this._layers = {}),
										this.update(V, []);
								}
								update(V, U) {
									for (const ie of V) {
										this._layerConfigs[ie.id] = ie;
										const pe = (this._layers[ie.id] = T.bJ(ie));
										(pe._featureFilter = T.aa(pe.filter)),
											this.keyCache[ie.id] && delete this.keyCache[ie.id];
									}
									for (const ie of U)
										delete this.keyCache[ie],
											delete this._layerConfigs[ie],
											delete this._layers[ie];
									this.familiesBySource = {};
									const Y = T.cC(
										Object.values(this._layerConfigs),
										this.keyCache
									);
									for (const ie of Y) {
										const pe = ie.map((Ke) => this._layers[Ke.id]),
											Se = pe[0];
										if (Se.visibility === "none") continue;
										const Me = Se.source || "";
										let we = this.familiesBySource[Me];
										we || (we = this.familiesBySource[Me] = {});
										const Ve = Se.sourceLayer || "_geojsonTileLayer";
										let ut = we[Ve];
										ut || (ut = we[Ve] = []), ut.push(pe);
									}
								}
							}
							class B {
								constructor(V) {
									const U = {},
										Y = [];
									for (const Me in V) {
										const we = V[Me],
											Ve = (U[Me] = {});
										for (const ut in we) {
											const Ke = we[+ut];
											if (
												!Ke ||
												Ke.bitmap.width === 0 ||
												Ke.bitmap.height === 0
											)
												continue;
											const kt = {
												x: 0,
												y: 0,
												w: Ke.bitmap.width + 2,
												h: Ke.bitmap.height + 2,
											};
											Y.push(kt), (Ve[ut] = { rect: kt, metrics: Ke.metrics });
										}
									}
									const { w: ie, h: pe } = T.p(Y),
										Se = new T.q({ width: ie || 1, height: pe || 1 });
									for (const Me in V) {
										const we = V[Me];
										for (const Ve in we) {
											const ut = we[+Ve];
											if (
												!ut ||
												ut.bitmap.width === 0 ||
												ut.bitmap.height === 0
											)
												continue;
											const Ke = U[Me][Ve].rect;
											T.q.copy(
												ut.bitmap,
												Se,
												{ x: 0, y: 0 },
												{ x: Ke.x + 1, y: Ke.y + 1 },
												ut.bitmap
											);
										}
									}
									(this.image = Se), (this.positions = U);
								}
							}
							T.cD("GlyphAtlas", B);
							class O {
								constructor(V) {
									(this.tileID = new T.Z(
										V.tileID.overscaledZ,
										V.tileID.wrap,
										V.tileID.canonical.z,
										V.tileID.canonical.x,
										V.tileID.canonical.y
									)),
										(this.uid = V.uid),
										(this.zoom = V.zoom),
										(this.pixelRatio = V.pixelRatio),
										(this.tileSize = V.tileSize),
										(this.source = V.source),
										(this.overscaling = this.tileID.overscaleFactor()),
										(this.showCollisionBoxes = V.showCollisionBoxes),
										(this.collectResourceTiming = !!V.collectResourceTiming),
										(this.returnDependencies = !!V.returnDependencies),
										(this.promoteId = V.promoteId),
										(this.inFlightDependencies = []),
										(this.globalState = V.globalState);
								}
								parse(V, U, Y, ie, pe) {
									return T._(this, void 0, void 0, function* () {
										(this.status = "parsing"),
											(this.data = V),
											(this.collisionBoxArray = new T.a8());
										const Se = new T.cE(Object.keys(V.layers).sort()),
											Me = new T.cF(this.tileID, this.promoteId);
										Me.bucketLayerIDs = [];
										const we = {},
											Ve = {
												featureIndex: Me,
												iconDependencies: {},
												patternDependencies: {},
												glyphDependencies: {},
												availableImages: Y,
												subdivisionGranularity: pe,
											},
											ut = U.familiesBySource[this.source];
										for (const Vt in ut) {
											const Et = V.layers[Vt];
											if (!Et) continue;
											Et.version === 1 &&
												T.w(
													`Vector tile source "${this.source}" layer "${Vt}" does not use vector tile spec v2 and therefore may have some rendering errors.`
												);
											const dr = Se.encode(Vt),
												ht = [];
											for (let Xr = 0; Xr < Et.length; Xr++) {
												const Yr = Et.feature(Xr),
													Zr = Me.getId(Yr, Vt);
												ht.push({
													feature: Yr,
													id: Zr,
													index: Xr,
													sourceLayerIndex: dr,
												});
											}
											for (const Xr of ut[Vt]) {
												const Yr = Xr[0];
												Yr.source !== this.source &&
													T.w(
														`layer.source = ${Yr.source} does not equal this.source = ${this.source}`
													),
													(Yr.minzoom && this.zoom < Math.floor(Yr.minzoom)) ||
														(Yr.maxzoom && this.zoom >= Yr.maxzoom) ||
														(Yr.visibility !== "none" &&
															(X(Xr, this.zoom, Y),
															(we[Yr.id] = Yr.createBucket({
																index: Me.bucketLayerIDs.length,
																layers: Xr,
																zoom: this.zoom,
																pixelRatio: this.pixelRatio,
																overscaling: this.overscaling,
																collisionBoxArray: this.collisionBoxArray,
																sourceLayerIndex: dr,
																sourceID: this.source,
																globalState: this.globalState,
															})).populate(ht, Ve, this.tileID.canonical),
															Me.bucketLayerIDs.push(Xr.map((Zr) => Zr.id))));
											}
										}
										const Ke = T.bN(Ve.glyphDependencies, (Vt) =>
											Object.keys(Vt).map(Number)
										);
										this.inFlightDependencies.forEach((Vt) =>
											Vt == null ? void 0 : Vt.abort()
										),
											(this.inFlightDependencies = []);
										let kt = Promise.resolve({});
										if (Object.keys(Ke).length) {
											const Vt = new AbortController();
											this.inFlightDependencies.push(Vt),
												(kt = ie.sendAsync(
													{
														type: "GG",
														data: {
															stacks: Ke,
															source: this.source,
															tileID: this.tileID,
															type: "glyphs",
														},
													},
													Vt
												));
										}
										const ye = Object.keys(Ve.iconDependencies);
										let Bt = Promise.resolve({});
										if (ye.length) {
											const Vt = new AbortController();
											this.inFlightDependencies.push(Vt),
												(Bt = ie.sendAsync(
													{
														type: "GI",
														data: {
															icons: ye,
															source: this.source,
															tileID: this.tileID,
															type: "icons",
														},
													},
													Vt
												));
										}
										const rr = Object.keys(Ve.patternDependencies);
										let Kt = Promise.resolve({});
										if (rr.length) {
											const Vt = new AbortController();
											this.inFlightDependencies.push(Vt),
												(Kt = ie.sendAsync(
													{
														type: "GI",
														data: {
															icons: rr,
															source: this.source,
															tileID: this.tileID,
															type: "patterns",
														},
													},
													Vt
												));
										}
										const [gr, Ur, nn] = yield Promise.all([kt, Bt, Kt]),
											mn = new B(gr),
											_n = new T.cG(Ur, nn);
										for (const Vt in we) {
											const Et = we[Vt];
											Et instanceof T.a9
												? (X(Et.layers, this.zoom, Y),
												  T.cH({
														bucket: Et,
														glyphMap: gr,
														glyphPositions: mn.positions,
														imageMap: Ur,
														imagePositions: _n.iconPositions,
														showCollisionBoxes: this.showCollisionBoxes,
														canonical: this.tileID.canonical,
														subdivisionGranularity: Ve.subdivisionGranularity,
												  }))
												: Et.hasPattern &&
												  (Et instanceof T.cI ||
														Et instanceof T.cJ ||
														Et instanceof T.cK) &&
												  (X(Et.layers, this.zoom, Y),
												  Et.addFeatures(
														Ve,
														this.tileID.canonical,
														_n.patternPositions
												  ));
										}
										return (
											(this.status = "done"),
											{
												buckets: Object.values(we).filter(
													(Vt) => !Vt.isEmpty()
												),
												featureIndex: Me,
												collisionBoxArray: this.collisionBoxArray,
												glyphAtlasImage: mn.image,
												imageAtlas: _n,
												glyphMap: this.returnDependencies ? gr : null,
												iconMap: this.returnDependencies ? Ur : null,
												glyphPositions: this.returnDependencies
													? mn.positions
													: null,
											}
										);
									});
								}
							}
							function X(ue, V, U) {
								const Y = new T.F(V);
								for (const ie of ue) ie.recalculate(Y, U);
							}
							class K {
								constructor(V, U, Y) {
									(this.actor = V),
										(this.layerIndex = U),
										(this.availableImages = Y),
										(this.fetching = {}),
										(this.loading = {}),
										(this.loaded = {});
								}
								loadVectorTile(V, U) {
									return T._(this, void 0, void 0, function* () {
										const Y = yield T.n(V.request, U);
										try {
											return {
												vectorTile: new T.cL(new T.cM(Y.data)),
												rawData: Y.data,
												cacheControl: Y.cacheControl,
												expires: Y.expires,
											};
										} catch (ie) {
											const pe = new Uint8Array(Y.data);
											let Se = `Unable to parse the tile at ${V.request.url}, `;
											throw (
												((Se +=
													pe[0] === 31 && pe[1] === 139
														? "please make sure the data is not gzipped and that you have configured the relevant header in the server"
														: `got error: ${ie.message}`),
												new Error(Se))
											);
										}
									});
								}
								loadTile(V) {
									return T._(this, void 0, void 0, function* () {
										const U = V.uid,
											Y =
												!!(V && V.request && V.request.collectResourceTiming) &&
												new T.cN(V.request),
											ie = new O(V);
										this.loading[U] = ie;
										const pe = new AbortController();
										ie.abort = pe;
										try {
											const Se = yield this.loadVectorTile(V, pe);
											if ((delete this.loading[U], !Se)) return null;
											const Me = Se.rawData,
												we = {};
											Se.expires && (we.expires = Se.expires),
												Se.cacheControl && (we.cacheControl = Se.cacheControl);
											const Ve = {};
											if (Y) {
												const Ke = Y.finish();
												Ke &&
													(Ve.resourceTiming = JSON.parse(JSON.stringify(Ke)));
											}
											ie.vectorTile = Se.vectorTile;
											const ut = ie.parse(
												Se.vectorTile,
												this.layerIndex,
												this.availableImages,
												this.actor,
												V.subdivisionGranularity
											);
											(this.loaded[U] = ie),
												(this.fetching[U] = {
													rawTileData: Me,
													cacheControl: we,
													resourceTiming: Ve,
												});
											try {
												const Ke = yield ut;
												return T.e({ rawTileData: Me.slice(0) }, Ke, we, Ve);
											} finally {
												delete this.fetching[U];
											}
										} catch (Se) {
											throw (
												(delete this.loading[U],
												(ie.status = "done"),
												(this.loaded[U] = ie),
												Se)
											);
										}
									});
								}
								reloadTile(V) {
									return T._(this, void 0, void 0, function* () {
										const U = V.uid;
										if (!this.loaded || !this.loaded[U])
											throw new Error(
												"Should not be trying to reload a tile that was never loaded or has been removed"
											);
										const Y = this.loaded[U];
										if (
											((Y.showCollisionBoxes = V.showCollisionBoxes),
											(Y.globalState = V.globalState),
											Y.status === "parsing")
										) {
											const ie = yield Y.parse(
												Y.vectorTile,
												this.layerIndex,
												this.availableImages,
												this.actor,
												V.subdivisionGranularity
											);
											let pe;
											if (this.fetching[U]) {
												const {
													rawTileData: Se,
													cacheControl: Me,
													resourceTiming: we,
												} = this.fetching[U];
												delete this.fetching[U],
													(pe = T.e({ rawTileData: Se.slice(0) }, ie, Me, we));
											} else pe = ie;
											return pe;
										}
										if (Y.status === "done" && Y.vectorTile)
											return Y.parse(
												Y.vectorTile,
												this.layerIndex,
												this.availableImages,
												this.actor,
												V.subdivisionGranularity
											);
									});
								}
								abortTile(V) {
									return T._(this, void 0, void 0, function* () {
										const U = this.loading,
											Y = V.uid;
										U &&
											U[Y] &&
											U[Y].abort &&
											(U[Y].abort.abort(), delete U[Y]);
									});
								}
								removeTile(V) {
									return T._(this, void 0, void 0, function* () {
										this.loaded &&
											this.loaded[V.uid] &&
											delete this.loaded[V.uid];
									});
								}
							}
							class ne {
								constructor() {
									this.loaded = {};
								}
								loadTile(V) {
									return T._(this, void 0, void 0, function* () {
										const {
												uid: U,
												encoding: Y,
												rawImageData: ie,
												redFactor: pe,
												greenFactor: Se,
												blueFactor: Me,
												baseShift: we,
											} = V,
											Ve = ie.width + 2,
											ut = ie.height + 2,
											Ke = T.b(ie)
												? new T.R(
														{ width: Ve, height: ut },
														yield T.cO(ie, -1, -1, Ve, ut)
												  )
												: ie,
											kt = new T.cP(U, Ke, Y, pe, Se, Me, we);
										return (
											(this.loaded = this.loaded || {}),
											(this.loaded[U] = kt),
											kt
										);
									});
								}
								removeTile(V) {
									const U = this.loaded,
										Y = V.uid;
									U && U[Y] && delete U[Y];
								}
							}
							var H,
								fe,
								ge = (function () {
									if (fe) return H;
									function ue(U, Y) {
										if (U.length !== 0) {
											V(U[0], Y);
											for (var ie = 1; ie < U.length; ie++) V(U[ie], !Y);
										}
									}
									function V(U, Y) {
										for (
											var ie = 0, pe = 0, Se = 0, Me = U.length, we = Me - 1;
											Se < Me;
											we = Se++
										) {
											var Ve = (U[Se][0] - U[we][0]) * (U[we][1] + U[Se][1]),
												ut = ie + Ve;
											(pe +=
												Math.abs(ie) >= Math.abs(Ve)
													? ie - ut + Ve
													: Ve - ut + ie),
												(ie = ut);
										}
										ie + pe >= 0 != !!Y && U.reverse();
									}
									return (
										(fe = 1),
										(H = function U(Y, ie) {
											var pe,
												Se = Y && Y.type;
											if (Se === "FeatureCollection")
												for (pe = 0; pe < Y.features.length; pe++)
													U(Y.features[pe], ie);
											else if (Se === "GeometryCollection")
												for (pe = 0; pe < Y.geometries.length; pe++)
													U(Y.geometries[pe], ie);
											else if (Se === "Feature") U(Y.geometry, ie);
											else if (Se === "Polygon") ue(Y.coordinates, ie);
											else if (Se === "MultiPolygon")
												for (pe = 0; pe < Y.coordinates.length; pe++)
													ue(Y.coordinates[pe], ie);
											return Y;
										})
									);
								})(),
								Ie = T.cQ(ge);
							class Ae extends T.cS {
								constructor(V, U) {
									super(new T.cM(), 0, U, [], []),
										(this.feature = V),
										(this.type = V.type),
										(this.properties = V.tags ? V.tags : {}),
										"id" in V &&
											(typeof V.id == "string"
												? (this.id = parseInt(V.id, 10))
												: typeof V.id != "number" ||
												  isNaN(V.id) ||
												  (this.id = V.id));
								}
								loadGeometry() {
									const V = [],
										U =
											this.feature.type === 1
												? [this.feature.geometry]
												: this.feature.geometry;
									for (const Y of U) {
										const ie = [];
										for (const pe of Y) ie.push(new T.P(pe[0], pe[1]));
										V.push(ie);
									}
									return V;
								}
							}
							class De extends T.cR {
								constructor(V, U) {
									super(new T.cM()),
										(this.layers = { _geojsonTileLayer: this }),
										(this.name = "_geojsonTileLayer"),
										(this.version = U ? U.version : 1),
										(this.extent = U ? U.extent : 4096),
										(this.length = V.length),
										(this.features = V);
								}
								feature(V) {
									return new Ae(this.features[V], this.extent);
								}
							}
							function Ee(ue, V) {
								V.writeVarintField(15, ue.version || 1),
									V.writeStringField(1, ue.name || ""),
									V.writeVarintField(5, ue.extent || 4096);
								const U = {
									keys: [],
									values: [],
									keycache: {},
									valuecache: {},
								};
								for (let pe = 0; pe < ue.length; pe++)
									(U.feature = ue.feature(pe)), V.writeMessage(2, Fe, U);
								const Y = U.keys;
								for (const pe of Y) V.writeStringField(3, pe);
								const ie = U.values;
								for (const pe of ie) V.writeMessage(4, Qe, pe);
							}
							function Fe(ue, V) {
								if (!ue.feature) return;
								const U = ue.feature;
								U.id !== void 0 && V.writeVarintField(1, U.id),
									V.writeMessage(2, $e, ue),
									V.writeVarintField(3, U.type),
									V.writeMessage(4, Ze, U);
							}
							function $e(ue, V) {
								var U;
								for (const Y in (U = ue.feature) == null
									? void 0
									: U.properties) {
									let ie = ue.feature.properties[Y],
										pe = ue.keycache[Y];
									if (ie === null) continue;
									pe === void 0 &&
										(ue.keys.push(Y),
										(pe = ue.keys.length - 1),
										(ue.keycache[Y] = pe)),
										V.writeVarint(pe),
										typeof ie != "string" &&
											typeof ie != "boolean" &&
											typeof ie != "number" &&
											(ie = JSON.stringify(ie));
									const Se = typeof ie + ":" + ie;
									let Me = ue.valuecache[Se];
									Me === void 0 &&
										(ue.values.push(ie),
										(Me = ue.values.length - 1),
										(ue.valuecache[Se] = Me)),
										V.writeVarint(Me);
								}
							}
							function Je(ue, V) {
								return (V << 3) + (7 & ue);
							}
							function qe(ue) {
								return (ue << 1) ^ (ue >> 31);
							}
							function Ze(ue, V) {
								const U = ue.loadGeometry(),
									Y = ue.type;
								let ie = 0,
									pe = 0;
								for (const Se of U) {
									let Me = 1;
									Y === 1 && (Me = Se.length), V.writeVarint(Je(1, Me));
									const we = Y === 3 ? Se.length - 1 : Se.length;
									for (let Ve = 0; Ve < we; Ve++) {
										Ve === 1 && Y !== 1 && V.writeVarint(Je(2, we - 1));
										const ut = Se[Ve].x - ie,
											Ke = Se[Ve].y - pe;
										V.writeVarint(qe(ut)),
											V.writeVarint(qe(Ke)),
											(ie += ut),
											(pe += Ke);
									}
									ue.type === 3 && V.writeVarint(Je(7, 1));
								}
							}
							function Qe(ue, V) {
								const U = typeof ue;
								U === "string"
									? V.writeStringField(1, ue)
									: U === "boolean"
									? V.writeBooleanField(7, ue)
									: U === "number" &&
									  (ue % 1 != 0
											? V.writeDoubleField(3, ue)
											: ue < 0
											? V.writeSVarintField(6, ue)
											: V.writeVarintField(5, ue));
							}
							const Le = {
									minZoom: 0,
									maxZoom: 16,
									minPoints: 2,
									radius: 40,
									extent: 512,
									nodeSize: 64,
									log: !1,
									generateId: !1,
									reduce: null,
									map: (ue) => ue,
								},
								et =
									Math.fround ||
									((nt = new Float32Array(1)), (ue) => ((nt[0] = +ue), nt[0]));
							var nt;
							class Ue {
								constructor(V) {
									(this.options = Object.assign(Object.create(Le), V)),
										(this.trees = new Array(this.options.maxZoom + 1)),
										(this.stride = this.options.reduce ? 7 : 6),
										(this.clusterProps = []);
								}
								load(V) {
									const { log: U, minZoom: Y, maxZoom: ie } = this.options;
									U && console.time("total time");
									const pe = `prepare ${V.length} points`;
									U && console.time(pe), (this.points = V);
									const Se = [];
									for (let we = 0; we < V.length; we++) {
										const Ve = V[we];
										if (!Ve.geometry) continue;
										const [ut, Ke] = Ve.geometry.coordinates,
											kt = et(ee(ut)),
											ye = et(re(Ke));
										Se.push(kt, ye, 1 / 0, we, -1, 1),
											this.options.reduce && Se.push(0);
									}
									let Me = (this.trees[ie + 1] = this._createTree(Se));
									U && console.timeEnd(pe);
									for (let we = ie; we >= Y; we--) {
										const Ve = +Date.now();
										(Me = this.trees[we] =
											this._createTree(this._cluster(Me, we))),
											U &&
												console.log(
													"z%d: %d clusters in %dms",
													we,
													Me.numItems,
													+Date.now() - Ve
												);
									}
									return U && console.timeEnd("total time"), this;
								}
								getClusters(V, U) {
									let Y = ((((V[0] + 180) % 360) + 360) % 360) - 180;
									const ie = Math.max(-90, Math.min(90, V[1]));
									let pe =
										V[2] === 180
											? 180
											: ((((V[2] + 180) % 360) + 360) % 360) - 180;
									const Se = Math.max(-90, Math.min(90, V[3]));
									if (V[2] - V[0] >= 360) (Y = -180), (pe = 180);
									else if (Y > pe) {
										const Ke = this.getClusters([Y, ie, 180, Se], U),
											kt = this.getClusters([-180, ie, pe, Se], U);
										return Ke.concat(kt);
									}
									const Me = this.trees[this._limitZoom(U)],
										we = Me.range(ee(Y), re(Se), ee(pe), re(ie)),
										Ve = Me.data,
										ut = [];
									for (const Ke of we) {
										const kt = this.stride * Ke;
										ut.push(
											Ve[kt + 5] > 1
												? ke(Ve, kt, this.clusterProps)
												: this.points[Ve[kt + 3]]
										);
									}
									return ut;
								}
								getChildren(V) {
									const U = this._getOriginId(V),
										Y = this._getOriginZoom(V),
										ie = "No cluster with the specified id.",
										pe = this.trees[Y];
									if (!pe) throw new Error(ie);
									const Se = pe.data;
									if (U * this.stride >= Se.length) throw new Error(ie);
									const Me =
											this.options.radius /
											(this.options.extent * Math.pow(2, Y - 1)),
										we = pe.within(
											Se[U * this.stride],
											Se[U * this.stride + 1],
											Me
										),
										Ve = [];
									for (const ut of we) {
										const Ke = ut * this.stride;
										Se[Ke + 4] === V &&
											Ve.push(
												Se[Ke + 5] > 1
													? ke(Se, Ke, this.clusterProps)
													: this.points[Se[Ke + 3]]
											);
									}
									if (Ve.length === 0) throw new Error(ie);
									return Ve;
								}
								getLeaves(V, U, Y) {
									const ie = [];
									return (
										this._appendLeaves(ie, V, (U = U || 10), (Y = Y || 0), 0),
										ie
									);
								}
								getTile(V, U, Y) {
									const ie = this.trees[this._limitZoom(V)],
										pe = Math.pow(2, V),
										{ extent: Se, radius: Me } = this.options,
										we = Me / Se,
										Ve = (Y - we) / pe,
										ut = (Y + 1 + we) / pe,
										Ke = { features: [] };
									return (
										this._addTileFeatures(
											ie.range((U - we) / pe, Ve, (U + 1 + we) / pe, ut),
											ie.data,
											U,
											Y,
											pe,
											Ke
										),
										U === 0 &&
											this._addTileFeatures(
												ie.range(1 - we / pe, Ve, 1, ut),
												ie.data,
												pe,
												Y,
												pe,
												Ke
											),
										U === pe - 1 &&
											this._addTileFeatures(
												ie.range(0, Ve, we / pe, ut),
												ie.data,
												-1,
												Y,
												pe,
												Ke
											),
										Ke.features.length ? Ke : null
									);
								}
								getClusterExpansionZoom(V) {
									let U = this._getOriginZoom(V) - 1;
									for (; U <= this.options.maxZoom; ) {
										const Y = this.getChildren(V);
										if ((U++, Y.length !== 1)) break;
										V = Y[0].properties.cluster_id;
									}
									return U;
								}
								_appendLeaves(V, U, Y, ie, pe) {
									const Se = this.getChildren(U);
									for (const Me of Se) {
										const we = Me.properties;
										if (
											(we && we.cluster
												? pe + we.point_count <= ie
													? (pe += we.point_count)
													: (pe = this._appendLeaves(
															V,
															we.cluster_id,
															Y,
															ie,
															pe
													  ))
												: pe < ie
												? pe++
												: V.push(Me),
											V.length === Y)
										)
											break;
									}
									return pe;
								}
								_createTree(V) {
									const U = new T.aI(
										(V.length / this.stride) | 0,
										this.options.nodeSize,
										Float32Array
									);
									for (let Y = 0; Y < V.length; Y += this.stride)
										U.add(V[Y], V[Y + 1]);
									return U.finish(), (U.data = V), U;
								}
								_addTileFeatures(V, U, Y, ie, pe, Se) {
									for (const Me of V) {
										const we = Me * this.stride,
											Ve = U[we + 5] > 1;
										let ut, Ke, kt;
										if (Ve)
											(ut = vt(U, we, this.clusterProps)),
												(Ke = U[we]),
												(kt = U[we + 1]);
										else {
											const rr = this.points[U[we + 3]];
											ut = rr.properties;
											const [Kt, gr] = rr.geometry.coordinates;
											(Ke = ee(Kt)), (kt = re(gr));
										}
										const ye = {
											type: 1,
											geometry: [
												[
													Math.round(this.options.extent * (Ke * pe - Y)),
													Math.round(this.options.extent * (kt * pe - ie)),
												],
											],
											tags: ut,
										};
										let Bt;
										(Bt =
											Ve || this.options.generateId
												? U[we + 3]
												: this.points[U[we + 3]].id),
											Bt !== void 0 && (ye.id = Bt),
											Se.features.push(ye);
									}
								}
								_limitZoom(V) {
									return Math.max(
										this.options.minZoom,
										Math.min(Math.floor(+V), this.options.maxZoom + 1)
									);
								}
								_cluster(V, U) {
									const {
											radius: Y,
											extent: ie,
											reduce: pe,
											minPoints: Se,
										} = this.options,
										Me = Y / (ie * Math.pow(2, U)),
										we = V.data,
										Ve = [],
										ut = this.stride;
									for (let Ke = 0; Ke < we.length; Ke += ut) {
										if (we[Ke + 2] <= U) continue;
										we[Ke + 2] = U;
										const kt = we[Ke],
											ye = we[Ke + 1],
											Bt = V.within(we[Ke], we[Ke + 1], Me),
											rr = we[Ke + 5];
										let Kt = rr;
										for (const gr of Bt) {
											const Ur = gr * ut;
											we[Ur + 2] > U && (Kt += we[Ur + 5]);
										}
										if (Kt > rr && Kt >= Se) {
											let gr,
												Ur = kt * rr,
												nn = ye * rr,
												mn = -1;
											const _n =
												((Ke / ut) << 5) + (U + 1) + this.points.length;
											for (const Vt of Bt) {
												const Et = Vt * ut;
												if (we[Et + 2] <= U) continue;
												we[Et + 2] = U;
												const dr = we[Et + 5];
												(Ur += we[Et] * dr),
													(nn += we[Et + 1] * dr),
													(we[Et + 4] = _n),
													pe &&
														(gr ||
															((gr = this._map(we, Ke, !0)),
															(mn = this.clusterProps.length),
															this.clusterProps.push(gr)),
														pe(gr, this._map(we, Et)));
											}
											(we[Ke + 4] = _n),
												Ve.push(Ur / Kt, nn / Kt, 1 / 0, _n, -1, Kt),
												pe && Ve.push(mn);
										} else {
											for (let gr = 0; gr < ut; gr++) Ve.push(we[Ke + gr]);
											if (Kt > 1)
												for (const gr of Bt) {
													const Ur = gr * ut;
													if (!(we[Ur + 2] <= U)) {
														we[Ur + 2] = U;
														for (let nn = 0; nn < ut; nn++)
															Ve.push(we[Ur + nn]);
													}
												}
										}
									}
									return Ve;
								}
								_getOriginId(V) {
									return (V - this.points.length) >> 5;
								}
								_getOriginZoom(V) {
									return (V - this.points.length) % 32;
								}
								_map(V, U, Y) {
									if (V[U + 5] > 1) {
										const Se = this.clusterProps[V[U + 6]];
										return Y ? Object.assign({}, Se) : Se;
									}
									const ie = this.points[V[U + 3]].properties,
										pe = this.options.map(ie);
									return Y && pe === ie ? Object.assign({}, pe) : pe;
								}
							}
							function ke(ue, V, U) {
								return {
									type: "Feature",
									id: ue[V + 3],
									properties: vt(ue, V, U),
									geometry: {
										type: "Point",
										coordinates: [
											((Y = ue[V]), 360 * (Y - 0.5)),
											he(ue[V + 1]),
										],
									},
								};
								var Y;
							}
							function vt(ue, V, U) {
								const Y = ue[V + 5],
									ie =
										Y >= 1e4
											? `${Math.round(Y / 1e3)}k`
											: Y >= 1e3
											? Math.round(Y / 100) / 10 + "k"
											: Y,
									pe = ue[V + 6],
									Se = pe === -1 ? {} : Object.assign({}, U[pe]);
								return Object.assign(Se, {
									cluster: !0,
									cluster_id: ue[V + 3],
									point_count: Y,
									point_count_abbreviated: ie,
								});
							}
							function ee(ue) {
								return ue / 360 + 0.5;
							}
							function re(ue) {
								const V = Math.sin((ue * Math.PI) / 180),
									U = 0.5 - (0.25 * Math.log((1 + V) / (1 - V))) / Math.PI;
								return U < 0 ? 0 : U > 1 ? 1 : U;
							}
							function he(ue) {
								const V = ((180 - 360 * ue) * Math.PI) / 180;
								return (360 * Math.atan(Math.exp(V))) / Math.PI - 90;
							}
							function oe(ue, V, U, Y) {
								let ie = Y;
								const pe = V + ((U - V) >> 1);
								let Se,
									Me = U - V;
								const we = ue[V],
									Ve = ue[V + 1],
									ut = ue[U],
									Ke = ue[U + 1];
								for (let kt = V + 3; kt < U; kt += 3) {
									const ye = ze(ue[kt], ue[kt + 1], we, Ve, ut, Ke);
									if (ye > ie) (Se = kt), (ie = ye);
									else if (ye === ie) {
										const Bt = Math.abs(kt - pe);
										Bt < Me && ((Se = kt), (Me = Bt));
									}
								}
								ie > Y &&
									(Se - V > 3 && oe(ue, V, Se, Y),
									(ue[Se + 2] = ie),
									U - Se > 3 && oe(ue, Se, U, Y));
							}
							function ze(ue, V, U, Y, ie, pe) {
								let Se = ie - U,
									Me = pe - Y;
								if (Se !== 0 || Me !== 0) {
									const we =
										((ue - U) * Se + (V - Y) * Me) / (Se * Se + Me * Me);
									we > 1
										? ((U = ie), (Y = pe))
										: we > 0 && ((U += Se * we), (Y += Me * we));
								}
								return (Se = ue - U), (Me = V - Y), Se * Se + Me * Me;
							}
							function je(ue, V, U, Y) {
								const ie = {
									id: ue ?? null,
									type: V,
									geometry: U,
									tags: Y,
									minX: 1 / 0,
									minY: 1 / 0,
									maxX: -1 / 0,
									maxY: -1 / 0,
								};
								if (V === "Point" || V === "MultiPoint" || V === "LineString")
									pt(ie, U);
								else if (V === "Polygon") pt(ie, U[0]);
								else if (V === "MultiLineString")
									for (const pe of U) pt(ie, pe);
								else if (V === "MultiPolygon")
									for (const pe of U) pt(ie, pe[0]);
								return ie;
							}
							function pt(ue, V) {
								for (let U = 0; U < V.length; U += 3)
									(ue.minX = Math.min(ue.minX, V[U])),
										(ue.minY = Math.min(ue.minY, V[U + 1])),
										(ue.maxX = Math.max(ue.maxX, V[U])),
										(ue.maxY = Math.max(ue.maxY, V[U + 1]));
							}
							function it(ue, V, U, Y) {
								if (!V.geometry) return;
								const ie = V.geometry.coordinates;
								if (ie && ie.length === 0) return;
								const pe = V.geometry.type,
									Se = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
								let Me = [],
									we = V.id;
								if (
									(U.promoteId
										? (we = V.properties[U.promoteId])
										: U.generateId && (we = Y || 0),
									pe === "Point")
								)
									ct(ie, Me);
								else if (pe === "MultiPoint") for (const Ve of ie) ct(Ve, Me);
								else if (pe === "LineString") It(ie, Me, Se, !1);
								else if (pe === "MultiLineString") {
									if (U.lineMetrics) {
										for (const Ve of ie)
											(Me = []),
												It(Ve, Me, Se, !1),
												ue.push(je(we, "LineString", Me, V.properties));
										return;
									}
									Dt(ie, Me, Se, !1);
								} else if (pe === "Polygon") Dt(ie, Me, Se, !0);
								else {
									if (pe !== "MultiPolygon") {
										if (pe === "GeometryCollection") {
											for (const Ve of V.geometry.geometries)
												it(
													ue,
													{ id: we, geometry: Ve, properties: V.properties },
													U,
													Y
												);
											return;
										}
										throw new Error(
											"Input data is not a valid GeoJSON object."
										);
									}
									for (const Ve of ie) {
										const ut = [];
										Dt(Ve, ut, Se, !0), Me.push(ut);
									}
								}
								ue.push(je(we, pe, Me, V.properties));
							}
							function ct(ue, V) {
								V.push(at(ue[0]), dt(ue[1]), 0);
							}
							function It(ue, V, U, Y) {
								let ie,
									pe,
									Se = 0;
								for (let we = 0; we < ue.length; we++) {
									const Ve = at(ue[we][0]),
										ut = dt(ue[we][1]);
									V.push(Ve, ut, 0),
										we > 0 &&
											(Se += Y
												? (ie * ut - Ve * pe) / 2
												: Math.sqrt(
														Math.pow(Ve - ie, 2) + Math.pow(ut - pe, 2)
												  )),
										(ie = Ve),
										(pe = ut);
								}
								const Me = V.length - 3;
								(V[2] = 1),
									oe(V, 0, Me, U),
									(V[Me + 2] = 1),
									(V.size = Math.abs(Se)),
									(V.start = 0),
									(V.end = V.size);
							}
							function Dt(ue, V, U, Y) {
								for (let ie = 0; ie < ue.length; ie++) {
									const pe = [];
									It(ue[ie], pe, U, Y), V.push(pe);
								}
							}
							function at(ue) {
								return ue / 360 + 0.5;
							}
							function dt(ue) {
								const V = Math.sin((ue * Math.PI) / 180),
									U = 0.5 - (0.25 * Math.log((1 + V) / (1 - V))) / Math.PI;
								return U < 0 ? 0 : U > 1 ? 1 : U;
							}
							function yt(ue, V, U, Y, ie, pe, Se, Me) {
								if (((Y /= V), pe >= (U /= V) && Se < Y)) return ue;
								if (Se < U || pe >= Y) return null;
								const we = [];
								for (const Ve of ue) {
									const ut = Ve.geometry;
									let Ke = Ve.type;
									const kt = ie === 0 ? Ve.minX : Ve.minY,
										ye = ie === 0 ? Ve.maxX : Ve.maxY;
									if (kt >= U && ye < Y) {
										we.push(Ve);
										continue;
									}
									if (ye < U || kt >= Y) continue;
									let Bt = [];
									if (Ke === "Point" || Ke === "MultiPoint")
										xt(ut, Bt, U, Y, ie);
									else if (Ke === "LineString")
										St(ut, Bt, U, Y, ie, !1, Me.lineMetrics);
									else if (Ke === "MultiLineString") _t(ut, Bt, U, Y, ie, !1);
									else if (Ke === "Polygon") _t(ut, Bt, U, Y, ie, !0);
									else if (Ke === "MultiPolygon")
										for (const rr of ut) {
											const Kt = [];
											_t(rr, Kt, U, Y, ie, !0), Kt.length && Bt.push(Kt);
										}
									if (Bt.length) {
										if (Me.lineMetrics && Ke === "LineString") {
											for (const rr of Bt) we.push(je(Ve.id, Ke, rr, Ve.tags));
											continue;
										}
										(Ke !== "LineString" && Ke !== "MultiLineString") ||
											(Bt.length === 1
												? ((Ke = "LineString"), (Bt = Bt[0]))
												: (Ke = "MultiLineString")),
											(Ke !== "Point" && Ke !== "MultiPoint") ||
												(Ke = Bt.length === 3 ? "Point" : "MultiPoint"),
											we.push(je(Ve.id, Ke, Bt, Ve.tags));
									}
								}
								return we.length ? we : null;
							}
							function xt(ue, V, U, Y, ie) {
								for (let pe = 0; pe < ue.length; pe += 3) {
									const Se = ue[pe + ie];
									Se >= U && Se <= Y && Lt(V, ue[pe], ue[pe + 1], ue[pe + 2]);
								}
							}
							function St(ue, V, U, Y, ie, pe, Se) {
								let Me = wt(ue);
								const we = ie === 0 ? Rt : $t;
								let Ve,
									ut,
									Ke = ue.start;
								for (let Kt = 0; Kt < ue.length - 3; Kt += 3) {
									const gr = ue[Kt],
										Ur = ue[Kt + 1],
										nn = ue[Kt + 2],
										mn = ue[Kt + 3],
										_n = ue[Kt + 4],
										Vt = ie === 0 ? gr : Ur,
										Et = ie === 0 ? mn : _n;
									let dr = !1;
									Se &&
										(Ve = Math.sqrt(
											Math.pow(gr - mn, 2) + Math.pow(Ur - _n, 2)
										)),
										Vt < U
											? Et > U &&
											  ((ut = we(Me, gr, Ur, mn, _n, U)),
											  Se && (Me.start = Ke + Ve * ut))
											: Vt > Y
											? Et < Y &&
											  ((ut = we(Me, gr, Ur, mn, _n, Y)),
											  Se && (Me.start = Ke + Ve * ut))
											: Lt(Me, gr, Ur, nn),
										Et < U &&
											Vt >= U &&
											((ut = we(Me, gr, Ur, mn, _n, U)), (dr = !0)),
										Et > Y &&
											Vt <= Y &&
											((ut = we(Me, gr, Ur, mn, _n, Y)), (dr = !0)),
										!pe &&
											dr &&
											(Se && (Me.end = Ke + Ve * ut),
											V.push(Me),
											(Me = wt(ue))),
										Se && (Ke += Ve);
								}
								let kt = ue.length - 3;
								const ye = ue[kt],
									Bt = ue[kt + 1],
									rr = ie === 0 ? ye : Bt;
								rr >= U && rr <= Y && Lt(Me, ye, Bt, ue[kt + 2]),
									(kt = Me.length - 3),
									pe &&
										kt >= 3 &&
										(Me[kt] !== Me[0] || Me[kt + 1] !== Me[1]) &&
										Lt(Me, Me[0], Me[1], Me[2]),
									Me.length && V.push(Me);
							}
							function wt(ue) {
								const V = [];
								return (
									(V.size = ue.size), (V.start = ue.start), (V.end = ue.end), V
								);
							}
							function _t(ue, V, U, Y, ie, pe) {
								for (const Se of ue) St(Se, V, U, Y, ie, pe, !1);
							}
							function Lt(ue, V, U, Y) {
								ue.push(V, U, Y);
							}
							function Rt(ue, V, U, Y, ie, pe) {
								const Se = (pe - V) / (Y - V);
								return Lt(ue, pe, U + (ie - U) * Se, 1), Se;
							}
							function $t(ue, V, U, Y, ie, pe) {
								const Se = (pe - U) / (ie - U);
								return Lt(ue, V + (Y - V) * Se, pe, 1), Se;
							}
							function tr(ue, V) {
								const U = [];
								for (let Y = 0; Y < ue.length; Y++) {
									const ie = ue[Y],
										pe = ie.type;
									let Se;
									if (
										pe === "Point" ||
										pe === "MultiPoint" ||
										pe === "LineString"
									)
										Se = Qt(ie.geometry, V);
									else if (pe === "MultiLineString" || pe === "Polygon") {
										Se = [];
										for (const Me of ie.geometry) Se.push(Qt(Me, V));
									} else if (pe === "MultiPolygon") {
										Se = [];
										for (const Me of ie.geometry) {
											const we = [];
											for (const Ve of Me) we.push(Qt(Ve, V));
											Se.push(we);
										}
									}
									U.push(je(ie.id, pe, Se, ie.tags));
								}
								return U;
							}
							function Qt(ue, V) {
								const U = [];
								(U.size = ue.size),
									ue.start !== void 0 &&
										((U.start = ue.start), (U.end = ue.end));
								for (let Y = 0; Y < ue.length; Y += 3)
									U.push(ue[Y] + V, ue[Y + 1], ue[Y + 2]);
								return U;
							}
							function Ot(ue, V) {
								if (ue.transformed) return ue;
								const U = 1 << ue.z,
									Y = ue.x,
									ie = ue.y;
								for (const pe of ue.features) {
									const Se = pe.geometry,
										Me = pe.type;
									if (((pe.geometry = []), Me === 1))
										for (let we = 0; we < Se.length; we += 2)
											pe.geometry.push(Nt(Se[we], Se[we + 1], V, U, Y, ie));
									else
										for (let we = 0; we < Se.length; we++) {
											const Ve = [];
											for (let ut = 0; ut < Se[we].length; ut += 2)
												Ve.push(Nt(Se[we][ut], Se[we][ut + 1], V, U, Y, ie));
											pe.geometry.push(Ve);
										}
								}
								return (ue.transformed = !0), ue;
							}
							function Nt(ue, V, U, Y, ie, pe) {
								return [
									Math.round(U * (ue * Y - ie)),
									Math.round(U * (V * Y - pe)),
								];
							}
							function or(ue, V, U, Y, ie) {
								const pe =
										V === ie.maxZoom
											? 0
											: ie.tolerance / ((1 << V) * ie.extent),
									Se = {
										features: [],
										numPoints: 0,
										numSimplified: 0,
										numFeatures: ue.length,
										source: null,
										x: U,
										y: Y,
										z: V,
										transformed: !1,
										minX: 2,
										minY: 1,
										maxX: -1,
										maxY: 0,
									};
								for (const Me of ue) cr(Se, Me, pe, ie);
								return Se;
							}
							function cr(ue, V, U, Y) {
								const ie = V.geometry,
									pe = V.type,
									Se = [];
								if (
									((ue.minX = Math.min(ue.minX, V.minX)),
									(ue.minY = Math.min(ue.minY, V.minY)),
									(ue.maxX = Math.max(ue.maxX, V.maxX)),
									(ue.maxY = Math.max(ue.maxY, V.maxY)),
									pe === "Point" || pe === "MultiPoint")
								)
									for (let Me = 0; Me < ie.length; Me += 3)
										Se.push(ie[Me], ie[Me + 1]),
											ue.numPoints++,
											ue.numSimplified++;
								else if (pe === "LineString") Vr(Se, ie, ue, U, !1, !1);
								else if (pe === "MultiLineString" || pe === "Polygon")
									for (let Me = 0; Me < ie.length; Me++)
										Vr(Se, ie[Me], ue, U, pe === "Polygon", Me === 0);
								else if (pe === "MultiPolygon")
									for (let Me = 0; Me < ie.length; Me++) {
										const we = ie[Me];
										for (let Ve = 0; Ve < we.length; Ve++)
											Vr(Se, we[Ve], ue, U, !0, Ve === 0);
									}
								if (Se.length) {
									let Me = V.tags || null;
									if (pe === "LineString" && Y.lineMetrics) {
										Me = {};
										for (const Ve in V.tags) Me[Ve] = V.tags[Ve];
										(Me.mapbox_clip_start = ie.start / ie.size),
											(Me.mapbox_clip_end = ie.end / ie.size);
									}
									const we = {
										geometry: Se,
										type:
											pe === "Polygon" || pe === "MultiPolygon"
												? 3
												: pe === "LineString" || pe === "MultiLineString"
												? 2
												: 1,
										tags: Me,
									};
									V.id !== null && (we.id = V.id), ue.features.push(we);
								}
							}
							function Vr(ue, V, U, Y, ie, pe) {
								const Se = Y * Y;
								if (Y > 0 && V.size < (ie ? Se : Y))
									return void (U.numPoints += V.length / 3);
								const Me = [];
								for (let we = 0; we < V.length; we += 3)
									(Y === 0 || V[we + 2] > Se) &&
										(U.numSimplified++, Me.push(V[we], V[we + 1])),
										U.numPoints++;
								ie &&
									(function (we, Ve) {
										let ut = 0;
										for (
											let Ke = 0, kt = we.length, ye = kt - 2;
											Ke < kt;
											ye = Ke, Ke += 2
										)
											ut += (we[Ke] - we[ye]) * (we[Ke + 1] + we[ye + 1]);
										if (ut > 0 === Ve)
											for (let Ke = 0, kt = we.length; Ke < kt / 2; Ke += 2) {
												const ye = we[Ke],
													Bt = we[Ke + 1];
												(we[Ke] = we[kt - 2 - Ke]),
													(we[Ke + 1] = we[kt - 1 - Ke]),
													(we[kt - 2 - Ke] = ye),
													(we[kt - 1 - Ke] = Bt);
											}
									})(Me, pe),
									ue.push(Me);
							}
							const mr = {
								maxZoom: 14,
								indexMaxZoom: 5,
								indexMaxPoints: 1e5,
								tolerance: 3,
								extent: 4096,
								buffer: 64,
								lineMetrics: !1,
								promoteId: null,
								generateId: !1,
								debug: 0,
							};
							class hr {
								constructor(V, U) {
									const Y = (U = this.options =
										(function (pe, Se) {
											for (const Me in Se) pe[Me] = Se[Me];
											return pe;
										})(Object.create(mr), U)).debug;
									if (
										(Y && console.time("preprocess data"),
										U.maxZoom < 0 || U.maxZoom > 24)
									)
										throw new Error("maxZoom should be in the 0-24 range");
									if (U.promoteId && U.generateId)
										throw new Error(
											"promoteId and generateId cannot be used together."
										);
									let ie = (function (pe, Se) {
										const Me = [];
										if (pe.type === "FeatureCollection")
											for (let we = 0; we < pe.features.length; we++)
												it(Me, pe.features[we], Se, we);
										else
											it(Me, pe.type === "Feature" ? pe : { geometry: pe }, Se);
										return Me;
									})(V, U);
									(this.tiles = {}),
										(this.tileCoords = []),
										Y &&
											(console.timeEnd("preprocess data"),
											console.log(
												"index: maxZoom: %d, maxPoints: %d",
												U.indexMaxZoom,
												U.indexMaxPoints
											),
											console.time("generate tiles"),
											(this.stats = {}),
											(this.total = 0)),
										(ie = (function (pe, Se) {
											const Me = Se.buffer / Se.extent;
											let we = pe;
											const Ve = yt(pe, 1, -1 - Me, Me, 0, -1, 2, Se),
												ut = yt(pe, 1, 1 - Me, 2 + Me, 0, -1, 2, Se);
											return (
												(Ve || ut) &&
													((we = yt(pe, 1, -Me, 1 + Me, 0, -1, 2, Se) || []),
													Ve && (we = tr(Ve, 1).concat(we)),
													ut && (we = we.concat(tr(ut, -1)))),
												we
											);
										})(ie, U)),
										ie.length && this.splitTile(ie, 0, 0, 0),
										Y &&
											(ie.length &&
												console.log(
													"features: %d, points: %d",
													this.tiles[0].numFeatures,
													this.tiles[0].numPoints
												),
											console.timeEnd("generate tiles"),
											console.log(
												"tiles generated:",
												this.total,
												JSON.stringify(this.stats)
											));
								}
								splitTile(V, U, Y, ie, pe, Se, Me) {
									const we = [V, U, Y, ie],
										Ve = this.options,
										ut = Ve.debug;
									for (; we.length; ) {
										(ie = we.pop()),
											(Y = we.pop()),
											(U = we.pop()),
											(V = we.pop());
										const Ke = 1 << U,
											kt = _r(U, Y, ie);
										let ye = this.tiles[kt];
										if (
											!ye &&
											(ut > 1 && console.time("creation"),
											(ye = this.tiles[kt] = or(V, U, Y, ie, Ve)),
											this.tileCoords.push({ z: U, x: Y, y: ie }),
											ut)
										) {
											ut > 1 &&
												(console.log(
													"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
													U,
													Y,
													ie,
													ye.numFeatures,
													ye.numPoints,
													ye.numSimplified
												),
												console.timeEnd("creation"));
											const dr = `z${U}`;
											(this.stats[dr] = (this.stats[dr] || 0) + 1),
												this.total++;
										}
										if (((ye.source = V), pe == null)) {
											if (
												U === Ve.indexMaxZoom ||
												ye.numPoints <= Ve.indexMaxPoints
											)
												continue;
										} else {
											if (U === Ve.maxZoom || U === pe) continue;
											if (pe != null) {
												const dr = pe - U;
												if (Y !== Se >> dr || ie !== Me >> dr) continue;
											}
										}
										if (((ye.source = null), V.length === 0)) continue;
										ut > 1 && console.time("clipping");
										const Bt = (0.5 * Ve.buffer) / Ve.extent,
											rr = 0.5 - Bt,
											Kt = 0.5 + Bt,
											gr = 1 + Bt;
										let Ur = null,
											nn = null,
											mn = null,
											_n = null,
											Vt = yt(V, Ke, Y - Bt, Y + Kt, 0, ye.minX, ye.maxX, Ve),
											Et = yt(V, Ke, Y + rr, Y + gr, 0, ye.minX, ye.maxX, Ve);
										(V = null),
											Vt &&
												((Ur = yt(
													Vt,
													Ke,
													ie - Bt,
													ie + Kt,
													1,
													ye.minY,
													ye.maxY,
													Ve
												)),
												(nn = yt(
													Vt,
													Ke,
													ie + rr,
													ie + gr,
													1,
													ye.minY,
													ye.maxY,
													Ve
												)),
												(Vt = null)),
											Et &&
												((mn = yt(
													Et,
													Ke,
													ie - Bt,
													ie + Kt,
													1,
													ye.minY,
													ye.maxY,
													Ve
												)),
												(_n = yt(
													Et,
													Ke,
													ie + rr,
													ie + gr,
													1,
													ye.minY,
													ye.maxY,
													Ve
												)),
												(Et = null)),
											ut > 1 && console.timeEnd("clipping"),
											we.push(Ur || [], U + 1, 2 * Y, 2 * ie),
											we.push(nn || [], U + 1, 2 * Y, 2 * ie + 1),
											we.push(mn || [], U + 1, 2 * Y + 1, 2 * ie),
											we.push(_n || [], U + 1, 2 * Y + 1, 2 * ie + 1);
									}
								}
								getTile(V, U, Y) {
									(V = +V), (U = +U), (Y = +Y);
									const ie = this.options,
										{ extent: pe, debug: Se } = ie;
									if (V < 0 || V > 24) return null;
									const Me = 1 << V,
										we = _r(V, (U = (U + Me) & (Me - 1)), Y);
									if (this.tiles[we]) return Ot(this.tiles[we], pe);
									Se > 1 && console.log("drilling down to z%d-%d-%d", V, U, Y);
									let Ve,
										ut = V,
										Ke = U,
										kt = Y;
									for (; !Ve && ut > 0; )
										ut--,
											(Ke >>= 1),
											(kt >>= 1),
											(Ve = this.tiles[_r(ut, Ke, kt)]);
									return Ve && Ve.source
										? (Se > 1 &&
												(console.log("found parent tile z%d-%d-%d", ut, Ke, kt),
												console.time("drilling down")),
										  this.splitTile(Ve.source, ut, Ke, kt, V, U, Y),
										  Se > 1 && console.timeEnd("drilling down"),
										  this.tiles[we] ? Ot(this.tiles[we], pe) : null)
										: null;
								}
							}
							function _r(ue, V, U) {
								return 32 * ((1 << ue) * U + V) + ue;
							}
							class Ir extends K {
								constructor() {
									super(...arguments), (this._dataUpdateable = new Map());
								}
								loadVectorTile(V, U) {
									return T._(this, void 0, void 0, function* () {
										const Y = V.tileID.canonical;
										if (!this._geoJSONIndex)
											throw new Error(
												"Unable to parse the data into a cluster or geojson"
											);
										const ie = this._geoJSONIndex.getTile(Y.z, Y.x, Y.y);
										if (!ie) return null;
										const pe = new De(ie.features, { version: 2, extent: T.$ });
										let Se = (function (Me) {
											const we = new T.cM();
											return (
												(function (Ve, ut) {
													for (const Ke in Ve.layers)
														ut.writeMessage(3, Ee, Ve.layers[Ke]);
												})(Me, we),
												we.finish()
											);
										})(pe);
										return (
											(Se.byteOffset === 0 &&
												Se.byteLength === Se.buffer.byteLength) ||
												(Se = new Uint8Array(Se)),
											{ vectorTile: pe, rawData: Se.buffer }
										);
									});
								}
								loadData(V) {
									return T._(this, void 0, void 0, function* () {
										var U;
										(U = this._pendingRequest) === null ||
											U === void 0 ||
											U.abort();
										const Y =
											!!(V && V.request && V.request.collectResourceTiming) &&
											new T.cN(V.request);
										this._pendingRequest = new AbortController();
										try {
											this._pendingData = this.loadAndProcessGeoJSON(
												V,
												this._pendingRequest
											);
											const ie = yield this._pendingData;
											(this._geoJSONIndex = V.cluster
												? new Ue(
														(function ({
															superclusterOptions: Se,
															clusterProperties: Me,
														}) {
															if (!Me || !Se) return Se;
															const we = {},
																Ve = {},
																ut = { accumulated: null, zoom: 0 },
																Ke = { properties: null },
																kt = Object.keys(Me);
															for (const ye of kt) {
																const [Bt, rr] = Me[ye],
																	Kt = T.cT(rr),
																	gr = T.cT(
																		typeof Bt == "string"
																			? [Bt, ["accumulated"], ["get", ye]]
																			: Bt
																	);
																(we[ye] = Kt.value), (Ve[ye] = gr.value);
															}
															return (
																(Se.map = (ye) => {
																	Ke.properties = ye;
																	const Bt = {};
																	for (const rr of kt)
																		Bt[rr] = we[rr].evaluate(ut, Ke);
																	return Bt;
																}),
																(Se.reduce = (ye, Bt) => {
																	Ke.properties = Bt;
																	for (const rr of kt)
																		(ut.accumulated = ye[rr]),
																			(ye[rr] = Ve[rr].evaluate(ut, Ke));
																}),
																Se
															);
														})(V)
												  ).load(ie.features)
												: (function (Se, Me) {
														return new hr(Se, Me);
												  })(ie, V.geojsonVtOptions)),
												(this.loaded = {});
											const pe = { data: ie };
											if (Y) {
												const Se = Y.finish();
												Se &&
													((pe.resourceTiming = {}),
													(pe.resourceTiming[V.source] = JSON.parse(
														JSON.stringify(Se)
													)));
											}
											return pe;
										} catch (ie) {
											if ((delete this._pendingRequest, T.cy(ie)))
												return { abandoned: !0 };
											throw ie;
										}
									});
								}
								getData() {
									return T._(this, void 0, void 0, function* () {
										return this._pendingData;
									});
								}
								reloadTile(V) {
									const U = this.loaded;
									return U && U[V.uid] ? super.reloadTile(V) : this.loadTile(V);
								}
								loadAndProcessGeoJSON(V, U) {
									return T._(this, void 0, void 0, function* () {
										let Y = yield this.loadGeoJSON(V, U);
										if ((delete this._pendingRequest, typeof Y != "object"))
											throw new Error(
												`Input data given to '${V.source}' is not a valid GeoJSON object.`
											);
										if ((Ie(Y, !0), V.filter)) {
											const ie = T.cT(V.filter, {
												type: "boolean",
												"property-type": "data-driven",
												overridable: !1,
												transition: !1,
											});
											if (ie.result === "error")
												throw new Error(
													ie.value
														.map((Se) => `${Se.key}: ${Se.message}`)
														.join(", ")
												);
											Y = {
												type: "FeatureCollection",
												features: Y.features.filter((Se) =>
													ie.value.evaluate({ zoom: 0 }, Se)
												),
											};
										}
										return Y;
									});
								}
								loadGeoJSON(V, U) {
									return T._(this, void 0, void 0, function* () {
										const { promoteId: Y } = V;
										if (V.request) {
											const ie = yield T.j(V.request, U);
											return (
												(this._dataUpdateable = T.cV(ie.data, Y)
													? T.cU(ie.data, Y)
													: void 0),
												ie.data
											);
										}
										if (typeof V.data == "string")
											try {
												const ie = JSON.parse(V.data);
												return (
													(this._dataUpdateable = T.cV(ie, Y)
														? T.cU(ie, Y)
														: void 0),
													ie
												);
											} catch {
												throw new Error(
													`Input data given to '${V.source}' is not a valid GeoJSON object.`
												);
											}
										if (!V.dataDiff)
											throw new Error(
												`Input data given to '${V.source}' is not a valid GeoJSON object.`
											);
										if (!this._dataUpdateable)
											throw new Error(
												`Cannot update existing geojson data in ${V.source}`
											);
										return (
											T.cW(this._dataUpdateable, V.dataDiff, Y),
											{
												type: "FeatureCollection",
												features: Array.from(this._dataUpdateable.values()),
											}
										);
									});
								}
								removeSource(V) {
									return T._(this, void 0, void 0, function* () {
										this._pendingRequest && this._pendingRequest.abort();
									});
								}
								getClusterExpansionZoom(V) {
									return this._geoJSONIndex.getClusterExpansionZoom(
										V.clusterId
									);
								}
								getClusterChildren(V) {
									return this._geoJSONIndex.getChildren(V.clusterId);
								}
								getClusterLeaves(V) {
									return this._geoJSONIndex.getLeaves(
										V.clusterId,
										V.limit,
										V.offset
									);
								}
							}
							class qr {
								constructor(V) {
									(this.self = V),
										(this.actor = new T.J(V)),
										(this.layerIndexes = {}),
										(this.availableImages = {}),
										(this.workerSources = {}),
										(this.demWorkerSources = {}),
										(this.externalWorkerSourceTypes = {}),
										(this.self.registerWorkerSource = (U, Y) => {
											if (this.externalWorkerSourceTypes[U])
												throw new Error(
													`Worker source with name "${U}" already registered.`
												);
											this.externalWorkerSourceTypes[U] = Y;
										}),
										(this.self.addProtocol = T.cA),
										(this.self.removeProtocol = T.cB),
										(this.self.registerRTLTextPlugin = (U) => {
											T.cX.setMethods(U);
										}),
										this.actor.registerMessageHandler("LDT", (U, Y) =>
											this._getDEMWorkerSource(U, Y.source).loadTile(Y)
										),
										this.actor.registerMessageHandler("RDT", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												this._getDEMWorkerSource(U, Y.source).removeTile(Y);
											})
										),
										this.actor.registerMessageHandler("GCEZ", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												return this._getWorkerSource(
													U,
													Y.type,
													Y.source
												).getClusterExpansionZoom(Y);
											})
										),
										this.actor.registerMessageHandler("GCC", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												return this._getWorkerSource(
													U,
													Y.type,
													Y.source
												).getClusterChildren(Y);
											})
										),
										this.actor.registerMessageHandler("GCL", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												return this._getWorkerSource(
													U,
													Y.type,
													Y.source
												).getClusterLeaves(Y);
											})
										),
										this.actor.registerMessageHandler("LD", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).loadData(Y)
										),
										this.actor.registerMessageHandler("GD", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).getData()
										),
										this.actor.registerMessageHandler("LT", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).loadTile(Y)
										),
										this.actor.registerMessageHandler("RT", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).reloadTile(Y)
										),
										this.actor.registerMessageHandler("AT", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).abortTile(Y)
										),
										this.actor.registerMessageHandler("RMT", (U, Y) =>
											this._getWorkerSource(U, Y.type, Y.source).removeTile(Y)
										),
										this.actor.registerMessageHandler("RS", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												if (
													!this.workerSources[U] ||
													!this.workerSources[U][Y.type] ||
													!this.workerSources[U][Y.type][Y.source]
												)
													return;
												const ie = this.workerSources[U][Y.type][Y.source];
												delete this.workerSources[U][Y.type][Y.source],
													ie.removeSource !== void 0 && ie.removeSource(Y);
											})
										),
										this.actor.registerMessageHandler("RM", (U) =>
											T._(this, void 0, void 0, function* () {
												delete this.layerIndexes[U],
													delete this.availableImages[U],
													delete this.workerSources[U],
													delete this.demWorkerSources[U];
											})
										),
										this.actor.registerMessageHandler("SR", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												this.referrer = Y;
											})
										),
										this.actor.registerMessageHandler("SRPS", (U, Y) =>
											this._syncRTLPluginState(U, Y)
										),
										this.actor.registerMessageHandler("IS", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												this.self.importScripts(Y);
											})
										),
										this.actor.registerMessageHandler("SI", (U, Y) =>
											this._setImages(U, Y)
										),
										this.actor.registerMessageHandler("UL", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												this._getLayerIndex(U).update(Y.layers, Y.removedIds);
											})
										),
										this.actor.registerMessageHandler("SL", (U, Y) =>
											T._(this, void 0, void 0, function* () {
												this._getLayerIndex(U).replace(Y);
											})
										);
								}
								_setImages(V, U) {
									return T._(this, void 0, void 0, function* () {
										this.availableImages[V] = U;
										for (const Y in this.workerSources[V]) {
											const ie = this.workerSources[V][Y];
											for (const pe in ie) ie[pe].availableImages = U;
										}
									});
								}
								_syncRTLPluginState(V, U) {
									return T._(this, void 0, void 0, function* () {
										return yield T.cX.syncState(U, this.self.importScripts);
									});
								}
								_getAvailableImages(V) {
									let U = this.availableImages[V];
									return U || (U = []), U;
								}
								_getLayerIndex(V) {
									let U = this.layerIndexes[V];
									return U || (U = this.layerIndexes[V] = new s()), U;
								}
								_getWorkerSource(V, U, Y) {
									if (
										(this.workerSources[V] || (this.workerSources[V] = {}),
										this.workerSources[V][U] || (this.workerSources[V][U] = {}),
										!this.workerSources[V][U][Y])
									) {
										const ie = {
											sendAsync: (pe, Se) => (
												(pe.targetMapId = V), this.actor.sendAsync(pe, Se)
											),
										};
										switch (U) {
											case "vector":
												this.workerSources[V][U][Y] = new K(
													ie,
													this._getLayerIndex(V),
													this._getAvailableImages(V)
												);
												break;
											case "geojson":
												this.workerSources[V][U][Y] = new Ir(
													ie,
													this._getLayerIndex(V),
													this._getAvailableImages(V)
												);
												break;
											default:
												this.workerSources[V][U][Y] =
													new this.externalWorkerSourceTypes[U](
														ie,
														this._getLayerIndex(V),
														this._getAvailableImages(V)
													);
										}
									}
									return this.workerSources[V][U][Y];
								}
								_getDEMWorkerSource(V, U) {
									return (
										this.demWorkerSources[V] || (this.demWorkerSources[V] = {}),
										this.demWorkerSources[V][U] ||
											(this.demWorkerSources[V][U] = new ne()),
										this.demWorkerSources[V][U]
									);
								}
							}
							return T.i(self) && (self.worker = new qr(self)), qr;
						}),
						M("index", ["exports", "./shared"], function (T, s) {
							var B = "5.6.2";
							function O() {
								var h = new s.A(4);
								return (
									s.A != Float32Array && ((h[1] = 0), (h[2] = 0)),
									(h[0] = 1),
									(h[3] = 1),
									h
								);
							}
							let X, K;
							const ne = {
								now:
									typeof performance < "u" && performance && performance.now
										? performance.now.bind(performance)
										: Date.now.bind(Date),
								frame(h, e, i) {
									const l = requestAnimationFrame((d) => {
											u(), e(d);
										}),
										{ unsubscribe: u } = s.s(
											h.signal,
											"abort",
											() => {
												u(), cancelAnimationFrame(l), i(s.c());
											},
											!1
										);
								},
								frameAsync(h) {
									return new Promise((e, i) => {
										this.frame(h, e, i);
									});
								},
								getImageData(h, e = 0) {
									return this.getImageCanvasContext(h).getImageData(
										-e,
										-e,
										h.width + 2 * e,
										h.height + 2 * e
									);
								},
								getImageCanvasContext(h) {
									const e = window.document.createElement("canvas"),
										i = e.getContext("2d", { willReadFrequently: !0 });
									if (!i) throw new Error("failed to create canvas 2d context");
									return (
										(e.width = h.width),
										(e.height = h.height),
										i.drawImage(h, 0, 0, h.width, h.height),
										i
									);
								},
								resolveURL: (h) => (
									X || (X = document.createElement("a")), (X.href = h), X.href
								),
								hardwareConcurrency:
									(typeof navigator < "u" && navigator.hardwareConcurrency) ||
									4,
								get prefersReducedMotion() {
									return (
										!!matchMedia &&
										(K == null &&
											(K = matchMedia("(prefers-reduced-motion: reduce)")),
										K.matches)
									);
								},
							};
							class H {
								static testProp(e) {
									if (!H.docStyle) return e[0];
									for (let i = 0; i < e.length; i++)
										if (e[i] in H.docStyle) return e[i];
									return e[0];
								}
								static create(e, i, l) {
									const u = window.document.createElement(e);
									return (
										i !== void 0 && (u.className = i), l && l.appendChild(u), u
									);
								}
								static createNS(e, i) {
									return window.document.createElementNS(e, i);
								}
								static disableDrag() {
									H.docStyle &&
										H.selectProp &&
										((H.userSelect = H.docStyle[H.selectProp]),
										(H.docStyle[H.selectProp] = "none"));
								}
								static enableDrag() {
									H.docStyle &&
										H.selectProp &&
										(H.docStyle[H.selectProp] = H.userSelect);
								}
								static setTransform(e, i) {
									e.style[H.transformProp] = i;
								}
								static addEventListener(e, i, l, u = {}) {
									e.addEventListener(i, l, "passive" in u ? u : u.capture);
								}
								static removeEventListener(e, i, l, u = {}) {
									e.removeEventListener(i, l, "passive" in u ? u : u.capture);
								}
								static suppressClickInternal(e) {
									e.preventDefault(),
										e.stopPropagation(),
										window.removeEventListener(
											"click",
											H.suppressClickInternal,
											!0
										);
								}
								static suppressClick() {
									window.addEventListener("click", H.suppressClickInternal, !0),
										window.setTimeout(() => {
											window.removeEventListener(
												"click",
												H.suppressClickInternal,
												!0
											);
										}, 0);
								}
								static getScale(e) {
									const i = e.getBoundingClientRect();
									return {
										x: i.width / e.offsetWidth || 1,
										y: i.height / e.offsetHeight || 1,
										boundingClientRect: i,
									};
								}
								static getPoint(e, i, l) {
									const u = i.boundingClientRect;
									return new s.P(
										(l.clientX - u.left) / i.x - e.clientLeft,
										(l.clientY - u.top) / i.y - e.clientTop
									);
								}
								static mousePos(e, i) {
									const l = H.getScale(e);
									return H.getPoint(e, l, i);
								}
								static touchPos(e, i) {
									const l = [],
										u = H.getScale(e);
									for (let d = 0; d < i.length; d++)
										l.push(H.getPoint(e, u, i[d]));
									return l;
								}
								static mouseButton(e) {
									return e.button;
								}
								static remove(e) {
									e.parentNode && e.parentNode.removeChild(e);
								}
								static sanitize(e) {
									const i =
											new DOMParser().parseFromString(e, "text/html").body ||
											document.createElement("body"),
										l = i.querySelectorAll("script");
									for (const u of l) u.remove();
									return H.clean(i), i.innerHTML;
								}
								static isPossiblyDangerous(e, i) {
									const l = i.replace(/\s+/g, "").toLowerCase();
									return (
										!(
											!["src", "href", "xlink:href"].includes(e) ||
											(!l.includes("javascript:") && !l.includes("data:"))
										) ||
										!!e.startsWith("on") ||
										void 0
									);
								}
								static clean(e) {
									const i = e.children;
									for (const l of i) H.removeAttributes(l), H.clean(l);
								}
								static removeAttributes(e) {
									for (const { name: i, value: l } of e.attributes)
										H.isPossiblyDangerous(i, l) && e.removeAttribute(i);
								}
							}
							(H.docStyle =
								typeof window < "u" &&
								window.document &&
								window.document.documentElement.style),
								(H.selectProp = H.testProp([
									"userSelect",
									"MozUserSelect",
									"WebkitUserSelect",
									"msUserSelect",
								])),
								(H.transformProp = H.testProp([
									"transform",
									"WebkitTransform",
								]));
							const fe = {
								supported: !1,
								testSupport: function (h) {
									!Ae && Ie && (De ? Ee(h) : (ge = h));
								},
							};
							let ge,
								Ie,
								Ae = !1,
								De = !1;
							function Ee(h) {
								const e = h.createTexture();
								h.bindTexture(h.TEXTURE_2D, e);
								try {
									if (
										(h.texImage2D(
											h.TEXTURE_2D,
											0,
											h.RGBA,
											h.RGBA,
											h.UNSIGNED_BYTE,
											Ie
										),
										h.isContextLost())
									)
										return;
									fe.supported = !0;
								} catch {}
								h.deleteTexture(e), (Ae = !0);
							}
							var Fe;
							typeof document < "u" &&
								((Ie = document.createElement("img")),
								(Ie.onload = () => {
									ge && Ee(ge), (ge = null), (De = !0);
								}),
								(Ie.onerror = () => {
									(Ae = !0), (ge = null);
								}),
								(Ie.src =
									"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=")),
								(function (h) {
									let e, i, l, u;
									(h.resetRequestQueue = () => {
										(e = []), (i = 0), (l = 0), (u = {});
									}),
										(h.addThrottleControl = (C) => {
											const P = l++;
											return (u[P] = C), P;
										}),
										(h.removeThrottleControl = (C) => {
											delete u[C], g();
										}),
										(h.getImage = (C, P, E = !0) =>
											new Promise((R, D) => {
												fe.supported &&
													(C.headers || (C.headers = {}),
													(C.headers.accept = "image/webp,*/*")),
													s.e(C, { type: "image" }),
													e.push({
														abortController: P,
														requestParameters: C,
														supportImageRefresh: E,
														state: "queued",
														onError: (N) => {
															D(N);
														},
														onSuccess: (N) => {
															R(N);
														},
													}),
													g();
											}));
									const d = (C) =>
											s._(this, void 0, void 0, function* () {
												C.state = "running";
												const {
														requestParameters: P,
														supportImageRefresh: E,
														onError: R,
														onSuccess: D,
														abortController: N,
													} = C,
													G =
														E === !1 &&
														!s.i(self) &&
														!s.g(P.url) &&
														(!P.headers ||
															Object.keys(P.headers).reduce(
																(ae, ce) => ae && ce === "accept",
																!0
															));
												i++;
												const te = G ? w(P, N) : s.m(P, N);
												try {
													const ae = yield te;
													delete C.abortController,
														(C.state = "completed"),
														ae.data instanceof HTMLImageElement || s.b(ae.data)
															? D(ae)
															: ae.data &&
															  D({
																	data: yield ((Q = ae.data),
																	typeof createImageBitmap == "function"
																		? s.f(Q)
																		: s.h(Q)),
																	cacheControl: ae.cacheControl,
																	expires: ae.expires,
															  });
												} catch (ae) {
													delete C.abortController, R(ae);
												} finally {
													i--, g();
												}
												var Q;
											}),
										g = () => {
											const C = (() => {
												for (const P of Object.keys(u)) if (u[P]()) return !0;
												return !1;
											})()
												? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME
												: s.a.MAX_PARALLEL_IMAGE_REQUESTS;
											for (let P = i; P < C && e.length > 0; P++) {
												const E = e.shift();
												E.abortController.signal.aborted ? P-- : d(E);
											}
										},
										w = (C, P) =>
											new Promise((E, R) => {
												const D = new Image(),
													N = C.url,
													G = C.credentials;
												G && G === "include"
													? (D.crossOrigin = "use-credentials")
													: ((G && G === "same-origin") || !s.d(N)) &&
													  (D.crossOrigin = "anonymous"),
													P.signal.addEventListener("abort", () => {
														(D.src = ""), R(s.c());
													}),
													(D.fetchPriority = "high"),
													(D.onload = () => {
														(D.onerror = D.onload = null), E({ data: D });
													}),
													(D.onerror = () => {
														(D.onerror = D.onload = null),
															P.signal.aborted ||
																R(
																	new Error(
																		"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
																	)
																);
													}),
													(D.src = N);
											});
								})(Fe || (Fe = {})),
								Fe.resetRequestQueue();
							class $e {
								constructor(e) {
									this._transformRequestFn = e ?? null;
								}
								transformRequest(e, i) {
									return (
										(this._transformRequestFn &&
											this._transformRequestFn(e, i)) || { url: e }
									);
								}
								setTransformRequest(e) {
									this._transformRequestFn = e;
								}
							}
							function Je(h) {
								const e = [];
								if (typeof h == "string") e.push({ id: "default", url: h });
								else if (h && h.length > 0) {
									const i = [];
									for (const { id: l, url: u } of h) {
										const d = `${l}${u}`;
										i.indexOf(d) === -1 &&
											(i.push(d), e.push({ id: l, url: u }));
									}
								}
								return e;
							}
							function qe(h, e, i) {
								try {
									const l = new URL(h);
									return (l.pathname += `${e}${i}`), l.toString();
								} catch {
									throw new Error(
										`Invalid sprite URL "${h}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`
									);
								}
							}
							function Ze(h) {
								const { userImage: e } = h;
								return (
									!!(e && e.render && e.render()) &&
									(h.data.replace(new Uint8Array(e.data.buffer)), !0)
								);
							}
							class Qe extends s.E {
								constructor() {
									super(),
										(this.images = {}),
										(this.updatedImages = {}),
										(this.callbackDispatchedThisFrame = {}),
										(this.loaded = !1),
										(this.requestors = []),
										(this.patterns = {}),
										(this.atlasImage = new s.R({ width: 1, height: 1 })),
										(this.dirty = !0);
								}
								isLoaded() {
									return this.loaded;
								}
								setLoaded(e) {
									if (this.loaded !== e && ((this.loaded = e), e)) {
										for (const { ids: i, promiseResolve: l } of this.requestors)
											l(this._getImagesForIds(i));
										this.requestors = [];
									}
								}
								getImage(e) {
									const i = this.images[e];
									if (i && !i.data && i.spriteData) {
										const l = i.spriteData;
										(i.data = new s.R(
											{ width: l.width, height: l.height },
											l.context.getImageData(l.x, l.y, l.width, l.height).data
										)),
											(i.spriteData = null);
									}
									return i;
								}
								addImage(e, i) {
									if (this.images[e])
										throw new Error(
											`Image id ${e} already exist, use updateImage instead`
										);
									this._validate(e, i) && (this.images[e] = i);
								}
								_validate(e, i) {
									let l = !0;
									const u = i.data || i.spriteData;
									return (
										this._validateStretch(i.stretchX, u && u.width) ||
											(this.fire(
												new s.k(
													new Error(`Image "${e}" has invalid "stretchX" value`)
												)
											),
											(l = !1)),
										this._validateStretch(i.stretchY, u && u.height) ||
											(this.fire(
												new s.k(
													new Error(`Image "${e}" has invalid "stretchY" value`)
												)
											),
											(l = !1)),
										this._validateContent(i.content, i) ||
											(this.fire(
												new s.k(
													new Error(`Image "${e}" has invalid "content" value`)
												)
											),
											(l = !1)),
										l
									);
								}
								_validateStretch(e, i) {
									if (!e) return !0;
									let l = 0;
									for (const u of e) {
										if (u[0] < l || u[1] < u[0] || i < u[1]) return !1;
										l = u[1];
									}
									return !0;
								}
								_validateContent(e, i) {
									if (!e) return !0;
									if (e.length !== 4) return !1;
									const l = i.spriteData,
										u = (l && l.width) || i.data.width,
										d = (l && l.height) || i.data.height;
									return !(
										e[0] < 0 ||
										u < e[0] ||
										e[1] < 0 ||
										d < e[1] ||
										e[2] < 0 ||
										u < e[2] ||
										e[3] < 0 ||
										d < e[3] ||
										e[2] < e[0] ||
										e[3] < e[1]
									);
								}
								updateImage(e, i, l = !0) {
									const u = this.getImage(e);
									if (
										l &&
										(u.data.width !== i.data.width ||
											u.data.height !== i.data.height)
									)
										throw new Error(
											`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${i.data.width}x${i.data.height}).`
										);
									(i.version = u.version + 1),
										(this.images[e] = i),
										(this.updatedImages[e] = !0);
								}
								removeImage(e) {
									const i = this.images[e];
									delete this.images[e],
										delete this.patterns[e],
										i.userImage &&
											i.userImage.onRemove &&
											i.userImage.onRemove();
								}
								listImages() {
									return Object.keys(this.images);
								}
								getImages(e) {
									return new Promise((i, l) => {
										let u = !0;
										if (!this.isLoaded())
											for (const d of e) this.images[d] || (u = !1);
										this.isLoaded() || u
											? i(this._getImagesForIds(e))
											: this.requestors.push({ ids: e, promiseResolve: i });
									});
								}
								_getImagesForIds(e) {
									const i = {};
									for (const l of e) {
										let u = this.getImage(l);
										u ||
											(this.fire(new s.l("styleimagemissing", { id: l })),
											(u = this.getImage(l))),
											u
												? (i[l] = {
														data: u.data.clone(),
														pixelRatio: u.pixelRatio,
														sdf: u.sdf,
														version: u.version,
														stretchX: u.stretchX,
														stretchY: u.stretchY,
														content: u.content,
														textFitWidth: u.textFitWidth,
														textFitHeight: u.textFitHeight,
														hasRenderCallback: !!(
															u.userImage && u.userImage.render
														),
												  })
												: s.w(
														`Image "${l}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
												  );
									}
									return i;
								}
								getPixelSize() {
									const { width: e, height: i } = this.atlasImage;
									return { width: e, height: i };
								}
								getPattern(e) {
									const i = this.patterns[e],
										l = this.getImage(e);
									if (!l) return null;
									if (i && i.position.version === l.version) return i.position;
									if (i) i.position.version = l.version;
									else {
										const u = {
												w: l.data.width + 2,
												h: l.data.height + 2,
												x: 0,
												y: 0,
											},
											d = new s.I(u, l);
										this.patterns[e] = { bin: u, position: d };
									}
									return this._updatePatternAtlas(), this.patterns[e].position;
								}
								bind(e) {
									const i = e.gl;
									this.atlasTexture
										? this.dirty &&
										  (this.atlasTexture.update(this.atlasImage),
										  (this.dirty = !1))
										: (this.atlasTexture = new s.T(e, this.atlasImage, i.RGBA)),
										this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
								}
								_updatePatternAtlas() {
									const e = [];
									for (const d in this.patterns) e.push(this.patterns[d].bin);
									const { w: i, h: l } = s.p(e),
										u = this.atlasImage;
									u.resize({ width: i || 1, height: l || 1 });
									for (const d in this.patterns) {
										const { bin: g } = this.patterns[d],
											w = g.x + 1,
											C = g.y + 1,
											P = this.getImage(d).data,
											E = P.width,
											R = P.height;
										s.R.copy(
											P,
											u,
											{ x: 0, y: 0 },
											{ x: w, y: C },
											{ width: E, height: R }
										),
											s.R.copy(
												P,
												u,
												{ x: 0, y: R - 1 },
												{ x: w, y: C - 1 },
												{ width: E, height: 1 }
											),
											s.R.copy(
												P,
												u,
												{ x: 0, y: 0 },
												{ x: w, y: C + R },
												{ width: E, height: 1 }
											),
											s.R.copy(
												P,
												u,
												{ x: E - 1, y: 0 },
												{ x: w - 1, y: C },
												{ width: 1, height: R }
											),
											s.R.copy(
												P,
												u,
												{ x: 0, y: 0 },
												{ x: w + E, y: C },
												{ width: 1, height: R }
											);
									}
									this.dirty = !0;
								}
								beginFrame() {
									this.callbackDispatchedThisFrame = {};
								}
								dispatchRenderCallbacks(e) {
									for (const i of e) {
										if (this.callbackDispatchedThisFrame[i]) continue;
										this.callbackDispatchedThisFrame[i] = !0;
										const l = this.getImage(i);
										l || s.w(`Image with ID: "${i}" was not found`),
											Ze(l) && this.updateImage(i, l);
									}
								}
							}
							const Le = 1e20;
							function et(h, e, i, l, u, d, g, w, C) {
								for (let P = e; P < e + l; P++) nt(h, i * d + P, d, u, g, w, C);
								for (let P = i; P < i + u; P++) nt(h, P * d + e, 1, l, g, w, C);
							}
							function nt(h, e, i, l, u, d, g) {
								(d[0] = 0), (g[0] = -Le), (g[1] = Le), (u[0] = h[e]);
								for (let w = 1, C = 0, P = 0; w < l; w++) {
									u[w] = h[e + w * i];
									const E = w * w;
									do {
										const R = d[C];
										P = (u[w] - u[R] + E - R * R) / (w - R) / 2;
									} while (P <= g[C] && --C > -1);
									C++, (d[C] = w), (g[C] = P), (g[C + 1] = Le);
								}
								for (let w = 0, C = 0; w < l; w++) {
									for (; g[C + 1] < w; ) C++;
									const P = d[C],
										E = w - P;
									h[e + w * i] = u[P] + E * E;
								}
							}
							class Ue {
								constructor(e, i) {
									(this.requestManager = e),
										(this.localIdeographFontFamily = i),
										(this.entries = {});
								}
								setURL(e) {
									this.url = e;
								}
								getGlyphs(e) {
									return s._(this, void 0, void 0, function* () {
										const i = [];
										for (const d in e)
											for (const g of e[d])
												i.push(this._getAndCacheGlyphsPromise(d, g));
										const l = yield Promise.all(i),
											u = {};
										for (const { stack: d, id: g, glyph: w } of l)
											u[d] || (u[d] = {}),
												(u[d][g] = w && {
													id: w.id,
													bitmap: w.bitmap.clone(),
													metrics: w.metrics,
												});
										return u;
									});
								}
								_getAndCacheGlyphsPromise(e, i) {
									return s._(this, void 0, void 0, function* () {
										let l = this.entries[e];
										l ||
											(l = this.entries[e] =
												{ glyphs: {}, requests: {}, ranges: {} });
										let u = l.glyphs[i];
										if (u !== void 0) return { stack: e, id: i, glyph: u };
										if (((u = this._tinySDF(l, e, i)), u))
											return (l.glyphs[i] = u), { stack: e, id: i, glyph: u };
										const d = Math.floor(i / 256);
										if (256 * d > 65535)
											throw new Error("glyphs > 65535 not supported");
										if (l.ranges[d]) return { stack: e, id: i, glyph: u };
										if (!this.url) throw new Error("glyphsUrl is not set");
										if (!l.requests[d]) {
											const w = Ue.loadGlyphRange(
												e,
												d,
												this.url,
												this.requestManager
											);
											l.requests[d] = w;
										}
										const g = yield l.requests[d];
										for (const w in g)
											this._doesCharSupportLocalGlyph(+w) ||
												(l.glyphs[+w] = g[+w]);
										return (
											(l.ranges[d] = !0),
											{ stack: e, id: i, glyph: g[i] || null }
										);
									});
								}
								_doesCharSupportLocalGlyph(e) {
									return (
										!!this.localIdeographFontFamily &&
										(new RegExp(
											"\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}",
											"u"
										).test(String.fromCodePoint(e)) ||
											s.u["CJK Unified Ideographs"](e) ||
											s.u["Hangul Syllables"](e) ||
											s.u.Hiragana(e) ||
											s.u.Katakana(e) ||
											s.u["CJK Symbols and Punctuation"](e) ||
											s.u["Halfwidth and Fullwidth Forms"](e))
									);
								}
								_tinySDF(e, i, l) {
									const u = this.localIdeographFontFamily;
									if (!u || !this._doesCharSupportLocalGlyph(l)) return;
									let d = e.tinySDF;
									if (!d) {
										let w = "400";
										/bold/i.test(i)
											? (w = "900")
											: /medium/i.test(i)
											? (w = "500")
											: /light/i.test(i) && (w = "200"),
											(d = e.tinySDF =
												new Ue.TinySDF({
													fontSize: 48,
													buffer: 6,
													radius: 16,
													cutoff: 0.25,
													fontFamily: u,
													fontWeight: w,
												}));
									}
									const g = d.draw(String.fromCharCode(l));
									return {
										id: l,
										bitmap: new s.q(
											{ width: g.width || 60, height: g.height || 60 },
											g.data
										),
										metrics: {
											width: g.glyphWidth / 2 || 24,
											height: g.glyphHeight / 2 || 24,
											left: g.glyphLeft / 2 + 0.5 || 0,
											top: g.glyphTop / 2 - 27.5 || -8,
											advance: g.glyphAdvance / 2 || 24,
											isDoubleResolution: !0,
										},
									};
								}
							}
							(Ue.loadGlyphRange = function (h, e, i, l) {
								return s._(this, void 0, void 0, function* () {
									const u = 256 * e,
										d = u + 255,
										g = l.transformRequest(
											i
												.replace("{fontstack}", h)
												.replace("{range}", `${u}-${d}`),
											"Glyphs"
										),
										w = yield s.n(g, new AbortController());
									if (!w || !w.data)
										throw new Error(
											`Could not load glyph range. range: ${e}, ${u}-${d}`
										);
									const C = {};
									for (const P of s.o(w.data)) C[P.id] = P;
									return C;
								});
							}),
								(Ue.TinySDF = class {
									constructor({
										fontSize: h = 24,
										buffer: e = 3,
										radius: i = 8,
										cutoff: l = 0.25,
										fontFamily: u = "sans-serif",
										fontWeight: d = "normal",
										fontStyle: g = "normal",
										lang: w = null,
									} = {}) {
										(this.buffer = e),
											(this.cutoff = l),
											(this.radius = i),
											(this.lang = w);
										const C = (this.size = h + 4 * e),
											P = this._createCanvas(C),
											E = (this.ctx = P.getContext("2d", {
												willReadFrequently: !0,
											}));
										(E.font = `${g} ${d} ${h}px ${u}`),
											(E.textBaseline = "alphabetic"),
											(E.textAlign = "left"),
											(E.fillStyle = "black"),
											(this.gridOuter = new Float64Array(C * C)),
											(this.gridInner = new Float64Array(C * C)),
											(this.f = new Float64Array(C)),
											(this.z = new Float64Array(C + 1)),
											(this.v = new Uint16Array(C));
									}
									_createCanvas(h) {
										const e = document.createElement("canvas");
										return (e.width = e.height = h), e;
									}
									draw(h) {
										const {
												width: e,
												actualBoundingBoxAscent: i,
												actualBoundingBoxDescent: l,
												actualBoundingBoxLeft: u,
												actualBoundingBoxRight: d,
											} = this.ctx.measureText(h),
											g = Math.ceil(i),
											w = Math.max(
												0,
												Math.min(this.size - this.buffer, Math.ceil(d - u))
											),
											C = Math.min(this.size - this.buffer, g + Math.ceil(l)),
											P = w + 2 * this.buffer,
											E = C + 2 * this.buffer,
											R = Math.max(P * E, 0),
											D = new Uint8ClampedArray(R),
											N = {
												data: D,
												width: P,
												height: E,
												glyphWidth: w,
												glyphHeight: C,
												glyphTop: g,
												glyphLeft: 0,
												glyphAdvance: e,
											};
										if (w === 0 || C === 0) return N;
										const {
											ctx: G,
											buffer: te,
											gridInner: Q,
											gridOuter: ae,
										} = this;
										this.lang && (G.lang = this.lang),
											G.clearRect(te, te, w, C),
											G.fillText(h, te, te + g);
										const ce = G.getImageData(te, te, w, C);
										ae.fill(Le, 0, R), Q.fill(0, 0, R);
										for (let ve = 0; ve < C; ve++)
											for (let me = 0; me < w; me++) {
												const be = ce.data[4 * (ve * w + me) + 3] / 255;
												if (be === 0) continue;
												const Pe = (ve + te) * P + me + te;
												if (be === 1) (ae[Pe] = 0), (Q[Pe] = Le);
												else {
													const _e = 0.5 - be;
													(ae[Pe] = _e > 0 ? _e * _e : 0),
														(Q[Pe] = _e < 0 ? _e * _e : 0);
												}
											}
										et(ae, 0, 0, P, E, P, this.f, this.v, this.z),
											et(Q, te, te, w, C, P, this.f, this.v, this.z);
										for (let ve = 0; ve < R; ve++) {
											const me = Math.sqrt(ae[ve]) - Math.sqrt(Q[ve]);
											D[ve] = Math.round(
												255 - 255 * (me / this.radius + this.cutoff)
											);
										}
										return N;
									}
								});
							class ke {
								constructor() {
									this.specification = s.v.light.position;
								}
								possiblyEvaluate(e, i) {
									return s.B(e.expression.evaluate(i));
								}
								interpolate(e, i, l) {
									return {
										x: s.C.number(e.x, i.x, l),
										y: s.C.number(e.y, i.y, l),
										z: s.C.number(e.z, i.z, l),
									};
								}
							}
							let vt;
							class ee extends s.E {
								constructor(e) {
									super(),
										(vt =
											vt ||
											new s.r({
												anchor: new s.D(s.v.light.anchor),
												position: new ke(),
												color: new s.D(s.v.light.color),
												intensity: new s.D(s.v.light.intensity),
											})),
										(this._transitionable = new s.t(vt)),
										this.setLight(e),
										(this._transitioning =
											this._transitionable.untransitioned());
								}
								getLight() {
									return this._transitionable.serialize();
								}
								setLight(e, i = {}) {
									if (!this._validate(s.x, e, i))
										for (const l in e) {
											const u = e[l];
											l.endsWith("-transition")
												? this._transitionable.setTransition(l.slice(0, -11), u)
												: this._transitionable.setValue(l, u);
										}
								}
								updateTransitions(e) {
									this._transitioning = this._transitionable.transitioned(
										e,
										this._transitioning
									);
								}
								hasTransition() {
									return this._transitioning.hasTransition();
								}
								recalculate(e) {
									this.properties = this._transitioning.possiblyEvaluate(e);
								}
								_validate(e, i, l) {
									return (
										(!l || l.validate !== !1) &&
										s.y(
											this,
											e.call(s.z, {
												value: i,
												style: { glyphs: !0, sprite: !0 },
												styleSpec: s.v,
											})
										)
									);
								}
							}
							const re = new s.r({
								"sky-color": new s.D(s.v.sky["sky-color"]),
								"horizon-color": new s.D(s.v.sky["horizon-color"]),
								"fog-color": new s.D(s.v.sky["fog-color"]),
								"fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]),
								"horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]),
								"sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]),
								"atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"]),
							});
							class he extends s.E {
								constructor(e) {
									super(),
										(this._transitionable = new s.t(re)),
										this.setSky(e),
										(this._transitioning =
											this._transitionable.untransitioned()),
										this.recalculate(new s.F(0));
								}
								setSky(e, i = {}) {
									if (!this._validate(s.G, e, i)) {
										e ||
											(e = {
												"sky-color": "transparent",
												"horizon-color": "transparent",
												"fog-color": "transparent",
												"fog-ground-blend": 1,
												"atmosphere-blend": 0,
											});
										for (const l in e) {
											const u = e[l];
											l.endsWith("-transition")
												? this._transitionable.setTransition(l.slice(0, -11), u)
												: this._transitionable.setValue(l, u);
										}
									}
								}
								getSky() {
									return this._transitionable.serialize();
								}
								updateTransitions(e) {
									this._transitioning = this._transitionable.transitioned(
										e,
										this._transitioning
									);
								}
								hasTransition() {
									return this._transitioning.hasTransition();
								}
								recalculate(e) {
									this.properties = this._transitioning.possiblyEvaluate(e);
								}
								_validate(e, i, l = {}) {
									return (
										(l == null ? void 0 : l.validate) !== !1 &&
										s.y(
											this,
											e.call(
												s.z,
												s.e({
													value: i,
													style: { glyphs: !0, sprite: !0 },
													styleSpec: s.v,
												})
											)
										)
									);
								}
								calculateFogBlendOpacity(e) {
									return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
								}
							}
							class oe {
								constructor(e, i) {
									(this.width = e),
										(this.height = i),
										(this.nextRow = 0),
										(this.data = new Uint8Array(this.width * this.height)),
										(this.dashEntry = {});
								}
								getDash(e, i) {
									const l = e.join(",") + String(i);
									return (
										this.dashEntry[l] ||
											(this.dashEntry[l] = this.addDash(e, i)),
										this.dashEntry[l]
									);
								}
								getDashRanges(e, i, l) {
									const u = [];
									let d = e.length % 2 == 1 ? -e[e.length - 1] * l : 0,
										g = e[0] * l,
										w = !0;
									u.push({
										left: d,
										right: g,
										isDash: w,
										zeroLength: e[0] === 0,
									});
									let C = e[0];
									for (let P = 1; P < e.length; P++) {
										w = !w;
										const E = e[P];
										(d = C * l),
											(C += E),
											(g = C * l),
											u.push({
												left: d,
												right: g,
												isDash: w,
												zeroLength: E === 0,
											});
									}
									return u;
								}
								addRoundDash(e, i, l) {
									const u = i / 2;
									for (let d = -l; d <= l; d++) {
										const g = this.width * (this.nextRow + l + d);
										let w = 0,
											C = e[w];
										for (let P = 0; P < this.width; P++) {
											P / C.right > 1 && (C = e[++w]);
											const E = Math.abs(P - C.left),
												R = Math.abs(P - C.right),
												D = Math.min(E, R);
											let N;
											const G = (d / l) * (u + 1);
											if (C.isDash) {
												const te = u - Math.abs(G);
												N = Math.sqrt(D * D + te * te);
											} else N = u - Math.sqrt(D * D + G * G);
											this.data[g + P] = Math.max(0, Math.min(255, N + 128));
										}
									}
								}
								addRegularDash(e) {
									for (let w = e.length - 1; w >= 0; --w) {
										const C = e[w],
											P = e[w + 1];
										C.zeroLength
											? e.splice(w, 1)
											: P &&
											  P.isDash === C.isDash &&
											  ((P.left = C.left), e.splice(w, 1));
									}
									const i = e[0],
										l = e[e.length - 1];
									i.isDash === l.isDash &&
										((i.left = l.left - this.width),
										(l.right = i.right + this.width));
									const u = this.width * this.nextRow;
									let d = 0,
										g = e[d];
									for (let w = 0; w < this.width; w++) {
										w / g.right > 1 && (g = e[++d]);
										const C = Math.abs(w - g.left),
											P = Math.abs(w - g.right),
											E = Math.min(C, P);
										this.data[u + w] = Math.max(
											0,
											Math.min(255, (g.isDash ? E : -E) + 128)
										);
									}
								}
								addDash(e, i) {
									const l = i ? 7 : 0,
										u = 2 * l + 1;
									if (this.nextRow + u > this.height)
										return s.w("LineAtlas out of space"), null;
									let d = 0;
									for (let w = 0; w < e.length; w++) d += e[w];
									if (d !== 0) {
										const w = this.width / d,
											C = this.getDashRanges(e, this.width, w);
										i ? this.addRoundDash(C, w, l) : this.addRegularDash(C);
									}
									const g = {
										y: (this.nextRow + l + 0.5) / this.height,
										height: (2 * l) / this.height,
										width: d,
									};
									return (this.nextRow += u), (this.dirty = !0), g;
								}
								bind(e) {
									const i = e.gl;
									this.texture
										? (i.bindTexture(i.TEXTURE_2D, this.texture),
										  this.dirty &&
												((this.dirty = !1),
												i.texSubImage2D(
													i.TEXTURE_2D,
													0,
													0,
													0,
													this.width,
													this.height,
													i.ALPHA,
													i.UNSIGNED_BYTE,
													this.data
												)))
										: ((this.texture = i.createTexture()),
										  i.bindTexture(i.TEXTURE_2D, this.texture),
										  i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT),
										  i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT),
										  i.texParameteri(
												i.TEXTURE_2D,
												i.TEXTURE_MIN_FILTER,
												i.LINEAR
										  ),
										  i.texParameteri(
												i.TEXTURE_2D,
												i.TEXTURE_MAG_FILTER,
												i.LINEAR
										  ),
										  i.texImage2D(
												i.TEXTURE_2D,
												0,
												i.ALPHA,
												this.width,
												this.height,
												0,
												i.ALPHA,
												i.UNSIGNED_BYTE,
												this.data
										  ));
								}
							}
							const ze = "maplibre_preloaded_worker_pool";
							class je {
								constructor() {
									this.active = {};
								}
								acquire(e) {
									if (!this.workers)
										for (
											this.workers = [];
											this.workers.length < je.workerCount;

										)
											this.workers.push(new Worker(s.a.WORKER_URL));
									return (this.active[e] = !0), this.workers.slice();
								}
								release(e) {
									delete this.active[e],
										this.numActive() === 0 &&
											(this.workers.forEach((i) => {
												i.terminate();
											}),
											(this.workers = null));
								}
								isPreloaded() {
									return !!this.active[ze];
								}
								numActive() {
									return Object.keys(this.active).length;
								}
							}
							const pt = Math.floor(ne.hardwareConcurrency / 2);
							let it, ct;
							function It() {
								return it || (it = new je()), it;
							}
							je.workerCount = s.H(globalThis)
								? Math.max(Math.min(pt, 3), 1)
								: 1;
							class Dt {
								constructor(e, i) {
									(this.workerPool = e),
										(this.actors = []),
										(this.currentActor = 0),
										(this.id = i);
									const l = this.workerPool.acquire(i);
									for (let u = 0; u < l.length; u++) {
										const d = new s.J(l[u], i);
										(d.name = `Worker ${u}`), this.actors.push(d);
									}
									if (!this.actors.length) throw new Error("No actors found");
								}
								broadcast(e, i) {
									const l = [];
									for (const u of this.actors)
										l.push(u.sendAsync({ type: e, data: i }));
									return Promise.all(l);
								}
								getActor() {
									return (
										(this.currentActor =
											(this.currentActor + 1) % this.actors.length),
										this.actors[this.currentActor]
									);
								}
								remove(e = !0) {
									this.actors.forEach((i) => {
										i.remove();
									}),
										(this.actors = []),
										e && this.workerPool.release(this.id);
								}
								registerMessageHandler(e, i) {
									for (const l of this.actors) l.registerMessageHandler(e, i);
								}
							}
							function at() {
								return (
									ct ||
										((ct = new Dt(It(), s.K)),
										ct.registerMessageHandler("GR", (h, e, i) => s.m(e, i))),
									ct
								);
							}
							function dt(h, e) {
								const i = s.L();
								return (
									s.M(i, i, [1, 1, 0]),
									s.N(i, i, [0.5 * h.width, 0.5 * h.height, 1]),
									h.calculatePosMatrix
										? s.O(i, i, h.calculatePosMatrix(e.toUnwrapped()))
										: i
								);
							}
							function yt(h, e, i, l, u, d, g) {
								var w;
								const C = (function (D, N, G) {
										if (D)
											for (const te of D) {
												const Q = N[te];
												if (Q && Q.source === G && Q.type === "fill-extrusion")
													return !0;
											}
										else
											for (const te in N) {
												const Q = N[te];
												if (Q.source === G && Q.type === "fill-extrusion")
													return !0;
											}
										return !1;
									})(
										(w = u == null ? void 0 : u.layers) !== null && w !== void 0
											? w
											: null,
										e,
										h.id
									),
									P = d.maxPitchScaleFactor(),
									E = h.tilesIn(l, P, C);
								E.sort(xt);
								const R = [];
								for (const D of E)
									R.push({
										wrappedTileID: D.tileID.wrapped().key,
										queryResults: D.tile.queryRenderedFeatures(
											e,
											i,
											h._state,
											D.queryGeometry,
											D.cameraQueryGeometry,
											D.scale,
											u,
											d,
											P,
											dt(h.transform, D.tileID),
											g ? (N, G) => g(D.tileID, N, G) : void 0
										),
									});
								return (function (D, N) {
									for (const G in D) for (const te of D[G]) St(te, N);
									return D;
								})(
									(function (D) {
										const N = {},
											G = {};
										for (const te of D) {
											const Q = te.queryResults,
												ae = te.wrappedTileID,
												ce = (G[ae] = G[ae] || {});
											for (const ve in Q) {
												const me = Q[ve],
													be = (ce[ve] = ce[ve] || {}),
													Pe = (N[ve] = N[ve] || []);
												for (const _e of me)
													be[_e.featureIndex] ||
														((be[_e.featureIndex] = !0), Pe.push(_e));
											}
										}
										return N;
									})(R),
									h
								);
							}
							function xt(h, e) {
								const i = h.tileID,
									l = e.tileID;
								return (
									i.overscaledZ - l.overscaledZ ||
									i.canonical.y - l.canonical.y ||
									i.wrap - l.wrap ||
									i.canonical.x - l.canonical.x
								);
							}
							function St(h, e) {
								const i = h.feature,
									l = e.getFeatureState(i.layer["source-layer"], i.id);
								(i.source = i.layer.source),
									i.layer["source-layer"] &&
										(i.sourceLayer = i.layer["source-layer"]),
									(i.state = l);
							}
							function wt(h, e, i) {
								return s._(this, void 0, void 0, function* () {
									let l = h;
									if (
										(h.url
											? (l = (yield s.j(e.transformRequest(h.url, "Source"), i))
													.data)
											: yield ne.frameAsync(i),
										!l)
									)
										return null;
									const u = s.Q(s.e(l, h), [
										"tiles",
										"minzoom",
										"maxzoom",
										"attribution",
										"bounds",
										"scheme",
										"tileSize",
										"encoding",
									]);
									return (
										"vector_layers" in l &&
											l.vector_layers &&
											(u.vectorLayerIds = l.vector_layers.map((d) => d.id)),
										u
									);
								});
							}
							class _t {
								constructor(e, i) {
									e &&
										(i
											? this.setSouthWest(e).setNorthEast(i)
											: Array.isArray(e) &&
											  (e.length === 4
													? this.setSouthWest([e[0], e[1]]).setNorthEast([
															e[2],
															e[3],
													  ])
													: this.setSouthWest(e[0]).setNorthEast(e[1])));
								}
								setNorthEast(e) {
									return (
										(this._ne =
											e instanceof s.S
												? new s.S(e.lng, e.lat)
												: s.S.convert(e)),
										this
									);
								}
								setSouthWest(e) {
									return (
										(this._sw =
											e instanceof s.S
												? new s.S(e.lng, e.lat)
												: s.S.convert(e)),
										this
									);
								}
								extend(e) {
									const i = this._sw,
										l = this._ne;
									let u, d;
									if (e instanceof s.S) (u = e), (d = e);
									else {
										if (!(e instanceof _t))
											return Array.isArray(e)
												? e.length === 4 || e.every(Array.isArray)
													? this.extend(_t.convert(e))
													: this.extend(s.S.convert(e))
												: e && ("lng" in e || "lon" in e) && "lat" in e
												? this.extend(s.S.convert(e))
												: this;
										if (((u = e._sw), (d = e._ne), !u || !d)) return this;
									}
									return (
										i || l
											? ((i.lng = Math.min(u.lng, i.lng)),
											  (i.lat = Math.min(u.lat, i.lat)),
											  (l.lng = Math.max(d.lng, l.lng)),
											  (l.lat = Math.max(d.lat, l.lat)))
											: ((this._sw = new s.S(u.lng, u.lat)),
											  (this._ne = new s.S(d.lng, d.lat))),
										this
									);
								}
								getCenter() {
									return new s.S(
										(this._sw.lng + this._ne.lng) / 2,
										(this._sw.lat + this._ne.lat) / 2
									);
								}
								getSouthWest() {
									return this._sw;
								}
								getNorthEast() {
									return this._ne;
								}
								getNorthWest() {
									return new s.S(this.getWest(), this.getNorth());
								}
								getSouthEast() {
									return new s.S(this.getEast(), this.getSouth());
								}
								getWest() {
									return this._sw.lng;
								}
								getSouth() {
									return this._sw.lat;
								}
								getEast() {
									return this._ne.lng;
								}
								getNorth() {
									return this._ne.lat;
								}
								toArray() {
									return [this._sw.toArray(), this._ne.toArray()];
								}
								toString() {
									return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
								}
								isEmpty() {
									return !(this._sw && this._ne);
								}
								contains(e) {
									const { lng: i, lat: l } = s.S.convert(e);
									let u = this._sw.lng <= i && i <= this._ne.lng;
									return (
										this._sw.lng > this._ne.lng &&
											(u = this._sw.lng >= i && i >= this._ne.lng),
										this._sw.lat <= l && l <= this._ne.lat && u
									);
								}
								static convert(e) {
									return e instanceof _t ? e : e && new _t(e);
								}
								static fromLngLat(e, i = 0) {
									const l = (360 * i) / 40075017,
										u = l / Math.cos((Math.PI / 180) * e.lat);
									return new _t(
										new s.S(e.lng - u, e.lat - l),
										new s.S(e.lng + u, e.lat + l)
									);
								}
								adjustAntiMeridian() {
									const e = new s.S(this._sw.lng, this._sw.lat),
										i = new s.S(this._ne.lng, this._ne.lat);
									return new _t(
										e,
										e.lng > i.lng ? new s.S(i.lng + 360, i.lat) : i
									);
								}
							}
							class Lt {
								constructor(e, i, l) {
									(this.bounds = _t.convert(this.validateBounds(e))),
										(this.minzoom = i || 0),
										(this.maxzoom = l || 24);
								}
								validateBounds(e) {
									return Array.isArray(e) && e.length === 4
										? [
												Math.max(-180, e[0]),
												Math.max(-90, e[1]),
												Math.min(180, e[2]),
												Math.min(90, e[3]),
										  ]
										: [-180, -90, 180, 90];
								}
								contains(e) {
									const i = Math.pow(2, e.z),
										l = Math.floor(s.V(this.bounds.getWest()) * i),
										u = Math.floor(s.U(this.bounds.getNorth()) * i),
										d = Math.ceil(s.V(this.bounds.getEast()) * i),
										g = Math.ceil(s.U(this.bounds.getSouth()) * i);
									return e.x >= l && e.x < d && e.y >= u && e.y < g;
								}
							}
							class Rt extends s.E {
								constructor(e, i, l, u) {
									if (
										(super(),
										(this.id = e),
										(this.dispatcher = l),
										(this.type = "vector"),
										(this.minzoom = 0),
										(this.maxzoom = 22),
										(this.scheme = "xyz"),
										(this.tileSize = 512),
										(this.reparseOverscaled = !0),
										(this.isTileClipped = !0),
										(this._loaded = !1),
										s.e(
											this,
											s.Q(i, ["url", "scheme", "tileSize", "promoteId"])
										),
										(this._options = s.e({ type: "vector" }, i)),
										(this._collectResourceTiming = i.collectResourceTiming),
										this.tileSize !== 512)
									)
										throw new Error(
											"vector tile sources must have a tileSize of 512"
										);
									this.setEventedParent(u);
								}
								load() {
									return s._(this, void 0, void 0, function* () {
										(this._loaded = !1),
											this.fire(new s.l("dataloading", { dataType: "source" })),
											(this._tileJSONRequest = new AbortController());
										try {
											const e = yield wt(
												this._options,
												this.map._requestManager,
												this._tileJSONRequest
											);
											(this._tileJSONRequest = null),
												(this._loaded = !0),
												this.map.style.sourceCaches[this.id].clearTiles(),
												e &&
													(s.e(this, e),
													e.bounds &&
														(this.tileBounds = new Lt(
															e.bounds,
															this.minzoom,
															this.maxzoom
														)),
													this.fire(
														new s.l("data", {
															dataType: "source",
															sourceDataType: "metadata",
														})
													),
													this.fire(
														new s.l("data", {
															dataType: "source",
															sourceDataType: "content",
														})
													));
										} catch (e) {
											(this._tileJSONRequest = null), this.fire(new s.k(e));
										}
									});
								}
								loaded() {
									return this._loaded;
								}
								hasTile(e) {
									return (
										!this.tileBounds || this.tileBounds.contains(e.canonical)
									);
								}
								onAdd(e) {
									(this.map = e), this.load();
								}
								setSourceProperty(e) {
									this._tileJSONRequest && this._tileJSONRequest.abort(),
										e(),
										this.load();
								}
								setTiles(e) {
									return (
										this.setSourceProperty(() => {
											this._options.tiles = e;
										}),
										this
									);
								}
								setUrl(e) {
									return (
										this.setSourceProperty(() => {
											(this.url = e), (this._options.url = e);
										}),
										this
									);
								}
								onRemove() {
									this._tileJSONRequest &&
										(this._tileJSONRequest.abort(),
										(this._tileJSONRequest = null));
								}
								serialize() {
									return s.e({}, this._options);
								}
								loadTile(e) {
									return s._(this, void 0, void 0, function* () {
										const i = e.tileID.canonical.url(
												this.tiles,
												this.map.getPixelRatio(),
												this.scheme
											),
											l = {
												request: this.map._requestManager.transformRequest(
													i,
													"Tile"
												),
												uid: e.uid,
												tileID: e.tileID,
												zoom: e.tileID.overscaledZ,
												tileSize: this.tileSize * e.tileID.overscaleFactor(),
												type: this.type,
												source: this.id,
												pixelRatio: this.map.getPixelRatio(),
												showCollisionBoxes: this.map.showCollisionBoxes,
												promoteId: this.promoteId,
												subdivisionGranularity:
													this.map.style.projection.subdivisionGranularity,
												globalState: this.map.getGlobalState(),
											};
										l.request.collectResourceTiming =
											this._collectResourceTiming;
										let u = "RT";
										if (e.actor && e.state !== "expired") {
											if (e.state === "loading")
												return new Promise((d, g) => {
													e.reloadPromise = { resolve: d, reject: g };
												});
										} else (e.actor = this.dispatcher.getActor()), (u = "LT");
										e.abortController = new AbortController();
										try {
											const d = yield e.actor.sendAsync(
												{ type: u, data: l },
												e.abortController
											);
											if ((delete e.abortController, e.aborted)) return;
											this._afterTileLoadWorkerResponse(e, d);
										} catch (d) {
											if ((delete e.abortController, e.aborted)) return;
											if (d && d.status !== 404) throw d;
											this._afterTileLoadWorkerResponse(e, null);
										}
									});
								}
								_afterTileLoadWorkerResponse(e, i) {
									if (
										(i &&
											i.resourceTiming &&
											(e.resourceTiming = i.resourceTiming),
										i && this.map._refreshExpiredTiles && e.setExpiryData(i),
										e.loadVectorData(i, this.map.painter),
										e.reloadPromise)
									) {
										const l = e.reloadPromise;
										(e.reloadPromise = null),
											this.loadTile(e).then(l.resolve).catch(l.reject);
									}
								}
								abortTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.abortController &&
											(e.abortController.abort(), delete e.abortController),
											e.actor &&
												(yield e.actor.sendAsync({
													type: "AT",
													data: {
														uid: e.uid,
														type: this.type,
														source: this.id,
													},
												}));
									});
								}
								unloadTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.unloadVectorData(),
											e.actor &&
												(yield e.actor.sendAsync({
													type: "RMT",
													data: {
														uid: e.uid,
														type: this.type,
														source: this.id,
													},
												}));
									});
								}
								hasTransition() {
									return !1;
								}
							}
							class $t extends s.E {
								constructor(e, i, l, u) {
									super(),
										(this.id = e),
										(this.dispatcher = l),
										this.setEventedParent(u),
										(this.type = "raster"),
										(this.minzoom = 0),
										(this.maxzoom = 22),
										(this.roundZoom = !0),
										(this.scheme = "xyz"),
										(this.tileSize = 512),
										(this._loaded = !1),
										(this._options = s.e({ type: "raster" }, i)),
										s.e(this, s.Q(i, ["url", "scheme", "tileSize"]));
								}
								load() {
									return s._(this, arguments, void 0, function* (e = !1) {
										(this._loaded = !1),
											this.fire(new s.l("dataloading", { dataType: "source" })),
											(this._tileJSONRequest = new AbortController());
										try {
											const i = yield wt(
												this._options,
												this.map._requestManager,
												this._tileJSONRequest
											);
											(this._tileJSONRequest = null),
												(this._loaded = !0),
												i &&
													(s.e(this, i),
													i.bounds &&
														(this.tileBounds = new Lt(
															i.bounds,
															this.minzoom,
															this.maxzoom
														)),
													this.fire(
														new s.l("data", {
															dataType: "source",
															sourceDataType: "metadata",
														})
													),
													this.fire(
														new s.l("data", {
															dataType: "source",
															sourceDataType: "content",
															sourceDataChanged: e,
														})
													));
										} catch (i) {
											(this._tileJSONRequest = null), this.fire(new s.k(i));
										}
									});
								}
								loaded() {
									return this._loaded;
								}
								onAdd(e) {
									(this.map = e), this.load();
								}
								onRemove() {
									this._tileJSONRequest &&
										(this._tileJSONRequest.abort(),
										(this._tileJSONRequest = null));
								}
								setSourceProperty(e) {
									this._tileJSONRequest &&
										(this._tileJSONRequest.abort(),
										(this._tileJSONRequest = null)),
										e(),
										this.load(!0);
								}
								setTiles(e) {
									return (
										this.setSourceProperty(() => {
											this._options.tiles = e;
										}),
										this
									);
								}
								setUrl(e) {
									return (
										this.setSourceProperty(() => {
											(this.url = e), (this._options.url = e);
										}),
										this
									);
								}
								serialize() {
									return s.e({}, this._options);
								}
								hasTile(e) {
									return (
										!this.tileBounds || this.tileBounds.contains(e.canonical)
									);
								}
								loadTile(e) {
									return s._(this, void 0, void 0, function* () {
										const i = e.tileID.canonical.url(
											this.tiles,
											this.map.getPixelRatio(),
											this.scheme
										);
										e.abortController = new AbortController();
										try {
											const l = yield Fe.getImage(
												this.map._requestManager.transformRequest(i, "Tile"),
												e.abortController,
												this.map._refreshExpiredTiles
											);
											if ((delete e.abortController, e.aborted))
												return void (e.state = "unloaded");
											if (l && l.data) {
												this.map._refreshExpiredTiles &&
													(l.cacheControl || l.expires) &&
													e.setExpiryData({
														cacheControl: l.cacheControl,
														expires: l.expires,
													});
												const u = this.map.painter.context,
													d = u.gl,
													g = l.data;
												(e.texture = this.map.painter.getTileTexture(g.width)),
													e.texture
														? e.texture.update(g, { useMipmap: !0 })
														: ((e.texture = new s.T(u, g, d.RGBA, {
																useMipmap: !0,
														  })),
														  e.texture.bind(
																d.LINEAR,
																d.CLAMP_TO_EDGE,
																d.LINEAR_MIPMAP_NEAREST
														  )),
													(e.state = "loaded");
											}
										} catch (l) {
											if ((delete e.abortController, e.aborted))
												e.state = "unloaded";
											else if (l) throw ((e.state = "errored"), l);
										}
									});
								}
								abortTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.abortController &&
											(e.abortController.abort(), delete e.abortController);
									});
								}
								unloadTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.texture && this.map.painter.saveTileTexture(e.texture);
									});
								}
								hasTransition() {
									return !1;
								}
							}
							class tr extends $t {
								constructor(e, i, l, u) {
									super(e, i, l, u),
										(this.type = "raster-dem"),
										(this.maxzoom = 22),
										(this._options = s.e({ type: "raster-dem" }, i)),
										(this.encoding = i.encoding || "mapbox"),
										(this.redFactor = i.redFactor),
										(this.greenFactor = i.greenFactor),
										(this.blueFactor = i.blueFactor),
										(this.baseShift = i.baseShift);
								}
								loadTile(e) {
									return s._(this, void 0, void 0, function* () {
										const i = e.tileID.canonical.url(
												this.tiles,
												this.map.getPixelRatio(),
												this.scheme
											),
											l = this.map._requestManager.transformRequest(i, "Tile");
										(e.neighboringTiles = this._getNeighboringTiles(e.tileID)),
											(e.abortController = new AbortController());
										try {
											const u = yield Fe.getImage(
												l,
												e.abortController,
												this.map._refreshExpiredTiles
											);
											if ((delete e.abortController, e.aborted))
												return void (e.state = "unloaded");
											if (u && u.data) {
												const d = u.data;
												this.map._refreshExpiredTiles &&
													(u.cacheControl || u.expires) &&
													e.setExpiryData({
														cacheControl: u.cacheControl,
														expires: u.expires,
													});
												const g =
														s.b(d) && s.W() ? d : yield this.readImageNow(d),
													w = {
														type: this.type,
														uid: e.uid,
														source: this.id,
														rawImageData: g,
														encoding: this.encoding,
														redFactor: this.redFactor,
														greenFactor: this.greenFactor,
														blueFactor: this.blueFactor,
														baseShift: this.baseShift,
													};
												if (!e.actor || e.state === "expired") {
													e.actor = this.dispatcher.getActor();
													const C = yield e.actor.sendAsync({
														type: "LDT",
														data: w,
													});
													(e.dem = C),
														(e.needsHillshadePrepare = !0),
														(e.needsTerrainPrepare = !0),
														(e.state = "loaded");
												}
											}
										} catch (u) {
											if ((delete e.abortController, e.aborted))
												e.state = "unloaded";
											else if (u) throw ((e.state = "errored"), u);
										}
									});
								}
								readImageNow(e) {
									return s._(this, void 0, void 0, function* () {
										if (typeof VideoFrame < "u" && s.X()) {
											const i = e.width + 2,
												l = e.height + 2;
											try {
												return new s.R(
													{ width: i, height: l },
													yield s.Y(e, -1, -1, i, l)
												);
											} catch {}
										}
										return ne.getImageData(e, 1);
									});
								}
								_getNeighboringTiles(e) {
									const i = e.canonical,
										l = Math.pow(2, i.z),
										u = (i.x - 1 + l) % l,
										d = i.x === 0 ? e.wrap - 1 : e.wrap,
										g = (i.x + 1 + l) % l,
										w = i.x + 1 === l ? e.wrap + 1 : e.wrap,
										C = {};
									return (
										(C[new s.Z(e.overscaledZ, d, i.z, u, i.y).key] = {
											backfilled: !1,
										}),
										(C[new s.Z(e.overscaledZ, w, i.z, g, i.y).key] = {
											backfilled: !1,
										}),
										i.y > 0 &&
											((C[new s.Z(e.overscaledZ, d, i.z, u, i.y - 1).key] = {
												backfilled: !1,
											}),
											(C[
												new s.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key
											] = { backfilled: !1 }),
											(C[new s.Z(e.overscaledZ, w, i.z, g, i.y - 1).key] = {
												backfilled: !1,
											})),
										i.y + 1 < l &&
											((C[new s.Z(e.overscaledZ, d, i.z, u, i.y + 1).key] = {
												backfilled: !1,
											}),
											(C[
												new s.Z(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key
											] = { backfilled: !1 }),
											(C[new s.Z(e.overscaledZ, w, i.z, g, i.y + 1).key] = {
												backfilled: !1,
											})),
										C
									);
								}
								unloadTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.demTexture &&
											this.map.painter.saveTileTexture(e.demTexture),
											e.fbo && (e.fbo.destroy(), delete e.fbo),
											e.dem && delete e.dem,
											delete e.neighboringTiles,
											(e.state = "unloaded"),
											e.actor &&
												(yield e.actor.sendAsync({
													type: "RDT",
													data: {
														type: this.type,
														uid: e.uid,
														source: this.id,
													},
												}));
									});
								}
							}
							class Qt extends s.E {
								constructor(e, i, l, u) {
									super(),
										(this.id = e),
										(this.type = "geojson"),
										(this.minzoom = 0),
										(this.maxzoom = 18),
										(this.tileSize = 512),
										(this.isTileClipped = !0),
										(this.reparseOverscaled = !0),
										(this._removed = !1),
										(this._isUpdatingWorker = !1),
										(this._pendingWorkerUpdate = { data: i.data }),
										(this.actor = l.getActor()),
										this.setEventedParent(u),
										(this._data = i.data),
										(this._options = s.e({}, i)),
										(this._collectResourceTiming = i.collectResourceTiming),
										i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom),
										i.type && (this.type = i.type),
										i.attribution && (this.attribution = i.attribution),
										(this.promoteId = i.promoteId),
										i.clusterMaxZoom !== void 0 &&
											this.maxzoom <= i.clusterMaxZoom &&
											s.w(
												`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`
											),
										(this.workerOptions = s.e(
											{
												source: this.id,
												cluster: i.cluster || !1,
												geojsonVtOptions: {
													buffer: this._pixelsToTileUnits(
														i.buffer !== void 0 ? i.buffer : 128
													),
													tolerance: this._pixelsToTileUnits(
														i.tolerance !== void 0 ? i.tolerance : 0.375
													),
													extent: s.$,
													maxZoom: this.maxzoom,
													lineMetrics: i.lineMetrics || !1,
													generateId: i.generateId || !1,
												},
												superclusterOptions: {
													maxZoom: this._getClusterMaxZoom(i.clusterMaxZoom),
													minPoints: Math.max(2, i.clusterMinPoints || 2),
													extent: s.$,
													radius: this._pixelsToTileUnits(
														i.clusterRadius || 50
													),
													log: !1,
													generateId: i.generateId || !1,
												},
												clusterProperties: i.clusterProperties,
												filter: i.filter,
											},
											i.workerOptions
										)),
										typeof this.promoteId == "string" &&
											(this.workerOptions.promoteId = this.promoteId);
								}
								_pixelsToTileUnits(e) {
									return e * (s.$ / this.tileSize);
								}
								_getClusterMaxZoom(e) {
									const i = e ? Math.round(e) : this.maxzoom - 1;
									return (
										Number.isInteger(e) ||
											e === void 0 ||
											s.w(
												`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${i}"`
											),
										i
									);
								}
								load() {
									return s._(this, void 0, void 0, function* () {
										yield this._updateWorkerData();
									});
								}
								onAdd(e) {
									(this.map = e), this.load();
								}
								setData(e) {
									return (
										(this._data = e),
										(this._pendingWorkerUpdate = { data: e }),
										this._updateWorkerData(),
										this
									);
								}
								updateData(e) {
									return (
										(this._pendingWorkerUpdate.diff = s.a0(
											this._pendingWorkerUpdate.diff,
											e
										)),
										this._updateWorkerData(),
										this
									);
								}
								getData() {
									return s._(this, void 0, void 0, function* () {
										const e = s.e({ type: this.type }, this.workerOptions);
										return this.actor.sendAsync({ type: "GD", data: e });
									});
								}
								getCoordinatesFromGeometry(e) {
									return e.type === "GeometryCollection"
										? e.geometries.map((i) => i.coordinates).flat(1 / 0)
										: e.coordinates.flat(1 / 0);
								}
								getBounds() {
									return s._(this, void 0, void 0, function* () {
										const e = new _t(),
											i = yield this.getData();
										let l;
										switch (i.type) {
											case "FeatureCollection":
												l = i.features
													.map((u) =>
														this.getCoordinatesFromGeometry(u.geometry)
													)
													.flat(1 / 0);
												break;
											case "Feature":
												l = this.getCoordinatesFromGeometry(i.geometry);
												break;
											default:
												l = this.getCoordinatesFromGeometry(i);
										}
										if (l.length == 0) return e;
										for (let u = 0; u < l.length - 1; u += 2)
											e.extend([l[u], l[u + 1]]);
										return e;
									});
								}
								setClusterOptions(e) {
									return (
										(this.workerOptions.cluster = e.cluster),
										e &&
											(e.clusterRadius !== void 0 &&
												(this.workerOptions.superclusterOptions.radius =
													this._pixelsToTileUnits(e.clusterRadius)),
											e.clusterMaxZoom !== void 0 &&
												(this.workerOptions.superclusterOptions.maxZoom =
													this._getClusterMaxZoom(e.clusterMaxZoom))),
										this._updateWorkerData(),
										this
									);
								}
								getClusterExpansionZoom(e) {
									return this.actor.sendAsync({
										type: "GCEZ",
										data: { type: this.type, clusterId: e, source: this.id },
									});
								}
								getClusterChildren(e) {
									return this.actor.sendAsync({
										type: "GCC",
										data: { type: this.type, clusterId: e, source: this.id },
									});
								}
								getClusterLeaves(e, i, l) {
									return this.actor.sendAsync({
										type: "GCL",
										data: {
											type: this.type,
											source: this.id,
											clusterId: e,
											limit: i,
											offset: l,
										},
									});
								}
								_updateWorkerData() {
									return s._(this, void 0, void 0, function* () {
										if (this._isUpdatingWorker) return;
										const { data: e, diff: i } = this._pendingWorkerUpdate;
										if (!e && !i)
											return void s.w(
												`No data or diff provided to GeoJSONSource ${this.id}.`
											);
										const l = s.e({ type: this.type }, this.workerOptions);
										e
											? (typeof e == "string"
													? ((l.request =
															this.map._requestManager.transformRequest(
																ne.resolveURL(e),
																"Source"
															)),
													  (l.request.collectResourceTiming =
															this._collectResourceTiming))
													: (l.data = JSON.stringify(e)),
											  (this._pendingWorkerUpdate.data = void 0))
											: i &&
											  ((l.dataDiff = i),
											  (this._pendingWorkerUpdate.diff = void 0)),
											(this._isUpdatingWorker = !0),
											this.fire(new s.l("dataloading", { dataType: "source" }));
										try {
											const u = yield this.actor.sendAsync({
												type: "LD",
												data: l,
											});
											if (
												((this._isUpdatingWorker = !1),
												this._removed || u.abandoned)
											)
												return void this.fire(
													new s.l("dataabort", { dataType: "source" })
												);
											this._data = u.data;
											let d = null;
											u.resourceTiming &&
												u.resourceTiming[this.id] &&
												(d = u.resourceTiming[this.id].slice(0));
											const g = { dataType: "source" };
											this._collectResourceTiming &&
												d &&
												d.length > 0 &&
												s.e(g, { resourceTiming: d }),
												this.fire(
													new s.l(
														"data",
														Object.assign(Object.assign({}, g), {
															sourceDataType: "metadata",
														})
													)
												),
												this.fire(
													new s.l(
														"data",
														Object.assign(Object.assign({}, g), {
															sourceDataType: "content",
														})
													)
												);
										} catch (u) {
											if (((this._isUpdatingWorker = !1), this._removed))
												return void this.fire(
													new s.l("dataabort", { dataType: "source" })
												);
											this.fire(new s.k(u));
										} finally {
											(this._pendingWorkerUpdate.data ||
												this._pendingWorkerUpdate.diff) &&
												this._updateWorkerData();
										}
									});
								}
								loaded() {
									return (
										!this._isUpdatingWorker &&
										this._pendingWorkerUpdate.data === void 0 &&
										this._pendingWorkerUpdate.diff === void 0
									);
								}
								loadTile(e) {
									return s._(this, void 0, void 0, function* () {
										const i = e.actor ? "RT" : "LT";
										e.actor = this.actor;
										const l = {
											type: this.type,
											uid: e.uid,
											tileID: e.tileID,
											zoom: e.tileID.overscaledZ,
											maxZoom: this.maxzoom,
											tileSize: this.tileSize,
											source: this.id,
											pixelRatio: this.map.getPixelRatio(),
											showCollisionBoxes: this.map.showCollisionBoxes,
											promoteId: this.promoteId,
											subdivisionGranularity:
												this.map.style.projection.subdivisionGranularity,
											globalState: this.map.getGlobalState(),
										};
										e.abortController = new AbortController();
										const u = yield this.actor.sendAsync(
											{ type: i, data: l },
											e.abortController
										);
										delete e.abortController,
											e.unloadVectorData(),
											e.aborted ||
												e.loadVectorData(u, this.map.painter, i === "RT");
									});
								}
								abortTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.abortController &&
											(e.abortController.abort(), delete e.abortController),
											(e.aborted = !0);
									});
								}
								unloadTile(e) {
									return s._(this, void 0, void 0, function* () {
										e.unloadVectorData(),
											yield this.actor.sendAsync({
												type: "RMT",
												data: { uid: e.uid, type: this.type, source: this.id },
											});
									});
								}
								onRemove() {
									(this._removed = !0),
										this.actor.sendAsync({
											type: "RS",
											data: { type: this.type, source: this.id },
										});
								}
								serialize() {
									return s.e({}, this._options, {
										type: this.type,
										data: this._data,
									});
								}
								hasTransition() {
									return !1;
								}
							}
							class Ot extends s.E {
								constructor(e, i, l, u) {
									super(),
										(this.flippedWindingOrder = !1),
										(this.id = e),
										(this.dispatcher = l),
										(this.coordinates = i.coordinates),
										(this.type = "image"),
										(this.minzoom = 0),
										(this.maxzoom = 22),
										(this.tileSize = 512),
										(this.tiles = {}),
										(this._loaded = !1),
										this.setEventedParent(u),
										(this.options = i);
								}
								load(e) {
									return s._(this, void 0, void 0, function* () {
										(this._loaded = !1),
											this.fire(new s.l("dataloading", { dataType: "source" })),
											(this.url = this.options.url),
											(this._request = new AbortController());
										try {
											const i = yield Fe.getImage(
												this.map._requestManager.transformRequest(
													this.url,
													"Image"
												),
												this._request
											);
											(this._request = null),
												(this._loaded = !0),
												i &&
													i.data &&
													((this.image = i.data),
													e && (this.coordinates = e),
													this._finishLoading());
										} catch (i) {
											(this._request = null),
												(this._loaded = !0),
												this.fire(new s.k(i));
										}
									});
								}
								loaded() {
									return this._loaded;
								}
								updateImage(e) {
									return e.url
										? (this._request &&
												(this._request.abort(), (this._request = null)),
										  (this.options.url = e.url),
										  this.load(e.coordinates).finally(() => {
												this.texture = null;
										  }),
										  this)
										: this;
								}
								_finishLoading() {
									this.map &&
										(this.setCoordinates(this.coordinates),
										this.fire(
											new s.l("data", {
												dataType: "source",
												sourceDataType: "metadata",
											})
										));
								}
								onAdd(e) {
									(this.map = e), this.load();
								}
								onRemove() {
									this._request &&
										(this._request.abort(), (this._request = null));
								}
								setCoordinates(e) {
									this.coordinates = e;
									const i = e.map(s.a1.fromLngLat);
									var l;
									return (
										(this.tileID = (function (u) {
											const d = s.a2.fromPoints(u),
												g = d.width(),
												w = d.height(),
												C = Math.max(g, w),
												P = Math.max(0, Math.floor(-Math.log(C) / Math.LN2)),
												E = Math.pow(2, P);
											return new s.a4(
												P,
												Math.floor(((d.minX + d.maxX) / 2) * E),
												Math.floor(((d.minY + d.maxY) / 2) * E)
											);
										})(i)),
										(this.terrainTileRanges =
											this._getOverlappingTileRanges(i)),
										(this.minzoom = this.maxzoom = this.tileID.z),
										(this.tileCoords = i.map((u) =>
											this.tileID.getTilePoint(u)._round()
										)),
										(this.flippedWindingOrder =
											((l = this.tileCoords)[1].x - l[0].x) *
												(l[2].y - l[0].y) -
												(l[1].y - l[0].y) * (l[2].x - l[0].x) <
											0),
										this.fire(
											new s.l("data", {
												dataType: "source",
												sourceDataType: "content",
											})
										),
										this
									);
								}
								prepare() {
									if (Object.keys(this.tiles).length === 0 || !this.image)
										return;
									const e = this.map.painter.context,
										i = e.gl;
									this.texture ||
										((this.texture = new s.T(e, this.image, i.RGBA)),
										this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
									let l = !1;
									for (const u in this.tiles) {
										const d = this.tiles[u];
										d.state !== "loaded" &&
											((d.state = "loaded"),
											(d.texture = this.texture),
											(l = !0));
									}
									l &&
										this.fire(
											new s.l("data", {
												dataType: "source",
												sourceDataType: "idle",
												sourceId: this.id,
											})
										);
								}
								loadTile(e) {
									return s._(this, void 0, void 0, function* () {
										this.tileID && this.tileID.equals(e.tileID.canonical)
											? ((this.tiles[String(e.tileID.wrap)] = e),
											  (e.buckets = {}))
											: (e.state = "errored");
									});
								}
								serialize() {
									return {
										type: "image",
										url: this.options.url,
										coordinates: this.coordinates,
									};
								}
								hasTransition() {
									return !1;
								}
								_getOverlappingTileRanges(e) {
									const {
											minX: i,
											minY: l,
											maxX: u,
											maxY: d,
										} = s.a2.fromPoints(e),
										g = {};
									for (let w = 0; w <= s.a3; w++) {
										const C = Math.pow(2, w),
											P = Math.floor(i * C),
											E = Math.floor(l * C),
											R = Math.floor(u * C),
											D = Math.floor(d * C);
										g[w] = {
											minTileX: P,
											minTileY: E,
											maxTileX: R,
											maxTileY: D,
										};
									}
									return g;
								}
							}
							class Nt extends Ot {
								constructor(e, i, l, u) {
									super(e, i, l, u),
										(this.roundZoom = !0),
										(this.type = "video"),
										(this.options = i);
								}
								load() {
									return s._(this, void 0, void 0, function* () {
										this._loaded = !1;
										const e = this.options;
										this.urls = [];
										for (const i of e.urls)
											this.urls.push(
												this.map._requestManager.transformRequest(i, "Source")
													.url
											);
										try {
											const i = yield s.a5(this.urls);
											if (((this._loaded = !0), !i)) return;
											(this.video = i),
												(this.video.loop = !0),
												this.video.addEventListener("playing", () => {
													this.map.triggerRepaint();
												}),
												this.map && this.video.play(),
												this._finishLoading();
										} catch (i) {
											this.fire(new s.k(i));
										}
									});
								}
								pause() {
									this.video && this.video.pause();
								}
								play() {
									this.video && this.video.play();
								}
								seek(e) {
									if (this.video) {
										const i = this.video.seekable;
										e < i.start(0) || e > i.end(0)
											? this.fire(
													new s.k(
														new s.a6(
															`sources.${this.id}`,
															null,
															`Playback for this video can be set only between the ${i.start(
																0
															)} and ${i.end(0)}-second mark.`
														)
													)
											  )
											: (this.video.currentTime = e);
									}
								}
								getVideo() {
									return this.video;
								}
								onAdd(e) {
									this.map ||
										((this.map = e),
										this.load(),
										this.video &&
											(this.video.play(),
											this.setCoordinates(this.coordinates)));
								}
								prepare() {
									if (
										Object.keys(this.tiles).length === 0 ||
										this.video.readyState < 2
									)
										return;
									const e = this.map.painter.context,
										i = e.gl;
									this.texture
										? this.video.paused ||
										  (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
										  i.texSubImage2D(
												i.TEXTURE_2D,
												0,
												0,
												0,
												i.RGBA,
												i.UNSIGNED_BYTE,
												this.video
										  ))
										: ((this.texture = new s.T(e, this.video, i.RGBA)),
										  this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
									let l = !1;
									for (const u in this.tiles) {
										const d = this.tiles[u];
										d.state !== "loaded" &&
											((d.state = "loaded"),
											(d.texture = this.texture),
											(l = !0));
									}
									l &&
										this.fire(
											new s.l("data", {
												dataType: "source",
												sourceDataType: "idle",
												sourceId: this.id,
											})
										);
								}
								serialize() {
									return {
										type: "video",
										urls: this.urls,
										coordinates: this.coordinates,
									};
								}
								hasTransition() {
									return this.video && !this.video.paused;
								}
							}
							class or extends Ot {
								constructor(e, i, l, u) {
									super(e, i, l, u),
										i.coordinates
											? (Array.isArray(i.coordinates) &&
													i.coordinates.length === 4 &&
													!i.coordinates.some(
														(d) =>
															!Array.isArray(d) ||
															d.length !== 2 ||
															d.some((g) => typeof g != "number")
													)) ||
											  this.fire(
													new s.k(
														new s.a6(
															`sources.${e}`,
															null,
															'"coordinates" property must be an array of 4 longitude/latitude array pairs'
														)
													)
											  )
											: this.fire(
													new s.k(
														new s.a6(
															`sources.${e}`,
															null,
															'missing required property "coordinates"'
														)
													)
											  ),
										i.animate &&
											typeof i.animate != "boolean" &&
											this.fire(
												new s.k(
													new s.a6(
														`sources.${e}`,
														null,
														'optional "animate" property must be a boolean value'
													)
												)
											),
										i.canvas
											? typeof i.canvas == "string" ||
											  i.canvas instanceof HTMLCanvasElement ||
											  this.fire(
													new s.k(
														new s.a6(
															`sources.${e}`,
															null,
															'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
														)
													)
											  )
											: this.fire(
													new s.k(
														new s.a6(
															`sources.${e}`,
															null,
															'missing required property "canvas"'
														)
													)
											  ),
										(this.options = i),
										(this.animate = i.animate === void 0 || i.animate);
								}
								load() {
									return s._(this, void 0, void 0, function* () {
										(this._loaded = !0),
											this.canvas ||
												(this.canvas =
													this.options.canvas instanceof HTMLCanvasElement
														? this.options.canvas
														: document.getElementById(this.options.canvas)),
											(this.width = this.canvas.width),
											(this.height = this.canvas.height),
											this._hasInvalidDimensions()
												? this.fire(
														new s.k(
															new Error(
																"Canvas dimensions cannot be less than or equal to zero."
															)
														)
												  )
												: ((this.play = function () {
														(this._playing = !0), this.map.triggerRepaint();
												  }),
												  (this.pause = function () {
														this._playing &&
															(this.prepare(), (this._playing = !1));
												  }),
												  this._finishLoading());
									});
								}
								getCanvas() {
									return this.canvas;
								}
								onAdd(e) {
									(this.map = e),
										this.load(),
										this.canvas && this.animate && this.play();
								}
								onRemove() {
									this.pause();
								}
								prepare() {
									let e = !1;
									if (
										(this.canvas.width !== this.width &&
											((this.width = this.canvas.width), (e = !0)),
										this.canvas.height !== this.height &&
											((this.height = this.canvas.height), (e = !0)),
										this._hasInvalidDimensions() ||
											Object.keys(this.tiles).length === 0)
									)
										return;
									const i = this.map.painter.context,
										l = i.gl;
									this.texture
										? (e || this._playing) &&
										  this.texture.update(this.canvas, { premultiply: !0 })
										: (this.texture = new s.T(i, this.canvas, l.RGBA, {
												premultiply: !0,
										  }));
									let u = !1;
									for (const d in this.tiles) {
										const g = this.tiles[d];
										g.state !== "loaded" &&
											((g.state = "loaded"),
											(g.texture = this.texture),
											(u = !0));
									}
									u &&
										this.fire(
											new s.l("data", {
												dataType: "source",
												sourceDataType: "idle",
												sourceId: this.id,
											})
										);
								}
								serialize() {
									return { type: "canvas", coordinates: this.coordinates };
								}
								hasTransition() {
									return this._playing;
								}
								_hasInvalidDimensions() {
									for (const e of [this.canvas.width, this.canvas.height])
										if (isNaN(e) || e <= 0) return !0;
									return !1;
								}
							}
							const cr = {},
								Vr = (h) => {
									switch (h) {
										case "geojson":
											return Qt;
										case "image":
											return Ot;
										case "raster":
											return $t;
										case "raster-dem":
											return tr;
										case "vector":
											return Rt;
										case "video":
											return Nt;
										case "canvas":
											return or;
									}
									return cr[h];
								},
								mr = "RTLPluginLoaded";
							class hr extends s.E {
								constructor() {
									super(...arguments),
										(this.status = "unavailable"),
										(this.url = null),
										(this.dispatcher = at());
								}
								_syncState(e) {
									return (
										(this.status = e),
										this.dispatcher
											.broadcast("SRPS", {
												pluginStatus: e,
												pluginURL: this.url,
											})
											.catch((i) => {
												throw ((this.status = "error"), i);
											})
									);
								}
								getRTLTextPluginStatus() {
									return this.status;
								}
								clearRTLTextPlugin() {
									(this.status = "unavailable"), (this.url = null);
								}
								setRTLTextPlugin(e) {
									return s._(this, arguments, void 0, function* (i, l = !1) {
										if (this.url)
											throw new Error(
												"setRTLTextPlugin cannot be called multiple times."
											);
										if (((this.url = ne.resolveURL(i)), !this.url))
											throw new Error(`requested url ${i} is invalid`);
										if (this.status === "unavailable") {
											if (!l) return this._requestImport();
											(this.status = "deferred"), this._syncState(this.status);
										} else if (this.status === "requested") return this._requestImport();
									});
								}
								_requestImport() {
									return s._(this, void 0, void 0, function* () {
										yield this._syncState("loading"),
											(this.status = "loaded"),
											this.fire(new s.l(mr));
									});
								}
								lazyLoad() {
									this.status === "unavailable"
										? (this.status = "requested")
										: this.status === "deferred" && this._requestImport();
								}
							}
							let _r = null;
							function Ir() {
								return _r || (_r = new hr()), _r;
							}
							class qr {
								constructor(e, i) {
									(this.timeAdded = 0),
										(this.fadeEndTime = 0),
										(this.tileID = e),
										(this.uid = s.a7()),
										(this.uses = 0),
										(this.tileSize = i),
										(this.buckets = {}),
										(this.expirationTime = null),
										(this.queryPadding = 0),
										(this.hasSymbolBuckets = !1),
										(this.hasRTLText = !1),
										(this.dependencies = {}),
										(this.rtt = []),
										(this.rttCoords = {}),
										(this.expiredRequestCount = 0),
										(this.state = "loading");
								}
								registerFadeDuration(e) {
									const i = e + this.timeAdded;
									i < this.fadeEndTime || (this.fadeEndTime = i);
								}
								wasRequested() {
									return (
										this.state === "errored" ||
										this.state === "loaded" ||
										this.state === "reloading"
									);
								}
								clearTextures(e) {
									this.demTexture && e.saveTileTexture(this.demTexture),
										(this.demTexture = null);
								}
								loadVectorData(e, i, l) {
									if (
										(this.hasData() && this.unloadVectorData(),
										(this.state = "loaded"),
										e)
									) {
										e.featureIndex &&
											((this.latestFeatureIndex = e.featureIndex),
											e.rawTileData
												? ((this.latestRawTileData = e.rawTileData),
												  (this.latestFeatureIndex.rawTileData = e.rawTileData))
												: this.latestRawTileData &&
												  (this.latestFeatureIndex.rawTileData =
														this.latestRawTileData)),
											(this.collisionBoxArray = e.collisionBoxArray),
											(this.buckets = (function (u, d) {
												const g = {};
												if (!d) return g;
												for (const w of u) {
													const C = w.layerIds
														.map((P) => d.getLayer(P))
														.filter(Boolean);
													if (C.length !== 0) {
														(w.layers = C),
															w.stateDependentLayerIds &&
																(w.stateDependentLayers =
																	w.stateDependentLayerIds.map(
																		(P) => C.filter((E) => E.id === P)[0]
																	));
														for (const P of C) g[P.id] = w;
													}
												}
												return g;
											})(e.buckets, i == null ? void 0 : i.style)),
											(this.hasSymbolBuckets = !1);
										for (const u in this.buckets) {
											const d = this.buckets[u];
											if (d instanceof s.a9) {
												if (((this.hasSymbolBuckets = !0), !l)) break;
												d.justReloaded = !0;
											}
										}
										if (((this.hasRTLText = !1), this.hasSymbolBuckets))
											for (const u in this.buckets) {
												const d = this.buckets[u];
												if (d instanceof s.a9 && d.hasRTLText) {
													(this.hasRTLText = !0), Ir().lazyLoad();
													break;
												}
											}
										this.queryPadding = 0;
										for (const u in this.buckets) {
											const d = this.buckets[u];
											this.queryPadding = Math.max(
												this.queryPadding,
												i.style.getLayer(u).queryRadius(d)
											);
										}
										e.imageAtlas && (this.imageAtlas = e.imageAtlas),
											e.glyphAtlasImage &&
												(this.glyphAtlasImage = e.glyphAtlasImage);
									} else this.collisionBoxArray = new s.a8();
								}
								unloadVectorData() {
									for (const e in this.buckets) this.buckets[e].destroy();
									(this.buckets = {}),
										this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
										this.imageAtlas && (this.imageAtlas = null),
										this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
										(this.latestFeatureIndex = null),
										(this.state = "unloaded");
								}
								getBucket(e) {
									return this.buckets[e.id];
								}
								upload(e) {
									for (const l in this.buckets) {
										const u = this.buckets[l];
										u.uploadPending() && u.upload(e);
									}
									const i = e.gl;
									this.imageAtlas &&
										!this.imageAtlas.uploaded &&
										((this.imageAtlasTexture = new s.T(
											e,
											this.imageAtlas.image,
											i.RGBA
										)),
										(this.imageAtlas.uploaded = !0)),
										this.glyphAtlasImage &&
											((this.glyphAtlasTexture = new s.T(
												e,
												this.glyphAtlasImage,
												i.ALPHA
											)),
											(this.glyphAtlasImage = null));
								}
								prepare(e) {
									this.imageAtlas &&
										this.imageAtlas.patchUpdatedImages(
											e,
											this.imageAtlasTexture
										);
								}
								queryRenderedFeatures(e, i, l, u, d, g, w, C, P, E, R) {
									return this.latestFeatureIndex &&
										this.latestFeatureIndex.rawTileData
										? this.latestFeatureIndex.query(
												{
													queryGeometry: u,
													cameraQueryGeometry: d,
													scale: g,
													tileSize: this.tileSize,
													pixelPosMatrix: E,
													transform: C,
													params: w,
													queryPadding: this.queryPadding * P,
													getElevation: R,
												},
												e,
												i,
												l
										  )
										: {};
								}
								querySourceFeatures(e, i) {
									const l = this.latestFeatureIndex;
									if (!l || !l.rawTileData) return;
									const u = l.loadVTLayers(),
										d = i && i.sourceLayer ? i.sourceLayer : "",
										g = u._geojsonTileLayer || u[d];
									if (!g) return;
									const w = s.aa(i && i.filter),
										{ z: C, x: P, y: E } = this.tileID.canonical,
										R = { z: C, x: P, y: E };
									for (let D = 0; D < g.length; D++) {
										const N = g.feature(D);
										if (w.needGeometry) {
											const Q = s.ab(N, !0);
											if (
												!w.filter(
													new s.F(this.tileID.overscaledZ),
													Q,
													this.tileID.canonical
												)
											)
												continue;
										} else if (!w.filter(new s.F(this.tileID.overscaledZ), N))
											continue;
										const G = l.getId(N, d),
											te = new s.ac(N, C, P, E, G);
										(te.tile = R), e.push(te);
									}
								}
								hasData() {
									return (
										this.state === "loaded" ||
										this.state === "reloading" ||
										this.state === "expired"
									);
								}
								patternsLoaded() {
									return (
										this.imageAtlas &&
										!!Object.keys(this.imageAtlas.patternPositions).length
									);
								}
								setExpiryData(e) {
									const i = this.expirationTime;
									if (e.cacheControl) {
										const l = s.ad(e.cacheControl);
										l["max-age"] &&
											(this.expirationTime = Date.now() + 1e3 * l["max-age"]);
									} else e.expires && (this.expirationTime = new Date(e.expires).getTime());
									if (this.expirationTime) {
										const l = Date.now();
										let u = !1;
										if (this.expirationTime > l) u = !1;
										else if (i)
											if (this.expirationTime < i) u = !0;
											else {
												const d = this.expirationTime - i;
												d
													? (this.expirationTime = l + Math.max(d, 3e4))
													: (u = !0);
											}
										else u = !0;
										u
											? (this.expiredRequestCount++, (this.state = "expired"))
											: (this.expiredRequestCount = 0);
									}
								}
								getExpiryTimeout() {
									if (this.expirationTime)
										return this.expiredRequestCount
											? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
											: Math.min(
													this.expirationTime - new Date().getTime(),
													Math.pow(2, 31) - 1
											  );
								}
								setFeatureState(e, i) {
									if (
										!this.latestFeatureIndex ||
										!this.latestFeatureIndex.rawTileData ||
										Object.keys(e).length === 0
									)
										return;
									const l = this.latestFeatureIndex.loadVTLayers();
									for (const u in this.buckets) {
										if (!i.style.hasLayer(u)) continue;
										const d = this.buckets[u],
											g = d.layers[0].sourceLayer || "_geojsonTileLayer",
											w = l[g],
											C = e[g];
										if (!w || !C || Object.keys(C).length === 0) continue;
										d.update(
											C,
											w,
											(this.imageAtlas && this.imageAtlas.patternPositions) ||
												{}
										);
										const P = i && i.style && i.style.getLayer(u);
										P &&
											(this.queryPadding = Math.max(
												this.queryPadding,
												P.queryRadius(d)
											));
									}
								}
								holdingForFade() {
									return this.symbolFadeHoldUntil !== void 0;
								}
								symbolFadeFinished() {
									return (
										!this.symbolFadeHoldUntil ||
										this.symbolFadeHoldUntil < ne.now()
									);
								}
								clearFadeHold() {
									this.symbolFadeHoldUntil = void 0;
								}
								setHoldDuration(e) {
									this.symbolFadeHoldUntil = ne.now() + e;
								}
								setDependencies(e, i) {
									const l = {};
									for (const u of i) l[u] = !0;
									this.dependencies[e] = l;
								}
								hasDependency(e, i) {
									for (const l of e) {
										const u = this.dependencies[l];
										if (u) {
											for (const d of i) if (u[d]) return !0;
										}
									}
									return !1;
								}
							}
							class ue {
								constructor(e, i) {
									(this.max = e), (this.onRemove = i), this.reset();
								}
								reset() {
									for (const e in this.data)
										for (const i of this.data[e])
											i.timeout && clearTimeout(i.timeout),
												this.onRemove(i.value);
									return (this.data = {}), (this.order = []), this;
								}
								add(e, i, l) {
									const u = e.wrapped().key;
									this.data[u] === void 0 && (this.data[u] = []);
									const d = { value: i, timeout: void 0 };
									if (
										(l !== void 0 &&
											(d.timeout = setTimeout(() => {
												this.remove(e, d);
											}, l)),
										this.data[u].push(d),
										this.order.push(u),
										this.order.length > this.max)
									) {
										const g = this._getAndRemoveByKey(this.order[0]);
										g && this.onRemove(g);
									}
									return this;
								}
								has(e) {
									return e.wrapped().key in this.data;
								}
								getAndRemove(e) {
									return this.has(e)
										? this._getAndRemoveByKey(e.wrapped().key)
										: null;
								}
								_getAndRemoveByKey(e) {
									const i = this.data[e].shift();
									return (
										i.timeout && clearTimeout(i.timeout),
										this.data[e].length === 0 && delete this.data[e],
										this.order.splice(this.order.indexOf(e), 1),
										i.value
									);
								}
								getByKey(e) {
									const i = this.data[e];
									return i ? i[0].value : null;
								}
								get(e) {
									return this.has(e)
										? this.data[e.wrapped().key][0].value
										: null;
								}
								remove(e, i) {
									if (!this.has(e)) return this;
									const l = e.wrapped().key,
										u = i === void 0 ? 0 : this.data[l].indexOf(i),
										d = this.data[l][u];
									return (
										this.data[l].splice(u, 1),
										d.timeout && clearTimeout(d.timeout),
										this.data[l].length === 0 && delete this.data[l],
										this.onRemove(d.value),
										this.order.splice(this.order.indexOf(l), 1),
										this
									);
								}
								setMaxSize(e) {
									for (this.max = e; this.order.length > this.max; ) {
										const i = this._getAndRemoveByKey(this.order[0]);
										i && this.onRemove(i);
									}
									return this;
								}
								filter(e) {
									const i = [];
									for (const l in this.data)
										for (const u of this.data[l]) e(u.value) || i.push(u);
									for (const l of i) this.remove(l.value.tileID, l);
								}
							}
							class V {
								constructor() {
									(this.state = {}),
										(this.stateChanges = {}),
										(this.deletedStates = {});
								}
								updateState(e, i, l) {
									const u = String(i);
									if (
										((this.stateChanges[e] = this.stateChanges[e] || {}),
										(this.stateChanges[e][u] = this.stateChanges[e][u] || {}),
										s.e(this.stateChanges[e][u], l),
										this.deletedStates[e] === null)
									) {
										this.deletedStates[e] = {};
										for (const d in this.state[e])
											d !== u && (this.deletedStates[e][d] = null);
									} else if (
										this.deletedStates[e] &&
										this.deletedStates[e][u] === null
									) {
										this.deletedStates[e][u] = {};
										for (const d in this.state[e][u])
											l[d] || (this.deletedStates[e][u][d] = null);
									} else
										for (const d in l)
											this.deletedStates[e] &&
												this.deletedStates[e][u] &&
												this.deletedStates[e][u][d] === null &&
												delete this.deletedStates[e][u][d];
								}
								removeFeatureState(e, i, l) {
									if (this.deletedStates[e] === null) return;
									const u = String(i);
									if (
										((this.deletedStates[e] = this.deletedStates[e] || {}),
										l && i !== void 0)
									)
										this.deletedStates[e][u] !== null &&
											((this.deletedStates[e][u] =
												this.deletedStates[e][u] || {}),
											(this.deletedStates[e][u][l] = null));
									else if (i !== void 0)
										if (this.stateChanges[e] && this.stateChanges[e][u])
											for (l in ((this.deletedStates[e][u] = {}),
											this.stateChanges[e][u]))
												this.deletedStates[e][u][l] = null;
										else this.deletedStates[e][u] = null;
									else this.deletedStates[e] = null;
								}
								getState(e, i) {
									const l = String(i),
										u = s.e(
											{},
											(this.state[e] || {})[l],
											(this.stateChanges[e] || {})[l]
										);
									if (this.deletedStates[e] === null) return {};
									if (this.deletedStates[e]) {
										const d = this.deletedStates[e][i];
										if (d === null) return {};
										for (const g in d) delete u[g];
									}
									return u;
								}
								initializeTileState(e, i) {
									e.setFeatureState(this.state, i);
								}
								coalesceChanges(e, i) {
									const l = {};
									for (const u in this.stateChanges) {
										this.state[u] = this.state[u] || {};
										const d = {};
										for (const g in this.stateChanges[u])
											this.state[u][g] || (this.state[u][g] = {}),
												s.e(this.state[u][g], this.stateChanges[u][g]),
												(d[g] = this.state[u][g]);
										l[u] = d;
									}
									for (const u in this.deletedStates) {
										this.state[u] = this.state[u] || {};
										const d = {};
										if (this.deletedStates[u] === null)
											for (const g in this.state[u])
												(d[g] = {}), (this.state[u][g] = {});
										else
											for (const g in this.deletedStates[u]) {
												if (this.deletedStates[u][g] === null)
													this.state[u][g] = {};
												else
													for (const w of Object.keys(this.deletedStates[u][g]))
														delete this.state[u][g][w];
												d[g] = this.state[u][g];
											}
										(l[u] = l[u] || {}), s.e(l[u], d);
									}
									if (
										((this.stateChanges = {}),
										(this.deletedStates = {}),
										Object.keys(l).length !== 0)
									)
										for (const u in e) e[u].setFeatureState(l, i);
								}
							}
							const U = 89.25;
							function Y(h, e) {
								const i = s.ah(e.lat, -s.ai, s.ai);
								return new s.P(s.V(e.lng) * h, s.U(i) * h);
							}
							function ie(h, e) {
								return new s.a1(e.x / h, e.y / h).toLngLat();
							}
							function pe(h) {
								return (
									h.cameraToCenterDistance *
									Math.min(
										0.85 * Math.tan(s.ae(90 - h.pitch)),
										Math.tan(s.ae(U - h.pitch))
									)
								);
							}
							function Se(h, e) {
								const i = h.canonical,
									l = e / s.af(i.z),
									u = i.x + Math.pow(2, i.z) * h.wrap,
									d = s.ag(new Float64Array(16));
								return (
									s.M(d, d, [u * l, i.y * l, 0]),
									s.N(d, d, [l / s.$, l / s.$, 1]),
									d
								);
							}
							function Me(h, e, i, l, u) {
								const d = s.a1.fromLngLat(h, e),
									g = u * s.aj(1, h.lat),
									w = g * Math.cos(s.ae(i)),
									C = Math.sqrt(g * g - w * w),
									P = C * Math.sin(s.ae(-l)),
									E = C * Math.cos(s.ae(-l));
								return new s.a1(d.x + P, d.y + E, d.z + w);
							}
							function we(h, e, i) {
								const l = e.intersectsFrustum(h);
								if (!i || l === 0) return l;
								const u = e.intersectsPlane(i);
								return u === 0 ? 0 : l === 2 && u === 2 ? 2 : 1;
							}
							function Ve(h, e, i) {
								let l = 0;
								const u = (i - e) / 10;
								for (let d = 0; d < 10; d++)
									l +=
										u * Math.pow(Math.cos(e + ((d + 0.5) / 10) * (i - e)), h);
								return l;
							}
							function ut(h, e) {
								return function (i, l, u, d, g) {
									const w =
											2 *
											((h - 1) /
												s.ak(Math.cos(s.ae(U - g)) / Math.cos(s.ae(U))) -
												1),
										C = Math.acos(u / d),
										P = 2 * Ve(w - 1, 0, s.ae(g / 2)),
										E = Math.min(s.ae(U), C + s.ae(g / 2)),
										R = Ve(w - 1, Math.min(E, C - s.ae(g / 2)), E),
										D = Math.atan(l / u),
										N = Math.hypot(l, u);
									let G = i;
									return (
										(G += s.ak(d / N / Math.max(0.5, Math.cos(s.ae(g / 2))))),
										(G += (w * s.ak(Math.cos(D))) / 2),
										(G -= s.ak(Math.max(1, R / P / e)) / 2),
										G
									);
								};
							}
							const Ke = ut(9.314, 3);
							function kt(h, e) {
								const i = (e.roundZoom ? Math.round : Math.floor)(
									h.zoom + s.ak(h.tileSize / e.tileSize)
								);
								return Math.max(0, i);
							}
							function ye(h, e) {
								const i = h.getCameraFrustum(),
									l = h.getClippingPlane(),
									u = h.screenPointToMercatorCoordinate(h.getCameraPoint()),
									d = s.a1.fromLngLat(h.center, h.elevation);
								u.z =
									d.z +
									(Math.cos(h.pitchInRadians) * h.cameraToCenterDistance) /
										h.worldSize;
								const g = h.getCoveringTilesDetailsProvider(),
									w = g.allowVariableZoom(h, e),
									C = kt(h, e),
									P = e.minzoom || 0,
									E = e.maxzoom !== void 0 ? e.maxzoom : h.maxZoom,
									R = Math.min(Math.max(0, C), E),
									D = Math.pow(2, R),
									N = [D * u.x, D * u.y, 0],
									G = [D * d.x, D * d.y, 0],
									te = Math.hypot(d.x - u.x, d.y - u.y),
									Q = Math.abs(d.z - u.z),
									ae = Math.hypot(te, Q),
									ce = (be) => ({
										zoom: 0,
										x: 0,
										y: 0,
										wrap: be,
										fullyVisible: !1,
									}),
									ve = [],
									me = [];
								if (h.renderWorldCopies && g.allowWorldCopies())
									for (let be = 1; be <= 3; be++)
										ve.push(ce(-be)), ve.push(ce(be));
								for (ve.push(ce(0)); ve.length > 0; ) {
									const be = ve.pop(),
										Pe = be.x,
										_e = be.y;
									let Be = be.fullyVisible;
									const rt = { x: Pe, y: _e, z: be.zoom },
										Ge = g.getTileBoundingVolume(rt, be.wrap, h.elevation, e);
									if (!Be) {
										const Zt = we(i, Ge, l);
										if (Zt === 0) continue;
										Be = Zt === 2;
									}
									const Xe = g.distanceToTile2d(u.x, u.y, rt, Ge);
									let tt = C;
									w &&
										(tt = (e.calculateTileZoom || Ke)(
											h.zoom + s.ak(h.tileSize / e.tileSize),
											Xe,
											Q,
											ae,
											h.fov
										)),
										(tt = (e.roundZoom ? Math.round : Math.floor)(tt)),
										(tt = Math.max(0, tt));
									const jt = Math.min(tt, E);
									if (((be.wrap = g.getWrap(d, rt, be.wrap)), be.zoom >= jt)) {
										if (be.zoom < P) continue;
										const Zt = R - be.zoom,
											Tt = N[0] - 0.5 - (Pe << Zt),
											vr = N[1] - 0.5 - (_e << Zt),
											Jr = e.reparseOverscaled
												? Math.max(be.zoom, tt)
												: be.zoom;
										me.push({
											tileID: new s.Z(
												be.zoom === E ? Jr : be.zoom,
												be.wrap,
												be.zoom,
												Pe,
												_e
											),
											distanceSq: s.al([G[0] - 0.5 - Pe, G[1] - 0.5 - _e]),
											tileDistanceToCamera: Math.sqrt(Tt * Tt + vr * vr),
										});
									} else
										for (let Zt = 0; Zt < 4; Zt++)
											ve.push({
												zoom: be.zoom + 1,
												x: (Pe << 1) + (Zt % 2),
												y: (_e << 1) + (Zt >> 1),
												wrap: be.wrap,
												fullyVisible: Be,
											});
								}
								return me
									.sort((be, Pe) => be.distanceSq - Pe.distanceSq)
									.map((be) => be.tileID);
							}
							const Bt = s.a2.fromPoints([new s.P(0, 0), new s.P(s.$, s.$)]);
							class rr extends s.E {
								constructor(e, i, l) {
									super(),
										(this.id = e),
										(this.dispatcher = l),
										this.on("data", (u) => this._dataHandler(u)),
										this.on("dataloading", () => {
											this._sourceErrored = !1;
										}),
										this.on("error", () => {
											this._sourceErrored = this._source.loaded();
										}),
										(this._source = ((u, d, g, w) => {
											const C = new (Vr(d.type))(u, d, g, w);
											if (C.id !== u)
												throw new Error(
													`Expected Source id to be ${u} instead of ${C.id}`
												);
											return C;
										})(e, i, l, this)),
										(this._tiles = {}),
										(this._cache = new ue(0, (u) => this._unloadTile(u))),
										(this._timers = {}),
										(this._cacheTimers = {}),
										(this._maxTileCacheSize = null),
										(this._maxTileCacheZoomLevels = null),
										(this._loadedParentTiles = {}),
										(this._coveredTiles = {}),
										(this._state = new V()),
										(this._didEmitContent = !1),
										(this._updated = !1);
								}
								onAdd(e) {
									(this.map = e),
										(this._maxTileCacheSize = e ? e._maxTileCacheSize : null),
										(this._maxTileCacheZoomLevels = e
											? e._maxTileCacheZoomLevels
											: null),
										this._source && this._source.onAdd && this._source.onAdd(e);
								}
								onRemove(e) {
									this.clearTiles(),
										this._source &&
											this._source.onRemove &&
											this._source.onRemove(e);
								}
								loaded() {
									if (this._sourceErrored) return !0;
									if (!this._sourceLoaded || !this._source.loaded()) return !1;
									if (
										!(
											(this.used === void 0 &&
												this.usedForTerrain === void 0) ||
											this.used ||
											this.usedForTerrain
										)
									)
										return !0;
									if (!this._updated) return !1;
									for (const e in this._tiles) {
										const i = this._tiles[e];
										if (i.state !== "loaded" && i.state !== "errored")
											return !1;
									}
									return !0;
								}
								getSource() {
									return this._source;
								}
								pause() {
									this._paused = !0;
								}
								resume() {
									if (!this._paused) return;
									const e = this._shouldReloadOnResume;
									(this._paused = !1),
										(this._shouldReloadOnResume = !1),
										e && this.reload(),
										this.transform && this.update(this.transform, this.terrain);
								}
								_loadTile(e, i, l) {
									return s._(this, void 0, void 0, function* () {
										try {
											yield this._source.loadTile(e), this._tileLoaded(e, i, l);
										} catch (u) {
											(e.state = "errored"),
												u.status !== 404
													? this._source.fire(new s.k(u, { tile: e }))
													: this.update(this.transform, this.terrain);
										}
									});
								}
								_unloadTile(e) {
									this._source.unloadTile && this._source.unloadTile(e);
								}
								_abortTile(e) {
									this._source.abortTile && this._source.abortTile(e),
										this._source.fire(
											new s.l("dataabort", {
												tile: e,
												coord: e.tileID,
												dataType: "source",
											})
										);
								}
								serialize() {
									return this._source.serialize();
								}
								prepare(e) {
									this._source.prepare && this._source.prepare(),
										this._state.coalesceChanges(
											this._tiles,
											this.map ? this.map.painter : null
										);
									for (const i in this._tiles) {
										const l = this._tiles[i];
										l.upload(e), l.prepare(this.map.style.imageManager);
									}
								}
								getIds() {
									return Object.values(this._tiles)
										.map((e) => e.tileID)
										.sort(Kt)
										.map((e) => e.key);
								}
								getRenderableIds(e) {
									const i = [];
									for (const l in this._tiles)
										this._isIdRenderable(l, e) && i.push(this._tiles[l]);
									return e
										? i
												.sort((l, u) => {
													const d = l.tileID,
														g = u.tileID,
														w = new s.P(d.canonical.x, d.canonical.y)._rotate(
															-this.transform.bearingInRadians
														),
														C = new s.P(g.canonical.x, g.canonical.y)._rotate(
															-this.transform.bearingInRadians
														);
													return (
														d.overscaledZ - g.overscaledZ ||
														C.y - w.y ||
														C.x - w.x
													);
												})
												.map((l) => l.tileID.key)
										: i
												.map((l) => l.tileID)
												.sort(Kt)
												.map((l) => l.key);
								}
								hasRenderableParent(e) {
									const i = this.findLoadedParent(e, 0);
									return !!i && this._isIdRenderable(i.tileID.key);
								}
								_isIdRenderable(e, i) {
									return (
										this._tiles[e] &&
										this._tiles[e].hasData() &&
										!this._coveredTiles[e] &&
										(i || !this._tiles[e].holdingForFade())
									);
								}
								reload(e) {
									if (this._paused) this._shouldReloadOnResume = !0;
									else {
										this._cache.reset();
										for (const i in this._tiles)
											e
												? this._reloadTile(i, "expired")
												: this._tiles[i].state !== "errored" &&
												  this._reloadTile(i, "reloading");
									}
								}
								_reloadTile(e, i) {
									return s._(this, void 0, void 0, function* () {
										const l = this._tiles[e];
										l &&
											(l.state !== "loading" && (l.state = i),
											yield this._loadTile(l, e, i));
									});
								}
								_tileLoaded(e, i, l) {
									(e.timeAdded = ne.now()),
										l === "expired" && (e.refreshedUponExpiration = !0),
										this._setTileReloadTimer(i, e),
										this.getSource().type === "raster-dem" &&
											e.dem &&
											this._backfillDEM(e),
										this._state.initializeTileState(
											e,
											this.map ? this.map.painter : null
										),
										e.aborted ||
											this._source.fire(
												new s.l("data", {
													dataType: "source",
													tile: e,
													coord: e.tileID,
												})
											);
								}
								_backfillDEM(e) {
									const i = this.getRenderableIds();
									for (let u = 0; u < i.length; u++) {
										const d = i[u];
										if (e.neighboringTiles && e.neighboringTiles[d]) {
											const g = this.getTileByID(d);
											l(e, g), l(g, e);
										}
									}
									function l(u, d) {
										(u.needsHillshadePrepare = !0),
											(u.needsTerrainPrepare = !0);
										let g = d.tileID.canonical.x - u.tileID.canonical.x;
										const w = d.tileID.canonical.y - u.tileID.canonical.y,
											C = Math.pow(2, u.tileID.canonical.z),
											P = d.tileID.key;
										(g === 0 && w === 0) ||
											Math.abs(w) > 1 ||
											(Math.abs(g) > 1 &&
												(Math.abs(g + C) === 1
													? (g += C)
													: Math.abs(g - C) === 1 && (g -= C)),
											d.dem &&
												u.dem &&
												(u.dem.backfillBorder(d.dem, g, w),
												u.neighboringTiles &&
													u.neighboringTiles[P] &&
													(u.neighboringTiles[P].backfilled = !0)));
									}
								}
								getTile(e) {
									return this.getTileByID(e.key);
								}
								getTileByID(e) {
									return this._tiles[e];
								}
								_retainLoadedChildren(e, i, l, u) {
									for (const d in this._tiles) {
										let g = this._tiles[d];
										if (
											u[d] ||
											!g.hasData() ||
											g.tileID.overscaledZ <= i ||
											g.tileID.overscaledZ > l
										)
											continue;
										let w = g.tileID;
										for (; g && g.tileID.overscaledZ > i + 1; ) {
											const P = g.tileID.scaledTo(g.tileID.overscaledZ - 1);
											(g = this._tiles[P.key]), g && g.hasData() && (w = P);
										}
										let C = w;
										for (; C.overscaledZ > i; )
											if (
												((C = C.scaledTo(C.overscaledZ - 1)),
												e[C.key] || e[C.canonical.key])
											) {
												u[w.key] = w;
												break;
											}
									}
								}
								findLoadedParent(e, i) {
									if (e.key in this._loadedParentTiles) {
										const l = this._loadedParentTiles[e.key];
										return l && l.tileID.overscaledZ >= i ? l : null;
									}
									for (let l = e.overscaledZ - 1; l >= i; l--) {
										const u = e.scaledTo(l),
											d = this._getLoadedTile(u);
										if (d) return d;
									}
								}
								findLoadedSibling(e) {
									return this._getLoadedTile(e);
								}
								_getLoadedTile(e) {
									const i = this._tiles[e.key];
									return i && i.hasData()
										? i
										: this._cache.getByKey(e.wrapped().key);
								}
								updateCacheSize(e) {
									const i = Math.ceil(e.width / this._source.tileSize) + 1,
										l = Math.ceil(e.height / this._source.tileSize) + 1,
										u = Math.floor(
											i *
												l *
												(this._maxTileCacheZoomLevels === null
													? s.a.MAX_TILE_CACHE_ZOOM_LEVELS
													: this._maxTileCacheZoomLevels)
										),
										d =
											typeof this._maxTileCacheSize == "number"
												? Math.min(this._maxTileCacheSize, u)
												: u;
									this._cache.setMaxSize(d);
								}
								handleWrapJump(e) {
									const i = Math.round(
										(e - (this._prevLng === void 0 ? e : this._prevLng)) / 360
									);
									if (((this._prevLng = e), i)) {
										const l = {};
										for (const u in this._tiles) {
											const d = this._tiles[u];
											(d.tileID = d.tileID.unwrapTo(d.tileID.wrap + i)),
												(l[d.tileID.key] = d);
										}
										this._tiles = l;
										for (const u in this._timers)
											clearTimeout(this._timers[u]), delete this._timers[u];
										for (const u in this._tiles)
											this._setTileReloadTimer(u, this._tiles[u]);
									}
								}
								_updateCoveredAndRetainedTiles(e, i, l, u, d, g) {
									const w = {},
										C = {},
										P = Object.keys(e),
										E = ne.now();
									for (const R of P) {
										const D = e[R],
											N = this._tiles[R];
										if (!N || (N.fadeEndTime !== 0 && N.fadeEndTime <= E))
											continue;
										const G = this.findLoadedParent(D, i),
											te = this.findLoadedSibling(D),
											Q = G || te || null;
										Q &&
											(this._addTile(Q.tileID), (w[Q.tileID.key] = Q.tileID)),
											(C[R] = D);
									}
									this._retainLoadedChildren(C, u, l, e);
									for (const R in w)
										e[R] || ((this._coveredTiles[R] = !0), (e[R] = w[R]));
									if (g) {
										const R = {},
											D = {};
										for (const N of d)
											this._tiles[N.key].hasData()
												? (R[N.key] = N)
												: (D[N.key] = N);
										for (const N in D) {
											const G = D[N].children(this._source.maxzoom);
											this._tiles[G[0].key] &&
												this._tiles[G[1].key] &&
												this._tiles[G[2].key] &&
												this._tiles[G[3].key] &&
												((R[G[0].key] = e[G[0].key] = G[0]),
												(R[G[1].key] = e[G[1].key] = G[1]),
												(R[G[2].key] = e[G[2].key] = G[2]),
												(R[G[3].key] = e[G[3].key] = G[3]),
												delete D[N]);
										}
										for (const N in D) {
											const G = D[N],
												te = this.findLoadedParent(G, this._source.minzoom),
												Q = this.findLoadedSibling(G),
												ae = te || Q || null;
											if (ae) {
												R[ae.tileID.key] = e[ae.tileID.key] = ae.tileID;
												for (const ce in R)
													R[ce].isChildOf(ae.tileID) && delete R[ce];
											}
										}
										for (const N in this._tiles)
											R[N] || (this._coveredTiles[N] = !0);
									}
								}
								update(e, i) {
									if (!this._sourceLoaded || this._paused) return;
									let l;
									(this.transform = e),
										(this.terrain = i),
										this.updateCacheSize(e),
										this.handleWrapJump(this.transform.center.lng),
										(this._coveredTiles = {}),
										this.used || this.usedForTerrain
											? this._source.tileID
												? (l = e
														.getVisibleUnwrappedCoordinates(this._source.tileID)
														.map(
															(E) =>
																new s.Z(
																	E.canonical.z,
																	E.wrap,
																	E.canonical.z,
																	E.canonical.x,
																	E.canonical.y
																)
														))
												: ((l = ye(e, {
														tileSize: this.usedForTerrain
															? this.tileSize
															: this._source.tileSize,
														minzoom: this._source.minzoom,
														maxzoom: this._source.maxzoom,
														roundZoom:
															!this.usedForTerrain && this._source.roundZoom,
														reparseOverscaled: this._source.reparseOverscaled,
														terrain: i,
														calculateTileZoom: this._source.calculateTileZoom,
												  })),
												  this._source.hasTile &&
														(l = l.filter((E) => this._source.hasTile(E))))
											: (l = []);
									const u = kt(e, this._source),
										d = Math.max(u - rr.maxOverzooming, this._source.minzoom),
										g = Math.max(u + rr.maxUnderzooming, this._source.minzoom);
									if (this.usedForTerrain) {
										const E = {};
										for (const R of l)
											if (R.canonical.z > this._source.minzoom) {
												const D = R.scaledTo(R.canonical.z - 1);
												E[D.key] = D;
												const N = R.scaledTo(
													Math.max(
														this._source.minzoom,
														Math.min(R.canonical.z, 5)
													)
												);
												E[N.key] = N;
											}
										l = l.concat(Object.values(E));
									}
									const w =
										l.length === 0 && !this._updated && this._didEmitContent;
									(this._updated = !0),
										w &&
											this.fire(
												new s.l("data", {
													sourceDataType: "idle",
													dataType: "source",
													sourceId: this.id,
												})
											);
									const C = this._updateRetainedTiles(l, u);
									gr(this._source.type) &&
										this._updateCoveredAndRetainedTiles(C, d, g, u, l, i);
									for (const E in C) this._tiles[E].clearFadeHold();
									const P = s.am(this._tiles, C);
									for (const E of P) {
										const R = this._tiles[E];
										R.hasSymbolBuckets && !R.holdingForFade()
											? R.setHoldDuration(this.map._fadeDuration)
											: (R.hasSymbolBuckets && !R.symbolFadeFinished()) ||
											  this._removeTile(E);
									}
									this._updateLoadedParentTileCache(),
										this._updateLoadedSiblingTileCache();
								}
								releaseSymbolFadeTiles() {
									for (const e in this._tiles)
										this._tiles[e].holdingForFade() && this._removeTile(e);
								}
								_updateRetainedTiles(e, i) {
									var l;
									const u = {},
										d = {},
										g = Math.max(i - rr.maxOverzooming, this._source.minzoom),
										w = Math.max(i + rr.maxUnderzooming, this._source.minzoom),
										C = {};
									for (const P of e) {
										const E = this._addTile(P);
										(u[P.key] = P),
											E.hasData() ||
												(i < this._source.maxzoom && (C[P.key] = P));
									}
									this._retainLoadedChildren(C, i, w, u);
									for (const P of e) {
										let E = this._tiles[P.key];
										if (E.hasData()) continue;
										if (i + 1 > this._source.maxzoom) {
											const D = P.children(this._source.maxzoom)[0],
												N = this.getTile(D);
											if (N && N.hasData()) {
												u[D.key] = D;
												continue;
											}
										} else {
											const D = P.children(this._source.maxzoom);
											if (
												u[D[0].key] &&
												u[D[1].key] &&
												u[D[2].key] &&
												u[D[3].key]
											)
												continue;
										}
										let R = E.wasRequested();
										for (let D = P.overscaledZ - 1; D >= g; --D) {
											const N = P.scaledTo(D);
											if (d[N.key]) break;
											if (
												((d[N.key] = !0),
												(E = this.getTile(N)),
												!E && R && (E = this._addTile(N)),
												E)
											) {
												const G = E.hasData();
												if (
													((G ||
														!(
															!((l = this.map) === null || l === void 0) &&
															l.cancelPendingTileRequestsWhileZooming
														) ||
														R) &&
														(u[N.key] = N),
													(R = E.wasRequested()),
													G)
												)
													break;
											}
										}
									}
									return u;
								}
								_updateLoadedParentTileCache() {
									this._loadedParentTiles = {};
									for (const e in this._tiles) {
										const i = [];
										let l,
											u = this._tiles[e].tileID;
										for (; u.overscaledZ > 0; ) {
											if (u.key in this._loadedParentTiles) {
												l = this._loadedParentTiles[u.key];
												break;
											}
											i.push(u.key);
											const d = u.scaledTo(u.overscaledZ - 1);
											if (((l = this._getLoadedTile(d)), l)) break;
											u = d;
										}
										for (const d of i) this._loadedParentTiles[d] = l;
									}
								}
								_updateLoadedSiblingTileCache() {
									this._loadedSiblingTiles = {};
									for (const e in this._tiles) {
										const i = this._tiles[e].tileID,
											l = this._getLoadedTile(i);
										this._loadedSiblingTiles[i.key] = l;
									}
								}
								_addTile(e) {
									let i = this._tiles[e.key];
									if (i) return i;
									(i = this._cache.getAndRemove(e)),
										i &&
											(this._setTileReloadTimer(e.key, i),
											(i.tileID = e),
											this._state.initializeTileState(
												i,
												this.map ? this.map.painter : null
											),
											this._cacheTimers[e.key] &&
												(clearTimeout(this._cacheTimers[e.key]),
												delete this._cacheTimers[e.key],
												this._setTileReloadTimer(e.key, i)));
									const l = i;
									return (
										i ||
											((i = new qr(
												e,
												this._source.tileSize * e.overscaleFactor()
											)),
											this._loadTile(i, e.key, i.state)),
										i.uses++,
										(this._tiles[e.key] = i),
										l ||
											this._source.fire(
												new s.l("dataloading", {
													tile: i,
													coord: i.tileID,
													dataType: "source",
												})
											),
										i
									);
								}
								_setTileReloadTimer(e, i) {
									e in this._timers &&
										(clearTimeout(this._timers[e]), delete this._timers[e]);
									const l = i.getExpiryTimeout();
									l &&
										(this._timers[e] = setTimeout(() => {
											this._reloadTile(e, "expired"), delete this._timers[e];
										}, l));
								}
								refreshTiles(e) {
									for (const i in this._tiles)
										(this._isIdRenderable(i) ||
											this._tiles[i].state == "errored") &&
											e.some((l) =>
												l.equals(this._tiles[i].tileID.canonical)
											) &&
											this._reloadTile(i, "expired");
								}
								_removeTile(e) {
									const i = this._tiles[e];
									i &&
										(i.uses--,
										delete this._tiles[e],
										this._timers[e] &&
											(clearTimeout(this._timers[e]), delete this._timers[e]),
										i.uses > 0 ||
											(i.hasData() && i.state !== "reloading"
												? this._cache.add(i.tileID, i, i.getExpiryTimeout())
												: ((i.aborted = !0),
												  this._abortTile(i),
												  this._unloadTile(i))));
								}
								_dataHandler(e) {
									const i = e.sourceDataType;
									e.dataType === "source" &&
										i === "metadata" &&
										(this._sourceLoaded = !0),
										this._sourceLoaded &&
											!this._paused &&
											e.dataType === "source" &&
											i === "content" &&
											(this.reload(e.sourceDataChanged),
											this.transform &&
												this.update(this.transform, this.terrain),
											(this._didEmitContent = !0));
								}
								clearTiles() {
									(this._shouldReloadOnResume = !1), (this._paused = !1);
									for (const e in this._tiles) this._removeTile(e);
									this._cache.reset();
								}
								tilesIn(e, i, l) {
									const u = [],
										d = this.transform;
									if (!d) return u;
									const g = d
											.getCoveringTilesDetailsProvider()
											.allowWorldCopies(),
										w = l ? d.getCameraQueryGeometry(e) : e,
										C = (N) =>
											d.screenPointToMercatorCoordinate(N, this.terrain),
										P = this.transformBbox(e, C, !g),
										E = this.transformBbox(w, C, !g),
										R = this.getIds(),
										D = s.a2.fromPoints(E);
									for (let N = 0; N < R.length; N++) {
										const G = this._tiles[R[N]];
										if (G.holdingForFade()) continue;
										const te = g
												? [G.tileID]
												: [G.tileID.unwrapTo(-1), G.tileID.unwrapTo(0)],
											Q = Math.pow(2, d.zoom - G.tileID.overscaledZ),
											ae = (i * G.queryPadding * s.$) / G.tileSize / Q;
										for (const ce of te) {
											const ve = D.map((me) =>
												ce.getTilePoint(new s.a1(me.x, me.y))
											);
											if ((ve.expandBy(ae), ve.intersects(Bt))) {
												const me = P.map((Pe) => ce.getTilePoint(Pe)),
													be = E.map((Pe) => ce.getTilePoint(Pe));
												u.push({
													tile: G,
													tileID: g ? ce : ce.unwrapTo(0),
													queryGeometry: me,
													cameraQueryGeometry: be,
													scale: Q,
												});
											}
										}
									}
									return u;
								}
								transformBbox(e, i, l) {
									let u = e.map(i);
									if (l) {
										const d = s.a2.fromPoints(e);
										d.shrinkBy(0.001 * Math.min(d.width(), d.height()));
										const g = d.map(i);
										s.a2.fromPoints(u).covers(g) ||
											(u = u.map((w) =>
												w.x > 0.5 ? new s.a1(w.x - 1, w.y, w.z) : w
											));
									}
									return u;
								}
								getVisibleCoordinates(e) {
									const i = this.getRenderableIds(e).map(
										(l) => this._tiles[l].tileID
									);
									return this.transform && this.transform.populateCache(i), i;
								}
								hasTransition() {
									if (this._source.hasTransition()) return !0;
									if (gr(this._source.type)) {
										const e = ne.now();
										for (const i in this._tiles)
											if (this._tiles[i].fadeEndTime >= e) return !0;
									}
									return !1;
								}
								setFeatureState(e, i, l) {
									this._state.updateState((e = e || "_geojsonTileLayer"), i, l);
								}
								removeFeatureState(e, i, l) {
									this._state.removeFeatureState(
										(e = e || "_geojsonTileLayer"),
										i,
										l
									);
								}
								getFeatureState(e, i) {
									return this._state.getState(
										(e = e || "_geojsonTileLayer"),
										i
									);
								}
								setDependencies(e, i, l) {
									const u = this._tiles[e];
									u && u.setDependencies(i, l);
								}
								reloadTilesForDependencies(e, i) {
									for (const l in this._tiles)
										this._tiles[l].hasDependency(e, i) &&
											this._reloadTile(l, "reloading");
									this._cache.filter((l) => !l.hasDependency(e, i));
								}
							}
							function Kt(h, e) {
								const i = Math.abs(2 * h.wrap) - +(h.wrap < 0),
									l = Math.abs(2 * e.wrap) - +(e.wrap < 0);
								return (
									h.overscaledZ - e.overscaledZ ||
									l - i ||
									e.canonical.y - h.canonical.y ||
									e.canonical.x - h.canonical.x
								);
							}
							function gr(h) {
								return h === "raster" || h === "image" || h === "video";
							}
							(rr.maxOverzooming = 10), (rr.maxUnderzooming = 3);
							class Ur {
								constructor(e, i) {
									this.reset(e, i);
								}
								reset(e, i) {
									(this.points = e || []), (this._distances = [0]);
									for (let l = 1; l < this.points.length; l++)
										this._distances[l] =
											this._distances[l - 1] +
											this.points[l].dist(this.points[l - 1]);
									(this.length = this._distances[this._distances.length - 1]),
										(this.padding = Math.min(i || 0, 0.5 * this.length)),
										(this.paddedLength = this.length - 2 * this.padding);
								}
								lerp(e) {
									if (this.points.length === 1) return this.points[0];
									e = s.ah(e, 0, 1);
									let i = 1,
										l = this._distances[i];
									const u = e * this.paddedLength + this.padding;
									for (; l < u && i < this._distances.length; )
										l = this._distances[++i];
									const d = i - 1,
										g = this._distances[d],
										w = l - g,
										C = w > 0 ? (u - g) / w : 0;
									return this.points[d].mult(1 - C).add(this.points[i].mult(C));
								}
							}
							function nn(h, e) {
								let i = !0;
								return (
									h === "always" ||
										(h !== "never" && e !== "never") ||
										(i = !1),
									i
								);
							}
							class mn {
								constructor(e, i, l) {
									const u = (this.boxCells = []),
										d = (this.circleCells = []);
									(this.xCellCount = Math.ceil(e / l)),
										(this.yCellCount = Math.ceil(i / l));
									for (let g = 0; g < this.xCellCount * this.yCellCount; g++)
										u.push([]), d.push([]);
									(this.circleKeys = []),
										(this.boxKeys = []),
										(this.bboxes = []),
										(this.circles = []),
										(this.width = e),
										(this.height = i),
										(this.xScale = this.xCellCount / e),
										(this.yScale = this.yCellCount / i),
										(this.boxUid = 0),
										(this.circleUid = 0);
								}
								keysLength() {
									return this.boxKeys.length + this.circleKeys.length;
								}
								insert(e, i, l, u, d) {
									this._forEachCell(
										i,
										l,
										u,
										d,
										this._insertBoxCell,
										this.boxUid++
									),
										this.boxKeys.push(e),
										this.bboxes.push(i),
										this.bboxes.push(l),
										this.bboxes.push(u),
										this.bboxes.push(d);
								}
								insertCircle(e, i, l, u) {
									this._forEachCell(
										i - u,
										l - u,
										i + u,
										l + u,
										this._insertCircleCell,
										this.circleUid++
									),
										this.circleKeys.push(e),
										this.circles.push(i),
										this.circles.push(l),
										this.circles.push(u);
								}
								_insertBoxCell(e, i, l, u, d, g) {
									this.boxCells[d].push(g);
								}
								_insertCircleCell(e, i, l, u, d, g) {
									this.circleCells[d].push(g);
								}
								_query(e, i, l, u, d, g, w) {
									if (l < 0 || e > this.width || u < 0 || i > this.height)
										return [];
									const C = [];
									if (e <= 0 && i <= 0 && this.width <= l && this.height <= u) {
										if (d) return [{ key: null, x1: e, y1: i, x2: l, y2: u }];
										for (let P = 0; P < this.boxKeys.length; P++)
											C.push({
												key: this.boxKeys[P],
												x1: this.bboxes[4 * P],
												y1: this.bboxes[4 * P + 1],
												x2: this.bboxes[4 * P + 2],
												y2: this.bboxes[4 * P + 3],
											});
										for (let P = 0; P < this.circleKeys.length; P++) {
											const E = this.circles[3 * P],
												R = this.circles[3 * P + 1],
												D = this.circles[3 * P + 2];
											C.push({
												key: this.circleKeys[P],
												x1: E - D,
												y1: R - D,
												x2: E + D,
												y2: R + D,
											});
										}
									} else this._forEachCell(e, i, l, u, this._queryCell, C, { hitTest: d, overlapMode: g, seenUids: { box: {}, circle: {} } }, w);
									return C;
								}
								query(e, i, l, u) {
									return this._query(e, i, l, u, !1, null);
								}
								hitTest(e, i, l, u, d, g) {
									return this._query(e, i, l, u, !0, d, g).length > 0;
								}
								hitTestCircle(e, i, l, u, d) {
									const g = e - l,
										w = e + l,
										C = i - l,
										P = i + l;
									if (w < 0 || g > this.width || P < 0 || C > this.height)
										return !1;
									const E = [];
									return (
										this._forEachCell(
											g,
											C,
											w,
											P,
											this._queryCellCircle,
											E,
											{
												hitTest: !0,
												overlapMode: u,
												circle: { x: e, y: i, radius: l },
												seenUids: { box: {}, circle: {} },
											},
											d
										),
										E.length > 0
									);
								}
								_queryCell(e, i, l, u, d, g, w, C) {
									const { seenUids: P, hitTest: E, overlapMode: R } = w,
										D = this.boxCells[d];
									if (D !== null) {
										const G = this.bboxes;
										for (const te of D)
											if (!P.box[te]) {
												P.box[te] = !0;
												const Q = 4 * te,
													ae = this.boxKeys[te];
												if (
													e <= G[Q + 2] &&
													i <= G[Q + 3] &&
													l >= G[Q + 0] &&
													u >= G[Q + 1] &&
													(!C || C(ae)) &&
													(!E || !nn(R, ae.overlapMode)) &&
													(g.push({
														key: ae,
														x1: G[Q],
														y1: G[Q + 1],
														x2: G[Q + 2],
														y2: G[Q + 3],
													}),
													E)
												)
													return !0;
											}
									}
									const N = this.circleCells[d];
									if (N !== null) {
										const G = this.circles;
										for (const te of N)
											if (!P.circle[te]) {
												P.circle[te] = !0;
												const Q = 3 * te,
													ae = this.circleKeys[te];
												if (
													this._circleAndRectCollide(
														G[Q],
														G[Q + 1],
														G[Q + 2],
														e,
														i,
														l,
														u
													) &&
													(!C || C(ae)) &&
													(!E || !nn(R, ae.overlapMode))
												) {
													const ce = G[Q],
														ve = G[Q + 1],
														me = G[Q + 2];
													if (
														(g.push({
															key: ae,
															x1: ce - me,
															y1: ve - me,
															x2: ce + me,
															y2: ve + me,
														}),
														E)
													)
														return !0;
												}
											}
									}
									return !1;
								}
								_queryCellCircle(e, i, l, u, d, g, w, C) {
									const { circle: P, seenUids: E, overlapMode: R } = w,
										D = this.boxCells[d];
									if (D !== null) {
										const G = this.bboxes;
										for (const te of D)
											if (!E.box[te]) {
												E.box[te] = !0;
												const Q = 4 * te,
													ae = this.boxKeys[te];
												if (
													this._circleAndRectCollide(
														P.x,
														P.y,
														P.radius,
														G[Q + 0],
														G[Q + 1],
														G[Q + 2],
														G[Q + 3]
													) &&
													(!C || C(ae)) &&
													!nn(R, ae.overlapMode)
												)
													return g.push(!0), !0;
											}
									}
									const N = this.circleCells[d];
									if (N !== null) {
										const G = this.circles;
										for (const te of N)
											if (!E.circle[te]) {
												E.circle[te] = !0;
												const Q = 3 * te,
													ae = this.circleKeys[te];
												if (
													this._circlesCollide(
														G[Q],
														G[Q + 1],
														G[Q + 2],
														P.x,
														P.y,
														P.radius
													) &&
													(!C || C(ae)) &&
													!nn(R, ae.overlapMode)
												)
													return g.push(!0), !0;
											}
									}
								}
								_forEachCell(e, i, l, u, d, g, w, C) {
									const P = this._convertToXCellCoord(e),
										E = this._convertToYCellCoord(i),
										R = this._convertToXCellCoord(l),
										D = this._convertToYCellCoord(u);
									for (let N = P; N <= R; N++)
										for (let G = E; G <= D; G++)
											if (
												d.call(
													this,
													e,
													i,
													l,
													u,
													this.xCellCount * G + N,
													g,
													w,
													C
												)
											)
												return;
								}
								_convertToXCellCoord(e) {
									return Math.max(
										0,
										Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))
									);
								}
								_convertToYCellCoord(e) {
									return Math.max(
										0,
										Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))
									);
								}
								_circlesCollide(e, i, l, u, d, g) {
									const w = u - e,
										C = d - i,
										P = l + g;
									return P * P > w * w + C * C;
								}
								_circleAndRectCollide(e, i, l, u, d, g, w) {
									const C = (g - u) / 2,
										P = Math.abs(e - (u + C));
									if (P > C + l) return !1;
									const E = (w - d) / 2,
										R = Math.abs(i - (d + E));
									if (R > E + l) return !1;
									if (P <= C || R <= E) return !0;
									const D = P - C,
										N = R - E;
									return D * D + N * N <= l * l;
								}
							}
							function _n(h, e, i) {
								const l = s.L();
								if (!h) {
									const { vecSouth: R, vecEast: D } = Et(e),
										N = O();
									(N[0] = D[0]),
										(N[1] = D[1]),
										(N[2] = R[0]),
										(N[3] = R[1]),
										(u = N),
										(E =
											(g = (d = N)[0]) * (P = d[3]) -
											(C = d[2]) * (w = d[1])) &&
											((u[0] = P * (E = 1 / E)),
											(u[1] = -w * E),
											(u[2] = -C * E),
											(u[3] = g * E)),
										(l[0] = N[0]),
										(l[1] = N[1]),
										(l[4] = N[2]),
										(l[5] = N[3]);
								}
								var u, d, g, w, C, P, E;
								return s.N(l, l, [1 / i, 1 / i, 1]), l;
							}
							function Vt(h, e, i, l) {
								if (h) {
									const u = s.L();
									if (!e) {
										const { vecSouth: d, vecEast: g } = Et(i);
										(u[0] = g[0]), (u[1] = g[1]), (u[4] = d[0]), (u[5] = d[1]);
									}
									return s.N(u, u, [l, l, 1]), u;
								}
								return i.pixelsToClipSpaceMatrix;
							}
							function Et(h) {
								const e = Math.cos(h.rollInRadians),
									i = Math.sin(h.rollInRadians),
									l = Math.cos(h.pitchInRadians),
									u = Math.cos(h.bearingInRadians),
									d = Math.sin(h.bearingInRadians),
									g = s.ar();
								(g[0] = -u * l * i - d * e), (g[1] = -d * l * i + u * e);
								const w = s.as(g);
								w < 1e-9 ? s.at(g) : s.au(g, g, 1 / w);
								const C = s.ar();
								(C[0] = u * l * e - d * i), (C[1] = d * l * e + u * i);
								const P = s.as(C);
								return (
									P < 1e-9 ? s.at(C) : s.au(C, C, 1 / P),
									{ vecEast: C, vecSouth: g }
								);
							}
							function dr(h, e, i, l) {
								let u;
								l
									? ((u = [h, e, l(h, e), 1]), s.aw(u, u, i))
									: ((u = [h, e, 0, 1]), En(u, u, i));
								const d = u[3];
								return {
									point: new s.P(u[0] / d, u[1] / d),
									signedDistanceFromCamera: d,
									isOccluded: !1,
								};
							}
							function ht(h, e) {
								return 0.5 + (h / e) * 0.5;
							}
							function Xr(h, e) {
								return (
									h.x >= -e[0] && h.x <= e[0] && h.y >= -e[1] && h.y <= e[1]
								);
							}
							function Yr(h, e, i, l, u, d, g, w, C, P, E, R, D) {
								const N = i ? h.textSizeData : h.iconSizeData,
									G = s.an(N, e.transform.zoom),
									te = [(256 / e.width) * 2 + 1, (256 / e.height) * 2 + 1],
									Q = i
										? h.text.dynamicLayoutVertexArray
										: h.icon.dynamicLayoutVertexArray;
								Q.clear();
								const ae = h.lineVertexArray,
									ce = i ? h.text.placedSymbolArray : h.icon.placedSymbolArray,
									ve = e.transform.width / e.transform.height;
								let me = !1;
								for (let be = 0; be < ce.length; be++) {
									const Pe = ce.get(be);
									if (Pe.hidden || (Pe.writingMode === s.ao.vertical && !me)) {
										ln(Pe.numGlyphs, Q);
										continue;
									}
									me = !1;
									const _e = new s.P(Pe.anchorX, Pe.anchorY),
										Be = {
											getElevation: D,
											pitchedLabelPlaneMatrix: l,
											lineVertexArray: ae,
											pitchWithMap: d,
											projectionCache: {
												projections: {},
												offsets: {},
												cachedAnchorPoint: void 0,
												anyProjectionOccluded: !1,
											},
											transform: e.transform,
											tileAnchorPoint: _e,
											unwrappedTileID: C,
											width: P,
											height: E,
											translation: R,
										},
										rt = Er(Pe.anchorX, Pe.anchorY, Be);
									if (!Xr(rt.point, te)) {
										ln(Pe.numGlyphs, Q);
										continue;
									}
									const Ge = ht(
											e.transform.cameraToCenterDistance,
											rt.signedDistanceFromCamera
										),
										Xe = s.ap(N, G, Pe),
										tt = d
											? (Xe *
													e.transform.getPitchedTextCorrection(
														Pe.anchorX,
														Pe.anchorY,
														C
													)) /
											  Ge
											: Xe * Ge,
										jt = He({
											projectionContext: Be,
											pitchedLabelPlaneMatrixInverse: u,
											symbol: Pe,
											fontSize: tt,
											flip: !1,
											keepUpright: g,
											glyphOffsetArray: h.glyphOffsetArray,
											dynamicLayoutVertexArray: Q,
											aspectRatio: ve,
											rotateToLine: w,
										});
									(me = jt.useVertical),
										(jt.notEnoughRoom ||
											me ||
											(jt.needsFlipping &&
												He({
													projectionContext: Be,
													pitchedLabelPlaneMatrixInverse: u,
													symbol: Pe,
													fontSize: tt,
													flip: !0,
													keepUpright: g,
													glyphOffsetArray: h.glyphOffsetArray,
													dynamicLayoutVertexArray: Q,
													aspectRatio: ve,
													rotateToLine: w,
												}).notEnoughRoom)) &&
											ln(Pe.numGlyphs, Q);
								}
								i
									? h.text.dynamicLayoutVertexBuffer.updateData(Q)
									: h.icon.dynamicLayoutVertexBuffer.updateData(Q);
							}
							function Zr(h, e, i, l, u, d, g, w) {
								const C = d.glyphStartIndex + d.numGlyphs,
									P = d.lineStartIndex,
									E = d.lineStartIndex + d.lineLength,
									R = e.getoffsetX(d.glyphStartIndex),
									D = e.getoffsetX(C - 1),
									N = pn(h * R, i, l, u, d.segment, P, E, w, g);
								if (!N) return null;
								const G = pn(h * D, i, l, u, d.segment, P, E, w, g);
								return G
									? w.projectionCache.anyProjectionOccluded
										? null
										: { first: N, last: G }
									: null;
							}
							function mt(h, e, i, l) {
								return h === s.ao.horizontal &&
									Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * l
									? { useVertical: !0 }
									: (h === s.ao.vertical ? e.y < i.y : e.x > i.x)
									? { needsFlipping: !0 }
									: null;
							}
							function He(h) {
								const {
										projectionContext: e,
										pitchedLabelPlaneMatrixInverse: i,
										symbol: l,
										fontSize: u,
										flip: d,
										keepUpright: g,
										glyphOffsetArray: w,
										dynamicLayoutVertexArray: C,
										aspectRatio: P,
										rotateToLine: E,
									} = h,
									R = u / 24,
									D = l.lineOffsetX * R,
									N = l.lineOffsetY * R;
								let G;
								if (l.numGlyphs > 1) {
									const te = l.glyphStartIndex + l.numGlyphs,
										Q = l.lineStartIndex,
										ae = l.lineStartIndex + l.lineLength,
										ce = Zr(R, w, D, N, d, l, E, e);
									if (!ce) return { notEnoughRoom: !0 };
									const ve = Cr(ce.first.point.x, ce.first.point.y, e, i),
										me = Cr(ce.last.point.x, ce.last.point.y, e, i);
									if (g && !d) {
										const be = mt(l.writingMode, ve, me, P);
										if (be) return be;
									}
									G = [ce.first];
									for (let be = l.glyphStartIndex + 1; be < te - 1; be++) {
										const Pe = pn(
											R * w.getoffsetX(be),
											D,
											N,
											d,
											l.segment,
											Q,
											ae,
											e,
											E
										);
										if (!Pe) return { notEnoughRoom: !0 };
										G.push(Pe);
									}
									G.push(ce.last);
								} else {
									if (g && !d) {
										const Q = Jt(
												e.tileAnchorPoint.x,
												e.tileAnchorPoint.y,
												e
											).point,
											ae = l.lineStartIndex + l.segment + 1,
											ce = new s.P(
												e.lineVertexArray.getx(ae),
												e.lineVertexArray.gety(ae)
											),
											ve = Jt(ce.x, ce.y, e),
											me =
												ve.signedDistanceFromCamera > 0
													? ve.point
													: At(e.tileAnchorPoint, ce, Q, 1, e),
											be = Cr(Q.x, Q.y, e, i),
											Pe = Cr(me.x, me.y, e, i),
											_e = mt(l.writingMode, be, Pe, P);
										if (_e) return _e;
									}
									const te = pn(
										R * w.getoffsetX(l.glyphStartIndex),
										D,
										N,
										d,
										l.segment,
										l.lineStartIndex,
										l.lineStartIndex + l.lineLength,
										e,
										E
									);
									if (!te || e.projectionCache.anyProjectionOccluded)
										return { notEnoughRoom: !0 };
									G = [te];
								}
								for (const te of G) s.av(C, te.point, te.angle);
								return {};
							}
							function At(h, e, i, l, u) {
								const d = h.add(h.sub(e)._unit()),
									g = Jt(d.x, d.y, u).point,
									w = i.sub(g);
								return i.add(w._mult(l / w.mag()));
							}
							function Ft(h, e, i) {
								const l = e.projectionCache;
								if (l.projections[h]) return l.projections[h];
								const u = new s.P(
										e.lineVertexArray.getx(h),
										e.lineVertexArray.gety(h)
									),
									d = Jt(u.x, u.y, e);
								if (d.signedDistanceFromCamera > 0)
									return (
										(l.projections[h] = d.point),
										(l.anyProjectionOccluded =
											l.anyProjectionOccluded || d.isOccluded),
										d.point
									);
								const g = h - i.direction;
								return At(
									i.distanceFromAnchor === 0
										? e.tileAnchorPoint
										: new s.P(
												e.lineVertexArray.getx(g),
												e.lineVertexArray.gety(g)
										  ),
									u,
									i.previousVertex,
									i.absOffsetX - i.distanceFromAnchor + 1,
									e
								);
							}
							function Jt(h, e, i) {
								const l = h + i.translation[0],
									u = e + i.translation[1];
								let d;
								return (
									i.pitchWithMap
										? ((d = dr(
												l,
												u,
												i.pitchedLabelPlaneMatrix,
												i.getElevation
										  )),
										  (d.isOccluded = !1))
										: ((d = i.transform.projectTileCoordinates(
												l,
												u,
												i.unwrappedTileID,
												i.getElevation
										  )),
										  (d.point.x = (0.5 * d.point.x + 0.5) * i.width),
										  (d.point.y = (0.5 * -d.point.y + 0.5) * i.height)),
									d
								);
							}
							function Cr(h, e, i, l) {
								if (i.pitchWithMap) {
									const u = [h, e, 0, 1];
									return (
										s.aw(u, u, l),
										i.transform.projectTileCoordinates(
											u[0] / u[3],
											u[1] / u[3],
											i.unwrappedTileID,
											i.getElevation
										).point
									);
								}
								return { x: (h / i.width) * 2 - 1, y: 1 - (e / i.height) * 2 };
							}
							function Er(h, e, i) {
								return i.transform.projectTileCoordinates(
									h,
									e,
									i.unwrappedTileID,
									i.getElevation
								);
							}
							function ur(h, e, i) {
								return h
									._unit()
									._perp()
									._mult(e * i);
							}
							function rn(h, e, i, l, u, d, g, w, C) {
								if (w.projectionCache.offsets[h])
									return w.projectionCache.offsets[h];
								const P = i.add(e);
								if (h + C.direction < l || h + C.direction >= u)
									return (w.projectionCache.offsets[h] = P), P;
								const E = Ft(h + C.direction, w, C),
									R = ur(E.sub(i), g, C.direction),
									D = i.add(R),
									N = E.add(R);
								return (
									(w.projectionCache.offsets[h] = s.ax(d, P, D, N) || P),
									w.projectionCache.offsets[h]
								);
							}
							function pn(h, e, i, l, u, d, g, w, C) {
								const P = l ? h - e : h + e;
								let E = P > 0 ? 1 : -1,
									R = 0;
								l && ((E *= -1), (R = Math.PI)), E < 0 && (R += Math.PI);
								let D,
									N = E > 0 ? d + u : d + u + 1;
								w.projectionCache.cachedAnchorPoint
									? (D = w.projectionCache.cachedAnchorPoint)
									: ((D = Jt(
											w.tileAnchorPoint.x,
											w.tileAnchorPoint.y,
											w
									  ).point),
									  (w.projectionCache.cachedAnchorPoint = D));
								let G,
									te,
									Q = D,
									ae = D,
									ce = 0,
									ve = 0;
								const me = Math.abs(P),
									be = [];
								let Pe;
								for (; ce + ve <= me; ) {
									if (((N += E), N < d || N >= g)) return null;
									(ce += ve), (ae = Q), (te = G);
									const rt = {
										absOffsetX: me,
										direction: E,
										distanceFromAnchor: ce,
										previousVertex: ae,
									};
									if (((Q = Ft(N, w, rt)), i === 0))
										be.push(ae), (Pe = Q.sub(ae));
									else {
										let Ge;
										const Xe = Q.sub(ae);
										(Ge =
											Xe.mag() === 0
												? ur(Ft(N + E, w, rt).sub(Q), i, E)
												: ur(Xe, i, E)),
											te || (te = ae.add(Ge)),
											(G = rn(N, Ge, Q, d, g, te, i, w, rt)),
											be.push(te),
											(Pe = G.sub(te));
									}
									ve = Pe.mag();
								}
								const _e = Pe._mult((me - ce) / ve)._add(te || ae),
									Be = R + Math.atan2(Q.y - ae.y, Q.x - ae.x);
								return be.push(_e), { point: _e, angle: C ? Be : 0, path: be };
							}
							const gn = new Float32Array([
								-1 / 0,
								-1 / 0,
								0,
								-1 / 0,
								-1 / 0,
								0,
								-1 / 0,
								-1 / 0,
								0,
								-1 / 0,
								-1 / 0,
								0,
							]);
							function ln(h, e) {
								for (let i = 0; i < h; i++) {
									const l = e.length;
									e.resize(l + 4), e.float32.set(gn, 3 * l);
								}
							}
							function En(h, e, i) {
								const l = e[0],
									u = e[1];
								return (
									(h[0] = i[0] * l + i[4] * u + i[12]),
									(h[1] = i[1] * l + i[5] * u + i[13]),
									(h[3] = i[3] * l + i[7] * u + i[15]),
									h
								);
							}
							const pr = 100;
							class In {
								constructor(
									e,
									i = new mn(e.width + 200, e.height + 200, 25),
									l = new mn(e.width + 200, e.height + 200, 25)
								) {
									(this.transform = e),
										(this.grid = i),
										(this.ignoredGrid = l),
										(this.pitchFactor =
											Math.cos((e.pitch * Math.PI) / 180) *
											e.cameraToCenterDistance),
										(this.screenRightBoundary = e.width + pr),
										(this.screenBottomBoundary = e.height + pr),
										(this.gridRightBoundary = e.width + 200),
										(this.gridBottomBoundary = e.height + 200),
										(this.perspectiveRatioCutoff = 0.6);
								}
								placeCollisionBox(e, i, l, u, d, g, w, C, P, E, R, D) {
									const N = this.projectAndGetPerspectiveRatio(
											e.anchorPointX + C[0],
											e.anchorPointY + C[1],
											d,
											E,
											D
										),
										G = l * N.perspectiveRatio;
									let te;
									if (g || w)
										te = this._projectCollisionBox(
											e,
											G,
											u,
											d,
											g,
											w,
											C,
											N,
											E,
											R,
											D
										);
									else {
										const Pe = N.x + (R ? R.x * G : 0),
											_e = N.y + (R ? R.y * G : 0);
										te = {
											allPointsOccluded: !1,
											box: [
												Pe + e.x1 * G,
												_e + e.y1 * G,
												Pe + e.x2 * G,
												_e + e.y2 * G,
											],
										};
									}
									const [Q, ae, ce, ve] = te.box,
										me = g ? te.allPointsOccluded : N.isOccluded;
									let be = me;
									return (
										be ||
											(be = N.perspectiveRatio < this.perspectiveRatioCutoff),
										be || (be = !this.isInsideGrid(Q, ae, ce, ve)),
										be ||
										(i !== "always" && this.grid.hitTest(Q, ae, ce, ve, i, P))
											? {
													box: [Q, ae, ce, ve],
													placeable: !1,
													offscreen: !1,
													occluded: me,
											  }
											: {
													box: [Q, ae, ce, ve],
													placeable: !0,
													offscreen: this.isOffscreen(Q, ae, ce, ve),
													occluded: me,
											  }
									);
								}
								placeCollisionCircles(
									e,
									i,
									l,
									u,
									d,
									g,
									w,
									C,
									P,
									E,
									R,
									D,
									N,
									G
								) {
									const te = [],
										Q = new s.P(i.anchorX, i.anchorY),
										ae = this.getPerspectiveRatio(Q.x, Q.y, g, G),
										ce =
											(P
												? (d *
														this.transform.getPitchedTextCorrection(
															i.anchorX,
															i.anchorY,
															g
														)) /
												  ae
												: d * ae) / s.aB,
										ve = {
											getElevation: G,
											pitchedLabelPlaneMatrix: w,
											lineVertexArray: l,
											pitchWithMap: P,
											projectionCache: {
												projections: {},
												offsets: {},
												cachedAnchorPoint: void 0,
												anyProjectionOccluded: !1,
											},
											transform: this.transform,
											tileAnchorPoint: Q,
											unwrappedTileID: g,
											width: this.transform.width,
											height: this.transform.height,
											translation: N,
										},
										me = Zr(
											ce,
											u,
											i.lineOffsetX * ce,
											i.lineOffsetY * ce,
											!1,
											i,
											!1,
											ve
										);
									let be = !1,
										Pe = !1,
										_e = !0;
									if (me) {
										const Be = 0.5 * R * ae + D,
											rt = new s.P(-100, -100),
											Ge = new s.P(
												this.screenRightBoundary,
												this.screenBottomBoundary
											),
											Xe = new Ur(),
											tt = me.first,
											jt = me.last;
										let Zt = [];
										for (let Jr = tt.path.length - 1; Jr >= 1; Jr--)
											Zt.push(tt.path[Jr]);
										for (let Jr = 1; Jr < jt.path.length; Jr++)
											Zt.push(jt.path[Jr]);
										const Tt = 2.5 * Be;
										if (P) {
											const Jr = this.projectPathToScreenSpace(Zt, ve);
											Zt = Jr.some((An) => An.signedDistanceFromCamera <= 0)
												? []
												: Jr.map((An) => An.point);
										}
										let vr = [];
										if (Zt.length > 0) {
											const Jr = Zt[0].clone(),
												An = Zt[0].clone();
											for (let Rn = 1; Rn < Zt.length; Rn++)
												(Jr.x = Math.min(Jr.x, Zt[Rn].x)),
													(Jr.y = Math.min(Jr.y, Zt[Rn].y)),
													(An.x = Math.max(An.x, Zt[Rn].x)),
													(An.y = Math.max(An.y, Zt[Rn].y));
											vr =
												Jr.x >= rt.x &&
												An.x <= Ge.x &&
												Jr.y >= rt.y &&
												An.y <= Ge.y
													? [Zt]
													: An.x < rt.x ||
													  Jr.x > Ge.x ||
													  An.y < rt.y ||
													  Jr.y > Ge.y
													? []
													: s.ay([Zt], rt.x, rt.y, Ge.x, Ge.y);
										}
										for (const Jr of vr) {
											Xe.reset(Jr, 0.25 * Be);
											let An = 0;
											An =
												Xe.length <= 0.5 * Be
													? 1
													: Math.ceil(Xe.paddedLength / Tt) + 1;
											for (let Rn = 0; Rn < An; Rn++) {
												const Ln = Rn / Math.max(An - 1, 1),
													Wn = Xe.lerp(Ln),
													Jn = Wn.x + pr,
													Kr = Wn.y + pr;
												te.push(Jn, Kr, Be, 0);
												const Bn = Jn - Be,
													si = Kr - Be,
													mi = Jn + Be,
													Ci = Kr + Be;
												if (
													((_e = _e && this.isOffscreen(Bn, si, mi, Ci)),
													(Pe = Pe || this.isInsideGrid(Bn, si, mi, Ci)),
													e !== "always" &&
														this.grid.hitTestCircle(Jn, Kr, Be, e, E) &&
														((be = !0), !C))
												)
													return {
														circles: [],
														offscreen: !1,
														collisionDetected: be,
													};
											}
										}
									}
									return {
										circles:
											(!C && be) || !Pe || ae < this.perspectiveRatioCutoff
												? []
												: te,
										offscreen: _e,
										collisionDetected: be,
									};
								}
								projectPathToScreenSpace(e, i) {
									const l = (function (u, d) {
										const g = s.L();
										return (
											s.aq(g, d.pitchedLabelPlaneMatrix),
											u.map((w) => {
												const C = dr(w.x, w.y, g, d.getElevation),
													P = d.transform.projectTileCoordinates(
														C.point.x,
														C.point.y,
														d.unwrappedTileID,
														d.getElevation
													);
												return (
													(P.point.x = (0.5 * P.point.x + 0.5) * d.width),
													(P.point.y = (0.5 * -P.point.y + 0.5) * d.height),
													P
												);
											})
										);
									})(e, i);
									return (function (u) {
										let d = 0,
											g = 0,
											w = 0,
											C = 0;
										for (let P = 0; P < u.length; P++)
											u[P].isOccluded
												? ((w = P + 1), (C = 0))
												: (C++, C > g && ((g = C), (d = w)));
										return u.slice(d, d + g);
									})(l);
								}
								queryRenderedSymbols(e) {
									if (
										e.length === 0 ||
										(this.grid.keysLength() === 0 &&
											this.ignoredGrid.keysLength() === 0)
									)
										return {};
									const i = [],
										l = new s.a2();
									for (const R of e) {
										const D = new s.P(R.x + pr, R.y + pr);
										l.extend(D), i.push(D);
									}
									const { minX: u, minY: d, maxX: g, maxY: w } = l,
										C = this.grid
											.query(u, d, g, w)
											.concat(this.ignoredGrid.query(u, d, g, w)),
										P = {},
										E = {};
									for (const R of C) {
										const D = R.key;
										if (
											(P[D.bucketInstanceId] === void 0 &&
												(P[D.bucketInstanceId] = {}),
											P[D.bucketInstanceId][D.featureIndex])
										)
											continue;
										const N = [
											new s.P(R.x1, R.y1),
											new s.P(R.x2, R.y1),
											new s.P(R.x2, R.y2),
											new s.P(R.x1, R.y2),
										];
										s.az(i, N) &&
											((P[D.bucketInstanceId][D.featureIndex] = !0),
											E[D.bucketInstanceId] === void 0 &&
												(E[D.bucketInstanceId] = []),
											E[D.bucketInstanceId].push(D.featureIndex));
									}
									return E;
								}
								insertCollisionBox(e, i, l, u, d, g) {
									(l ? this.ignoredGrid : this.grid).insert(
										{
											bucketInstanceId: u,
											featureIndex: d,
											collisionGroupID: g,
											overlapMode: i,
										},
										e[0],
										e[1],
										e[2],
										e[3]
									);
								}
								insertCollisionCircles(e, i, l, u, d, g) {
									const w = l ? this.ignoredGrid : this.grid,
										C = {
											bucketInstanceId: u,
											featureIndex: d,
											collisionGroupID: g,
											overlapMode: i,
										};
									for (let P = 0; P < e.length; P += 4)
										w.insertCircle(C, e[P], e[P + 1], e[P + 2]);
								}
								projectAndGetPerspectiveRatio(e, i, l, u, d) {
									if (d) {
										let g;
										u
											? ((g = [e, i, u(e, i), 1]), s.aw(g, g, d))
											: ((g = [e, i, 0, 1]), En(g, g, d));
										const w = g[3];
										return {
											x: ((g[0] / w + 1) / 2) * this.transform.width + pr,
											y: ((-g[1] / w + 1) / 2) * this.transform.height + pr,
											perspectiveRatio:
												0.5 + (this.transform.cameraToCenterDistance / w) * 0.5,
											isOccluded: !1,
											signedDistanceFromCamera: w,
										};
									}
									{
										const g = this.transform.projectTileCoordinates(e, i, l, u);
										return {
											x: ((g.point.x + 1) / 2) * this.transform.width + pr,
											y: ((1 - g.point.y) / 2) * this.transform.height + pr,
											perspectiveRatio:
												0.5 +
												(this.transform.cameraToCenterDistance /
													g.signedDistanceFromCamera) *
													0.5,
											isOccluded: g.isOccluded,
											signedDistanceFromCamera: g.signedDistanceFromCamera,
										};
									}
								}
								getPerspectiveRatio(e, i, l, u) {
									const d = this.transform.projectTileCoordinates(e, i, l, u);
									return (
										0.5 +
										(this.transform.cameraToCenterDistance /
											d.signedDistanceFromCamera) *
											0.5
									);
								}
								isOffscreen(e, i, l, u) {
									return (
										l < pr ||
										e >= this.screenRightBoundary ||
										u < pr ||
										i > this.screenBottomBoundary
									);
								}
								isInsideGrid(e, i, l, u) {
									return (
										l >= 0 &&
										e < this.gridRightBoundary &&
										u >= 0 &&
										i < this.gridBottomBoundary
									);
								}
								getViewportMatrix() {
									const e = s.ag([]);
									return s.M(e, e, [-100, -100, 0]), e;
								}
								_projectCollisionBox(e, i, l, u, d, g, w, C, P, E, R) {
									let D = 1,
										N = 0,
										G = 0,
										te = 1;
									const Q = e.anchorPointX + w[0],
										ae = e.anchorPointY + w[1];
									if (g && !d) {
										const Zt = this.projectAndGetPerspectiveRatio(
												Q + 1,
												ae,
												u,
												P,
												R
											),
											Tt = Zt.x - C.x,
											vr =
												Math.atan((Zt.y - C.y) / Tt) + (Tt < 0 ? Math.PI : 0),
											Jr = Math.sin(vr),
											An = Math.cos(vr);
										(D = An), (N = Jr), (G = -Jr), (te = An);
									} else if (!g && d) {
										const Zt = Et(this.transform);
										(D = Zt.vecEast[0]),
											(N = Zt.vecEast[1]),
											(G = Zt.vecSouth[0]),
											(te = Zt.vecSouth[1]);
									}
									let ce = C.x,
										ve = C.y,
										me = i;
									d &&
										((ce = Q),
										(ve = ae),
										(me = Math.pow(2, -(this.transform.zoom - l.overscaledZ))),
										(me *= this.transform.getPitchedTextCorrection(Q, ae, u)),
										E ||
											(me *= s.ah(
												0.5 +
													(C.signedDistanceFromCamera /
														this.transform.cameraToCenterDistance) *
														0.5,
												0,
												4
											))),
										E &&
											((ce += D * E.x * me + G * E.y * me),
											(ve += N * E.x * me + te * E.y * me));
									const be = e.x1 * me,
										Pe = e.x2 * me,
										_e = (be + Pe) / 2,
										Be = e.y1 * me,
										rt = e.y2 * me,
										Ge = (Be + rt) / 2,
										Xe = [
											{ offsetX: be, offsetY: Be },
											{ offsetX: _e, offsetY: Be },
											{ offsetX: Pe, offsetY: Be },
											{ offsetX: Pe, offsetY: Ge },
											{ offsetX: Pe, offsetY: rt },
											{ offsetX: _e, offsetY: rt },
											{ offsetX: be, offsetY: rt },
											{ offsetX: be, offsetY: Ge },
										];
									let tt = [];
									for (const { offsetX: Zt, offsetY: Tt } of Xe)
										tt.push(
											new s.P(ce + D * Zt + G * Tt, ve + N * Zt + te * Tt)
										);
									let jt = !1;
									if (d) {
										const Zt = tt.map((Tt) =>
											this.projectAndGetPerspectiveRatio(Tt.x, Tt.y, u, P, R)
										);
										(jt = Zt.some((Tt) => !Tt.isOccluded)),
											(tt = Zt.map((Tt) => new s.P(Tt.x, Tt.y)));
									} else jt = !0;
									return { box: s.aA(tt), allPointsOccluded: !jt };
								}
							}
							class tn {
								constructor(e, i, l, u) {
									(this.opacity = e
										? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i)))
										: u && l
										? 1
										: 0),
										(this.placed = l);
								}
								isHidden() {
									return this.opacity === 0 && !this.placed;
								}
							}
							class en {
								constructor(e, i, l, u, d) {
									(this.text = new tn(e ? e.text : null, i, l, d)),
										(this.icon = new tn(e ? e.icon : null, i, u, d));
								}
								isHidden() {
									return this.text.isHidden() && this.icon.isHidden();
								}
							}
							class ma {
								constructor(e, i, l) {
									(this.text = e), (this.icon = i), (this.skipFade = l);
								}
							}
							class pi {
								constructor(e, i, l, u, d) {
									(this.bucketInstanceId = e),
										(this.featureIndex = i),
										(this.sourceLayerIndex = l),
										(this.bucketIndex = u),
										(this.tileID = d);
								}
							}
							class Xi {
								constructor(e) {
									(this.crossSourceCollisions = e),
										(this.maxGroupID = 0),
										(this.collisionGroups = {});
								}
								get(e) {
									if (this.crossSourceCollisions)
										return { ID: 0, predicate: null };
									if (!this.collisionGroups[e]) {
										const i = ++this.maxGroupID;
										this.collisionGroups[e] = {
											ID: i,
											predicate: (l) => l.collisionGroupID === i,
										};
									}
									return this.collisionGroups[e];
								}
							}
							function Zn(h, e, i, l, u) {
								const { horizontalAlign: d, verticalAlign: g } = s.aH(h);
								return new s.P(
									-(d - 0.5) * e + l[0] * u,
									-(g - 0.5) * i + l[1] * u
								);
							}
							class ni {
								constructor(e, i, l, u, d) {
									(this.transform = e.clone()),
										(this.terrain = i),
										(this.collisionIndex = new In(this.transform)),
										(this.placements = {}),
										(this.opacities = {}),
										(this.variableOffsets = {}),
										(this.stale = !1),
										(this.commitTime = 0),
										(this.fadeDuration = l),
										(this.retainedQueryData = {}),
										(this.collisionGroups = new Xi(u)),
										(this.collisionCircleArrays = {}),
										(this.collisionBoxArrays = new Map()),
										(this.prevPlacement = d),
										d && (d.prevPlacement = void 0),
										(this.placedOrientations = {});
								}
								_getTerrainElevationFunc(e) {
									const i = this.terrain;
									return i ? (l, u) => i.getElevation(e, l, u) : null;
								}
								getBucketParts(e, i, l, u) {
									const d = l.getBucket(i),
										g = l.latestFeatureIndex;
									if (!d || !g || i.id !== d.layerIds[0]) return;
									const w = l.collisionBoxArray,
										C = d.layers[0].layout,
										P = d.layers[0].paint,
										E = Math.pow(2, this.transform.zoom - l.tileID.overscaledZ),
										R = l.tileSize / s.$,
										D = l.tileID.toUnwrapped(),
										N = C.get("text-rotation-alignment") === "map",
										G = s.aC(l, 1, this.transform.zoom),
										te = s.aD(
											this.collisionIndex.transform,
											l,
											P.get("text-translate"),
											P.get("text-translate-anchor")
										),
										Q = s.aD(
											this.collisionIndex.transform,
											l,
											P.get("icon-translate"),
											P.get("icon-translate-anchor")
										),
										ae = _n(N, this.transform, G);
									this.retainedQueryData[d.bucketInstanceId] = new pi(
										d.bucketInstanceId,
										g,
										d.sourceLayerIndex,
										d.index,
										l.tileID
									);
									const ce = {
										bucket: d,
										layout: C,
										translationText: te,
										translationIcon: Q,
										unwrappedTileID: D,
										pitchedLabelPlaneMatrix: ae,
										scale: E,
										textPixelRatio: R,
										holdingForFade: l.holdingForFade(),
										collisionBoxArray: w,
										partiallyEvaluatedTextSize: s.an(
											d.textSizeData,
											this.transform.zoom
										),
										collisionGroup: this.collisionGroups.get(d.sourceID),
									};
									if (u)
										for (const ve of d.sortKeyRanges) {
											const {
												sortKey: me,
												symbolInstanceStart: be,
												symbolInstanceEnd: Pe,
											} = ve;
											e.push({
												sortKey: me,
												symbolInstanceStart: be,
												symbolInstanceEnd: Pe,
												parameters: ce,
											});
										}
									else
										e.push({
											symbolInstanceStart: 0,
											symbolInstanceEnd: d.symbolInstances.length,
											parameters: ce,
										});
								}
								attemptAnchorPlacement(
									e,
									i,
									l,
									u,
									d,
									g,
									w,
									C,
									P,
									E,
									R,
									D,
									N,
									G,
									te,
									Q,
									ae,
									ce,
									ve,
									me
								) {
									const be = s.aE[e.textAnchor],
										Pe = [e.textOffset0, e.textOffset1],
										_e = Zn(be, l, u, Pe, d),
										Be = this.collisionIndex.placeCollisionBox(
											i,
											D,
											C,
											P,
											E,
											w,
											g,
											Q,
											R.predicate,
											ve,
											_e,
											me
										);
									if (
										(!ce ||
											this.collisionIndex.placeCollisionBox(
												ce,
												D,
												C,
												P,
												E,
												w,
												g,
												ae,
												R.predicate,
												ve,
												_e,
												me
											).placeable) &&
										Be.placeable
									) {
										let rt;
										if (
											(this.prevPlacement &&
												this.prevPlacement.variableOffsets[N.crossTileID] &&
												this.prevPlacement.placements[N.crossTileID] &&
												this.prevPlacement.placements[N.crossTileID].text &&
												(rt =
													this.prevPlacement.variableOffsets[N.crossTileID]
														.anchor),
											N.crossTileID === 0)
										)
											throw new Error("symbolInstance.crossTileID can't be 0");
										return (
											(this.variableOffsets[N.crossTileID] = {
												textOffset: Pe,
												width: l,
												height: u,
												anchor: be,
												textBoxScale: d,
												prevAnchor: rt,
											}),
											this.markUsedJustification(G, be, N, te),
											G.allowVerticalPlacement &&
												(this.markUsedOrientation(G, te, N),
												(this.placedOrientations[N.crossTileID] = te)),
											{ shift: _e, placedGlyphBoxes: Be }
										);
									}
								}
								placeLayerBucketPart(e, i, l) {
									const {
											bucket: u,
											layout: d,
											translationText: g,
											translationIcon: w,
											unwrappedTileID: C,
											pitchedLabelPlaneMatrix: P,
											textPixelRatio: E,
											holdingForFade: R,
											collisionBoxArray: D,
											partiallyEvaluatedTextSize: N,
											collisionGroup: G,
										} = e.parameters,
										te = d.get("text-optional"),
										Q = d.get("icon-optional"),
										ae = s.aF(d, "text-overlap", "text-allow-overlap"),
										ce = ae === "always",
										ve = s.aF(d, "icon-overlap", "icon-allow-overlap"),
										me = ve === "always",
										be = d.get("text-rotation-alignment") === "map",
										Pe = d.get("text-pitch-alignment") === "map",
										_e = d.get("icon-text-fit") !== "none",
										Be = d.get("symbol-z-order") === "viewport-y",
										rt = ce && (me || !u.hasIconData() || Q),
										Ge = me && (ce || !u.hasTextData() || te);
									!u.collisionArrays && D && u.deserializeCollisionBoxes(D);
									const Xe = this.retainedQueryData[u.bucketInstanceId].tileID,
										tt = this._getTerrainElevationFunc(Xe),
										jt = this.transform.getFastPathSimpleProjectionMatrix(Xe),
										Zt = (Tt, vr, Jr) => {
											var An, Rn;
											if (i[Tt.crossTileID]) return;
											if (R)
												return void (this.placements[Tt.crossTileID] = new ma(
													!1,
													!1,
													!1
												));
											let Ln = !1,
												Wn = !1,
												Jn = !0,
												Kr = null,
												Bn = {
													box: null,
													placeable: !1,
													offscreen: null,
													occluded: !1,
												},
												si = { placeable: !1 },
												mi = null,
												Ci = null,
												$i = null,
												za = 0,
												go = 0,
												vo = 0;
											vr.textFeatureIndex
												? (za = vr.textFeatureIndex)
												: Tt.useRuntimeCollisionCircles &&
												  (za = Tt.featureIndex),
												vr.verticalTextFeatureIndex &&
													(go = vr.verticalTextFeatureIndex);
											const fs = vr.textBox;
											if (fs) {
												const ta = (li) => {
														let _i = s.ao.horizontal;
														if (
															u.allowVerticalPlacement &&
															!li &&
															this.prevPlacement
														) {
															const ba =
																this.prevPlacement.placedOrientations[
																	Tt.crossTileID
																];
															ba &&
																((this.placedOrientations[Tt.crossTileID] = ba),
																(_i = ba),
																this.markUsedOrientation(u, _i, Tt));
														}
														return _i;
													},
													La = (li, _i) => {
														if (
															u.allowVerticalPlacement &&
															Tt.numVerticalGlyphVertices > 0 &&
															vr.verticalTextBox
														) {
															for (const ba of u.writingModes)
																if (
																	(ba === s.ao.vertical
																		? ((Bn = _i()), (si = Bn))
																		: (Bn = li()),
																	Bn && Bn.placeable)
																)
																	break;
														} else Bn = li();
													},
													Gi = Tt.textAnchorOffsetStartIndex,
													yo = Tt.textAnchorOffsetEndIndex;
												if (yo === Gi) {
													const li = (_i, ba) => {
														const ci = this.collisionIndex.placeCollisionBox(
															_i,
															ae,
															E,
															Xe,
															C,
															Pe,
															be,
															g,
															G.predicate,
															tt,
															void 0,
															jt
														);
														return (
															ci &&
																ci.placeable &&
																(this.markUsedOrientation(u, ba, Tt),
																(this.placedOrientations[Tt.crossTileID] = ba)),
															ci
														);
													};
													La(
														() => li(fs, s.ao.horizontal),
														() => {
															const _i = vr.verticalTextBox;
															return u.allowVerticalPlacement &&
																Tt.numVerticalGlyphVertices > 0 &&
																_i
																? li(_i, s.ao.vertical)
																: { box: null, offscreen: null };
														}
													),
														ta(Bn && Bn.placeable);
												} else {
													let li =
														s.aE[
															(Rn =
																(An = this.prevPlacement) === null ||
																An === void 0
																	? void 0
																	: An.variableOffsets[Tt.crossTileID]) ===
																null || Rn === void 0
																? void 0
																: Rn.anchor
														];
													const _i = (ci, Qs, _s) => {
														const ro = ci.x2 - ci.x1,
															Da = ci.y2 - ci.y1,
															xo = Tt.textBoxScale,
															Cd = _e && ve === "never" ? Qs : null;
														let la = null,
															Sd = ae === "never" ? 1 : 2,
															_u = "never";
														li && Sd++;
														for (let Wl = 0; Wl < Sd; Wl++) {
															for (let Xl = Gi; Xl < yo; Xl++) {
																const bo = u.textAnchorOffsets.get(Xl);
																if (li && bo.textAnchor !== li) continue;
																const no = this.attemptAnchorPlacement(
																	bo,
																	ci,
																	ro,
																	Da,
																	xo,
																	be,
																	Pe,
																	E,
																	Xe,
																	C,
																	G,
																	_u,
																	Tt,
																	u,
																	_s,
																	g,
																	w,
																	Cd,
																	tt
																);
																if (
																	no &&
																	((la = no.placedGlyphBoxes),
																	la && la.placeable)
																)
																	return (Ln = !0), (Kr = no.shift), la;
															}
															li ? (li = null) : (_u = ae);
														}
														return (
															l &&
																!la &&
																(la = {
																	box: this.collisionIndex.placeCollisionBox(
																		fs,
																		"always",
																		E,
																		Xe,
																		C,
																		Pe,
																		be,
																		g,
																		G.predicate,
																		tt,
																		void 0,
																		jt
																	).box,
																	offscreen: !1,
																	placeable: !1,
																	occluded: !1,
																}),
															la
														);
													};
													La(
														() => _i(fs, vr.iconBox, s.ao.horizontal),
														() => {
															const ci = vr.verticalTextBox;
															return u.allowVerticalPlacement &&
																(!Bn || !Bn.placeable) &&
																Tt.numVerticalGlyphVertices > 0 &&
																ci
																? _i(ci, vr.verticalIconBox, s.ao.vertical)
																: { box: null, occluded: !0, offscreen: null };
														}
													),
														Bn && ((Ln = Bn.placeable), (Jn = Bn.offscreen));
													const ba = ta(Bn && Bn.placeable);
													if (!Ln && this.prevPlacement) {
														const ci =
															this.prevPlacement.variableOffsets[
																Tt.crossTileID
															];
														ci &&
															((this.variableOffsets[Tt.crossTileID] = ci),
															this.markUsedJustification(u, ci.anchor, Tt, ba));
													}
												}
											}
											if (
												((mi = Bn),
												(Ln = mi && mi.placeable),
												(Jn = mi && mi.offscreen),
												Tt.useRuntimeCollisionCircles)
											) {
												const ta = u.text.placedSymbolArray.get(
														Tt.centerJustifiedTextSymbolIndex
													),
													La = s.ap(u.textSizeData, N, ta),
													Gi = d.get("text-padding");
												(Ci = this.collisionIndex.placeCollisionCircles(
													ae,
													ta,
													u.lineVertexArray,
													u.glyphOffsetArray,
													La,
													C,
													P,
													l,
													Pe,
													G.predicate,
													Tt.collisionCircleDiameter,
													Gi,
													g,
													tt
												)),
													Ci.circles.length &&
														Ci.collisionDetected &&
														!l &&
														s.w(
															"Collisions detected, but collision boxes are not shown"
														),
													(Ln =
														ce ||
														(Ci.circles.length > 0 && !Ci.collisionDetected)),
													(Jn = Jn && Ci.offscreen);
											}
											if (
												(vr.iconFeatureIndex && (vo = vr.iconFeatureIndex),
												vr.iconBox)
											) {
												const ta = (La) =>
													this.collisionIndex.placeCollisionBox(
														La,
														ve,
														E,
														Xe,
														C,
														Pe,
														be,
														w,
														G.predicate,
														tt,
														_e && Kr ? Kr : void 0,
														jt
													);
												si && si.placeable && vr.verticalIconBox
													? (($i = ta(vr.verticalIconBox)), (Wn = $i.placeable))
													: (($i = ta(vr.iconBox)), (Wn = $i.placeable)),
													(Jn = Jn && $i.offscreen);
											}
											const ms =
													te ||
													(Tt.numHorizontalGlyphVertices === 0 &&
														Tt.numVerticalGlyphVertices === 0),
												Vo = Q || Tt.numIconVertices === 0;
											ms || Vo
												? Vo
													? ms || (Wn = Wn && Ln)
													: (Ln = Wn && Ln)
												: (Wn = Ln = Wn && Ln);
											const qo = Wn && $i.placeable;
											if (
												(Ln &&
													mi.placeable &&
													this.collisionIndex.insertCollisionBox(
														mi.box,
														ae,
														d.get("text-ignore-placement"),
														u.bucketInstanceId,
														si && si.placeable && go ? go : za,
														G.ID
													),
												qo &&
													this.collisionIndex.insertCollisionBox(
														$i.box,
														ve,
														d.get("icon-ignore-placement"),
														u.bucketInstanceId,
														vo,
														G.ID
													),
												Ci &&
													Ln &&
													this.collisionIndex.insertCollisionCircles(
														Ci.circles,
														ae,
														d.get("text-ignore-placement"),
														u.bucketInstanceId,
														za,
														G.ID
													),
												l &&
													this.storeCollisionData(
														u.bucketInstanceId,
														Jr,
														vr,
														mi,
														$i,
														Ci
													),
												Tt.crossTileID === 0)
											)
												throw new Error(
													"symbolInstance.crossTileID can't be 0"
												);
											if (u.bucketInstanceId === 0)
												throw new Error("bucket.bucketInstanceId can't be 0");
											(this.placements[Tt.crossTileID] = new ma(
												(Ln || rt) && !(mi != null && mi.occluded),
												(Wn || Ge) && !($i != null && $i.occluded),
												Jn || u.justReloaded
											)),
												(i[Tt.crossTileID] = !0);
										};
									if (Be) {
										if (e.symbolInstanceStart !== 0)
											throw new Error("bucket.bucketInstanceId should be 0");
										const Tt = u.getSortedSymbolIndexes(
											-this.transform.bearingInRadians
										);
										for (let vr = Tt.length - 1; vr >= 0; --vr) {
											const Jr = Tt[vr];
											Zt(u.symbolInstances.get(Jr), u.collisionArrays[Jr], Jr);
										}
									} else for (let Tt = e.symbolInstanceStart; Tt < e.symbolInstanceEnd; Tt++) Zt(u.symbolInstances.get(Tt), u.collisionArrays[Tt], Tt);
									u.justReloaded = !1;
								}
								storeCollisionData(e, i, l, u, d, g) {
									if (l.textBox || l.iconBox) {
										let w, C;
										this.collisionBoxArrays.has(e)
											? (w = this.collisionBoxArrays.get(e))
											: ((w = new Map()), this.collisionBoxArrays.set(e, w)),
											w.has(i)
												? (C = w.get(i))
												: ((C = { text: null, icon: null }), w.set(i, C)),
											l.textBox && (C.text = u.box),
											l.iconBox && (C.icon = d.box);
									}
									if (g) {
										let w = this.collisionCircleArrays[e];
										w === void 0 && (w = this.collisionCircleArrays[e] = []);
										for (let C = 0; C < g.circles.length; C += 4)
											w.push(g.circles[C + 0] - pr),
												w.push(g.circles[C + 1] - pr),
												w.push(g.circles[C + 2]),
												w.push(g.collisionDetected ? 1 : 0);
									}
								}
								markUsedJustification(e, i, l, u) {
									let d;
									d =
										u === s.ao.vertical
											? l.verticalPlacedTextSymbolIndex
											: {
													left: l.leftJustifiedTextSymbolIndex,
													center: l.centerJustifiedTextSymbolIndex,
													right: l.rightJustifiedTextSymbolIndex,
											  }[s.aG(i)];
									const g = [
										l.leftJustifiedTextSymbolIndex,
										l.centerJustifiedTextSymbolIndex,
										l.rightJustifiedTextSymbolIndex,
										l.verticalPlacedTextSymbolIndex,
									];
									for (const w of g)
										w >= 0 &&
											(e.text.placedSymbolArray.get(w).crossTileID =
												d >= 0 && w !== d ? 0 : l.crossTileID);
								}
								markUsedOrientation(e, i, l) {
									const u =
											i === s.ao.horizontal || i === s.ao.horizontalOnly
												? i
												: 0,
										d = i === s.ao.vertical ? i : 0,
										g = [
											l.leftJustifiedTextSymbolIndex,
											l.centerJustifiedTextSymbolIndex,
											l.rightJustifiedTextSymbolIndex,
										];
									for (const w of g)
										e.text.placedSymbolArray.get(w).placedOrientation = u;
									l.verticalPlacedTextSymbolIndex &&
										(e.text.placedSymbolArray.get(
											l.verticalPlacedTextSymbolIndex
										).placedOrientation = d);
								}
								commit(e) {
									(this.commitTime = e),
										(this.zoomAtLastRecencyCheck = this.transform.zoom);
									const i = this.prevPlacement;
									let l = !1;
									this.prevZoomAdjustment = i
										? i.zoomAdjustment(this.transform.zoom)
										: 0;
									const u = i ? i.symbolFadeChange(e) : 1,
										d = i ? i.opacities : {},
										g = i ? i.variableOffsets : {},
										w = i ? i.placedOrientations : {};
									for (const C in this.placements) {
										const P = this.placements[C],
											E = d[C];
										E
											? ((this.opacities[C] = new en(E, u, P.text, P.icon)),
											  (l =
													l ||
													P.text !== E.text.placed ||
													P.icon !== E.icon.placed))
											: ((this.opacities[C] = new en(
													null,
													u,
													P.text,
													P.icon,
													P.skipFade
											  )),
											  (l = l || P.text || P.icon));
									}
									for (const C in d) {
										const P = d[C];
										if (!this.opacities[C]) {
											const E = new en(P, u, !1, !1);
											E.isHidden() ||
												((this.opacities[C] = E),
												(l = l || P.text.placed || P.icon.placed));
										}
									}
									for (const C in g)
										this.variableOffsets[C] ||
											!this.opacities[C] ||
											this.opacities[C].isHidden() ||
											(this.variableOffsets[C] = g[C]);
									for (const C in w)
										this.placedOrientations[C] ||
											!this.opacities[C] ||
											this.opacities[C].isHidden() ||
											(this.placedOrientations[C] = w[C]);
									if (i && i.lastPlacementChangeTime === void 0)
										throw new Error(
											"Last placement time for previous placement is not defined"
										);
									l
										? (this.lastPlacementChangeTime = e)
										: typeof this.lastPlacementChangeTime != "number" &&
										  (this.lastPlacementChangeTime = i
												? i.lastPlacementChangeTime
												: e);
								}
								updateLayerOpacities(e, i) {
									const l = {};
									for (const u of i) {
										const d = u.getBucket(e);
										d &&
											u.latestFeatureIndex &&
											e.id === d.layerIds[0] &&
											this.updateBucketOpacities(
												d,
												u.tileID,
												l,
												u.collisionBoxArray
											);
									}
								}
								updateBucketOpacities(e, i, l, u) {
									e.hasTextData() &&
										(e.text.opacityVertexArray.clear(),
										(e.text.hasVisibleVertices = !1)),
										e.hasIconData() &&
											(e.icon.opacityVertexArray.clear(),
											(e.icon.hasVisibleVertices = !1)),
										e.hasIconCollisionBoxData() &&
											e.iconCollisionBox.collisionVertexArray.clear(),
										e.hasTextCollisionBoxData() &&
											e.textCollisionBox.collisionVertexArray.clear();
									const d = e.layers[0],
										g = d.layout,
										w = new en(null, 0, !1, !1, !0),
										C = g.get("text-allow-overlap"),
										P = g.get("icon-allow-overlap"),
										E =
											d._unevaluatedLayout.hasValue("text-variable-anchor") ||
											d._unevaluatedLayout.hasValue(
												"text-variable-anchor-offset"
											),
										R = g.get("text-rotation-alignment") === "map",
										D = g.get("text-pitch-alignment") === "map",
										N = g.get("icon-text-fit") !== "none",
										G = new en(
											null,
											0,
											C && (P || !e.hasIconData() || g.get("icon-optional")),
											P && (C || !e.hasTextData() || g.get("text-optional")),
											!0
										);
									!e.collisionArrays &&
										u &&
										(e.hasIconCollisionBoxData() ||
											e.hasTextCollisionBoxData()) &&
										e.deserializeCollisionBoxes(u);
									const te = (ae, ce, ve) => {
											for (let me = 0; me < ce / 4; me++)
												ae.opacityVertexArray.emplaceBack(ve);
											ae.hasVisibleVertices =
												ae.hasVisibleVertices || ve !== Br;
										},
										Q = this.collisionBoxArrays.get(e.bucketInstanceId);
									for (let ae = 0; ae < e.symbolInstances.length; ae++) {
										const ce = e.symbolInstances.get(ae),
											{
												numHorizontalGlyphVertices: ve,
												numVerticalGlyphVertices: me,
												crossTileID: be,
											} = ce;
										let Pe = this.opacities[be];
										l[be]
											? (Pe = w)
											: Pe || ((Pe = G), (this.opacities[be] = Pe)),
											(l[be] = !0);
										const _e = ce.numIconVertices > 0,
											Be = this.placedOrientations[ce.crossTileID],
											rt = Be === s.ao.vertical,
											Ge = Be === s.ao.horizontal || Be === s.ao.horizontalOnly;
										if (ve > 0 || me > 0) {
											const tt = Xt(Pe.text);
											te(e.text, ve, rt ? Br : tt),
												te(e.text, me, Ge ? Br : tt);
											const jt = Pe.text.isHidden();
											[
												ce.rightJustifiedTextSymbolIndex,
												ce.centerJustifiedTextSymbolIndex,
												ce.leftJustifiedTextSymbolIndex,
											].forEach((vr) => {
												vr >= 0 &&
													(e.text.placedSymbolArray.get(vr).hidden =
														jt || rt ? 1 : 0);
											}),
												ce.verticalPlacedTextSymbolIndex >= 0 &&
													(e.text.placedSymbolArray.get(
														ce.verticalPlacedTextSymbolIndex
													).hidden = jt || Ge ? 1 : 0);
											const Zt = this.variableOffsets[ce.crossTileID];
											Zt && this.markUsedJustification(e, Zt.anchor, ce, Be);
											const Tt = this.placedOrientations[ce.crossTileID];
											Tt &&
												(this.markUsedJustification(e, "left", ce, Tt),
												this.markUsedOrientation(e, Tt, ce));
										}
										if (_e) {
											const tt = Xt(Pe.icon),
												jt = !(N && ce.verticalPlacedIconSymbolIndex && rt);
											ce.placedIconSymbolIndex >= 0 &&
												(te(e.icon, ce.numIconVertices, jt ? tt : Br),
												(e.icon.placedSymbolArray.get(
													ce.placedIconSymbolIndex
												).hidden = Pe.icon.isHidden())),
												ce.verticalPlacedIconSymbolIndex >= 0 &&
													(te(e.icon, ce.numVerticalIconVertices, jt ? Br : tt),
													(e.icon.placedSymbolArray.get(
														ce.verticalPlacedIconSymbolIndex
													).hidden = Pe.icon.isHidden()));
										}
										const Xe =
											Q && Q.has(ae) ? Q.get(ae) : { text: null, icon: null };
										if (
											e.hasIconCollisionBoxData() ||
											e.hasTextCollisionBoxData()
										) {
											const tt = e.collisionArrays[ae];
											if (tt) {
												let jt = new s.P(0, 0);
												if (tt.textBox || tt.verticalTextBox) {
													let Zt = !0;
													if (E) {
														const Tt = this.variableOffsets[be];
														Tt
															? ((jt = Zn(
																	Tt.anchor,
																	Tt.width,
																	Tt.height,
																	Tt.textOffset,
																	Tt.textBoxScale
															  )),
															  R &&
																	jt._rotate(
																		D
																			? -this.transform.bearingInRadians
																			: this.transform.bearingInRadians
																	))
															: (Zt = !1);
													}
													if (tt.textBox || tt.verticalTextBox) {
														let Tt;
														tt.textBox && (Tt = rt),
															tt.verticalTextBox && (Tt = Ge),
															Zi(
																e.textCollisionBox.collisionVertexArray,
																Pe.text.placed,
																!Zt || Tt,
																Xe.text,
																jt.x,
																jt.y
															);
													}
												}
												if (tt.iconBox || tt.verticalIconBox) {
													const Zt = !!(!Ge && tt.verticalIconBox);
													let Tt;
													tt.iconBox && (Tt = Zt),
														tt.verticalIconBox && (Tt = !Zt),
														Zi(
															e.iconCollisionBox.collisionVertexArray,
															Pe.icon.placed,
															Tt,
															Xe.icon,
															N ? jt.x : 0,
															N ? jt.y : 0
														);
												}
											}
										}
									}
									if (
										(e.sortFeatures(-this.transform.bearingInRadians),
										this.retainedQueryData[e.bucketInstanceId] &&
											(this.retainedQueryData[
												e.bucketInstanceId
											].featureSortOrder = e.featureSortOrder),
										e.hasTextData() &&
											e.text.opacityVertexBuffer &&
											e.text.opacityVertexBuffer.updateData(
												e.text.opacityVertexArray
											),
										e.hasIconData() &&
											e.icon.opacityVertexBuffer &&
											e.icon.opacityVertexBuffer.updateData(
												e.icon.opacityVertexArray
											),
										e.hasIconCollisionBoxData() &&
											e.iconCollisionBox.collisionVertexBuffer &&
											e.iconCollisionBox.collisionVertexBuffer.updateData(
												e.iconCollisionBox.collisionVertexArray
											),
										e.hasTextCollisionBoxData() &&
											e.textCollisionBox.collisionVertexBuffer &&
											e.textCollisionBox.collisionVertexBuffer.updateData(
												e.textCollisionBox.collisionVertexArray
											),
										e.text.opacityVertexArray.length !==
											e.text.layoutVertexArray.length / 4)
									)
										throw new Error(
											`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`
										);
									if (
										e.icon.opacityVertexArray.length !==
										e.icon.layoutVertexArray.length / 4
									)
										throw new Error(
											`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`
										);
									e.bucketInstanceId in this.collisionCircleArrays &&
										((e.collisionCircleArray =
											this.collisionCircleArrays[e.bucketInstanceId]),
										delete this.collisionCircleArrays[e.bucketInstanceId]);
								}
								symbolFadeChange(e) {
									return this.fadeDuration === 0
										? 1
										: (e - this.commitTime) / this.fadeDuration +
												this.prevZoomAdjustment;
								}
								zoomAdjustment(e) {
									return Math.max(0, (this.transform.zoom - e) / 1.5);
								}
								hasTransitions(e) {
									return (
										this.stale ||
										e - this.lastPlacementChangeTime < this.fadeDuration
									);
								}
								stillRecent(e, i) {
									const l =
										this.zoomAtLastRecencyCheck === i
											? 1 - this.zoomAdjustment(i)
											: 1;
									return (
										(this.zoomAtLastRecencyCheck = i),
										this.commitTime + this.fadeDuration * l > e
									);
								}
								setStale() {
									this.stale = !0;
								}
							}
							function Zi(h, e, i, l, u, d) {
								(l && l.length !== 0) || (l = [0, 0, 0, 0]);
								const g = l[0] - pr,
									w = l[1] - pr,
									C = l[2] - pr,
									P = l[3] - pr;
								h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, w),
									h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, C, w),
									h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, C, P),
									h.emplaceBack(e ? 1 : 0, i ? 1 : 0, u || 0, d || 0, g, P);
							}
							const Yi = Math.pow(2, 25),
								Ei = Math.pow(2, 24),
								zi = Math.pow(2, 17),
								Ki = Math.pow(2, 16),
								oa = Math.pow(2, 9),
								Ta = Math.pow(2, 8),
								bt = Math.pow(2, 1);
							function Xt(h) {
								if (h.opacity === 0 && !h.placed) return 0;
								if (h.opacity === 1 && h.placed) return 4294967295;
								const e = h.placed ? 1 : 0,
									i = Math.floor(127 * h.opacity);
								return (
									i * Yi +
									e * Ei +
									i * zi +
									e * Ki +
									i * oa +
									e * Ta +
									i * bt +
									e
								);
							}
							const Br = 0;
							class xn {
								constructor(e) {
									(this._sortAcrossTiles =
										e.layout.get("symbol-z-order") !== "viewport-y" &&
										!e.layout.get("symbol-sort-key").isConstant()),
										(this._currentTileIndex = 0),
										(this._currentPartIndex = 0),
										(this._seenCrossTileIDs = {}),
										(this._bucketParts = []);
								}
								continuePlacement(e, i, l, u, d) {
									const g = this._bucketParts;
									for (; this._currentTileIndex < e.length; )
										if (
											(i.getBucketParts(
												g,
												u,
												e[this._currentTileIndex],
												this._sortAcrossTiles
											),
											this._currentTileIndex++,
											d())
										)
											return !0;
									for (
										this._sortAcrossTiles &&
										((this._sortAcrossTiles = !1),
										g.sort((w, C) => w.sortKey - C.sortKey));
										this._currentPartIndex < g.length;

									)
										if (
											(i.placeLayerBucketPart(
												g[this._currentPartIndex],
												this._seenCrossTileIDs,
												l
											),
											this._currentPartIndex++,
											d())
										)
											return !0;
									return !1;
								}
							}
							class On {
								constructor(e, i, l, u, d, g, w, C) {
									(this.placement = new ni(e, i, g, w, C)),
										(this._currentPlacementIndex = l.length - 1),
										(this._forceFullPlacement = u),
										(this._showCollisionBoxes = d),
										(this._done = !1);
								}
								isDone() {
									return this._done;
								}
								continuePlacement(e, i, l) {
									const u = ne.now(),
										d = () => !this._forceFullPlacement && ne.now() - u > 2;
									for (; this._currentPlacementIndex >= 0; ) {
										const g = i[e[this._currentPlacementIndex]],
											w = this.placement.collisionIndex.transform.zoom;
										if (
											g.type === "symbol" &&
											(!g.minzoom || g.minzoom <= w) &&
											(!g.maxzoom || g.maxzoom > w)
										) {
											if (
												(this._inProgressLayer ||
													(this._inProgressLayer = new xn(g)),
												this._inProgressLayer.continuePlacement(
													l[g.source],
													this.placement,
													this._showCollisionBoxes,
													g,
													d
												))
											)
												return;
											delete this._inProgressLayer;
										}
										this._currentPlacementIndex--;
									}
									this._done = !0;
								}
								commit(e) {
									return this.placement.commit(e), this.placement;
								}
							}
							const Yn = 512 / s.$ / 2;
							class Vn {
								constructor(e, i, l) {
									(this.tileID = e),
										(this.bucketInstanceId = l),
										(this._symbolsByKey = {});
									const u = new Map();
									for (let d = 0; d < i.length; d++) {
										const g = i.get(d),
											w = g.key,
											C = u.get(w);
										C ? C.push(g) : u.set(w, [g]);
									}
									for (const [d, g] of u) {
										const w = {
											positions: g.map((C) => ({
												x: Math.floor(C.anchorX * Yn),
												y: Math.floor(C.anchorY * Yn),
											})),
											crossTileIDs: g.map((C) => C.crossTileID),
										};
										if (w.positions.length > 128) {
											const C = new s.aI(w.positions.length, 16, Uint16Array);
											for (const { x: P, y: E } of w.positions) C.add(P, E);
											C.finish(), delete w.positions, (w.index = C);
										}
										this._symbolsByKey[d] = w;
									}
								}
								getScaledCoordinates(e, i) {
									const { x: l, y: u, z: d } = this.tileID.canonical,
										{ x: g, y: w, z: C } = i.canonical,
										P = Yn / Math.pow(2, C - d),
										E = (w * s.$ + e.anchorY) * P,
										R = u * s.$ * Yn;
									return {
										x: Math.floor((g * s.$ + e.anchorX) * P - l * s.$ * Yn),
										y: Math.floor(E - R),
									};
								}
								findMatches(e, i, l) {
									const u =
										this.tileID.canonical.z < i.canonical.z
											? 1
											: Math.pow(2, this.tileID.canonical.z - i.canonical.z);
									for (let d = 0; d < e.length; d++) {
										const g = e.get(d);
										if (g.crossTileID) continue;
										const w = this._symbolsByKey[g.key];
										if (!w) continue;
										const C = this.getScaledCoordinates(g, i);
										if (w.index) {
											const P = w.index
												.range(C.x - u, C.y - u, C.x + u, C.y + u)
												.sort();
											for (const E of P) {
												const R = w.crossTileIDs[E];
												if (!l[R]) {
													(l[R] = !0), (g.crossTileID = R);
													break;
												}
											}
										} else if (w.positions)
											for (let P = 0; P < w.positions.length; P++) {
												const E = w.positions[P],
													R = w.crossTileIDs[P];
												if (
													Math.abs(E.x - C.x) <= u &&
													Math.abs(E.y - C.y) <= u &&
													!l[R]
												) {
													(l[R] = !0), (g.crossTileID = R);
													break;
												}
											}
									}
								}
								getCrossTileIDsLists() {
									return Object.values(this._symbolsByKey).map(
										({ crossTileIDs: e }) => e
									);
								}
							}
							class wn {
								constructor() {
									this.maxCrossTileID = 0;
								}
								generate() {
									return ++this.maxCrossTileID;
								}
							}
							class Ji {
								constructor() {
									(this.indexes = {}),
										(this.usedCrossTileIDs = {}),
										(this.lng = 0);
								}
								handleWrapJump(e) {
									const i = Math.round((e - this.lng) / 360);
									if (i !== 0)
										for (const l in this.indexes) {
											const u = this.indexes[l],
												d = {};
											for (const g in u) {
												const w = u[g];
												(w.tileID = w.tileID.unwrapTo(w.tileID.wrap + i)),
													(d[w.tileID.key] = w);
											}
											this.indexes[l] = d;
										}
									this.lng = e;
								}
								addBucket(e, i, l) {
									if (
										this.indexes[e.overscaledZ] &&
										this.indexes[e.overscaledZ][e.key]
									) {
										if (
											this.indexes[e.overscaledZ][e.key].bucketInstanceId ===
											i.bucketInstanceId
										)
											return !1;
										this.removeBucketCrossTileIDs(
											e.overscaledZ,
											this.indexes[e.overscaledZ][e.key]
										);
									}
									for (let d = 0; d < i.symbolInstances.length; d++)
										i.symbolInstances.get(d).crossTileID = 0;
									this.usedCrossTileIDs[e.overscaledZ] ||
										(this.usedCrossTileIDs[e.overscaledZ] = {});
									const u = this.usedCrossTileIDs[e.overscaledZ];
									for (const d in this.indexes) {
										const g = this.indexes[d];
										if (Number(d) > e.overscaledZ)
											for (const w in g) {
												const C = g[w];
												C.tileID.isChildOf(e) &&
													C.findMatches(i.symbolInstances, e, u);
											}
										else {
											const w = g[e.scaledTo(Number(d)).key];
											w && w.findMatches(i.symbolInstances, e, u);
										}
									}
									for (let d = 0; d < i.symbolInstances.length; d++) {
										const g = i.symbolInstances.get(d);
										g.crossTileID ||
											((g.crossTileID = l.generate()), (u[g.crossTileID] = !0));
									}
									return (
										this.indexes[e.overscaledZ] === void 0 &&
											(this.indexes[e.overscaledZ] = {}),
										(this.indexes[e.overscaledZ][e.key] = new Vn(
											e,
											i.symbolInstances,
											i.bucketInstanceId
										)),
										!0
									);
								}
								removeBucketCrossTileIDs(e, i) {
									for (const l of i.getCrossTileIDsLists())
										for (const u of l) delete this.usedCrossTileIDs[e][u];
								}
								removeStaleBuckets(e) {
									let i = !1;
									for (const l in this.indexes) {
										const u = this.indexes[l];
										for (const d in u)
											e[u[d].bucketInstanceId] ||
												(this.removeBucketCrossTileIDs(l, u[d]),
												delete u[d],
												(i = !0));
									}
									return i;
								}
							}
							class sr {
								constructor() {
									(this.layerIndexes = {}),
										(this.crossTileIDs = new wn()),
										(this.maxBucketInstanceId = 0),
										(this.bucketsInCurrentPlacement = {});
								}
								addLayer(e, i, l) {
									let u = this.layerIndexes[e.id];
									u === void 0 && (u = this.layerIndexes[e.id] = new Ji());
									let d = !1;
									const g = {};
									u.handleWrapJump(l);
									for (const w of i) {
										const C = w.getBucket(e);
										C &&
											e.id === C.layerIds[0] &&
											(C.bucketInstanceId ||
												(C.bucketInstanceId = ++this.maxBucketInstanceId),
											u.addBucket(w.tileID, C, this.crossTileIDs) && (d = !0),
											(g[C.bucketInstanceId] = !0));
									}
									return u.removeStaleBuckets(g) && (d = !0), d;
								}
								pruneUnusedLayers(e) {
									const i = {};
									e.forEach((l) => {
										i[l] = !0;
									});
									for (const l in this.layerIndexes)
										i[l] || delete this.layerIndexes[l];
								}
							}
							var Ut = "void main() {fragColor=vec4(1.0);}";
							const $r = {
								prelude: lr(
									`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`,
									`#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`
								),
								projectionMercator: lr(
									"",
									"float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"
								),
								projectionGlobe: lr(
									"",
									`#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY);
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`
								),
								background: lr(
									`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									"in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"
								),
								backgroundPattern: lr(
									`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									"uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"
								),
								circle: lr(
									`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`
								),
								clippingMask: lr(
									Ut,
									"in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"
								),
								heatmap: lr(
									`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`
								),
								heatmapTexture: lr(
									`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`,
									"uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"
								),
								collisionBox: lr(
									"in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}",
									"in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"
								),
								collisionCircle: lr(
									"in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}",
									"in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"
								),
								colorRelief: lr(
									`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									"uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"
								),
								debug: lr(
									"uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}",
									"in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"
								),
								depth: lr(
									Ut,
									`in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`
								),
								fill: lr(
									`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`
								),
								fillOutline: lr(
									`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`
								),
								fillOutlinePattern: lr(
									`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`
								),
								fillPattern: lr(
									`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`
								),
								fillExtrusion: lr(
									`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`
								),
								fillExtrusionPattern: lr(
									`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`
								),
								hillshadePrepare: lr(
									`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									"uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"
								),
								hillshade: lr(
									`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									"uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"
								),
								line: lr(
									`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`
								),
								lineGradient: lr(
									`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`
								),
								linePattern: lr(
									`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`
								),
								lineSDF: lr(
									`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`
								),
								raster: lr(
									`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`
								),
								symbolIcon: lr(
									`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`
								),
								symbolSDF: lr(
									`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`
								),
								symbolTextAndIcon: lr(
									`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`,
									`in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`
								),
								terrain: lr(
									"uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}",
									"in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"
								),
								terrainDepth: lr(
									"in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}",
									"in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"
								),
								terrainCoords: lr(
									"precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}",
									"in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"
								),
								projectionErrorMeasurement: lr(
									"in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}",
									"in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"
								),
								atmosphere: lr(
									`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`,
									"in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"
								),
								sky: lr(
									"uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}",
									"in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}"
								),
							};
							function lr(h, e) {
								const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
									l = e.match(/in ([\w]+) ([\w]+)/g),
									u = h.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
									d = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g),
									g = d ? d.concat(u) : u,
									w = {};
								return {
									fragmentSource: (h = h.replace(
										i,
										(C, P, E, R, D) => (
											(w[D] = !0),
											P === "define"
												? `
#ifndef HAS_UNIFORM_u_${D}
in ${E} ${R} ${D};
#else
uniform ${E} ${R} u_${D};
#endif
`
												: `
#ifdef HAS_UNIFORM_u_${D}
    ${E} ${R} ${D} = u_${D};
#endif
`
										)
									)),
									vertexSource: (e = e.replace(i, (C, P, E, R, D) => {
										const N = R === "float" ? "vec2" : "vec4",
											G = D.match(/color/) ? "color" : N;
										return w[D]
											? P === "define"
												? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${E} ${N} a_${D};
out ${E} ${R} ${D};
#else
uniform ${E} ${R} u_${D};
#endif
`
												: G === "vec4"
												? `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = a_${D};
#else
    ${E} ${R} ${D} = u_${D};
#endif
`
												: `
#ifndef HAS_UNIFORM_u_${D}
    ${D} = unpack_mix_${G}(a_${D}, u_${D}_t);
#else
    ${E} ${R} ${D} = u_${D};
#endif
`
											: P === "define"
											? `
#ifndef HAS_UNIFORM_u_${D}
uniform lowp float u_${D}_t;
in ${E} ${N} a_${D};
#else
uniform ${E} ${R} u_${D};
#endif
`
											: G === "vec4"
											? `
#ifndef HAS_UNIFORM_u_${D}
    ${E} ${R} ${D} = a_${D};
#else
    ${E} ${R} ${D} = u_${D};
#endif
`
											: `
#ifndef HAS_UNIFORM_u_${D}
    ${E} ${R} ${D} = unpack_mix_${G}(a_${D}, u_${D}_t);
#else
    ${E} ${R} ${D} = u_${D};
#endif
`;
									})),
									staticAttributes: l,
									staticUniforms: g,
								};
							}
							class Tn {
								constructor(e, i, l) {
									(this.vertexBuffer = e),
										(this.indexBuffer = i),
										(this.segments = l);
								}
								destroy() {
									this.vertexBuffer.destroy(),
										this.indexBuffer.destroy(),
										this.segments.destroy(),
										(this.vertexBuffer = null),
										(this.indexBuffer = null),
										(this.segments = null);
								}
							}
							var an = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
							const Cn = "#define PROJECTION_MERCATOR",
								Gn = "mercator";
							class Mr {
								constructor() {
									this._cachedMesh = null;
								}
								get name() {
									return "mercator";
								}
								get useSubdivision() {
									return !1;
								}
								get shaderVariantName() {
									return Gn;
								}
								get shaderDefine() {
									return Cn;
								}
								get shaderPreludeCode() {
									return $r.projectionMercator;
								}
								get vertexShaderPreludeCode() {
									return $r.projectionMercator.vertexSource;
								}
								get subdivisionGranularity() {
									return s.aK.noSubdivision;
								}
								get useGlobeControls() {
									return !1;
								}
								get transitionState() {
									return 0;
								}
								get latitudeErrorCorrectionRadians() {
									return 0;
								}
								destroy() {}
								updateGPUdependent(e) {}
								getMeshFromTileID(e, i, l, u, d) {
									if (this._cachedMesh) return this._cachedMesh;
									const g = new s.aL();
									g.emplaceBack(0, 0),
										g.emplaceBack(s.$, 0),
										g.emplaceBack(0, s.$),
										g.emplaceBack(s.$, s.$);
									const w = e.createVertexBuffer(g, an.members),
										C = s.aM.simpleSegment(0, 0, 4, 2),
										P = new s.aN();
									P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3);
									const E = e.createIndexBuffer(P);
									return (this._cachedMesh = new Tn(w, E, C)), this._cachedMesh;
								}
								recalculate() {}
								hasTransition() {
									return !1;
								}
								setErrorQueryLatitudeDegrees(e) {}
							}
							class Mn {
								constructor(e = 0, i = 0, l = 0, u = 0) {
									if (
										isNaN(e) ||
										e < 0 ||
										isNaN(i) ||
										i < 0 ||
										isNaN(l) ||
										l < 0 ||
										isNaN(u) ||
										u < 0
									)
										throw new Error(
											"Invalid value for edge-insets, top, bottom, left and right must all be numbers"
										);
									(this.top = e),
										(this.bottom = i),
										(this.left = l),
										(this.right = u);
								}
								interpolate(e, i, l) {
									return (
										i.top != null &&
											e.top != null &&
											(this.top = s.C.number(e.top, i.top, l)),
										i.bottom != null &&
											e.bottom != null &&
											(this.bottom = s.C.number(e.bottom, i.bottom, l)),
										i.left != null &&
											e.left != null &&
											(this.left = s.C.number(e.left, i.left, l)),
										i.right != null &&
											e.right != null &&
											(this.right = s.C.number(e.right, i.right, l)),
										this
									);
								}
								getCenter(e, i) {
									const l = s.ah((this.left + e - this.right) / 2, 0, e),
										u = s.ah((this.top + i - this.bottom) / 2, 0, i);
									return new s.P(l, u);
								}
								equals(e) {
									return (
										this.top === e.top &&
										this.bottom === e.bottom &&
										this.left === e.left &&
										this.right === e.right
									);
								}
								clone() {
									return new Mn(this.top, this.bottom, this.left, this.right);
								}
								toJSON() {
									return {
										top: this.top,
										bottom: this.bottom,
										left: this.left,
										right: this.right,
									};
								}
							}
							function bn(h, e) {
								if (!h.renderWorldCopies || h.lngRange) return;
								const i = e.lng - h.center.lng;
								e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
							}
							function cn(h) {
								return Math.max(0, Math.floor(h));
							}
							class Sn {
								constructor(e, i, l, u, d, g) {
									(this._callbacks = e),
										(this._tileSize = 512),
										(this._renderWorldCopies = g === void 0 || !!g),
										(this._minZoom = i || 0),
										(this._maxZoom = l || 22),
										(this._minPitch = u ?? 0),
										(this._maxPitch = d ?? 60),
										this.setMaxBounds(),
										(this._width = 0),
										(this._height = 0),
										(this._center = new s.S(0, 0)),
										(this._elevation = 0),
										(this._zoom = 0),
										(this._tileZoom = cn(this._zoom)),
										(this._scale = s.af(this._zoom)),
										(this._bearingInRadians = 0),
										(this._fovInRadians = 0.6435011087932844),
										(this._pitchInRadians = 0),
										(this._rollInRadians = 0),
										(this._unmodified = !0),
										(this._edgeInsets = new Mn()),
										(this._minElevationForCurrentTile = 0),
										(this._autoCalculateNearFarZ = !0);
								}
								apply(e, i, l) {
									(this._latRange = e.latRange),
										(this._lngRange = e.lngRange),
										(this._width = e.width),
										(this._height = e.height),
										(this._center = e.center),
										(this._elevation = e.elevation),
										(this._minElevationForCurrentTile =
											e.minElevationForCurrentTile),
										(this._zoom = e.zoom),
										(this._tileZoom = cn(this._zoom)),
										(this._scale = s.af(this._zoom)),
										(this._bearingInRadians = e.bearingInRadians),
										(this._fovInRadians = e.fovInRadians),
										(this._pitchInRadians = e.pitchInRadians),
										(this._rollInRadians = e.rollInRadians),
										(this._unmodified = e.unmodified),
										(this._edgeInsets = new Mn(
											e.padding.top,
											e.padding.bottom,
											e.padding.left,
											e.padding.right
										)),
										(this._minZoom = e.minZoom),
										(this._maxZoom = e.maxZoom),
										(this._minPitch = e.minPitch),
										(this._maxPitch = e.maxPitch),
										(this._renderWorldCopies = e.renderWorldCopies),
										(this._cameraToCenterDistance = e.cameraToCenterDistance),
										(this._nearZ = e.nearZ),
										(this._farZ = e.farZ),
										(this._autoCalculateNearFarZ =
											!l && e.autoCalculateNearFarZ),
										i && this._constrain(),
										this._calcMatrices();
								}
								get pixelsToClipSpaceMatrix() {
									return this._pixelsToClipSpaceMatrix;
								}
								get clipSpaceToPixelsMatrix() {
									return this._clipSpaceToPixelsMatrix;
								}
								get minElevationForCurrentTile() {
									return this._minElevationForCurrentTile;
								}
								setMinElevationForCurrentTile(e) {
									this._minElevationForCurrentTile = e;
								}
								get tileSize() {
									return this._tileSize;
								}
								get tileZoom() {
									return this._tileZoom;
								}
								get scale() {
									return this._scale;
								}
								get width() {
									return this._width;
								}
								get height() {
									return this._height;
								}
								get bearingInRadians() {
									return this._bearingInRadians;
								}
								get lngRange() {
									return this._lngRange;
								}
								get latRange() {
									return this._latRange;
								}
								get pixelsToGLUnits() {
									return this._pixelsToGLUnits;
								}
								get minZoom() {
									return this._minZoom;
								}
								setMinZoom(e) {
									this._minZoom !== e &&
										((this._minZoom = e),
										this.setZoom(
											this.getConstrained(this._center, this.zoom).zoom
										));
								}
								get maxZoom() {
									return this._maxZoom;
								}
								setMaxZoom(e) {
									this._maxZoom !== e &&
										((this._maxZoom = e),
										this.setZoom(
											this.getConstrained(this._center, this.zoom).zoom
										));
								}
								get minPitch() {
									return this._minPitch;
								}
								setMinPitch(e) {
									this._minPitch !== e &&
										((this._minPitch = e),
										this.setPitch(Math.max(this.pitch, e)));
								}
								get maxPitch() {
									return this._maxPitch;
								}
								setMaxPitch(e) {
									this._maxPitch !== e &&
										((this._maxPitch = e),
										this.setPitch(Math.min(this.pitch, e)));
								}
								get renderWorldCopies() {
									return this._renderWorldCopies;
								}
								setRenderWorldCopies(e) {
									e === void 0 ? (e = !0) : e === null && (e = !1),
										(this._renderWorldCopies = e);
								}
								get worldSize() {
									return this._tileSize * this._scale;
								}
								get centerOffset() {
									return this.centerPoint._sub(this.size._div(2));
								}
								get size() {
									return new s.P(this._width, this._height);
								}
								get bearing() {
									return (this._bearingInRadians / Math.PI) * 180;
								}
								setBearing(e) {
									const i = (s.aO(e, -180, 180) * Math.PI) / 180;
									var l, u, d, g, w, C, P, E, R;
									this._bearingInRadians !== i &&
										((this._unmodified = !1),
										(this._bearingInRadians = i),
										this._calcMatrices(),
										(this._rotationMatrix = O()),
										(l = this._rotationMatrix),
										(d = -this._bearingInRadians),
										(g = (u = this._rotationMatrix)[0]),
										(w = u[1]),
										(C = u[2]),
										(P = u[3]),
										(E = Math.sin(d)),
										(R = Math.cos(d)),
										(l[0] = g * R + C * E),
										(l[1] = w * R + P * E),
										(l[2] = g * -E + C * R),
										(l[3] = w * -E + P * R));
								}
								get rotationMatrix() {
									return this._rotationMatrix;
								}
								get pitchInRadians() {
									return this._pitchInRadians;
								}
								get pitch() {
									return (this._pitchInRadians / Math.PI) * 180;
								}
								setPitch(e) {
									const i =
										(s.ah(e, this.minPitch, this.maxPitch) / 180) * Math.PI;
									this._pitchInRadians !== i &&
										((this._unmodified = !1),
										(this._pitchInRadians = i),
										this._calcMatrices());
								}
								get rollInRadians() {
									return this._rollInRadians;
								}
								get roll() {
									return (this._rollInRadians / Math.PI) * 180;
								}
								setRoll(e) {
									const i = (e / 180) * Math.PI;
									this._rollInRadians !== i &&
										((this._unmodified = !1),
										(this._rollInRadians = i),
										this._calcMatrices());
								}
								get fovInRadians() {
									return this._fovInRadians;
								}
								get fov() {
									return s.aP(this._fovInRadians);
								}
								setFov(e) {
									(e = s.ah(e, 0.1, 150)),
										this.fov !== e &&
											((this._unmodified = !1),
											(this._fovInRadians = s.ae(e)),
											this._calcMatrices());
								}
								get zoom() {
									return this._zoom;
								}
								setZoom(e) {
									const i = this.getConstrained(this._center, e).zoom;
									this._zoom !== i &&
										((this._unmodified = !1),
										(this._zoom = i),
										(this._tileZoom = Math.max(0, Math.floor(i))),
										(this._scale = s.af(i)),
										this._constrain(),
										this._calcMatrices());
								}
								get center() {
									return this._center;
								}
								setCenter(e) {
									(e.lat === this._center.lat && e.lng === this._center.lng) ||
										((this._unmodified = !1),
										(this._center = e),
										this._constrain(),
										this._calcMatrices());
								}
								get elevation() {
									return this._elevation;
								}
								setElevation(e) {
									e !== this._elevation &&
										((this._elevation = e),
										this._constrain(),
										this._calcMatrices());
								}
								get padding() {
									return this._edgeInsets.toJSON();
								}
								setPadding(e) {
									this._edgeInsets.equals(e) ||
										((this._unmodified = !1),
										this._edgeInsets.interpolate(this._edgeInsets, e, 1),
										this._calcMatrices());
								}
								get centerPoint() {
									return this._edgeInsets.getCenter(this._width, this._height);
								}
								get pixelsPerMeter() {
									return this._pixelPerMeter;
								}
								get unmodified() {
									return this._unmodified;
								}
								get cameraToCenterDistance() {
									return this._cameraToCenterDistance;
								}
								get nearZ() {
									return this._nearZ;
								}
								get farZ() {
									return this._farZ;
								}
								get autoCalculateNearFarZ() {
									return this._autoCalculateNearFarZ;
								}
								overrideNearFarZ(e, i) {
									(this._autoCalculateNearFarZ = !1),
										(this._nearZ = e),
										(this._farZ = i),
										this._calcMatrices();
								}
								clearNearFarZOverride() {
									(this._autoCalculateNearFarZ = !0), this._calcMatrices();
								}
								isPaddingEqual(e) {
									return this._edgeInsets.equals(e);
								}
								interpolatePadding(e, i, l) {
									(this._unmodified = !1),
										this._edgeInsets.interpolate(e, i, l),
										this._constrain(),
										this._calcMatrices();
								}
								resize(e, i, l = !0) {
									(this._width = e),
										(this._height = i),
										l && this._constrain(),
										this._calcMatrices();
								}
								getMaxBounds() {
									return this._latRange &&
										this._latRange.length === 2 &&
										this._lngRange &&
										this._lngRange.length === 2
										? new _t(
												[this._lngRange[0], this._latRange[0]],
												[this._lngRange[1], this._latRange[1]]
										  )
										: null;
								}
								setMaxBounds(e) {
									e
										? ((this._lngRange = [e.getWest(), e.getEast()]),
										  (this._latRange = [e.getSouth(), e.getNorth()]),
										  this._constrain())
										: ((this._lngRange = null),
										  (this._latRange = [-s.ai, s.ai]));
								}
								getConstrained(e, i) {
									return this._callbacks.getConstrained(e, i);
								}
								getCameraQueryGeometry(e, i) {
									if (i.length === 1) return [i[0], e];
									{
										const {
											minX: l,
											minY: u,
											maxX: d,
											maxY: g,
										} = s.a2.fromPoints(i).extend(e);
										return [
											new s.P(l, u),
											new s.P(d, u),
											new s.P(d, g),
											new s.P(l, g),
											new s.P(l, u),
										];
									}
								}
								_constrain() {
									if (
										!this.center ||
										!this._width ||
										!this._height ||
										this._constraining
									)
										return;
									this._constraining = !0;
									const e = this._unmodified,
										{ center: i, zoom: l } = this.getConstrained(
											this.center,
											this.zoom
										);
									this.setCenter(i),
										this.setZoom(l),
										(this._unmodified = e),
										(this._constraining = !1);
								}
								_calcMatrices() {
									if (this._width && this._height) {
										this._pixelsToGLUnits = [
											2 / this._width,
											-2 / this._height,
										];
										let e = s.ag(new Float64Array(16));
										s.N(e, e, [this._width / 2, -this._height / 2, 1]),
											s.M(e, e, [1, -1, 0]),
											(this._clipSpaceToPixelsMatrix = e),
											(e = s.ag(new Float64Array(16))),
											s.N(e, e, [1, -1, 1]),
											s.M(e, e, [-1, -1, 0]),
											s.N(e, e, [2 / this._width, 2 / this._height, 1]),
											(this._pixelsToClipSpaceMatrix = e),
											(this._cameraToCenterDistance =
												(0.5 / Math.tan(this.fovInRadians / 2)) * this._height);
									}
									this._callbacks.calcMatrices();
								}
								calculateCenterFromCameraLngLatAlt(e, i, l, u) {
									const d = l !== void 0 ? l : this.bearing,
										g = (u = u !== void 0 ? u : this.pitch),
										w = s.a1.fromLngLat(e, i),
										C = -Math.cos(s.ae(g)),
										P = Math.sin(s.ae(g)),
										E = P * Math.sin(s.ae(d)),
										R = -P * Math.cos(s.ae(d));
									let D = this.elevation;
									const N = i - D;
									let G;
									C * N >= 0 || Math.abs(C) < 0.1
										? ((G = 1e4), (D = i + G * C))
										: (G = -N / C);
									let te,
										Q,
										ae = s.aQ(1, w.y),
										ce = 0;
									do {
										if (((ce += 1), ce > 10)) break;
										(Q = G / ae),
											(te = new s.a1(w.x + E * Q, w.y + R * Q)),
											(ae = 1 / te.meterInMercatorCoordinateUnits());
									} while (Math.abs(G - Q * ae) > 1e-12);
									return {
										center: te.toLngLat(),
										elevation: D,
										zoom: s.ak(
											this.height /
												2 /
												Math.tan(this.fovInRadians / 2) /
												Q /
												this.tileSize
										),
									};
								}
								recalculateZoomAndCenter(e) {
									if (this.elevation - e == 0) return;
									const i = s.aj(1, this.center.lat) * this.worldSize,
										l = this.cameraToCenterDistance / i,
										u = s.a1.fromLngLat(this.center, this.elevation),
										d = Me(
											this.center,
											this.elevation,
											this.pitch,
											this.bearing,
											l
										);
									this._elevation = e;
									const g = this.calculateCenterFromCameraLngLatAlt(
										d.toLngLat(),
										s.aQ(d.z, u.y),
										this.bearing,
										this.pitch
									);
									(this._elevation = g.elevation),
										(this._center = g.center),
										this.setZoom(g.zoom);
								}
								getCameraPoint() {
									const e =
										Math.tan(this.pitchInRadians) *
										(this.cameraToCenterDistance || 1);
									return this.centerPoint.add(
										new s.P(
											e * Math.sin(this.rollInRadians),
											e * Math.cos(this.rollInRadians)
										)
									);
								}
								getCameraAltitude() {
									return (
										(Math.cos(this.pitchInRadians) *
											this._cameraToCenterDistance) /
											this._pixelPerMeter +
										this.elevation
									);
								}
								getCameraLngLat() {
									const e = s.aj(1, this.center.lat) * this.worldSize;
									return Me(
										this.center,
										this.elevation,
										this.pitch,
										this.bearing,
										this.cameraToCenterDistance / e
									).toLngLat();
								}
								getMercatorTileCoordinates(e) {
									if (!e) return [0, 0, 1, 1];
									const i =
										e.canonical.z >= 0
											? 1 << e.canonical.z
											: Math.pow(2, e.canonical.z);
									return [
										e.canonical.x / i,
										e.canonical.y / i,
										1 / i / s.$,
										1 / i / s.$,
									];
								}
							}
							class kn {
								constructor(e, i) {
									(this.min = e),
										(this.max = i),
										(this.center = s.aR([], s.aS([], this.min, this.max), 0.5));
								}
								quadrant(e) {
									const i = [e % 2 == 0, e < 2],
										l = s.aT(this.min),
										u = s.aT(this.max);
									for (let d = 0; d < i.length; d++)
										(l[d] = i[d] ? this.min[d] : this.center[d]),
											(u[d] = i[d] ? this.center[d] : this.max[d]);
									return (u[2] = this.max[2]), new kn(l, u);
								}
								distanceX(e) {
									return (
										Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
									);
								}
								distanceY(e) {
									return (
										Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
									);
								}
								intersectsFrustum(e) {
									let i = !0;
									for (let l = 0; l < e.planes.length; l++) {
										const u = this.intersectsPlane(e.planes[l]);
										if (u === 0) return 0;
										u === 1 && (i = !1);
									}
									return i
										? 2
										: e.aabb.min[0] > this.max[0] ||
										  e.aabb.min[1] > this.max[1] ||
										  e.aabb.min[2] > this.max[2] ||
										  e.aabb.max[0] < this.min[0] ||
										  e.aabb.max[1] < this.min[1] ||
										  e.aabb.max[2] < this.min[2]
										? 0
										: 1;
								}
								intersectsPlane(e) {
									let i = e[3],
										l = e[3];
									for (let u = 0; u < 3; u++)
										e[u] > 0
											? ((i += e[u] * this.min[u]), (l += e[u] * this.max[u]))
											: ((l += e[u] * this.min[u]), (i += e[u] * this.max[u]));
									return i >= 0 ? 2 : l < 0 ? 0 : 1;
								}
							}
							class vn {
								distanceToTile2d(e, i, l, u) {
									const d = u.distanceX([e, i]),
										g = u.distanceY([e, i]);
									return Math.hypot(d, g);
								}
								getWrap(e, i, l) {
									return l;
								}
								getTileBoundingVolume(e, i, l, u) {
									var d, g;
									let w = 0,
										C = 0;
									if (u != null && u.terrain) {
										const E = new s.Z(e.z, i, e.z, e.x, e.y),
											R = u.terrain.getMinMaxElevation(E);
										(w =
											(d = R.minElevation) !== null && d !== void 0
												? d
												: Math.min(0, l)),
											(C =
												(g = R.maxElevation) !== null && g !== void 0
													? g
													: Math.max(0, l));
									}
									const P = 1 << e.z;
									return new kn(
										[i + e.x / P, e.y / P, w],
										[i + (e.x + 1) / P, (e.y + 1) / P, C]
									);
								}
								allowVariableZoom(e, i) {
									const l =
											(e.fov *
												(Math.abs(Math.cos(e.rollInRadians)) * e.height +
													Math.abs(Math.sin(e.rollInRadians)) * e.width)) /
											e.height,
										u = s.ah(78.5 - l / 2, 0, 60);
									return !!i.terrain || e.pitch > u;
								}
								allowWorldCopies() {
									return !0;
								}
								prepareNextFrame() {}
							}
							class fn {
								constructor(e, i, l) {
									(this.points = e), (this.planes = i), (this.aabb = l);
								}
								static fromInvProjectionMatrix(e, i = 1, l = 0, u, d) {
									const g = d
											? [
													[6, 5, 4],
													[0, 1, 2],
													[0, 3, 7],
													[2, 1, 5],
													[3, 2, 6],
													[0, 4, 5],
											  ]
											: [
													[0, 1, 2],
													[6, 5, 4],
													[0, 3, 7],
													[2, 1, 5],
													[3, 2, 6],
													[0, 4, 5],
											  ],
										w = Math.pow(2, l),
										C = [
											[-1, 1, -1, 1],
											[1, 1, -1, 1],
											[1, -1, -1, 1],
											[-1, -1, -1, 1],
											[-1, 1, 1, 1],
											[1, 1, 1, 1],
											[1, -1, 1, 1],
											[-1, -1, 1, 1],
										].map((D) =>
											(function (N, G, te, Q) {
												const ae = s.aw([], N, G),
													ce = (1 / ae[3] / te) * Q;
												return s.aY(ae, ae, [ce, ce, 1 / ae[3], ce]);
											})(D, e, i, w)
										);
									u &&
										(function (D, N, G, te) {
											const Q = te ? 4 : 0,
												ae = te ? 0 : 4;
											let ce = 0;
											const ve = [],
												me = [];
											for (let _e = 0; _e < 4; _e++) {
												const Be = s.aU([], D[_e + ae], D[_e + Q]),
													rt = s.aZ(Be);
												s.aR(Be, Be, 1 / rt), ve.push(rt), me.push(Be);
											}
											for (let _e = 0; _e < 4; _e++) {
												const Be = s.a_(D[_e + Q], me[_e], G);
												ce =
													Be !== null && Be >= 0
														? Math.max(ce, Be)
														: Math.max(ce, ve[_e]);
											}
											const be = (function (_e, Be) {
													const rt = s.aU([], _e[Be[0]], _e[Be[1]]),
														Ge = s.aU([], _e[Be[2]], _e[Be[1]]),
														Xe = [0, 0, 0, 0];
													return (
														s.aV(Xe, s.aW([], rt, Ge)),
														(Xe[3] = -s.aX(Xe, _e[Be[0]])),
														Xe
													);
												})(D, N),
												Pe = (function (_e, Be) {
													const rt = s.a$(_e),
														Ge = s.b0([], _e, 1 / rt),
														Xe = s.aU([], Be, s.aR([], Ge, s.aX(Be, Ge))),
														tt = s.a$(Xe);
													if (tt > 0) {
														const jt = Math.sqrt(1 - Ge[3] * Ge[3]),
															Zt = s.aR([], Ge, -Ge[3]),
															Tt = s.aS([], Zt, s.aR([], Xe, jt / tt));
														return s.b1(Be, Tt);
													}
													return null;
												})(G, be);
											if (Pe !== null) {
												const _e = Pe / s.aX(me[0], be);
												ce = Math.min(ce, _e);
											}
											for (let _e = 0; _e < 4; _e++) {
												const Be = Math.min(ce, ve[_e]);
												D[_e + ae] = [
													D[_e + Q][0] + me[_e][0] * Be,
													D[_e + Q][1] + me[_e][1] * Be,
													D[_e + Q][2] + me[_e][2] * Be,
													1,
												];
											}
										})(C, g[0], u, d);
									const P = g.map((D) => {
											const N = s.aU([], C[D[0]], C[D[1]]),
												G = s.aU([], C[D[2]], C[D[1]]),
												te = s.aV([], s.aW([], N, G)),
												Q = -s.aX(te, C[D[1]]);
											return te.concat(Q);
										}),
										E = [
											Number.POSITIVE_INFINITY,
											Number.POSITIVE_INFINITY,
											Number.POSITIVE_INFINITY,
										],
										R = [
											Number.NEGATIVE_INFINITY,
											Number.NEGATIVE_INFINITY,
											Number.NEGATIVE_INFINITY,
										];
									for (const D of C)
										for (let N = 0; N < 3; N++)
											(E[N] = Math.min(E[N], D[N])),
												(R[N] = Math.max(R[N], D[N]));
									return new fn(C, P, new kn(E, R));
								}
							}
							class on {
								get pixelsToClipSpaceMatrix() {
									return this._helper.pixelsToClipSpaceMatrix;
								}
								get clipSpaceToPixelsMatrix() {
									return this._helper.clipSpaceToPixelsMatrix;
								}
								get pixelsToGLUnits() {
									return this._helper.pixelsToGLUnits;
								}
								get centerOffset() {
									return this._helper.centerOffset;
								}
								get size() {
									return this._helper.size;
								}
								get rotationMatrix() {
									return this._helper.rotationMatrix;
								}
								get centerPoint() {
									return this._helper.centerPoint;
								}
								get pixelsPerMeter() {
									return this._helper.pixelsPerMeter;
								}
								setMinZoom(e) {
									this._helper.setMinZoom(e);
								}
								setMaxZoom(e) {
									this._helper.setMaxZoom(e);
								}
								setMinPitch(e) {
									this._helper.setMinPitch(e);
								}
								setMaxPitch(e) {
									this._helper.setMaxPitch(e);
								}
								setRenderWorldCopies(e) {
									this._helper.setRenderWorldCopies(e);
								}
								setBearing(e) {
									this._helper.setBearing(e);
								}
								setPitch(e) {
									this._helper.setPitch(e);
								}
								setRoll(e) {
									this._helper.setRoll(e);
								}
								setFov(e) {
									this._helper.setFov(e);
								}
								setZoom(e) {
									this._helper.setZoom(e);
								}
								setCenter(e) {
									this._helper.setCenter(e);
								}
								setElevation(e) {
									this._helper.setElevation(e);
								}
								setMinElevationForCurrentTile(e) {
									this._helper.setMinElevationForCurrentTile(e);
								}
								setPadding(e) {
									this._helper.setPadding(e);
								}
								interpolatePadding(e, i, l) {
									return this._helper.interpolatePadding(e, i, l);
								}
								isPaddingEqual(e) {
									return this._helper.isPaddingEqual(e);
								}
								resize(e, i, l = !0) {
									this._helper.resize(e, i, l);
								}
								getMaxBounds() {
									return this._helper.getMaxBounds();
								}
								setMaxBounds(e) {
									this._helper.setMaxBounds(e);
								}
								overrideNearFarZ(e, i) {
									this._helper.overrideNearFarZ(e, i);
								}
								clearNearFarZOverride() {
									this._helper.clearNearFarZOverride();
								}
								getCameraQueryGeometry(e) {
									return this._helper.getCameraQueryGeometry(
										this.getCameraPoint(),
										e
									);
								}
								get tileSize() {
									return this._helper.tileSize;
								}
								get tileZoom() {
									return this._helper.tileZoom;
								}
								get scale() {
									return this._helper.scale;
								}
								get worldSize() {
									return this._helper.worldSize;
								}
								get width() {
									return this._helper.width;
								}
								get height() {
									return this._helper.height;
								}
								get lngRange() {
									return this._helper.lngRange;
								}
								get latRange() {
									return this._helper.latRange;
								}
								get minZoom() {
									return this._helper.minZoom;
								}
								get maxZoom() {
									return this._helper.maxZoom;
								}
								get zoom() {
									return this._helper.zoom;
								}
								get center() {
									return this._helper.center;
								}
								get minPitch() {
									return this._helper.minPitch;
								}
								get maxPitch() {
									return this._helper.maxPitch;
								}
								get pitch() {
									return this._helper.pitch;
								}
								get pitchInRadians() {
									return this._helper.pitchInRadians;
								}
								get roll() {
									return this._helper.roll;
								}
								get rollInRadians() {
									return this._helper.rollInRadians;
								}
								get bearing() {
									return this._helper.bearing;
								}
								get bearingInRadians() {
									return this._helper.bearingInRadians;
								}
								get fov() {
									return this._helper.fov;
								}
								get fovInRadians() {
									return this._helper.fovInRadians;
								}
								get elevation() {
									return this._helper.elevation;
								}
								get minElevationForCurrentTile() {
									return this._helper.minElevationForCurrentTile;
								}
								get padding() {
									return this._helper.padding;
								}
								get unmodified() {
									return this._helper.unmodified;
								}
								get renderWorldCopies() {
									return this._helper.renderWorldCopies;
								}
								get cameraToCenterDistance() {
									return this._helper.cameraToCenterDistance;
								}
								get nearZ() {
									return this._helper.nearZ;
								}
								get farZ() {
									return this._helper.farZ;
								}
								get autoCalculateNearFarZ() {
									return this._helper.autoCalculateNearFarZ;
								}
								setTransitionState(e, i) {}
								constructor(e, i, l, u, d) {
									(this._posMatrixCache = new Map()),
										(this._alignedPosMatrixCache = new Map()),
										(this._fogMatrixCacheF32 = new Map()),
										(this._helper = new Sn(
											{
												calcMatrices: () => {
													this._calcMatrices();
												},
												getConstrained: (g, w) => this.getConstrained(g, w),
											},
											e,
											i,
											l,
											u,
											d
										)),
										(this._coveringTilesDetailsProvider = new vn());
								}
								clone() {
									const e = new on();
									return e.apply(this), e;
								}
								apply(e, i, l) {
									this._helper.apply(e, i, l);
								}
								get cameraPosition() {
									return this._cameraPosition;
								}
								get projectionMatrix() {
									return this._projectionMatrix;
								}
								get modelViewProjectionMatrix() {
									return this._viewProjMatrix;
								}
								get inverseProjectionMatrix() {
									return this._invProjMatrix;
								}
								get mercatorMatrix() {
									return this._mercatorMatrix;
								}
								getVisibleUnwrappedCoordinates(e) {
									const i = [new s.b2(0, e)];
									if (this._helper._renderWorldCopies) {
										const l = this.screenPointToMercatorCoordinate(
												new s.P(0, 0)
											),
											u = this.screenPointToMercatorCoordinate(
												new s.P(this._helper._width, 0)
											),
											d = this.screenPointToMercatorCoordinate(
												new s.P(this._helper._width, this._helper._height)
											),
											g = this.screenPointToMercatorCoordinate(
												new s.P(0, this._helper._height)
											),
											w = Math.floor(Math.min(l.x, u.x, d.x, g.x)),
											C = Math.floor(Math.max(l.x, u.x, d.x, g.x)),
											P = 1;
										for (let E = w - P; E <= C + P; E++)
											E !== 0 && i.push(new s.b2(E, e));
									}
									return i;
								}
								getCameraFrustum() {
									return fn.fromInvProjectionMatrix(
										this._invViewProjMatrix,
										this.worldSize
									);
								}
								getClippingPlane() {
									return null;
								}
								getCoveringTilesDetailsProvider() {
									return this._coveringTilesDetailsProvider;
								}
								recalculateZoomAndCenter(e) {
									const i = this.screenPointToLocation(this.centerPoint, e),
										l = e
											? e.getElevationForLngLatZoom(i, this._helper._tileZoom)
											: 0;
									this._helper.recalculateZoomAndCenter(l);
								}
								setLocationAtPoint(e, i) {
									const l = s.aj(this.elevation, this.center.lat),
										u = this.screenPointToMercatorCoordinateAtZ(i, l),
										d = this.screenPointToMercatorCoordinateAtZ(
											this.centerPoint,
											l
										),
										g = s.a1.fromLngLat(e),
										w = new s.a1(g.x - (u.x - d.x), g.y - (u.y - d.y));
									this.setCenter(w == null ? void 0 : w.toLngLat()),
										this._helper._renderWorldCopies &&
											this.setCenter(this.center.wrap());
								}
								locationToScreenPoint(e, i) {
									return i
										? this.coordinatePoint(
												s.a1.fromLngLat(e),
												i.getElevationForLngLatZoom(e, this._helper._tileZoom),
												this._pixelMatrix3D
										  )
										: this.coordinatePoint(s.a1.fromLngLat(e));
								}
								screenPointToLocation(e, i) {
									var l;
									return (l = this.screenPointToMercatorCoordinate(e, i)) ===
										null || l === void 0
										? void 0
										: l.toLngLat();
								}
								screenPointToMercatorCoordinate(e, i) {
									if (i) {
										const l = i.pointCoordinate(e);
										if (l != null) return l;
									}
									return this.screenPointToMercatorCoordinateAtZ(e);
								}
								screenPointToMercatorCoordinateAtZ(e, i) {
									const l = i || 0,
										u = [e.x, e.y, 0, 1],
										d = [e.x, e.y, 1, 1];
									s.aw(u, u, this._pixelMatrixInverse),
										s.aw(d, d, this._pixelMatrixInverse);
									const g = u[3],
										w = d[3],
										C = u[1] / g,
										P = d[1] / w,
										E = u[2] / g,
										R = d[2] / w,
										D = E === R ? 0 : (l - E) / (R - E);
									return new s.a1(
										s.C.number(u[0] / g, d[0] / w, D) / this.worldSize,
										s.C.number(C, P, D) / this.worldSize,
										l
									);
								}
								coordinatePoint(e, i = 0, l = this._pixelMatrix) {
									const u = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
									return s.aw(u, u, l), new s.P(u[0] / u[3], u[1] / u[3]);
								}
								getBounds() {
									const e = Math.max(0, this._helper._height / 2 - pe(this));
									return new _t()
										.extend(this.screenPointToLocation(new s.P(0, e)))
										.extend(
											this.screenPointToLocation(
												new s.P(this._helper._width, e)
											)
										)
										.extend(
											this.screenPointToLocation(
												new s.P(this._helper._width, this._helper._height)
											)
										)
										.extend(
											this.screenPointToLocation(
												new s.P(0, this._helper._height)
											)
										);
								}
								isPointOnMapSurface(e, i) {
									return i
										? i.pointCoordinate(e) != null
										: e.y > this.height / 2 - pe(this);
								}
								calculatePosMatrix(e, i = !1, l) {
									var u;
									const d =
											(u = e.key) !== null && u !== void 0
												? u
												: s.b3(
														e.wrap,
														e.canonical.z,
														e.canonical.z,
														e.canonical.x,
														e.canonical.y
												  ),
										g = i ? this._alignedPosMatrixCache : this._posMatrixCache;
									if (g.has(d)) {
										const P = g.get(d);
										return l ? P.f32 : P.f64;
									}
									const w = Se(e, this.worldSize);
									s.O(w, i ? this._alignedProjMatrix : this._viewProjMatrix, w);
									const C = { f64: w, f32: new Float32Array(w) };
									return g.set(d, C), l ? C.f32 : C.f64;
								}
								calculateFogMatrix(e) {
									const i = e.key,
										l = this._fogMatrixCacheF32;
									if (l.has(i)) return l.get(i);
									const u = Se(e, this.worldSize);
									return (
										s.O(u, this._fogMatrix, u),
										l.set(i, new Float32Array(u)),
										l.get(i)
									);
								}
								getConstrained(e, i) {
									i = s.ah(+i, this.minZoom, this.maxZoom);
									const l = { center: new s.S(e.lng, e.lat), zoom: i };
									let u = this._helper._lngRange;
									if (!this._helper._renderWorldCopies && u === null) {
										const ve = 179.9999999999;
										u = [-ve, ve];
									}
									const d = this.tileSize * s.af(l.zoom);
									let g = 0,
										w = d,
										C = 0,
										P = d,
										E = 0,
										R = 0;
									const { x: D, y: N } = this.size;
									if (this._helper._latRange) {
										const ve = this._helper._latRange;
										(g = s.U(ve[1]) * d),
											(w = s.U(ve[0]) * d),
											w - g < N && (E = N / (w - g));
									}
									u &&
										((C = s.aO(s.V(u[0]) * d, 0, d)),
										(P = s.aO(s.V(u[1]) * d, 0, d)),
										P < C && (P += d),
										P - C < D && (R = D / (P - C)));
									const { x: G, y: te } = Y(d, e);
									let Q, ae;
									const ce = Math.max(R || 0, E || 0);
									if (ce) {
										const ve = new s.P(
											R ? (P + C) / 2 : G,
											E ? (w + g) / 2 : te
										);
										return (
											(l.center = ie(d, ve).wrap()), (l.zoom += s.ak(ce)), l
										);
									}
									if (this._helper._latRange) {
										const ve = N / 2;
										te - ve < g && (ae = g + ve), te + ve > w && (ae = w - ve);
									}
									if (u) {
										const ve = (C + P) / 2;
										let me = G;
										this._helper._renderWorldCopies &&
											(me = s.aO(G, ve - d / 2, ve + d / 2));
										const be = D / 2;
										me - be < C && (Q = C + be), me + be > P && (Q = P - be);
									}
									if (Q !== void 0 || ae !== void 0) {
										const ve = new s.P(Q ?? G, ae ?? te);
										l.center = ie(d, ve).wrap();
									}
									return l;
								}
								calculateCenterFromCameraLngLatAlt(e, i, l, u) {
									return this._helper.calculateCenterFromCameraLngLatAlt(
										e,
										i,
										l,
										u
									);
								}
								_calculateNearFarZIfNeeded(e, i, l) {
									if (!this._helper.autoCalculateNearFarZ) return;
									const u = Math.min(
											this.elevation,
											this.minElevationForCurrentTile,
											this.getCameraAltitude() - 100
										),
										d = e - (u * this._helper._pixelPerMeter) / Math.cos(i),
										g = u < 0 ? d : e,
										w = Math.PI / 2 + this.pitchInRadians,
										C =
											((s.ae(this.fov) *
												(Math.abs(Math.cos(s.ae(this.roll))) * this.height +
													Math.abs(Math.sin(s.ae(this.roll))) * this.width)) /
												this.height) *
											(0.5 + l.y / this.height),
										P =
											(Math.sin(C) * g) /
											Math.sin(s.ah(Math.PI - w - C, 0.01, Math.PI - 0.01)),
										E = pe(this),
										R = Math.atan(E / this._helper.cameraToCenterDistance),
										D = s.ae(0.75),
										N = R > D ? 2 * R * (0.5 + l.y / (2 * E)) : D,
										G =
											(Math.sin(N) * g) /
											Math.sin(s.ah(Math.PI - w - N, 0.01, Math.PI - 0.01)),
										te = Math.min(P, G);
									(this._helper._farZ =
										1.01 * (Math.cos(Math.PI / 2 - i) * te + g)),
										(this._helper._nearZ = this._helper._height / 50);
								}
								_calcMatrices() {
									if (!this._helper._height) return;
									const e = this.centerOffset,
										i = Y(this.worldSize, this.center),
										l = i.x,
										u = i.y;
									this._helper._pixelPerMeter =
										s.aj(1, this.center.lat) * this.worldSize;
									const d = s.ae(Math.min(this.pitch, U)),
										g = Math.max(
											this._helper.cameraToCenterDistance / 2,
											this._helper.cameraToCenterDistance +
												(this._helper._elevation *
													this._helper._pixelPerMeter) /
													Math.cos(d)
										);
									let w;
									this._calculateNearFarZIfNeeded(g, d, e),
										(w = new Float64Array(16)),
										s.b4(
											w,
											this.fovInRadians,
											this._helper._width / this._helper._height,
											this._helper._nearZ,
											this._helper._farZ
										),
										(this._invProjMatrix = new Float64Array(16)),
										s.aq(this._invProjMatrix, w),
										(w[8] = (2 * -e.x) / this._helper._width),
										(w[9] = (2 * e.y) / this._helper._height),
										(this._projectionMatrix = s.b5(w)),
										s.N(w, w, [1, -1, 1]),
										s.M(w, w, [0, 0, -this._helper.cameraToCenterDistance]),
										s.b6(w, w, -this.rollInRadians),
										s.b7(w, w, this.pitchInRadians),
										s.b6(w, w, -this.bearingInRadians),
										s.M(w, w, [-l, -u, 0]),
										(this._mercatorMatrix = s.N([], w, [
											this.worldSize,
											this.worldSize,
											this.worldSize,
										])),
										s.N(w, w, [1, 1, this._helper._pixelPerMeter]),
										(this._pixelMatrix = s.O(
											new Float64Array(16),
											this.clipSpaceToPixelsMatrix,
											w
										)),
										s.M(w, w, [0, 0, -this.elevation]),
										(this._viewProjMatrix = w),
										(this._invViewProjMatrix = s.aq([], w));
									const C = [0, 0, -1, 1];
									s.aw(C, C, this._invViewProjMatrix),
										(this._cameraPosition = [
											C[0] / C[3],
											C[1] / C[3],
											C[2] / C[3],
										]),
										(this._fogMatrix = new Float64Array(16)),
										s.b4(
											this._fogMatrix,
											this.fovInRadians,
											this.width / this.height,
											g,
											this._helper._farZ
										),
										(this._fogMatrix[8] = (2 * -e.x) / this.width),
										(this._fogMatrix[9] = (2 * e.y) / this.height),
										s.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
										s.M(this._fogMatrix, this._fogMatrix, [
											0,
											0,
											-this.cameraToCenterDistance,
										]),
										s.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
										s.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
										s.b6(
											this._fogMatrix,
											this._fogMatrix,
											-this.bearingInRadians
										),
										s.M(this._fogMatrix, this._fogMatrix, [-l, -u, 0]),
										s.N(this._fogMatrix, this._fogMatrix, [
											1,
											1,
											this._helper._pixelPerMeter,
										]),
										s.M(this._fogMatrix, this._fogMatrix, [
											0,
											0,
											-this.elevation,
										]),
										(this._pixelMatrix3D = s.O(
											new Float64Array(16),
											this.clipSpaceToPixelsMatrix,
											w
										));
									const P = (this._helper._width % 2) / 2,
										E = (this._helper._height % 2) / 2,
										R = Math.cos(this.bearingInRadians),
										D = Math.sin(-this.bearingInRadians),
										N = l - Math.round(l) + R * P + D * E,
										G = u - Math.round(u) + R * E + D * P,
										te = new Float64Array(w);
									if (
										(s.M(te, te, [N > 0.5 ? N - 1 : N, G > 0.5 ? G - 1 : G, 0]),
										(this._alignedProjMatrix = te),
										(w = s.aq(new Float64Array(16), this._pixelMatrix)),
										!w)
									)
										throw new Error("failed to invert matrix");
									(this._pixelMatrixInverse = w), this._clearMatrixCaches();
								}
								_clearMatrixCaches() {
									this._posMatrixCache.clear(),
										this._alignedPosMatrixCache.clear(),
										this._fogMatrixCacheF32.clear();
								}
								maxPitchScaleFactor() {
									if (!this._pixelMatrixInverse) return 1;
									const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)),
										i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
									return (
										s.aw(i, i, this._pixelMatrix)[3] /
										this._helper.cameraToCenterDistance
									);
								}
								getCameraPoint() {
									return this._helper.getCameraPoint();
								}
								getCameraAltitude() {
									return this._helper.getCameraAltitude();
								}
								getCameraLngLat() {
									const e = s.aj(1, this.center.lat) * this.worldSize;
									return Me(
										this.center,
										this.elevation,
										this.pitch,
										this.bearing,
										this._helper.cameraToCenterDistance / e
									).toLngLat();
								}
								lngLatToCameraDepth(e, i) {
									const l = s.a1.fromLngLat(e),
										u = [l.x * this.worldSize, l.y * this.worldSize, i, 1];
									return s.aw(u, u, this._viewProjMatrix), u[2] / u[3];
								}
								getProjectionData(e) {
									const {
											overscaledTileID: i,
											aligned: l,
											applyTerrainMatrix: u,
										} = e,
										d = this._helper.getMercatorTileCoordinates(i),
										g = i ? this.calculatePosMatrix(i, l, !0) : null;
									let w;
									return (
										(w =
											i && i.terrainRttPosMatrix32f && u
												? i.terrainRttPosMatrix32f
												: g || s.b8()),
										{
											mainMatrix: w,
											tileMercatorCoords: d,
											clippingPlane: [0, 0, 0, 0],
											projectionTransition: 0,
											fallbackMatrix: w,
										}
									);
								}
								isLocationOccluded(e) {
									return !1;
								}
								getPixelScale() {
									return 1;
								}
								getCircleRadiusCorrection() {
									return 1;
								}
								getPitchedTextCorrection(e, i, l) {
									return 1;
								}
								transformLightDirection(e) {
									return s.aT(e);
								}
								getRayDirectionFromPixel(e) {
									throw new Error("Not implemented.");
								}
								projectTileCoordinates(e, i, l, u) {
									const d = this.calculatePosMatrix(l);
									let g;
									u
										? ((g = [e, i, u(e, i), 1]), s.aw(g, g, d))
										: ((g = [e, i, 0, 1]), En(g, g, d));
									const w = g[3];
									return {
										point: new s.P(g[0] / w, g[1] / w),
										signedDistanceFromCamera: w,
										isOccluded: !1,
									};
								}
								populateCache(e) {
									for (const i of e) this.calculatePosMatrix(i);
								}
								getMatrixForModel(e, i) {
									const l = s.a1.fromLngLat(e, i),
										u = l.meterInMercatorCoordinateUnits(),
										d = s.b9();
									return (
										s.M(d, d, [l.x, l.y, l.z]),
										s.b6(d, d, Math.PI),
										s.b7(d, d, Math.PI / 2),
										s.N(d, d, [-u, u, u]),
										d
									);
								}
								getProjectionDataForCustomLayer(e = !0) {
									const i = new s.Z(0, 0, 0, 0, 0),
										l = this.getProjectionData({
											overscaledTileID: i,
											applyGlobeMatrix: e,
										}),
										u = Se(i, this.worldSize);
									s.O(u, this._viewProjMatrix, u),
										(l.tileMercatorCoords = [0, 0, 1, 1]);
									const d = [
											s.$,
											s.$,
											this.worldSize / this._helper.pixelsPerMeter,
										],
										g = s.ba();
									return (
										s.N(g, u, d), (l.fallbackMatrix = g), (l.mainMatrix = g), l
									);
								}
								getFastPathSimpleProjectionMatrix(e) {
									return this.calculatePosMatrix(e);
								}
							}
							function po() {
								s.w(
									"Map cannot fit within canvas with the given bounds, padding, and/or offset."
								);
							}
							function fi(h) {
								if (h.useSlerp)
									if (h.k < 1) {
										const e = s.bb(
												h.startEulerAngles.roll,
												h.startEulerAngles.pitch,
												h.startEulerAngles.bearing
											),
											i = s.bb(
												h.endEulerAngles.roll,
												h.endEulerAngles.pitch,
												h.endEulerAngles.bearing
											),
											l = new Float64Array(4);
										s.bc(l, e, i, h.k);
										const u = s.bd(l);
										h.tr.setRoll(u.roll),
											h.tr.setPitch(u.pitch),
											h.tr.setBearing(u.bearing);
									} else
										h.tr.setRoll(h.endEulerAngles.roll),
											h.tr.setPitch(h.endEulerAngles.pitch),
											h.tr.setBearing(h.endEulerAngles.bearing);
								else
									h.tr.setRoll(
										s.C.number(
											h.startEulerAngles.roll,
											h.endEulerAngles.roll,
											h.k
										)
									),
										h.tr.setPitch(
											s.C.number(
												h.startEulerAngles.pitch,
												h.endEulerAngles.pitch,
												h.k
											)
										),
										h.tr.setBearing(
											s.C.number(
												h.startEulerAngles.bearing,
												h.endEulerAngles.bearing,
												h.k
											)
										);
							}
							function Hn(h, e, i, l, u) {
								const d = u.padding,
									g = Y(u.worldSize, i.getNorthWest()),
									w = Y(u.worldSize, i.getNorthEast()),
									C = Y(u.worldSize, i.getSouthEast()),
									P = Y(u.worldSize, i.getSouthWest()),
									E = s.ae(-l),
									R = g.rotate(E),
									D = w.rotate(E),
									N = C.rotate(E),
									G = P.rotate(E),
									te = new s.P(
										Math.max(R.x, D.x, G.x, N.x),
										Math.max(R.y, D.y, G.y, N.y)
									),
									Q = new s.P(
										Math.min(R.x, D.x, G.x, N.x),
										Math.min(R.y, D.y, G.y, N.y)
									),
									ae = te.sub(Q),
									ce = (u.width - (d.left + d.right + e.left + e.right)) / ae.x,
									ve =
										(u.height - (d.top + d.bottom + e.top + e.bottom)) / ae.y;
								if (ve < 0 || ce < 0) return void po();
								const me = Math.min(
										s.ak(u.scale * Math.min(ce, ve)),
										h.maxZoom
									),
									be = s.P.convert(h.offset),
									Pe = new s.P(
										(e.left - e.right) / 2,
										(e.top - e.bottom) / 2
									).rotate(s.ae(l)),
									_e = be.add(Pe).mult(u.scale / s.af(me));
								return {
									center: ie(u.worldSize, g.add(C).div(2).sub(_e)),
									zoom: me,
									bearing: l,
								};
							}
							class jn {
								get useGlobeControls() {
									return !1;
								}
								handlePanInertia(e, i) {
									return { easingOffset: e, easingCenter: i.center };
								}
								handleMapControlsRollPitchBearingZoom(e, i) {
									e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
										e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
										e.rollDelta && i.setRoll(i.roll + e.rollDelta),
										e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
								}
								handleMapControlsPan(e, i, l) {
									e.around.distSqr(i.centerPoint) < 0.01 ||
										i.setLocationAtPoint(l, e.around);
								}
								cameraForBoxAndBearing(e, i, l, u, d) {
									return Hn(e, i, l, u, d);
								}
								handleJumpToCenterZoom(e, i) {
									e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) &&
										e.setZoom(+i.zoom),
										i.center !== void 0 && e.setCenter(s.S.convert(i.center));
								}
								handleEaseTo(e, i) {
									const l = e.zoom,
										u = e.padding,
										d = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
										g = {
											roll: i.roll === void 0 ? e.roll : i.roll,
											pitch: i.pitch === void 0 ? e.pitch : i.pitch,
											bearing: i.bearing === void 0 ? e.bearing : i.bearing,
										},
										w = i.zoom !== void 0,
										C = !e.isPaddingEqual(i.padding);
									let P = !1;
									const E = w ? +i.zoom : e.zoom;
									let R = e.centerPoint.add(i.offsetAsPoint);
									const D = e.screenPointToLocation(R),
										{ center: N, zoom: G } = e.getConstrained(
											s.S.convert(i.center || D),
											E ?? l
										);
									bn(e, N);
									const te = Y(e.worldSize, D),
										Q = Y(e.worldSize, N).sub(te),
										ae = s.af(G - l);
									return (
										(P = G !== l),
										{
											easeFunc: (ce) => {
												if (
													(P && e.setZoom(s.C.number(l, G, ce)),
													s.be(d, g) ||
														fi({
															startEulerAngles: d,
															endEulerAngles: g,
															tr: e,
															k: ce,
															useSlerp: d.roll != g.roll,
														}),
													C &&
														(e.interpolatePadding(u, i.padding, ce),
														(R = e.centerPoint.add(i.offsetAsPoint))),
													i.around)
												)
													e.setLocationAtPoint(i.around, i.aroundPoint);
												else {
													const ve = s.af(e.zoom - l),
														me = G > l ? Math.min(2, ae) : Math.max(0.5, ae),
														be = Math.pow(me, 1 - ce),
														Pe = ie(
															e.worldSize,
															te.add(Q.mult(ce * be)).mult(ve)
														);
													e.setLocationAtPoint(
														e.renderWorldCopies ? Pe.wrap() : Pe,
														R
													);
												}
											},
											isZooming: P,
											elevationCenter: N,
										}
									);
								}
								handleFlyTo(e, i) {
									const l = i.zoom !== void 0,
										u = e.zoom,
										d = e.getConstrained(
											s.S.convert(i.center || i.locationAtOffset),
											l ? +i.zoom : u
										),
										g = d.center,
										w = d.zoom;
									bn(e, g);
									const C = Y(e.worldSize, i.locationAtOffset),
										P = Y(e.worldSize, g).sub(C),
										E = P.mag(),
										R = s.af(w - u);
									let D;
									if (i.minZoom !== void 0) {
										const N = Math.min(+i.minZoom, u, w),
											G = e.getConstrained(g, N).zoom;
										D = s.af(G - u);
									}
									return {
										easeFunc: (N, G, te, Q) => {
											e.setZoom(N === 1 ? w : u + s.ak(G));
											const ae =
												N === 1
													? g
													: ie(e.worldSize, C.add(P.mult(te)).mult(G));
											e.setLocationAtPoint(
												e.renderWorldCopies ? ae.wrap() : ae,
												Q
											);
										},
										scaleOfZoom: R,
										targetCenter: g,
										scaleOfMinZoom: D,
										pixelPathLength: E,
									};
								}
							}
							class zn {
								constructor(e, i, l) {
									(this.blendFunction = e),
										(this.blendColor = i),
										(this.mask = l);
								}
							}
							(zn.Replace = [1, 0]),
								(zn.disabled = new zn(zn.Replace, s.bf.transparent, [
									!1,
									!1,
									!1,
									!1,
								])),
								(zn.unblended = new zn(zn.Replace, s.bf.transparent, [
									!0,
									!0,
									!0,
									!0,
								])),
								(zn.alphaBlended = new zn([1, 771], s.bf.transparent, [
									!0,
									!0,
									!0,
									!0,
								]));
							const qa = 2305;
							class Rr {
								constructor(e, i, l) {
									(this.enable = e), (this.mode = i), (this.frontFace = l);
								}
							}
							(Rr.disabled = new Rr(!1, 1029, qa)),
								(Rr.backCCW = new Rr(!0, 1029, qa)),
								(Rr.frontCCW = new Rr(!0, 1028, qa));
							class Gr {
								constructor(e, i, l) {
									(this.func = e), (this.mask = i), (this.range = l);
								}
							}
							(Gr.ReadOnly = !1),
								(Gr.ReadWrite = !0),
								(Gr.disabled = new Gr(519, Gr.ReadOnly, [0, 1]));
							const _a = 7680;
							class un {
								constructor(e, i, l, u, d, g) {
									(this.test = e),
										(this.ref = i),
										(this.mask = l),
										(this.fail = u),
										(this.depthFail = d),
										(this.pass = g);
								}
							}
							un.disabled = new un({ func: 519, mask: 0 }, 0, 0, _a, _a, _a);
							const Li = new WeakMap();
							function ga(h) {
								var e;
								if (Li.has(h)) return Li.get(h);
								{
									const i =
										(e = h.getParameter(h.VERSION)) === null || e === void 0
											? void 0
											: e.startsWith("WebGL 2.0");
									return Li.set(h, i), i;
								}
							}
							class sa {
								get awaitingQuery() {
									return !!this._readbackQueue;
								}
								constructor(e) {
									(this._readbackWaitFrames = 4),
										(this._measureWaitFrames = 6),
										(this._texWidth = 1),
										(this._texHeight = 1),
										(this._measuredError = 0),
										(this._updateCount = 0),
										(this._lastReadbackFrame = -1e3),
										(this._readbackQueue = null),
										(this._cachedRenderContext = e);
									const i = e.context,
										l = i.gl;
									(this._texFormat = l.RGBA), (this._texType = l.UNSIGNED_BYTE);
									const u = new s.aL();
									u.emplaceBack(-1, -1),
										u.emplaceBack(2, -1),
										u.emplaceBack(-1, 2);
									const d = new s.aN();
									d.emplaceBack(0, 1, 2),
										(this._fullscreenTriangle = new Tn(
											i.createVertexBuffer(u, an.members),
											i.createIndexBuffer(d),
											s.aM.simpleSegment(0, 0, u.length, d.length)
										)),
										(this._resultBuffer = new Uint8Array(4)),
										i.activeTexture.set(l.TEXTURE1);
									const g = l.createTexture();
									l.bindTexture(l.TEXTURE_2D, g),
										l.texParameteri(
											l.TEXTURE_2D,
											l.TEXTURE_WRAP_S,
											l.CLAMP_TO_EDGE
										),
										l.texParameteri(
											l.TEXTURE_2D,
											l.TEXTURE_WRAP_T,
											l.CLAMP_TO_EDGE
										),
										l.texParameteri(
											l.TEXTURE_2D,
											l.TEXTURE_MIN_FILTER,
											l.NEAREST
										),
										l.texParameteri(
											l.TEXTURE_2D,
											l.TEXTURE_MAG_FILTER,
											l.NEAREST
										),
										l.texImage2D(
											l.TEXTURE_2D,
											0,
											this._texFormat,
											this._texWidth,
											this._texHeight,
											0,
											this._texFormat,
											this._texType,
											null
										),
										(this._fbo = i.createFramebuffer(
											this._texWidth,
											this._texHeight,
											!1,
											!1
										)),
										this._fbo.colorAttachment.set(g),
										ga(l) &&
											((this._pbo = l.createBuffer()),
											l.bindBuffer(l.PIXEL_PACK_BUFFER, this._pbo),
											l.bufferData(l.PIXEL_PACK_BUFFER, 4, l.STREAM_READ),
											l.bindBuffer(l.PIXEL_PACK_BUFFER, null));
								}
								destroy() {
									const e = this._cachedRenderContext.context.gl;
									this._fullscreenTriangle.destroy(),
										this._fbo.destroy(),
										e.deleteBuffer(this._pbo),
										(this._fullscreenTriangle = null),
										(this._fbo = null),
										(this._pbo = null),
										(this._resultBuffer = null);
								}
								updateErrorLoop(e, i) {
									const l = this._updateCount;
									return (
										this._readbackQueue
											? l >=
													this._readbackQueue.frameNumberIssued +
														this._readbackWaitFrames && this._tryReadback()
											: l >=
													this._lastReadbackFrame + this._measureWaitFrames &&
											  this._renderErrorTexture(e, i),
										this._updateCount++,
										this._measuredError
									);
								}
								_bindFramebuffer() {
									const e = this._cachedRenderContext.context,
										i = e.gl;
									e.activeTexture.set(i.TEXTURE1),
										i.bindTexture(
											i.TEXTURE_2D,
											this._fbo.colorAttachment.get()
										),
										e.bindFramebuffer.set(this._fbo.framebuffer);
								}
								_renderErrorTexture(e, i) {
									const l = this._cachedRenderContext.context,
										u = l.gl;
									if (
										(this._bindFramebuffer(),
										l.viewport.set([0, 0, this._texWidth, this._texHeight]),
										l.clear({ color: s.bf.transparent }),
										this._cachedRenderContext
											.useProgram("projectionErrorMeasurement")
											.draw(
												l,
												u.TRIANGLES,
												Gr.disabled,
												un.disabled,
												zn.unblended,
												Rr.disabled,
												((d, g) => ({ u_input: d, u_output_expected: g }))(
													e,
													i
												),
												null,
												null,
												"$clipping",
												this._fullscreenTriangle.vertexBuffer,
												this._fullscreenTriangle.indexBuffer,
												this._fullscreenTriangle.segments
											),
										this._pbo && ga(u))
									) {
										u.bindBuffer(u.PIXEL_PACK_BUFFER, this._pbo),
											u.readBuffer(u.COLOR_ATTACHMENT0),
											u.readPixels(
												0,
												0,
												this._texWidth,
												this._texHeight,
												this._texFormat,
												this._texType,
												0
											),
											u.bindBuffer(u.PIXEL_PACK_BUFFER, null);
										const d = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
										u.flush(),
											(this._readbackQueue = {
												frameNumberIssued: this._updateCount,
												sync: d,
											});
									} else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
								}
								_tryReadback() {
									const e = this._cachedRenderContext.context.gl;
									if (this._pbo && this._readbackQueue && ga(e)) {
										const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
										if (i === e.WAIT_FAILED)
											return (
												s.w("WebGL2 clientWaitSync failed."),
												(this._readbackQueue = null),
												void (this._lastReadbackFrame = this._updateCount)
											);
										if (i === e.TIMEOUT_EXPIRED) return;
										e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
											e.getBufferSubData(
												e.PIXEL_PACK_BUFFER,
												0,
												this._resultBuffer,
												0,
												4
											),
											e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
									} else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
									(this._readbackQueue = null),
										(this._measuredError = sa._parseRGBA8float(
											this._resultBuffer
										)),
										(this._lastReadbackFrame = this._updateCount);
								}
								static _parseRGBA8float(e) {
									let i = 0;
									return (
										(i += e[0] / 256),
										(i += e[1] / 65536),
										(i += e[2] / 16777216),
										e[3] < 127 && (i = -i),
										i / 128
									);
								}
							}
							const Ja = s.$ / 128;
							function Ms(h, e) {
								const i =
										h.granularity !== void 0 ? Math.max(h.granularity, 1) : 1,
									l = i + (h.generateBorders ? 2 : 0),
									u =
										i +
										(h.extendToNorthPole || h.generateBorders ? 1 : 0) +
										(h.extendToSouthPole || h.generateBorders ? 1 : 0),
									d = l + 1,
									g = u + 1,
									w = h.generateBorders ? -1 : 0,
									C = h.generateBorders || h.extendToNorthPole ? -1 : 0,
									P = i + (h.generateBorders ? 1 : 0),
									E = i + (h.generateBorders || h.extendToSouthPole ? 1 : 0),
									R = d * g,
									D = l * u * 6,
									N = d * g > 65536;
								if (N && e === "16bit")
									throw new Error(
										"Granularity is too large and meshes would not fit inside 16 bit vertex indices."
									);
								const G = N || e === "32bit",
									te = new Int16Array(2 * R);
								let Q = 0;
								for (let ve = C; ve <= E; ve++)
									for (let me = w; me <= P; me++) {
										let be = (me / i) * s.$;
										me === -1 && (be = -Ja), me === i + 1 && (be = s.$ + Ja);
										let Pe = (ve / i) * s.$;
										ve === -1 && (Pe = h.extendToNorthPole ? s.bh : -Ja),
											ve === i + 1 &&
												(Pe = h.extendToSouthPole ? s.bi : s.$ + Ja),
											(te[Q++] = be),
											(te[Q++] = Pe);
									}
								const ae = G ? new Uint32Array(D) : new Uint16Array(D);
								let ce = 0;
								for (let ve = 0; ve < u; ve++)
									for (let me = 0; me < l; me++) {
										const be = me + 1 + ve * d,
											Pe = me + (ve + 1) * d,
											_e = me + 1 + (ve + 1) * d;
										(ae[ce++] = me + ve * d),
											(ae[ce++] = Pe),
											(ae[ce++] = be),
											(ae[ce++] = be),
											(ae[ce++] = Pe),
											(ae[ce++] = _e);
									}
								return {
									vertices: te.buffer.slice(0),
									indices: ae.buffer.slice(0),
									uses32bitIndices: G,
								};
							}
							const Ca = new s.aK({
								fill: new s.bj(128, 2),
								line: new s.bj(512, 0),
								tile: new s.bj(128, 32),
								stencil: new s.bj(128, 1),
								circle: 3,
							});
							class Qa {
								constructor() {
									(this._tileMeshCache = {}),
										(this._errorCorrectionUsable = 0),
										(this._errorMeasurementLastValue = 0),
										(this._errorCorrectionPreviousValue = 0),
										(this._errorMeasurementLastChangeTime = -1e3);
								}
								get name() {
									return "vertical-perspective";
								}
								get transitionState() {
									return 1;
								}
								get useSubdivision() {
									return !0;
								}
								get shaderVariantName() {
									return "globe";
								}
								get shaderDefine() {
									return "#define GLOBE";
								}
								get shaderPreludeCode() {
									return $r.projectionGlobe;
								}
								get vertexShaderPreludeCode() {
									return $r.projectionMercator.vertexSource;
								}
								get subdivisionGranularity() {
									return Ca;
								}
								get useGlobeControls() {
									return !0;
								}
								get latitudeErrorCorrectionRadians() {
									return this._errorCorrectionUsable;
								}
								destroy() {
									this._errorMeasurement && this._errorMeasurement.destroy();
								}
								updateGPUdependent(e) {
									this._errorMeasurement ||
										(this._errorMeasurement = new sa(e));
									const i = s.U(this._errorQueryLatitudeDegrees),
										l =
											2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) -
											0.5 * Math.PI,
										u = this._errorMeasurement.updateErrorLoop(i, l),
										d = ne.now();
									u !== this._errorMeasurementLastValue &&
										((this._errorCorrectionPreviousValue =
											this._errorCorrectionUsable),
										(this._errorMeasurementLastValue = u),
										(this._errorMeasurementLastChangeTime = d));
									const g = Math.min(
										Math.max(
											(d - this._errorMeasurementLastChangeTime) / 1e3 / 0.5,
											0
										),
										1
									);
									this._errorCorrectionUsable = s.bk(
										this._errorCorrectionPreviousValue,
										-this._errorMeasurementLastValue,
										s.bl(g)
									);
								}
								_getMeshKey(e) {
									return `${e.granularity.toString(
										36
									)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
								}
								getMeshFromTileID(e, i, l, u, d) {
									const g = (
										d === "stencil" ? Ca.stencil : Ca.tile
									).getGranularityForZoomLevel(i.z);
									return this._getMesh(e, {
										granularity: g,
										generateBorders: l,
										extendToNorthPole: i.y === 0 && u,
										extendToSouthPole: i.y === (1 << i.z) - 1 && u,
									});
								}
								_getMesh(e, i) {
									const l = this._getMeshKey(i);
									if (l in this._tileMeshCache) return this._tileMeshCache[l];
									const u = (function (d, g) {
										const w = Ms(g, "16bit"),
											C = s.aL.deserialize({
												arrayBuffer: w.vertices,
												length: w.vertices.byteLength / 2 / 2,
											}),
											P = s.aN.deserialize({
												arrayBuffer: w.indices,
												length: w.indices.byteLength / 2 / 3,
											});
										return new Tn(
											d.createVertexBuffer(C, an.members),
											d.createIndexBuffer(P),
											s.aM.simpleSegment(0, 0, C.length, P.length)
										);
									})(e, i);
									return (this._tileMeshCache[l] = u), u;
								}
								recalculate(e) {}
								hasTransition() {
									const e = ne.now();
									let i = !1;
									return (
										(i =
											i ||
											(e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7),
										(i =
											i ||
											(this._errorMeasurement &&
												this._errorMeasurement.awaitingQuery)),
										i
									);
								}
								setErrorQueryLatitudeDegrees(e) {
									this._errorQueryLatitudeDegrees = e;
								}
							}
							const Jo = new s.r({ type: new s.D(s.v.projection.type) });
							class gl extends s.E {
								constructor(e) {
									super(),
										(this._transitionable = new s.t(Jo)),
										this.setProjection(e),
										(this._transitioning =
											this._transitionable.untransitioned()),
										this.recalculate(new s.F(0)),
										(this._mercatorProjection = new Mr()),
										(this._verticalPerspectiveProjection = new Qa());
								}
								get transitionState() {
									const e = this.properties.get("type");
									if (typeof e == "string" && e === "mercator") return 0;
									if (typeof e == "string" && e === "vertical-perspective")
										return 1;
									if (e instanceof s.bm) {
										if (
											e.from === "vertical-perspective" &&
											e.to === "mercator"
										)
											return 1 - e.transition;
										if (
											e.from === "mercator" &&
											e.to === "vertical-perspective"
										)
											return e.transition;
									}
									return 1;
								}
								get useGlobeRendering() {
									return this.transitionState > 0;
								}
								get latitudeErrorCorrectionRadians() {
									return this
										._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
								}
								get currentProjection() {
									return this.useGlobeRendering
										? this._verticalPerspectiveProjection
										: this._mercatorProjection;
								}
								get name() {
									return "globe";
								}
								get useSubdivision() {
									return this.currentProjection.useSubdivision;
								}
								get shaderVariantName() {
									return this.currentProjection.shaderVariantName;
								}
								get shaderDefine() {
									return this.currentProjection.shaderDefine;
								}
								get shaderPreludeCode() {
									return this.currentProjection.shaderPreludeCode;
								}
								get vertexShaderPreludeCode() {
									return this.currentProjection.vertexShaderPreludeCode;
								}
								get subdivisionGranularity() {
									return this.currentProjection.subdivisionGranularity;
								}
								get useGlobeControls() {
									return this.transitionState > 0;
								}
								destroy() {
									this._mercatorProjection.destroy(),
										this._verticalPerspectiveProjection.destroy();
								}
								updateGPUdependent(e) {
									this._mercatorProjection.updateGPUdependent(e),
										this._verticalPerspectiveProjection.updateGPUdependent(e);
								}
								getMeshFromTileID(e, i, l, u, d) {
									return this.currentProjection.getMeshFromTileID(
										e,
										i,
										l,
										u,
										d
									);
								}
								setProjection(e) {
									this._transitionable.setValue(
										"type",
										(e == null ? void 0 : e.type) || "mercator"
									);
								}
								updateTransitions(e) {
									this._transitioning = this._transitionable.transitioned(
										e,
										this._transitioning
									);
								}
								hasTransition() {
									return (
										this._transitioning.hasTransition() ||
										this.currentProjection.hasTransition()
									);
								}
								recalculate(e) {
									this.properties = this._transitioning.possiblyEvaluate(e);
								}
								setErrorQueryLatitudeDegrees(e) {
									this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(
										e
									),
										this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
								}
							}
							function vl(h) {
								const e = Qo(h.worldSize, h.center.lat);
								return 2 * Math.PI * e;
							}
							function Sa(h, e, i, l, u) {
								const d = 1 / (1 << u),
									g = (e / s.$) * d + l * d,
									w = s.bo(
										((h / s.$) * d + i * d) * Math.PI * 2 + Math.PI,
										2 * Math.PI
									),
									C =
										2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) -
										0.5 * Math.PI,
									P = Math.cos(C),
									E = new Float64Array(3);
								return (
									(E[0] = Math.sin(w) * P),
									(E[1] = Math.sin(C)),
									(E[2] = Math.cos(w) * P),
									E
								);
							}
							function Ti(h) {
								return (function (e, i) {
									const l = Math.cos(i),
										u = new Float64Array(3);
									return (
										(u[0] = Math.sin(e) * l),
										(u[1] = Math.sin(i)),
										(u[2] = Math.cos(e) * l),
										u
									);
								})((h.lng * Math.PI) / 180, (h.lat * Math.PI) / 180);
							}
							function Qo(h, e) {
								return h / (2 * Math.PI) / Math.cos((e * Math.PI) / 180);
							}
							function ks(h) {
								const e = (Math.asin(h[1]) / Math.PI) * 180,
									i = Math.sqrt(h[0] * h[0] + h[2] * h[2]);
								if (i > 1e-6) {
									const l = h[0] / i,
										u = Math.acos(h[2] / i),
										d = ((l > 0 ? u : -u) / Math.PI) * 180;
									return new s.S(s.aO(d, -180, 180), e);
								}
								return new s.S(0, e);
							}
							function Mo(h) {
								return Math.cos((h * Math.PI) / 180);
							}
							function ei(h, e) {
								const i = Mo(h),
									l = Mo(e);
								return s.ak(l / i);
							}
							function Fh(h, e) {
								const i = h.rotate(e.bearingInRadians),
									l = e.zoom + ei(e.center.lat, 0),
									u = s.bk(
										1 / Mo(e.center.lat),
										1 / Mo(Math.min(Math.abs(e.center.lat), 60)),
										s.bn(l, 7, 3, 0, 1)
									),
									d =
										360 /
										vl({
											worldSize: e.worldSize,
											center: { lat: e.center.lat },
										});
								return new s.S(
									e.center.lng - i.x * d * u,
									s.ah(e.center.lat + i.y * d, -s.ai, s.ai)
								);
							}
							function As(h) {
								const e = 0.5 * h,
									i = Math.sin(e),
									l = Math.cos(e);
								return Math.log(i + l) - Math.log(l - i);
							}
							function Ec(h, e, i, l) {
								const u = h.lat + i * l;
								if (Math.abs(i) > 1) {
									const d =
											((Math.sign(h.lat + i) !== Math.sign(h.lat)
												? -Math.abs(h.lat)
												: Math.abs(h.lat)) *
												Math.PI) /
											180,
										g = (Math.abs(h.lat + i) * Math.PI) / 180,
										w = As(d + l * (g - d)),
										C = As(d),
										P = As(g);
									return new s.S(h.lng + e * ((w - C) / (P - C)), u);
								}
								return new s.S(h.lng + e * l, u);
							}
							class bp {
								constructor(e) {
									(this._cachePrevious = new Map()),
										(this._cache = new Map()),
										(this._hadAnyChanges = !1),
										(this._boundingVolumeFactory = e);
								}
								swapBuffers() {
									if (!this._hadAnyChanges) return;
									const e = this._cachePrevious;
									(this._cachePrevious = this._cache),
										(this._cache = e),
										this._cache.clear(),
										(this._hadAnyChanges = !1);
								}
								getTileBoundingVolume(e, i, l, u) {
									const d = `${e.z}_${e.x}_${e.y}_${
											u != null && u.terrain ? "t" : ""
										}`,
										g = this._cache.get(d);
									if (g) return g;
									const w = this._cachePrevious.get(d);
									if (w) return this._cache.set(d, w), w;
									const C = this._boundingVolumeFactory(e, i, l, u);
									return this._cache.set(d, C), (this._hadAnyChanges = !0), C;
								}
							}
							class es {
								constructor(e, i, l, u) {
									(this.min = l),
										(this.max = u),
										(this.points = e),
										(this.planes = i);
								}
								static fromAabb(e, i) {
									const l = [];
									for (let u = 0; u < 8; u++)
										l.push([
											1 & ~u ? e[0] : i[0],
											((u >> 1) & 1) == 1 ? i[1] : e[1],
											((u >> 2) & 1) == 1 ? i[2] : e[2],
										]);
									return new es(
										l,
										[
											[-1, 0, 0, i[0]],
											[1, 0, 0, -e[0]],
											[0, -1, 0, i[1]],
											[0, 1, 0, -e[1]],
											[0, 0, -1, i[2]],
											[0, 0, 1, -e[2]],
										],
										e,
										i
									);
								}
								static fromCenterSizeAngles(e, i, l) {
									const u = s.br([], l[0], l[1], l[2]),
										d = s.bs([], [i[0], 0, 0], u),
										g = s.bs([], [0, i[1], 0], u),
										w = s.bs([], [0, 0, i[2]], u),
										C = [...e],
										P = [...e];
									for (let R = 0; R < 8; R++)
										for (let D = 0; D < 3; D++) {
											const N =
												e[D] +
												d[D] * (1 & ~R ? -1 : 1) +
												g[D] * (((R >> 1) & 1) == 1 ? 1 : -1) +
												w[D] * (((R >> 2) & 1) == 1 ? 1 : -1);
											(C[D] = Math.min(C[D], N)), (P[D] = Math.max(P[D], N));
										}
									const E = [];
									for (let R = 0; R < 8; R++) {
										const D = [...e];
										s.aS(D, D, s.aR([], d, 1 & ~R ? -1 : 1)),
											s.aS(D, D, s.aR([], g, ((R >> 1) & 1) == 1 ? 1 : -1)),
											s.aS(D, D, s.aR([], w, ((R >> 2) & 1) == 1 ? 1 : -1)),
											E.push(D);
									}
									return new es(
										E,
										[
											[...d, -s.aX(d, E[0])],
											[...g, -s.aX(g, E[0])],
											[...w, -s.aX(w, E[0])],
											[-d[0], -d[1], -d[2], -s.aX(d, E[7])],
											[-g[0], -g[1], -g[2], -s.aX(g, E[7])],
											[-w[0], -w[1], -w[2], -s.aX(w, E[7])],
										],
										C,
										P
									);
								}
								intersectsFrustum(e) {
									let i = !0;
									const l = this.points.length,
										u = this.planes.length,
										d = e.planes.length,
										g = e.points.length;
									for (let w = 0; w < d; w++) {
										const C = e.planes[w];
										let P = 0;
										for (let E = 0; E < l; E++) {
											const R = this.points[E];
											C[0] * R[0] + C[1] * R[1] + C[2] * R[2] + C[3] >= 0 &&
												P++;
										}
										if (P === 0) return 0;
										P < l && (i = !1);
									}
									if (i) return 2;
									for (let w = 0; w < u; w++) {
										const C = this.planes[w];
										let P = 0;
										for (let E = 0; E < g; E++) {
											const R = e.points[E];
											C[0] * R[0] + C[1] * R[1] + C[2] * R[2] + C[3] >= 0 &&
												P++;
										}
										if (P === 0) return 0;
									}
									return 1;
								}
								intersectsPlane(e) {
									const i = this.points.length;
									let l = 0;
									for (let u = 0; u < i; u++) {
										const d = this.points[u];
										e[0] * d[0] + e[1] * d[1] + e[2] * d[2] + e[3] >= 0 && l++;
									}
									return l === i ? 2 : l === 0 ? 0 : 1;
								}
							}
							function Di(h, e, i) {
								const l = h - e;
								return l < 0 ? -l : Math.max(0, l - i);
							}
							function Es(h, e, i, l, u) {
								const d = h - i;
								let g;
								return (
									(g =
										d < 0
											? Math.min(-d, 1 + d - u)
											: d > 1
											? Math.min(Math.max(d - u, 0), 1 - d)
											: 0),
									Math.max(g, Di(e, l, u))
								);
							}
							class Za {
								constructor() {
									this._boundingVolumeCache = new bp(
										this._computeTileBoundingVolume
									);
								}
								prepareNextFrame() {
									this._boundingVolumeCache.swapBuffers();
								}
								distanceToTile2d(e, i, l, u) {
									const d = 1 << l.z,
										g = 1 / d,
										w = l.x / d,
										C = l.y / d;
									let P = 2;
									return (
										(P = Math.min(P, Es(e, i, w, C, g))),
										(P = Math.min(P, Es(e, i, w + 0.5, -C - g, g))),
										(P = Math.min(P, Es(e, i, w + 0.5, 2 - C - g, g))),
										P
									);
								}
								getWrap(e, i, l) {
									const u = 1 << i.z,
										d = 1 / u,
										g = i.x / u,
										w = Di(e.x, g, d),
										C = Di(e.x, g - 1, d),
										P = Di(e.x, g + 1, d),
										E = Math.min(w, C, P);
									return E === P ? 1 : E === C ? -1 : 0;
								}
								allowVariableZoom(e, i) {
									return kt(e, i) > 4;
								}
								allowWorldCopies() {
									return !1;
								}
								getTileBoundingVolume(e, i, l, u) {
									return this._boundingVolumeCache.getTileBoundingVolume(
										e,
										i,
										l,
										u
									);
								}
								_computeTileBoundingVolume(e, i, l, u) {
									var d, g;
									let w = 0,
										C = 0;
									if (u != null && u.terrain) {
										const P = new s.Z(e.z, i, e.z, e.x, e.y),
											E = u.terrain.getMinMaxElevation(P);
										(w =
											(d = E.minElevation) !== null && d !== void 0
												? d
												: Math.min(0, l)),
											(C =
												(g = E.maxElevation) !== null && g !== void 0
													? g
													: Math.max(0, l));
									}
									if (((w /= s.bu), (C /= s.bu), (w += 1), (C += 1), e.z <= 0))
										return es.fromAabb([-C, -C, -C], [C, C, C]);
									if (e.z === 1)
										return es.fromAabb(
											[e.x === 0 ? -C : 0, e.y === 0 ? 0 : -C, -C],
											[e.x === 0 ? 0 : C, e.y === 0 ? C : 0, C]
										);
									{
										const P = [
												Sa(0, 0, e.x, e.y, e.z),
												Sa(s.$, 0, e.x, e.y, e.z),
												Sa(s.$, s.$, e.x, e.y, e.z),
												Sa(0, s.$, e.x, e.y, e.z),
											],
											E = [];
										for (const Xe of P) E.push(s.aR([], Xe, C));
										if (C !== w) for (const Xe of P) E.push(s.aR([], Xe, w));
										e.y === 0 && E.push([0, 1, 0]),
											e.y === (1 << e.z) - 1 && E.push([0, -1, 0]);
										const R = [1, 1, 1],
											D = [-1, -1, -1];
										for (const Xe of E)
											for (let tt = 0; tt < 3; tt++)
												(R[tt] = Math.min(R[tt], Xe[tt])),
													(D[tt] = Math.max(D[tt], Xe[tt]));
										const N = Sa(s.$ / 2, s.$ / 2, e.x, e.y, e.z),
											G = s.aW([], [0, 1, 0], N);
										s.aV(G, G);
										const te = s.aW([], N, G);
										s.aV(te, te);
										const Q = s.aW([], P[2], P[1]);
										s.aV(Q, Q);
										const ae = s.aW([], P[0], P[3]);
										s.aV(ae, ae),
											E.push(s.aR([], N, C)),
											e.y >= (1 << e.z) / 2 &&
												E.push(s.aR([], Sa(s.$ / 2, 0, e.x, e.y, e.z), C)),
											e.y < (1 << e.z) / 2 &&
												E.push(s.aR([], Sa(s.$ / 2, s.$, e.x, e.y, e.z), C));
										const ce = zs(N, E),
											ve = zs(te, E),
											me = [-N[0], -N[1], -N[2], ce.max],
											be = [N[0], N[1], N[2], -ce.min],
											Pe = [-te[0], -te[1], -te[2], ve.max],
											_e = [te[0], te[1], te[2], -ve.min],
											Be = [...Q, 0],
											rt = [...ae, 0],
											Ge = [];
										return (
											e.y === 0
												? Ge.push(s.bt(rt, Be, me), s.bt(rt, Be, be))
												: Ge.push(
														s.bt(Pe, Be, me),
														s.bt(Pe, Be, be),
														s.bt(Pe, rt, me),
														s.bt(Pe, rt, be)
												  ),
											e.y === (1 << e.z) - 1
												? Ge.push(s.bt(rt, Be, me), s.bt(rt, Be, be))
												: Ge.push(
														s.bt(_e, Be, me),
														s.bt(_e, Be, be),
														s.bt(_e, rt, me),
														s.bt(_e, rt, be)
												  ),
											new es(Ge, [me, be, Pe, _e, Be, rt], R, D)
										);
									}
								}
							}
							function zs(h, e) {
								let i = 1 / 0,
									l = -1 / 0;
								for (const u of e) {
									const d = s.aX(h, u);
									(i = Math.min(i, d)), (l = Math.max(l, d));
								}
								return { min: i, max: l };
							}
							class Ls {
								get pixelsToClipSpaceMatrix() {
									return this._helper.pixelsToClipSpaceMatrix;
								}
								get clipSpaceToPixelsMatrix() {
									return this._helper.clipSpaceToPixelsMatrix;
								}
								get pixelsToGLUnits() {
									return this._helper.pixelsToGLUnits;
								}
								get centerOffset() {
									return this._helper.centerOffset;
								}
								get size() {
									return this._helper.size;
								}
								get rotationMatrix() {
									return this._helper.rotationMatrix;
								}
								get centerPoint() {
									return this._helper.centerPoint;
								}
								get pixelsPerMeter() {
									return this._helper.pixelsPerMeter;
								}
								setMinZoom(e) {
									this._helper.setMinZoom(e);
								}
								setMaxZoom(e) {
									this._helper.setMaxZoom(e);
								}
								setMinPitch(e) {
									this._helper.setMinPitch(e);
								}
								setMaxPitch(e) {
									this._helper.setMaxPitch(e);
								}
								setRenderWorldCopies(e) {
									this._helper.setRenderWorldCopies(e);
								}
								setBearing(e) {
									this._helper.setBearing(e);
								}
								setPitch(e) {
									this._helper.setPitch(e);
								}
								setRoll(e) {
									this._helper.setRoll(e);
								}
								setFov(e) {
									this._helper.setFov(e);
								}
								setZoom(e) {
									this._helper.setZoom(e);
								}
								setCenter(e) {
									this._helper.setCenter(e);
								}
								setElevation(e) {
									this._helper.setElevation(e);
								}
								setMinElevationForCurrentTile(e) {
									this._helper.setMinElevationForCurrentTile(e);
								}
								setPadding(e) {
									this._helper.setPadding(e);
								}
								interpolatePadding(e, i, l) {
									return this._helper.interpolatePadding(e, i, l);
								}
								isPaddingEqual(e) {
									return this._helper.isPaddingEqual(e);
								}
								resize(e, i) {
									this._helper.resize(e, i);
								}
								getMaxBounds() {
									return this._helper.getMaxBounds();
								}
								setMaxBounds(e) {
									this._helper.setMaxBounds(e);
								}
								overrideNearFarZ(e, i) {
									this._helper.overrideNearFarZ(e, i);
								}
								clearNearFarZOverride() {
									this._helper.clearNearFarZOverride();
								}
								getCameraQueryGeometry(e) {
									return this._helper.getCameraQueryGeometry(
										this.getCameraPoint(),
										e
									);
								}
								get tileSize() {
									return this._helper.tileSize;
								}
								get tileZoom() {
									return this._helper.tileZoom;
								}
								get scale() {
									return this._helper.scale;
								}
								get worldSize() {
									return this._helper.worldSize;
								}
								get width() {
									return this._helper.width;
								}
								get height() {
									return this._helper.height;
								}
								get lngRange() {
									return this._helper.lngRange;
								}
								get latRange() {
									return this._helper.latRange;
								}
								get minZoom() {
									return this._helper.minZoom;
								}
								get maxZoom() {
									return this._helper.maxZoom;
								}
								get zoom() {
									return this._helper.zoom;
								}
								get center() {
									return this._helper.center;
								}
								get minPitch() {
									return this._helper.minPitch;
								}
								get maxPitch() {
									return this._helper.maxPitch;
								}
								get pitch() {
									return this._helper.pitch;
								}
								get pitchInRadians() {
									return this._helper.pitchInRadians;
								}
								get roll() {
									return this._helper.roll;
								}
								get rollInRadians() {
									return this._helper.rollInRadians;
								}
								get bearing() {
									return this._helper.bearing;
								}
								get bearingInRadians() {
									return this._helper.bearingInRadians;
								}
								get fov() {
									return this._helper.fov;
								}
								get fovInRadians() {
									return this._helper.fovInRadians;
								}
								get elevation() {
									return this._helper.elevation;
								}
								get minElevationForCurrentTile() {
									return this._helper.minElevationForCurrentTile;
								}
								get padding() {
									return this._helper.padding;
								}
								get unmodified() {
									return this._helper.unmodified;
								}
								get renderWorldCopies() {
									return this._helper.renderWorldCopies;
								}
								get nearZ() {
									return this._helper.nearZ;
								}
								get farZ() {
									return this._helper.farZ;
								}
								get autoCalculateNearFarZ() {
									return this._helper.autoCalculateNearFarZ;
								}
								setTransitionState(e) {}
								constructor() {
									(this._cachedClippingPlane = s.bv()),
										(this._projectionMatrix = s.b9()),
										(this._globeViewProjMatrix32f = s.b8()),
										(this._globeViewProjMatrixNoCorrection = s.b9()),
										(this._globeViewProjMatrixNoCorrectionInverted = s.b9()),
										(this._globeProjMatrixInverted = s.b9()),
										(this._cameraPosition = s.bp()),
										(this._globeLatitudeErrorCorrectionRadians = 0),
										(this._helper = new Sn({
											calcMatrices: () => {
												this._calcMatrices();
											},
											getConstrained: (e, i) => this.getConstrained(e, i),
										})),
										(this._coveringTilesDetailsProvider = new Za());
								}
								clone() {
									const e = new Ls();
									return e.apply(this), e;
								}
								apply(e, i) {
									(this._globeLatitudeErrorCorrectionRadians = i || 0),
										this._helper.apply(e);
								}
								get projectionMatrix() {
									return this._projectionMatrix;
								}
								get modelViewProjectionMatrix() {
									return this._globeViewProjMatrixNoCorrection;
								}
								get inverseProjectionMatrix() {
									return this._globeProjMatrixInverted;
								}
								get cameraPosition() {
									const e = s.bp();
									return (
										(e[0] = this._cameraPosition[0]),
										(e[1] = this._cameraPosition[1]),
										(e[2] = this._cameraPosition[2]),
										e
									);
								}
								get cameraToCenterDistance() {
									return this._helper.cameraToCenterDistance;
								}
								getProjectionData(e) {
									const { overscaledTileID: i, applyGlobeMatrix: l } = e,
										u = this._helper.getMercatorTileCoordinates(i);
									return {
										mainMatrix: this._globeViewProjMatrix32f,
										tileMercatorCoords: u,
										clippingPlane: this._cachedClippingPlane,
										projectionTransition: l ? 1 : 0,
										fallbackMatrix: this._globeViewProjMatrix32f,
									};
								}
								_computeClippingPlane(e) {
									const i = this.pitchInRadians,
										l = this.cameraToCenterDistance / e,
										u = Math.sin(i) * l,
										d = Math.cos(i) * l + 1,
										g = (1 / Math.sqrt(u * u + d * d)) * 1;
									let w = -u,
										C = d;
									const P = Math.sqrt(w * w + C * C);
									(w /= P), (C /= P);
									const E = [0, w, C];
									s.bw(E, E, [0, 0, 0], -this.bearingInRadians),
										s.bx(
											E,
											E,
											[0, 0, 0],
											(-1 * this.center.lat * Math.PI) / 180
										),
										s.by(E, E, [0, 0, 0], (this.center.lng * Math.PI) / 180);
									const R = 1 / s.aZ(E);
									return s.aR(E, E, R), [...E, -g * R];
								}
								isLocationOccluded(e) {
									return !this.isSurfacePointVisible(Ti(e));
								}
								transformLightDirection(e) {
									const i = (this._helper._center.lng * Math.PI) / 180,
										l = (this._helper._center.lat * Math.PI) / 180,
										u = Math.cos(l),
										d = [Math.sin(i) * u, Math.sin(l), Math.cos(i) * u],
										g = [d[2], 0, -d[0]],
										w = [0, 0, 0];
									s.aW(w, g, d), s.aV(g, g), s.aV(w, w);
									const C = [0, 0, 0];
									return (
										s.aV(C, [
											g[0] * e[0] + w[0] * e[1] + d[0] * e[2],
											g[1] * e[0] + w[1] * e[1] + d[1] * e[2],
											g[2] * e[0] + w[2] * e[1] + d[2] * e[2],
										]),
										C
									);
								}
								getPixelScale() {
									return (
										1 / Math.cos((this._helper._center.lat * Math.PI) / 180)
									);
								}
								getCircleRadiusCorrection() {
									return Math.cos((this._helper._center.lat * Math.PI) / 180);
								}
								getPitchedTextCorrection(e, i, l) {
									const u = (function (w, C, P) {
											const E = 1 / (1 << P.z);
											return new s.a1(
												(w / s.$) * E + P.x * E,
												(C / s.$) * E + P.y * E
											);
										})(e, i, l.canonical),
										d =
											((g = u.y),
											[
												s.bo(u.x * Math.PI * 2 + Math.PI, 2 * Math.PI),
												2 * Math.atan(Math.exp(Math.PI - g * Math.PI * 2)) -
													0.5 * Math.PI,
											]);
									var g;
									return this.getCircleRadiusCorrection() / Math.cos(d[1]);
								}
								projectTileCoordinates(e, i, l, u) {
									const d = l.canonical,
										g = Sa(e, i, d.x, d.y, d.z),
										w = 1 + (u ? u(e, i) : 0) / s.bu,
										C = [g[0] * w, g[1] * w, g[2] * w, 1];
									s.aw(C, C, this._globeViewProjMatrixNoCorrection);
									const P = this._cachedClippingPlane,
										E = P[0] * g[0] + P[1] * g[1] + P[2] * g[2] + P[3] < 0;
									return {
										point: new s.P(C[0] / C[3], C[1] / C[3]),
										signedDistanceFromCamera: C[3],
										isOccluded: E,
									};
								}
								_calcMatrices() {
									if (!this._helper._width || !this._helper._height) return;
									const e = Qo(this.worldSize, this.center.lat),
										i = s.ba(),
										l = s.ba();
									this._helper.autoCalculateNearFarZ &&
										((this._helper._nearZ = 0.5),
										(this._helper._farZ = this.cameraToCenterDistance + 2 * e)),
										s.b4(
											i,
											this.fovInRadians,
											this.width / this.height,
											this._helper._nearZ,
											this._helper._farZ
										);
									const u = this.centerOffset;
									(i[8] = (2 * -u.x) / this._helper._width),
										(i[9] = (2 * u.y) / this._helper._height),
										(this._projectionMatrix = s.b5(i)),
										(this._globeProjMatrixInverted = s.ba()),
										s.aq(this._globeProjMatrixInverted, i),
										s.M(i, i, [0, 0, -this.cameraToCenterDistance]),
										s.b6(i, i, this.rollInRadians),
										s.b7(i, i, -this.pitchInRadians),
										s.b6(i, i, this.bearingInRadians),
										s.M(i, i, [0, 0, -e]);
									const d = s.bp();
									(d[0] = e),
										(d[1] = e),
										(d[2] = e),
										s.b7(l, i, (this.center.lat * Math.PI) / 180),
										s.bz(l, l, (-this.center.lng * Math.PI) / 180),
										s.N(l, l, d),
										(this._globeViewProjMatrixNoCorrection = l),
										s.b7(
											i,
											i,
											(this.center.lat * Math.PI) / 180 -
												this._globeLatitudeErrorCorrectionRadians
										),
										s.bz(i, i, (-this.center.lng * Math.PI) / 180),
										s.N(i, i, d),
										(this._globeViewProjMatrix32f = new Float32Array(i)),
										(this._globeViewProjMatrixNoCorrectionInverted = s.ba()),
										s.aq(this._globeViewProjMatrixNoCorrectionInverted, l);
									const g = s.bp();
									(this._cameraPosition = s.bp()),
										(this._cameraPosition[2] = this.cameraToCenterDistance / e),
										s.bw(
											this._cameraPosition,
											this._cameraPosition,
											g,
											-this.rollInRadians
										),
										s.bx(
											this._cameraPosition,
											this._cameraPosition,
											g,
											this.pitchInRadians
										),
										s.bw(
											this._cameraPosition,
											this._cameraPosition,
											g,
											-this.bearingInRadians
										),
										s.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
										s.bx(
											this._cameraPosition,
											this._cameraPosition,
											g,
											(-this.center.lat * Math.PI) / 180
										),
										s.by(
											this._cameraPosition,
											this._cameraPosition,
											g,
											(this.center.lng * Math.PI) / 180
										),
										(this._cachedClippingPlane = this._computeClippingPlane(e));
									const w = s.b5(this._globeViewProjMatrixNoCorrectionInverted);
									s.N(w, w, [1, 1, -1]),
										(this._cachedFrustum = fn.fromInvProjectionMatrix(
											w,
											1,
											0,
											this._cachedClippingPlane,
											!0
										));
								}
								calculateFogMatrix(e) {
									s.w(
										"calculateFogMatrix is not supported on globe projection."
									);
									const i = s.ba();
									return s.ag(i), i;
								}
								getVisibleUnwrappedCoordinates(e) {
									return [new s.b2(0, e)];
								}
								getCameraFrustum() {
									return this._cachedFrustum;
								}
								getClippingPlane() {
									return this._cachedClippingPlane;
								}
								getCoveringTilesDetailsProvider() {
									return this._coveringTilesDetailsProvider;
								}
								recalculateZoomAndCenter(e) {
									e &&
										s.w(
											"terrain is not fully supported on vertical perspective projection."
										),
										this._helper.recalculateZoomAndCenter(0);
								}
								maxPitchScaleFactor() {
									return 1;
								}
								getCameraPoint() {
									return this._helper.getCameraPoint();
								}
								getCameraAltitude() {
									return this._helper.getCameraAltitude();
								}
								getCameraLngLat() {
									return this._helper.getCameraLngLat();
								}
								lngLatToCameraDepth(e, i) {
									if (!this._globeViewProjMatrixNoCorrection) return 1;
									const l = Ti(e);
									s.aR(l, l, 1 + i / s.bu);
									const u = s.bv();
									return (
										s.aw(
											u,
											[l[0], l[1], l[2], 1],
											this._globeViewProjMatrixNoCorrection
										),
										u[2] / u[3]
									);
								}
								populateCache(e) {}
								getBounds() {
									const e = 0.5 * this.width,
										i = 0.5 * this.height,
										l = [
											new s.P(0, 0),
											new s.P(e, 0),
											new s.P(this.width, 0),
											new s.P(this.width, i),
											new s.P(this.width, this.height),
											new s.P(e, this.height),
											new s.P(0, this.height),
											new s.P(0, i),
										],
										u = [];
									for (const R of l) u.push(this.unprojectScreenPoint(R));
									let d = 0,
										g = 0,
										w = 0,
										C = 0;
									const P = this.center;
									for (const R of u) {
										const D = s.bA(P.lng, R.lng),
											N = s.bA(P.lat, R.lat);
										D < g && (g = D),
											D > d && (d = D),
											N < C && (C = N),
											N > w && (w = N);
									}
									const E = [P.lng + g, P.lat + C, P.lng + d, P.lat + w];
									return (
										this.isSurfacePointOnScreen([0, 1, 0]) &&
											((E[3] = 90), (E[0] = -180), (E[2] = 180)),
										this.isSurfacePointOnScreen([0, -1, 0]) &&
											((E[1] = -90), (E[0] = -180), (E[2] = 180)),
										new _t(E)
									);
								}
								getConstrained(e, i) {
									const l = s.ah(e.lat, -s.ai, s.ai),
										u = s.ah(+i, this.minZoom + ei(0, l), this.maxZoom);
									return { center: new s.S(e.lng, l), zoom: u };
								}
								calculateCenterFromCameraLngLatAlt(e, i, l, u) {
									return this._helper.calculateCenterFromCameraLngLatAlt(
										e,
										i,
										l,
										u
									);
								}
								setLocationAtPoint(e, i) {
									const l = Ti(this.unprojectScreenPoint(i)),
										u = Ti(e),
										d = s.bp();
									s.bB(d);
									const g = s.bp();
									s.by(g, l, d, (-this.center.lng * Math.PI) / 180),
										s.bx(g, g, d, (this.center.lat * Math.PI) / 180);
									const w = u[0] * u[0] + u[2] * u[2],
										C = g[0] * g[0];
									if (w < C) return;
									const P = Math.sqrt(w - C),
										E = -P,
										R = s.bC(u[0], u[2], g[0], P),
										D = s.bC(u[0], u[2], g[0], E),
										N = s.bp();
									s.by(N, u, d, -R);
									const G = s.bC(N[1], N[2], g[1], g[2]),
										te = s.bp();
									s.by(te, u, d, -D);
									const Q = s.bC(te[1], te[2], g[1], g[2]),
										ae = 0.5 * Math.PI,
										ce = G >= -ae && G <= ae,
										ve = Q >= -ae && Q <= ae;
									let me, be;
									if (ce && ve) {
										const rt = (this.center.lng * Math.PI) / 180,
											Ge = (this.center.lat * Math.PI) / 180;
										s.bD(R, rt) + s.bD(G, Ge) < s.bD(D, rt) + s.bD(Q, Ge)
											? ((me = R), (be = G))
											: ((me = D), (be = Q));
									} else if (ce) (me = R), (be = G);
									else {
										if (!ve) return;
										(me = D), (be = Q);
									}
									const Pe = (me / Math.PI) * 180,
										_e = (be / Math.PI) * 180,
										Be = this.center.lat;
									this.setCenter(new s.S(Pe, s.ah(_e, -90, 90))),
										this.setZoom(this.zoom + ei(Be, this.center.lat));
								}
								locationToScreenPoint(e, i) {
									const l = Ti(e);
									if (i) {
										const u = i.getElevationForLngLatZoom(
											e,
											this._helper._tileZoom
										);
										s.aR(l, l, 1 + u / s.bu);
									}
									return this._projectSurfacePointToScreen(l);
								}
								_projectSurfacePointToScreen(e) {
									const i = s.bv();
									return (
										s.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
										(i[0] /= i[3]),
										(i[1] /= i[3]),
										new s.P(
											(0.5 * i[0] + 0.5) * this.width,
											(0.5 * -i[1] + 0.5) * this.height
										)
									);
								}
								screenPointToMercatorCoordinate(e, i) {
									if (i) {
										const l = i.pointCoordinate(e);
										if (l) return l;
									}
									return s.a1.fromLngLat(this.unprojectScreenPoint(e));
								}
								screenPointToLocation(e, i) {
									var l;
									return (l = this.screenPointToMercatorCoordinate(e, i)) ===
										null || l === void 0
										? void 0
										: l.toLngLat();
								}
								isPointOnMapSurface(e, i) {
									const l = this._cameraPosition,
										u = this.getRayDirectionFromPixel(e);
									return !!this.rayPlanetIntersection(l, u);
								}
								getRayDirectionFromPixel(e) {
									const i = s.bv();
									(i[0] = (e.x / this.width) * 2 - 1),
										(i[1] = -1 * ((e.y / this.height) * 2 - 1)),
										(i[2] = 1),
										(i[3] = 1),
										s.aw(i, i, this._globeViewProjMatrixNoCorrectionInverted),
										(i[0] /= i[3]),
										(i[1] /= i[3]),
										(i[2] /= i[3]);
									const l = s.bp();
									(l[0] = i[0] - this._cameraPosition[0]),
										(l[1] = i[1] - this._cameraPosition[1]),
										(l[2] = i[2] - this._cameraPosition[2]);
									const u = s.bp();
									return s.aV(u, l), u;
								}
								isSurfacePointVisible(e) {
									const i = this._cachedClippingPlane;
									return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0;
								}
								isSurfacePointOnScreen(e) {
									if (!this.isSurfacePointVisible(e)) return !1;
									const i = s.bv();
									return (
										s.aw(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
										(i[0] /= i[3]),
										(i[1] /= i[3]),
										(i[2] /= i[3]),
										i[0] > -1 &&
											i[0] < 1 &&
											i[1] > -1 &&
											i[1] < 1 &&
											i[2] > -1 &&
											i[2] < 1
									);
								}
								rayPlanetIntersection(e, i) {
									const l = s.aX(e, i),
										u = s.bp(),
										d = s.bp();
									s.aR(d, i, l), s.aU(u, e, d);
									const g = 1 - s.aX(u, u);
									if (g < 0) return null;
									const w = s.aX(e, e) - 1,
										C = -l + (l < 0 ? 1 : -1) * Math.sqrt(g),
										P = w / C,
										E = C;
									return { tMin: Math.min(P, E), tMax: Math.max(P, E) };
								}
								unprojectScreenPoint(e) {
									const i = this._cameraPosition,
										l = this.getRayDirectionFromPixel(e),
										u = this.rayPlanetIntersection(i, l);
									if (u) {
										const E = s.bp();
										s.aS(E, i, [l[0] * u.tMin, l[1] * u.tMin, l[2] * u.tMin]);
										const R = s.bp();
										return s.aV(R, E), ks(R);
									}
									const d = this._cachedClippingPlane,
										g = d[0] * l[0] + d[1] * l[1] + d[2] * l[2],
										w = -s.b1(d, i) / g,
										C = s.bp();
									if (w > 0) s.aS(C, i, [l[0] * w, l[1] * w, l[2] * w]);
									else {
										const E = s.bp();
										s.aS(E, i, [2 * l[0], 2 * l[1], 2 * l[2]]);
										const R = s.b1(this._cachedClippingPlane, E);
										s.aU(C, E, [
											this._cachedClippingPlane[0] * R,
											this._cachedClippingPlane[1] * R,
											this._cachedClippingPlane[2] * R,
										]);
									}
									const P = (function (E) {
										const R = s.bp();
										return (
											(R[0] = E[0] * -E[3]),
											(R[1] = E[1] * -E[3]),
											(R[2] = E[2] * -E[3]),
											{ center: R, radius: Math.sqrt(1 - E[3] * E[3]) }
										);
									})(d);
									return ks(
										(function (E, R, D) {
											const N = s.bp();
											s.aU(N, D, E);
											const G = s.bp();
											return s.bq(G, E, N, R / s.a$(N)), G;
										})(P.center, P.radius, C)
									);
								}
								getMatrixForModel(e, i) {
									const l = s.S.convert(e),
										u = 1 / s.bu,
										d = s.b9();
									return (
										s.bz(d, d, (l.lng / 180) * Math.PI),
										s.b7(d, d, (-l.lat / 180) * Math.PI),
										s.M(d, d, [0, 0, 1 + i / s.bu]),
										s.b7(d, d, 0.5 * Math.PI),
										s.N(d, d, [u, u, u]),
										d
									);
								}
								getProjectionDataForCustomLayer(e = !0) {
									const i = this.getProjectionData({
										overscaledTileID: new s.Z(0, 0, 0, 0, 0),
										applyGlobeMatrix: e,
									});
									return (i.tileMercatorCoords = [0, 0, 1, 1]), i;
								}
								getFastPathSimpleProjectionMatrix(e) {}
							}
							class Ds {
								get pixelsToClipSpaceMatrix() {
									return this._helper.pixelsToClipSpaceMatrix;
								}
								get clipSpaceToPixelsMatrix() {
									return this._helper.clipSpaceToPixelsMatrix;
								}
								get pixelsToGLUnits() {
									return this._helper.pixelsToGLUnits;
								}
								get centerOffset() {
									return this._helper.centerOffset;
								}
								get size() {
									return this._helper.size;
								}
								get rotationMatrix() {
									return this._helper.rotationMatrix;
								}
								get centerPoint() {
									return this._helper.centerPoint;
								}
								get pixelsPerMeter() {
									return this._helper.pixelsPerMeter;
								}
								setMinZoom(e) {
									this._helper.setMinZoom(e);
								}
								setMaxZoom(e) {
									this._helper.setMaxZoom(e);
								}
								setMinPitch(e) {
									this._helper.setMinPitch(e);
								}
								setMaxPitch(e) {
									this._helper.setMaxPitch(e);
								}
								setRenderWorldCopies(e) {
									this._helper.setRenderWorldCopies(e);
								}
								setBearing(e) {
									this._helper.setBearing(e);
								}
								setPitch(e) {
									this._helper.setPitch(e);
								}
								setRoll(e) {
									this._helper.setRoll(e);
								}
								setFov(e) {
									this._helper.setFov(e);
								}
								setZoom(e) {
									this._helper.setZoom(e);
								}
								setCenter(e) {
									this._helper.setCenter(e);
								}
								setElevation(e) {
									this._helper.setElevation(e);
								}
								setMinElevationForCurrentTile(e) {
									this._helper.setMinElevationForCurrentTile(e);
								}
								setPadding(e) {
									this._helper.setPadding(e);
								}
								interpolatePadding(e, i, l) {
									return this._helper.interpolatePadding(e, i, l);
								}
								isPaddingEqual(e) {
									return this._helper.isPaddingEqual(e);
								}
								resize(e, i, l = !0) {
									this._helper.resize(e, i, l);
								}
								getMaxBounds() {
									return this._helper.getMaxBounds();
								}
								setMaxBounds(e) {
									this._helper.setMaxBounds(e);
								}
								overrideNearFarZ(e, i) {
									this._helper.overrideNearFarZ(e, i);
								}
								clearNearFarZOverride() {
									this._helper.clearNearFarZOverride();
								}
								getCameraQueryGeometry(e) {
									return this._helper.getCameraQueryGeometry(
										this.getCameraPoint(),
										e
									);
								}
								get tileSize() {
									return this._helper.tileSize;
								}
								get tileZoom() {
									return this._helper.tileZoom;
								}
								get scale() {
									return this._helper.scale;
								}
								get worldSize() {
									return this._helper.worldSize;
								}
								get width() {
									return this._helper.width;
								}
								get height() {
									return this._helper.height;
								}
								get lngRange() {
									return this._helper.lngRange;
								}
								get latRange() {
									return this._helper.latRange;
								}
								get minZoom() {
									return this._helper.minZoom;
								}
								get maxZoom() {
									return this._helper.maxZoom;
								}
								get zoom() {
									return this._helper.zoom;
								}
								get center() {
									return this._helper.center;
								}
								get minPitch() {
									return this._helper.minPitch;
								}
								get maxPitch() {
									return this._helper.maxPitch;
								}
								get pitch() {
									return this._helper.pitch;
								}
								get pitchInRadians() {
									return this._helper.pitchInRadians;
								}
								get roll() {
									return this._helper.roll;
								}
								get rollInRadians() {
									return this._helper.rollInRadians;
								}
								get bearing() {
									return this._helper.bearing;
								}
								get bearingInRadians() {
									return this._helper.bearingInRadians;
								}
								get fov() {
									return this._helper.fov;
								}
								get fovInRadians() {
									return this._helper.fovInRadians;
								}
								get elevation() {
									return this._helper.elevation;
								}
								get minElevationForCurrentTile() {
									return this._helper.minElevationForCurrentTile;
								}
								get padding() {
									return this._helper.padding;
								}
								get unmodified() {
									return this._helper.unmodified;
								}
								get renderWorldCopies() {
									return this._helper.renderWorldCopies;
								}
								get cameraToCenterDistance() {
									return this._helper.cameraToCenterDistance;
								}
								get nearZ() {
									return this._helper.nearZ;
								}
								get farZ() {
									return this._helper.farZ;
								}
								get autoCalculateNearFarZ() {
									return this._helper.autoCalculateNearFarZ;
								}
								get isGlobeRendering() {
									return this._globeness > 0;
								}
								setTransitionState(e, i) {
									(this._globeness = e),
										(this._globeLatitudeErrorCorrectionRadians = i),
										this._calcMatrices(),
										this._verticalPerspectiveTransform
											.getCoveringTilesDetailsProvider()
											.prepareNextFrame(),
										this._mercatorTransform
											.getCoveringTilesDetailsProvider()
											.prepareNextFrame();
								}
								get currentTransform() {
									return this.isGlobeRendering
										? this._verticalPerspectiveTransform
										: this._mercatorTransform;
								}
								constructor() {
									(this._globeLatitudeErrorCorrectionRadians = 0),
										(this._globeness = 1),
										(this._helper = new Sn({
											calcMatrices: () => {
												this._calcMatrices();
											},
											getConstrained: (e, i) => this.getConstrained(e, i),
										})),
										(this._globeness = 1),
										(this._mercatorTransform = new on()),
										(this._verticalPerspectiveTransform = new Ls());
								}
								clone() {
									const e = new Ds();
									return (
										(e._globeness = this._globeness),
										(e._globeLatitudeErrorCorrectionRadians =
											this._globeLatitudeErrorCorrectionRadians),
										e.apply(this),
										e
									);
								}
								apply(e) {
									this._helper.apply(e),
										this._mercatorTransform.apply(this),
										this._verticalPerspectiveTransform.apply(
											this,
											this._globeLatitudeErrorCorrectionRadians
										);
								}
								get projectionMatrix() {
									return this.currentTransform.projectionMatrix;
								}
								get modelViewProjectionMatrix() {
									return this.currentTransform.modelViewProjectionMatrix;
								}
								get inverseProjectionMatrix() {
									return this.currentTransform.inverseProjectionMatrix;
								}
								get cameraPosition() {
									return this.currentTransform.cameraPosition;
								}
								getProjectionData(e) {
									const i = this._mercatorTransform.getProjectionData(e),
										l = this._verticalPerspectiveTransform.getProjectionData(e);
									return {
										mainMatrix: this.isGlobeRendering
											? l.mainMatrix
											: i.mainMatrix,
										clippingPlane: l.clippingPlane,
										tileMercatorCoords: l.tileMercatorCoords,
										projectionTransition: e.applyGlobeMatrix
											? this._globeness
											: 0,
										fallbackMatrix: i.fallbackMatrix,
									};
								}
								isLocationOccluded(e) {
									return this.currentTransform.isLocationOccluded(e);
								}
								transformLightDirection(e) {
									return this.currentTransform.transformLightDirection(e);
								}
								getPixelScale() {
									return s.bk(
										this._mercatorTransform.getPixelScale(),
										this._verticalPerspectiveTransform.getPixelScale(),
										this._globeness
									);
								}
								getCircleRadiusCorrection() {
									return s.bk(
										this._mercatorTransform.getCircleRadiusCorrection(),
										this._verticalPerspectiveTransform.getCircleRadiusCorrection(),
										this._globeness
									);
								}
								getPitchedTextCorrection(e, i, l) {
									const u = this._mercatorTransform.getPitchedTextCorrection(
											e,
											i,
											l
										),
										d =
											this._verticalPerspectiveTransform.getPitchedTextCorrection(
												e,
												i,
												l
											);
									return s.bk(u, d, this._globeness);
								}
								projectTileCoordinates(e, i, l, u) {
									return this.currentTransform.projectTileCoordinates(
										e,
										i,
										l,
										u
									);
								}
								_calcMatrices() {
									this._helper._width &&
										this._helper._height &&
										(this._verticalPerspectiveTransform.apply(
											this,
											this._globeLatitudeErrorCorrectionRadians
										),
										(this._helper._nearZ =
											this._verticalPerspectiveTransform.nearZ),
										(this._helper._farZ =
											this._verticalPerspectiveTransform.farZ),
										this._mercatorTransform.apply(
											this,
											!0,
											this.isGlobeRendering
										),
										(this._helper._nearZ = this._mercatorTransform.nearZ),
										(this._helper._farZ = this._mercatorTransform.farZ));
								}
								calculateFogMatrix(e) {
									return this.currentTransform.calculateFogMatrix(e);
								}
								getVisibleUnwrappedCoordinates(e) {
									return this.currentTransform.getVisibleUnwrappedCoordinates(
										e
									);
								}
								getCameraFrustum() {
									return this.currentTransform.getCameraFrustum();
								}
								getClippingPlane() {
									return this.currentTransform.getClippingPlane();
								}
								getCoveringTilesDetailsProvider() {
									return this.currentTransform.getCoveringTilesDetailsProvider();
								}
								recalculateZoomAndCenter(e) {
									this._mercatorTransform.recalculateZoomAndCenter(e),
										this._verticalPerspectiveTransform.recalculateZoomAndCenter(
											e
										);
								}
								maxPitchScaleFactor() {
									return this._mercatorTransform.maxPitchScaleFactor();
								}
								getCameraPoint() {
									return this._helper.getCameraPoint();
								}
								getCameraAltitude() {
									return this._helper.getCameraAltitude();
								}
								getCameraLngLat() {
									return this._helper.getCameraLngLat();
								}
								lngLatToCameraDepth(e, i) {
									return this.currentTransform.lngLatToCameraDepth(e, i);
								}
								populateCache(e) {
									this._mercatorTransform.populateCache(e),
										this._verticalPerspectiveTransform.populateCache(e);
								}
								getBounds() {
									return this.currentTransform.getBounds();
								}
								getConstrained(e, i) {
									return this.currentTransform.getConstrained(e, i);
								}
								calculateCenterFromCameraLngLatAlt(e, i, l, u) {
									return this._helper.calculateCenterFromCameraLngLatAlt(
										e,
										i,
										l,
										u
									);
								}
								setLocationAtPoint(e, i) {
									if (!this.isGlobeRendering)
										return (
											this._mercatorTransform.setLocationAtPoint(e, i),
											void this.apply(this._mercatorTransform)
										);
									this._verticalPerspectiveTransform.setLocationAtPoint(e, i),
										this.apply(this._verticalPerspectiveTransform);
								}
								locationToScreenPoint(e, i) {
									return this.currentTransform.locationToScreenPoint(e, i);
								}
								screenPointToMercatorCoordinate(e, i) {
									return this.currentTransform.screenPointToMercatorCoordinate(
										e,
										i
									);
								}
								screenPointToLocation(e, i) {
									return this.currentTransform.screenPointToLocation(e, i);
								}
								isPointOnMapSurface(e, i) {
									return this.currentTransform.isPointOnMapSurface(e, i);
								}
								getRayDirectionFromPixel(e) {
									return this._verticalPerspectiveTransform.getRayDirectionFromPixel(
										e
									);
								}
								getMatrixForModel(e, i) {
									return this.currentTransform.getMatrixForModel(e, i);
								}
								getProjectionDataForCustomLayer(e = !0) {
									const i =
										this._mercatorTransform.getProjectionDataForCustomLayer(e);
									if (!this.isGlobeRendering) return i;
									const l =
										this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(
											e
										);
									return (l.fallbackMatrix = i.mainMatrix), l;
								}
								getFastPathSimpleProjectionMatrix(e) {
									return this.currentTransform.getFastPathSimpleProjectionMatrix(
										e
									);
								}
							}
							class ji {
								get useGlobeControls() {
									return !0;
								}
								handlePanInertia(e, i) {
									const l = Fh(e, i);
									return (
										Math.abs(l.lng - i.center.lng) > 180 &&
											(l.lng =
												i.center.lng + 179.5 * Math.sign(l.lng - i.center.lng)),
										{ easingCenter: l, easingOffset: new s.P(0, 0) }
									);
								}
								handleMapControlsRollPitchBearingZoom(e, i) {
									const l = e.around,
										u = i.screenPointToLocation(l);
									e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
										e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
										e.rollDelta && i.setRoll(i.roll + e.rollDelta);
									const d = i.zoom;
									e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
									const g = i.zoom - d;
									if (g === 0) return;
									const w = s.bA(i.center.lng, u.lng),
										C = w / (Math.abs(w / 180) + 1),
										P = s.bA(i.center.lat, u.lat),
										E = i.getRayDirectionFromPixel(l),
										R = i.cameraPosition,
										D = -1 * s.aX(R, E),
										N = s.bp();
									s.aS(N, R, [E[0] * D, E[1] * D, E[2] * D]);
									const G = s.aZ(N) - 1,
										te = Math.exp(0.5 * -Math.max(G - 0.3, 0)),
										Q =
											Qo(i.worldSize, i.center.lat) /
											Math.min(i.width, i.height),
										ae = s.bn(Q, 0.9, 0.5, 1, 0.25),
										ce = (1 - s.af(-g)) * Math.min(te, ae),
										ve = i.center.lat,
										me = i.zoom,
										be = new s.S(
											i.center.lng + C * ce,
											s.ah(i.center.lat + P * ce, -s.ai, s.ai)
										);
									i.setLocationAtPoint(u, l);
									const Pe = i.center,
										_e = s.bn(Math.abs(w), 45, 85, 0, 1),
										Be = s.bn(Q, 0.75, 0.35, 0, 1),
										rt = Math.pow(Math.max(_e, Be), 0.25),
										Ge = s.bA(Pe.lng, be.lng),
										Xe = s.bA(Pe.lat, be.lat);
									i.setCenter(
										new s.S(Pe.lng + Ge * rt, Pe.lat + Xe * rt).wrap()
									),
										i.setZoom(me + ei(ve, i.center.lat));
								}
								handleMapControlsPan(e, i, l) {
									if (!e.panDelta) return;
									const u = i.center.lat,
										d = i.zoom;
									i.setCenter(Fh(e.panDelta, i).wrap()),
										i.setZoom(d + ei(u, i.center.lat));
								}
								cameraForBoxAndBearing(e, i, l, u, d) {
									const g = Hn(e, i, l, u, d),
										w = (i.left / d.width) * 2 - 1,
										C = ((d.width - i.right) / d.width) * 2 - 1,
										P = (i.top / d.height) * -2 + 1,
										E = ((d.height - i.bottom) / d.height) * -2 + 1,
										R = s.bA(l.getWest(), l.getEast()) < 0,
										D = R ? l.getEast() : l.getWest(),
										N = R ? l.getWest() : l.getEast(),
										G = Math.max(l.getNorth(), l.getSouth()),
										te = Math.min(l.getNorth(), l.getSouth()),
										Q = D + 0.5 * s.bA(D, N),
										ae = G + 0.5 * s.bA(G, te),
										ce = d.clone();
									ce.setCenter(g.center),
										ce.setBearing(g.bearing),
										ce.setPitch(0),
										ce.setRoll(0),
										ce.setZoom(g.zoom);
									const ve = ce.modelViewProjectionMatrix,
										me = [
											Ti(l.getNorthWest()),
											Ti(l.getNorthEast()),
											Ti(l.getSouthWest()),
											Ti(l.getSouthEast()),
											Ti(new s.S(N, ae)),
											Ti(new s.S(D, ae)),
											Ti(new s.S(Q, G)),
											Ti(new s.S(Q, te)),
										],
										be = Ti(g.center);
									let Pe = Number.POSITIVE_INFINITY;
									for (const _e of me)
										w < 0 &&
											(Pe = ji.getLesserNonNegativeNonNull(
												Pe,
												ji.solveVectorScale(_e, be, ve, "x", w)
											)),
											C > 0 &&
												(Pe = ji.getLesserNonNegativeNonNull(
													Pe,
													ji.solveVectorScale(_e, be, ve, "x", C)
												)),
											P > 0 &&
												(Pe = ji.getLesserNonNegativeNonNull(
													Pe,
													ji.solveVectorScale(_e, be, ve, "y", P)
												)),
											E < 0 &&
												(Pe = ji.getLesserNonNegativeNonNull(
													Pe,
													ji.solveVectorScale(_e, be, ve, "y", E)
												));
									if (Number.isFinite(Pe) && Pe !== 0)
										return (g.zoom = ce.zoom + s.ak(Pe)), g;
									po();
								}
								handleJumpToCenterZoom(e, i) {
									const l = e.center.lat,
										u = e.getConstrained(
											i.center ? s.S.convert(i.center) : e.center,
											e.zoom
										).center;
									e.setCenter(u.wrap());
									const d = i.zoom !== void 0 ? +i.zoom : e.zoom + ei(l, u.lat);
									e.zoom !== d && e.setZoom(d);
								}
								handleEaseTo(e, i) {
									const l = e.zoom,
										u = e.center,
										d = e.padding,
										g = { roll: e.roll, pitch: e.pitch, bearing: e.bearing },
										w = {
											roll: i.roll === void 0 ? e.roll : i.roll,
											pitch: i.pitch === void 0 ? e.pitch : i.pitch,
											bearing: i.bearing === void 0 ? e.bearing : i.bearing,
										},
										C = i.zoom !== void 0,
										P = !e.isPaddingEqual(i.padding);
									let E = !1;
									const R = i.center ? s.S.convert(i.center) : u,
										D = e.getConstrained(R, l).center;
									bn(e, D);
									const N = e.clone();
									N.setCenter(D),
										N.setZoom(C ? +i.zoom : l + ei(u.lat, R.lat)),
										N.setBearing(i.bearing);
									const G = new s.P(
										s.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
										s.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)
									);
									N.setLocationAtPoint(D, G);
									const te =
											(i.offset && i.offsetAsPoint.mag()) > 0 ? N.center : D,
										Q = C ? +i.zoom : l + ei(u.lat, te.lat),
										ae = l + ei(u.lat, 0),
										ce = Q + ei(te.lat, 0),
										ve = s.bA(u.lng, te.lng),
										me = s.bA(u.lat, te.lat),
										be = s.af(ce - ae);
									return (
										(E = Q !== l),
										{
											easeFunc: (Pe) => {
												if (
													(s.be(g, w) ||
														fi({
															startEulerAngles: g,
															endEulerAngles: w,
															tr: e,
															k: Pe,
															useSlerp: g.roll != w.roll,
														}),
													P && e.interpolatePadding(d, i.padding, Pe),
													i.around)
												)
													s.w(
														"Easing around a point is not supported under globe projection."
													),
														e.setLocationAtPoint(i.around, i.aroundPoint);
												else {
													const _e =
															ce > ae ? Math.min(2, be) : Math.max(0.5, be),
														Be = Math.pow(_e, 1 - Pe),
														rt = Ec(u, ve, me, Pe * Be);
													e.setCenter(rt.wrap());
												}
												if (E) {
													const _e =
														s.C.number(ae, ce, Pe) + ei(0, e.center.lat);
													e.setZoom(_e);
												}
											},
											isZooming: E,
											elevationCenter: te,
										}
									);
								}
								handleFlyTo(e, i) {
									const l = i.zoom !== void 0,
										u = e.center,
										d = e.zoom,
										g = e.padding,
										w = !e.isPaddingEqual(i.padding),
										C = e.getConstrained(
											s.S.convert(i.center || i.locationAtOffset),
											d
										).center,
										P = l ? +i.zoom : e.zoom + ei(e.center.lat, C.lat),
										E = e.clone();
									E.setCenter(C), E.setZoom(P), E.setBearing(i.bearing);
									const R = new s.P(
										s.ah(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),
										s.ah(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)
									);
									E.setLocationAtPoint(C, R);
									const D = E.center;
									bn(e, D);
									const N = (function (me, be, Pe) {
											const _e = Ti(be),
												Be = Ti(Pe),
												rt = s.aX(_e, Be),
												Ge = Math.acos(rt),
												Xe = vl(me);
											return (Ge / (2 * Math.PI)) * Xe;
										})(e, u, D),
										G = d + ei(u.lat, 0),
										te = P + ei(D.lat, 0),
										Q = s.af(te - G);
									let ae;
									if (typeof i.minZoom == "number") {
										const me = +i.minZoom + ei(D.lat, 0),
											be = Math.min(me, G, te) + ei(0, D.lat),
											Pe = e.getConstrained(D, be).zoom + ei(D.lat, 0);
										ae = s.af(Pe - G);
									}
									const ce = s.bA(u.lng, D.lng),
										ve = s.bA(u.lat, D.lat);
									return {
										easeFunc: (me, be, Pe, _e) => {
											const Be = Ec(u, ce, ve, Pe);
											w && e.interpolatePadding(g, i.padding, me);
											const rt = me === 1 ? D : Be;
											e.setCenter(rt.wrap());
											const Ge = G + s.ak(be);
											e.setZoom(me === 1 ? P : Ge + ei(0, rt.lat));
										},
										scaleOfZoom: Q,
										targetCenter: D,
										scaleOfMinZoom: ae,
										pixelPathLength: N,
									};
								}
								static solveVectorScale(e, i, l, u, d) {
									const g =
											u === "x"
												? [l[0], l[4], l[8], l[12]]
												: [l[1], l[5], l[9], l[13]],
										w = [l[3], l[7], l[11], l[15]],
										C = e[0] * g[0] + e[1] * g[1] + e[2] * g[2],
										P = e[0] * w[0] + e[1] * w[1] + e[2] * w[2],
										E = i[0] * g[0] + i[1] * g[1] + i[2] * g[2],
										R = i[0] * w[0] + i[1] * w[1] + i[2] * w[2];
									return E + d * P === C + d * R ||
										w[3] * (C - E) + g[3] * (R - P) + C * R == E * P
										? null
										: (E + g[3] - d * R - d * w[3]) / (E - C - d * R + d * P);
								}
								static getLesserNonNegativeNonNull(e, i) {
									return i !== null && i >= 0 && i < e ? i : e;
								}
							}
							class Oh {
								constructor(e) {
									(this._globe = e),
										(this._mercatorCameraHelper = new jn()),
										(this._verticalPerspectiveCameraHelper = new ji());
								}
								get useGlobeControls() {
									return this._globe.useGlobeRendering;
								}
								get currentHelper() {
									return this.useGlobeControls
										? this._verticalPerspectiveCameraHelper
										: this._mercatorCameraHelper;
								}
								handlePanInertia(e, i) {
									return this.currentHelper.handlePanInertia(e, i);
								}
								handleMapControlsRollPitchBearingZoom(e, i) {
									return this.currentHelper.handleMapControlsRollPitchBearingZoom(
										e,
										i
									);
								}
								handleMapControlsPan(e, i, l) {
									this.currentHelper.handleMapControlsPan(e, i, l);
								}
								cameraForBoxAndBearing(e, i, l, u, d) {
									return this.currentHelper.cameraForBoxAndBearing(
										e,
										i,
										l,
										u,
										d
									);
								}
								handleJumpToCenterZoom(e, i) {
									this.currentHelper.handleJumpToCenterZoom(e, i);
								}
								handleEaseTo(e, i) {
									return this.currentHelper.handleEaseTo(e, i);
								}
								handleFlyTo(e, i) {
									return this.currentHelper.handleFlyTo(e, i);
								}
							}
							const yl = (h, e) =>
									s.y(
										h,
										e && e.filter((i) => i.identifier !== "source.canvas")
									),
								wp = s.bE();
							class zc extends s.E {
								constructor(e, i = {}) {
									super(),
										(this._rtlPluginLoaded = () => {
											for (const l in this.sourceCaches) {
												const u = this.sourceCaches[l].getSource().type;
												(u !== "vector" && u !== "geojson") ||
													this.sourceCaches[l].reload();
											}
										}),
										(this.map = e),
										(this.dispatcher = new Dt(It(), e._getMapId())),
										this.dispatcher.registerMessageHandler("GG", (l, u) =>
											this.getGlyphs(l, u)
										),
										this.dispatcher.registerMessageHandler("GI", (l, u) =>
											this.getImages(l, u)
										),
										(this.imageManager = new Qe()),
										this.imageManager.setEventedParent(this),
										(this.glyphManager = new Ue(
											e._requestManager,
											i.localIdeographFontFamily
										)),
										(this.lineAtlas = new oe(256, 512)),
										(this.crossTileSymbolIndex = new sr()),
										(this._spritesImagesIds = {}),
										(this._layers = {}),
										(this._order = []),
										(this.sourceCaches = {}),
										(this.zoomHistory = new s.bF()),
										(this._loaded = !1),
										(this._availableImages = []),
										(this._globalState = {}),
										this._resetUpdates(),
										this.dispatcher.broadcast("SR", s.bG()),
										Ir().on(mr, this._rtlPluginLoaded),
										this.on("data", (l) => {
											if (
												l.dataType !== "source" ||
												l.sourceDataType !== "metadata"
											)
												return;
											const u = this.sourceCaches[l.sourceId];
											if (!u) return;
											const d = u.getSource();
											if (d && d.vectorLayerIds)
												for (const g in this._layers) {
													const w = this._layers[g];
													w.source === d.id && this._validateLayer(w);
												}
										});
								}
								setGlobalStateProperty(e, i) {
									var l, u, d;
									this._checkLoaded();
									const g =
										i === null
											? (d =
													(u =
														(l = this.stylesheet.state) === null || l === void 0
															? void 0
															: l[e]) === null || u === void 0
														? void 0
														: u.default) !== null && d !== void 0
												? d
												: null
											: i;
									if (s.bH(g, this._globalState[e])) return this;
									this._globalState[e] = g;
									const w = this._findGlobalStateAffectedSources([e]);
									for (const C in this.sourceCaches)
										w.has(C) && (this._reloadSource(C), (this._changed = !0));
								}
								getGlobalState() {
									return this._globalState;
								}
								setGlobalState(e) {
									this._checkLoaded();
									const i = [];
									for (const u in e)
										!s.bH(this._globalState[u], e[u].default) &&
											(i.push(u), (this._globalState[u] = e[u].default));
									const l = this._findGlobalStateAffectedSources(i);
									for (const u in this.sourceCaches)
										l.has(u) && (this._reloadSource(u), (this._changed = !0));
								}
								_findGlobalStateAffectedSources(e) {
									if (e.length === 0) return new Set();
									const i = new Set();
									for (const l in this._layers) {
										const u = this._layers[l],
											d = u.getLayoutAffectingGlobalStateRefs();
										for (const g of e) d.has(g) && i.add(u.source);
									}
									return i;
								}
								loadURL(e, i = {}, l) {
									this.fire(new s.l("dataloading", { dataType: "style" })),
										(i.validate = typeof i.validate != "boolean" || i.validate);
									const u = this.map._requestManager.transformRequest(
										e,
										"Style"
									);
									this._loadStyleRequest = new AbortController();
									const d = this._loadStyleRequest;
									s.j(u, this._loadStyleRequest)
										.then((g) => {
											(this._loadStyleRequest = null), this._load(g.data, i, l);
										})
										.catch((g) => {
											(this._loadStyleRequest = null),
												g && !d.signal.aborted && this.fire(new s.k(g));
										});
								}
								loadJSON(e, i = {}, l) {
									this.fire(new s.l("dataloading", { dataType: "style" })),
										(this._frameRequest = new AbortController()),
										ne
											.frameAsync(this._frameRequest)
											.then(() => {
												(this._frameRequest = null),
													(i.validate = i.validate !== !1),
													this._load(e, i, l);
											})
											.catch(() => {});
								}
								loadEmpty() {
									this.fire(new s.l("dataloading", { dataType: "style" })),
										this._load(wp, { validate: !1 });
								}
								_load(e, i, l) {
									var u, d, g;
									const w = i.transformStyle ? i.transformStyle(l, e) : e;
									if (!i.validate || !yl(this, s.z(w))) {
										(this._loaded = !0), (this.stylesheet = w);
										for (const C in w.sources)
											this.addSource(C, w.sources[C], { validate: !1 });
										w.sprite
											? this._loadSprite(w.sprite)
											: this.imageManager.setLoaded(!0),
											this.glyphManager.setURL(w.glyphs),
											this._createLayers(),
											(this.light = new ee(this.stylesheet.light)),
											this._setProjectionInternal(
												((u = this.stylesheet.projection) === null ||
												u === void 0
													? void 0
													: u.type) || "mercator"
											),
											(this.sky = new he(this.stylesheet.sky)),
											this.map.setTerrain(
												(d = this.stylesheet.terrain) !== null && d !== void 0
													? d
													: null
											),
											this.setGlobalState(
												(g = this.stylesheet.state) !== null && g !== void 0
													? g
													: null
											),
											this.fire(new s.l("data", { dataType: "style" })),
											this.fire(new s.l("style.load"));
									}
								}
								_createLayers() {
									const e = s.bI(this.stylesheet.layers);
									this.dispatcher.broadcast("SL", e),
										(this._order = e.map((i) => i.id)),
										(this._layers = {}),
										(this._serializedLayers = null);
									for (const i of e) {
										const l = s.bJ(i);
										l.setEventedParent(this, { layer: { id: i.id } }),
											(this._layers[i.id] = l);
									}
								}
								_loadSprite(e, i = !1, l = void 0) {
									let u;
									this.imageManager.setLoaded(!1),
										(this._spriteRequest = new AbortController()),
										(function (d, g, w, C) {
											return s._(this, void 0, void 0, function* () {
												const P = Je(d),
													E = w > 1 ? "@2x" : "",
													R = {},
													D = {};
												for (const { id: N, url: G } of P) {
													const te = g.transformRequest(
														qe(G, E, ".json"),
														"SpriteJSON"
													);
													R[N] = s.j(te, C);
													const Q = g.transformRequest(
														qe(G, E, ".png"),
														"SpriteImage"
													);
													D[N] = Fe.getImage(Q, C);
												}
												return (
													yield Promise.all([
														...Object.values(R),
														...Object.values(D),
													]),
													(function (N, G) {
														return s._(this, void 0, void 0, function* () {
															const te = {};
															for (const Q in N) {
																te[Q] = {};
																const ae = ne.getImageCanvasContext(
																		(yield G[Q]).data
																	),
																	ce = (yield N[Q]).data;
																for (const ve in ce) {
																	const {
																		width: me,
																		height: be,
																		x: Pe,
																		y: _e,
																		sdf: Be,
																		pixelRatio: rt,
																		stretchX: Ge,
																		stretchY: Xe,
																		content: tt,
																		textFitWidth: jt,
																		textFitHeight: Zt,
																	} = ce[ve];
																	te[Q][ve] = {
																		data: null,
																		pixelRatio: rt,
																		sdf: Be,
																		stretchX: Ge,
																		stretchY: Xe,
																		content: tt,
																		textFitWidth: jt,
																		textFitHeight: Zt,
																		spriteData: {
																			width: me,
																			height: be,
																			x: Pe,
																			y: _e,
																			context: ae,
																		},
																	};
																}
															}
															return te;
														});
													})(R, D)
												);
											});
										})(
											e,
											this.map._requestManager,
											this.map.getPixelRatio(),
											this._spriteRequest
										)
											.then((d) => {
												if (((this._spriteRequest = null), d))
													for (const g in d) {
														this._spritesImagesIds[g] = [];
														const w = this._spritesImagesIds[g]
															? this._spritesImagesIds[g].filter(
																	(C) => !(C in d)
															  )
															: [];
														for (const C of w)
															this.imageManager.removeImage(C),
																(this._changedImages[C] = !0);
														for (const C in d[g]) {
															const P = g === "default" ? C : `${g}:${C}`;
															this._spritesImagesIds[g].push(P),
																P in this.imageManager.images
																	? this.imageManager.updateImage(
																			P,
																			d[g][C],
																			!1
																	  )
																	: this.imageManager.addImage(P, d[g][C]),
																i && (this._changedImages[P] = !0);
														}
													}
											})
											.catch((d) => {
												(this._spriteRequest = null),
													(u = d),
													this.fire(new s.k(u));
											})
											.finally(() => {
												this.imageManager.setLoaded(!0),
													(this._availableImages =
														this.imageManager.listImages()),
													i && (this._changed = !0),
													this.dispatcher.broadcast(
														"SI",
														this._availableImages
													),
													this.fire(new s.l("data", { dataType: "style" })),
													l && l(u);
											});
								}
								_unloadSprite() {
									for (const e of Object.values(this._spritesImagesIds).flat())
										this.imageManager.removeImage(e),
											(this._changedImages[e] = !0);
									(this._spritesImagesIds = {}),
										(this._availableImages = this.imageManager.listImages()),
										(this._changed = !0),
										this.dispatcher.broadcast("SI", this._availableImages),
										this.fire(new s.l("data", { dataType: "style" }));
								}
								_validateLayer(e) {
									const i = this.sourceCaches[e.source];
									if (!i) return;
									const l = e.sourceLayer;
									if (!l) return;
									const u = i.getSource();
									(u.type === "geojson" ||
										(u.vectorLayerIds && u.vectorLayerIds.indexOf(l) === -1)) &&
										this.fire(
											new s.k(
												new Error(
													`Source layer "${l}" does not exist on source "${u.id}" as specified by style layer "${e.id}".`
												)
											)
										);
								}
								loaded() {
									if (!this._loaded || Object.keys(this._updatedSources).length)
										return !1;
									for (const e in this.sourceCaches)
										if (!this.sourceCaches[e].loaded()) return !1;
									return !!this.imageManager.isLoaded();
								}
								_serializeByIds(e, i = !1) {
									const l = this._serializedAllLayers();
									if (!e || e.length === 0)
										return Object.values(i ? s.bK(l) : l);
									const u = [];
									for (const d of e)
										if (l[d]) {
											const g = i ? s.bK(l[d]) : l[d];
											u.push(g);
										}
									return u;
								}
								_serializedAllLayers() {
									let e = this._serializedLayers;
									if (e) return e;
									e = this._serializedLayers = {};
									const i = Object.keys(this._layers);
									for (const l of i) {
										const u = this._layers[l];
										u.type !== "custom" && (e[l] = u.serialize());
									}
									return e;
								}
								hasTransitions() {
									var e, i, l;
									if (
										(!((e = this.light) === null || e === void 0) &&
											e.hasTransition()) ||
										(!((i = this.sky) === null || i === void 0) &&
											i.hasTransition()) ||
										(!((l = this.projection) === null || l === void 0) &&
											l.hasTransition())
									)
										return !0;
									for (const u in this.sourceCaches)
										if (this.sourceCaches[u].hasTransition()) return !0;
									for (const u in this._layers)
										if (this._layers[u].hasTransition()) return !0;
									return !1;
								}
								_checkLoaded() {
									if (!this._loaded)
										throw new Error("Style is not done loading.");
								}
								update(e) {
									if (!this._loaded) return;
									const i = this._changed;
									if (i) {
										const u = Object.keys(this._updatedLayers),
											d = Object.keys(this._removedLayers);
										(u.length || d.length) && this._updateWorkerLayers(u, d);
										for (const g in this._updatedSources) {
											const w = this._updatedSources[g];
											if (w === "reload") this._reloadSource(g);
											else {
												if (w !== "clear")
													throw new Error(`Invalid action ${w}`);
												this._clearSource(g);
											}
										}
										this._updateTilesForChangedImages(),
											this._updateTilesForChangedGlyphs();
										for (const g in this._updatedPaintProps)
											this._layers[g].updateTransitions(e);
										this.light.updateTransitions(e),
											this.sky.updateTransitions(e),
											this._resetUpdates();
									}
									const l = {};
									for (const u in this.sourceCaches) {
										const d = this.sourceCaches[u];
										(l[u] = d.used), (d.used = !1);
									}
									for (const u of this._order) {
										const d = this._layers[u];
										d.recalculate(e, this._availableImages),
											!d.isHidden(e.zoom) &&
												d.source &&
												(this.sourceCaches[d.source].used = !0);
									}
									for (const u in l) {
										const d = this.sourceCaches[u];
										!!l[u] != !!d.used &&
											d.fire(
												new s.l("data", {
													sourceDataType: "visibility",
													dataType: "source",
													sourceId: u,
												})
											);
									}
									this.light.recalculate(e),
										this.sky.recalculate(e),
										this.projection.recalculate(e),
										(this.z = e.zoom),
										i && this.fire(new s.l("data", { dataType: "style" }));
								}
								_updateTilesForChangedImages() {
									const e = Object.keys(this._changedImages);
									if (e.length) {
										for (const i in this.sourceCaches)
											this.sourceCaches[i].reloadTilesForDependencies(
												["icons", "patterns"],
												e
											);
										this._changedImages = {};
									}
								}
								_updateTilesForChangedGlyphs() {
									if (this._glyphsDidChange) {
										for (const e in this.sourceCaches)
											this.sourceCaches[e].reloadTilesForDependencies(
												["glyphs"],
												[""]
											);
										this._glyphsDidChange = !1;
									}
								}
								_updateWorkerLayers(e, i) {
									this.dispatcher.broadcast("UL", {
										layers: this._serializeByIds(e, !1),
										removedIds: i,
									});
								}
								_resetUpdates() {
									(this._changed = !1),
										(this._updatedLayers = {}),
										(this._removedLayers = {}),
										(this._updatedSources = {}),
										(this._updatedPaintProps = {}),
										(this._changedImages = {}),
										(this._glyphsDidChange = !1);
								}
								setState(e, i = {}) {
									var l;
									this._checkLoaded();
									const u = this.serialize();
									if (
										((e = i.transformStyle ? i.transformStyle(u, e) : e),
										((l = i.validate) === null || l === void 0 || l) &&
											yl(this, s.z(e)))
									)
										return !1;
									(e = s.bK(e)).layers = s.bI(e.layers);
									const d = s.bL(u, e),
										g = this._getOperationsToPerform(d);
									if (g.unimplemented.length > 0)
										throw new Error(
											`Unimplemented: ${g.unimplemented.join(", ")}.`
										);
									if (g.operations.length === 0) return !1;
									for (const w of g.operations) w();
									return (
										(this.stylesheet = e), (this._serializedLayers = null), !0
									);
								}
								_getOperationsToPerform(e) {
									const i = [],
										l = [];
									for (const u of e)
										switch (u.command) {
											case "setCenter":
											case "setZoom":
											case "setBearing":
											case "setPitch":
											case "setRoll":
												continue;
											case "addLayer":
												i.push(() => this.addLayer.apply(this, u.args));
												break;
											case "removeLayer":
												i.push(() => this.removeLayer.apply(this, u.args));
												break;
											case "setPaintProperty":
												i.push(() => this.setPaintProperty.apply(this, u.args));
												break;
											case "setLayoutProperty":
												i.push(() =>
													this.setLayoutProperty.apply(this, u.args)
												);
												break;
											case "setFilter":
												i.push(() => this.setFilter.apply(this, u.args));
												break;
											case "addSource":
												i.push(() => this.addSource.apply(this, u.args));
												break;
											case "removeSource":
												i.push(() => this.removeSource.apply(this, u.args));
												break;
											case "setLayerZoomRange":
												i.push(() =>
													this.setLayerZoomRange.apply(this, u.args)
												);
												break;
											case "setLight":
												i.push(() => this.setLight.apply(this, u.args));
												break;
											case "setGeoJSONSourceData":
												i.push(() =>
													this.setGeoJSONSourceData.apply(this, u.args)
												);
												break;
											case "setGlyphs":
												i.push(() => this.setGlyphs.apply(this, u.args));
												break;
											case "setSprite":
												i.push(() => this.setSprite.apply(this, u.args));
												break;
											case "setTerrain":
												i.push(() => this.map.setTerrain.apply(this, u.args));
												break;
											case "setSky":
												i.push(() => this.setSky.apply(this, u.args));
												break;
											case "setProjection":
												this.setProjection.apply(this, u.args);
												break;
											case "setGlobalState":
												i.push(() => this.setGlobalState.apply(this, u.args));
												break;
											case "setTransition":
												i.push(() => {});
												break;
											default:
												l.push(u.command);
										}
									return { operations: i, unimplemented: l };
								}
								addImage(e, i) {
									if (this.getImage(e))
										return this.fire(
											new s.k(
												new Error(`An image named "${e}" already exists.`)
											)
										);
									this.imageManager.addImage(e, i), this._afterImageUpdated(e);
								}
								updateImage(e, i) {
									this.imageManager.updateImage(e, i);
								}
								getImage(e) {
									return this.imageManager.getImage(e);
								}
								removeImage(e) {
									if (!this.getImage(e))
										return this.fire(
											new s.k(
												new Error(`An image named "${e}" does not exist.`)
											)
										);
									this.imageManager.removeImage(e), this._afterImageUpdated(e);
								}
								_afterImageUpdated(e) {
									(this._availableImages = this.imageManager.listImages()),
										(this._changedImages[e] = !0),
										(this._changed = !0),
										this.dispatcher.broadcast("SI", this._availableImages),
										this.fire(new s.l("data", { dataType: "style" }));
								}
								listImages() {
									return this._checkLoaded(), this.imageManager.listImages();
								}
								addSource(e, i, l = {}) {
									if ((this._checkLoaded(), this.sourceCaches[e] !== void 0))
										throw new Error(`Source "${e}" already exists.`);
									if (!i.type)
										throw new Error(
											`The type property must be defined, but only the following properties were given: ${Object.keys(
												i
											).join(", ")}.`
										);
									if (
										["vector", "raster", "geojson", "video", "image"].indexOf(
											i.type
										) >= 0 &&
										this._validate(s.z.source, `sources.${e}`, i, null, l)
									)
										return;
									this.map &&
										this.map._collectResourceTiming &&
										(i.collectResourceTiming = !0);
									const u = (this.sourceCaches[e] = new rr(
										e,
										i,
										this.dispatcher
									));
									(u.style = this),
										u.setEventedParent(this, () => ({
											isSourceLoaded: u.loaded(),
											source: u.serialize(),
											sourceId: e,
										})),
										u.onAdd(this.map),
										(this._changed = !0);
								}
								removeSource(e) {
									if ((this._checkLoaded(), this.sourceCaches[e] === void 0))
										throw new Error("There is no source with this ID");
									for (const l in this._layers)
										if (this._layers[l].source === e)
											return this.fire(
												new s.k(
													new Error(
														`Source "${e}" cannot be removed while layer "${l}" is using it.`
													)
												)
											);
									const i = this.sourceCaches[e];
									delete this.sourceCaches[e],
										delete this._updatedSources[e],
										i.fire(
											new s.l("data", {
												sourceDataType: "metadata",
												dataType: "source",
												sourceId: e,
											})
										),
										i.setEventedParent(null),
										i.onRemove(this.map),
										(this._changed = !0);
								}
								setGeoJSONSourceData(e, i) {
									if ((this._checkLoaded(), this.sourceCaches[e] === void 0))
										throw new Error(`There is no source with this ID=${e}`);
									const l = this.sourceCaches[e].getSource();
									if (l.type !== "geojson")
										throw new Error(
											`geojsonSource.type is ${l.type}, which is !== 'geojson`
										);
									l.setData(i), (this._changed = !0);
								}
								getSource(e) {
									return (
										this.sourceCaches[e] && this.sourceCaches[e].getSource()
									);
								}
								addLayer(e, i, l = {}) {
									this._checkLoaded();
									const u = e.id;
									if (this.getLayer(u))
										return void this.fire(
											new s.k(
												new Error(`Layer "${u}" already exists on this map.`)
											)
										);
									let d;
									if (e.type === "custom") {
										if (yl(this, s.bM(e))) return;
										d = s.bJ(e);
									} else {
										if (
											("source" in e &&
												typeof e.source == "object" &&
												(this.addSource(u, e.source),
												(e = s.bK(e)),
												(e = s.e(e, { source: u }))),
											this._validate(
												s.z.layer,
												`layers.${u}`,
												e,
												{ arrayIndex: -1 },
												l
											))
										)
											return;
										(d = s.bJ(e)),
											this._validateLayer(d),
											d.setEventedParent(this, { layer: { id: u } });
									}
									const g = i ? this._order.indexOf(i) : this._order.length;
									if (i && g === -1)
										this.fire(
											new s.k(
												new Error(
													`Cannot add layer "${u}" before non-existing layer "${i}".`
												)
											)
										);
									else {
										if (
											(this._order.splice(g, 0, u),
											(this._layerOrderChanged = !0),
											(this._layers[u] = d),
											this._removedLayers[u] && d.source && d.type !== "custom")
										) {
											const w = this._removedLayers[u];
											delete this._removedLayers[u],
												w.type !== d.type
													? (this._updatedSources[d.source] = "clear")
													: ((this._updatedSources[d.source] = "reload"),
													  this.sourceCaches[d.source].pause());
										}
										this._updateLayer(d), d.onAdd && d.onAdd(this.map);
									}
								}
								moveLayer(e, i) {
									if (
										(this._checkLoaded(),
										(this._changed = !0),
										!this._layers[e])
									)
										return void this.fire(
											new s.k(
												new Error(
													`The layer '${e}' does not exist in the map's style and cannot be moved.`
												)
											)
										);
									if (e === i) return;
									const l = this._order.indexOf(e);
									this._order.splice(l, 1);
									const u = i ? this._order.indexOf(i) : this._order.length;
									i && u === -1
										? this.fire(
												new s.k(
													new Error(
														`Cannot move layer "${e}" before non-existing layer "${i}".`
													)
												)
										  )
										: (this._order.splice(u, 0, e),
										  (this._layerOrderChanged = !0));
								}
								removeLayer(e) {
									this._checkLoaded();
									const i = this._layers[e];
									if (!i)
										return void this.fire(
											new s.k(
												new Error(`Cannot remove non-existing layer "${e}".`)
											)
										);
									i.setEventedParent(null);
									const l = this._order.indexOf(e);
									this._order.splice(l, 1),
										(this._layerOrderChanged = !0),
										(this._changed = !0),
										(this._removedLayers[e] = i),
										delete this._layers[e],
										this._serializedLayers && delete this._serializedLayers[e],
										delete this._updatedLayers[e],
										delete this._updatedPaintProps[e],
										i.onRemove && i.onRemove(this.map);
								}
								getLayer(e) {
									return this._layers[e];
								}
								getLayersOrder() {
									return [...this._order];
								}
								hasLayer(e) {
									return e in this._layers;
								}
								setLayerZoomRange(e, i, l) {
									this._checkLoaded();
									const u = this.getLayer(e);
									u
										? (u.minzoom === i && u.maxzoom === l) ||
										  (i != null && (u.minzoom = i),
										  l != null && (u.maxzoom = l),
										  this._updateLayer(u))
										: this.fire(
												new s.k(
													new Error(
														`Cannot set the zoom range of non-existing layer "${e}".`
													)
												)
										  );
								}
								setFilter(e, i, l = {}) {
									this._checkLoaded();
									const u = this.getLayer(e);
									if (u) {
										if (!s.bH(u.filter, i))
											return i == null
												? (u.setFilter(void 0), void this._updateLayer(u))
												: void (
														this._validate(
															s.z.filter,
															`layers.${u.id}.filter`,
															i,
															null,
															l
														) || (u.setFilter(s.bK(i)), this._updateLayer(u))
												  );
									} else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
								}
								getFilter(e) {
									return s.bK(this.getLayer(e).filter);
								}
								setLayoutProperty(e, i, l, u = {}) {
									this._checkLoaded();
									const d = this.getLayer(e);
									d
										? s.bH(d.getLayoutProperty(i), l) ||
										  (d.setLayoutProperty(i, l, u), this._updateLayer(d))
										: this.fire(
												new s.k(
													new Error(`Cannot style non-existing layer "${e}".`)
												)
										  );
								}
								getLayoutProperty(e, i) {
									const l = this.getLayer(e);
									if (l) return l.getLayoutProperty(i);
									this.fire(
										new s.k(
											new Error(
												`Cannot get style of non-existing layer "${e}".`
											)
										)
									);
								}
								setPaintProperty(e, i, l, u = {}) {
									this._checkLoaded();
									const d = this.getLayer(e);
									d
										? s.bH(d.getPaintProperty(i), l) ||
										  (d.setPaintProperty(i, l, u) && this._updateLayer(d),
										  (this._changed = !0),
										  (this._updatedPaintProps[e] = !0),
										  (this._serializedLayers = null))
										: this.fire(
												new s.k(
													new Error(`Cannot style non-existing layer "${e}".`)
												)
										  );
								}
								getPaintProperty(e, i) {
									return this.getLayer(e).getPaintProperty(i);
								}
								setFeatureState(e, i) {
									this._checkLoaded();
									const l = e.source,
										u = e.sourceLayer,
										d = this.sourceCaches[l];
									if (d === void 0)
										return void this.fire(
											new s.k(
												new Error(
													`The source '${l}' does not exist in the map's style.`
												)
											)
										);
									const g = d.getSource().type;
									g === "geojson" && u
										? this.fire(
												new s.k(
													new Error(
														"GeoJSON sources cannot have a sourceLayer parameter."
													)
												)
										  )
										: g !== "vector" || u
										? (e.id === void 0 &&
												this.fire(
													new s.k(
														new Error(
															"The feature id parameter must be provided."
														)
													)
												),
										  d.setFeatureState(u, e.id, i))
										: this.fire(
												new s.k(
													new Error(
														"The sourceLayer parameter must be provided for vector source types."
													)
												)
										  );
								}
								removeFeatureState(e, i) {
									this._checkLoaded();
									const l = e.source,
										u = this.sourceCaches[l];
									if (u === void 0)
										return void this.fire(
											new s.k(
												new Error(
													`The source '${l}' does not exist in the map's style.`
												)
											)
										);
									const d = u.getSource().type,
										g = d === "vector" ? e.sourceLayer : void 0;
									d !== "vector" || g
										? i && typeof e.id != "string" && typeof e.id != "number"
											? this.fire(
													new s.k(
														new Error(
															"A feature id is required to remove its specific state property."
														)
													)
											  )
											: u.removeFeatureState(g, e.id, i)
										: this.fire(
												new s.k(
													new Error(
														"The sourceLayer parameter must be provided for vector source types."
													)
												)
										  );
								}
								getFeatureState(e) {
									this._checkLoaded();
									const i = e.source,
										l = e.sourceLayer,
										u = this.sourceCaches[i];
									if (u !== void 0)
										return u.getSource().type !== "vector" || l
											? (e.id === void 0 &&
													this.fire(
														new s.k(
															new Error(
																"The feature id parameter must be provided."
															)
														)
													),
											  u.getFeatureState(l, e.id))
											: void this.fire(
													new s.k(
														new Error(
															"The sourceLayer parameter must be provided for vector source types."
														)
													)
											  );
									this.fire(
										new s.k(
											new Error(
												`The source '${i}' does not exist in the map's style.`
											)
										)
									);
								}
								getTransition() {
									return s.e(
										{ duration: 300, delay: 0 },
										this.stylesheet && this.stylesheet.transition
									);
								}
								serialize() {
									if (!this._loaded) return;
									const e = s.bN(this.sourceCaches, (d) => d.serialize()),
										i = this._serializeByIds(this._order, !0),
										l = this.map.getTerrain() || void 0,
										u = this.stylesheet;
									return s.bO(
										{
											version: u.version,
											name: u.name,
											metadata: u.metadata,
											light: u.light,
											sky: u.sky,
											center: u.center,
											zoom: u.zoom,
											bearing: u.bearing,
											pitch: u.pitch,
											sprite: u.sprite,
											glyphs: u.glyphs,
											transition: u.transition,
											projection: u.projection,
											sources: e,
											layers: i,
											terrain: l,
										},
										(d) => d !== void 0
									);
								}
								_updateLayer(e) {
									(this._updatedLayers[e.id] = !0),
										e.source &&
											!this._updatedSources[e.source] &&
											this.sourceCaches[e.source].getSource().type !==
												"raster" &&
											((this._updatedSources[e.source] = "reload"),
											this.sourceCaches[e.source].pause()),
										(this._serializedLayers = null),
										(this._changed = !0);
								}
								_flattenAndSortRenderedFeatures(e) {
									const i = (g) => this._layers[g].type === "fill-extrusion",
										l = {},
										u = [];
									for (let g = this._order.length - 1; g >= 0; g--) {
										const w = this._order[g];
										if (i(w)) {
											l[w] = g;
											for (const C of e) {
												const P = C[w];
												if (P) for (const E of P) u.push(E);
											}
										}
									}
									u.sort((g, w) => w.intersectionZ - g.intersectionZ);
									const d = [];
									for (let g = this._order.length - 1; g >= 0; g--) {
										const w = this._order[g];
										if (i(w))
											for (let C = u.length - 1; C >= 0; C--) {
												const P = u[C].feature;
												if (l[P.layer.id] < g) break;
												d.push(P), u.pop();
											}
										else
											for (const C of e) {
												const P = C[w];
												if (P) for (const E of P) d.push(E.feature);
											}
									}
									return d;
								}
								queryRenderedFeatures(e, i, l) {
									i &&
										i.filter &&
										this._validate(
											s.z.filter,
											"queryRenderedFeatures.filter",
											i.filter,
											null,
											i
										);
									const u = {};
									if (i && i.layers) {
										if (!(Array.isArray(i.layers) || i.layers instanceof Set))
											return (
												this.fire(
													new s.k(
														new Error(
															"parameters.layers must be an Array or a Set of strings"
														)
													)
												),
												[]
											);
										for (const P of i.layers) {
											const E = this._layers[P];
											if (!E)
												return (
													this.fire(
														new s.k(
															new Error(
																`The layer '${P}' does not exist in the map's style and cannot be queried for features.`
															)
														)
													),
													[]
												);
											u[E.source] = !0;
										}
									}
									const d = [];
									i.availableImages = this._availableImages;
									const g = this._serializedAllLayers(),
										w =
											i.layers instanceof Set
												? i.layers
												: Array.isArray(i.layers)
												? new Set(i.layers)
												: null,
										C = Object.assign(Object.assign({}, i), { layers: w });
									for (const P in this.sourceCaches)
										(i.layers && !u[P]) ||
											d.push(
												yt(
													this.sourceCaches[P],
													this._layers,
													g,
													e,
													C,
													l,
													this.map.terrain
														? (E, R, D) =>
																this.map.terrain.getElevation(E, R, D)
														: void 0
												)
											);
									return (
										this.placement &&
											d.push(
												(function (P, E, R, D, N, G, te) {
													const Q = {},
														ae = G.queryRenderedSymbols(D),
														ce = [];
													for (const ve of Object.keys(ae).map(Number))
														ce.push(te[ve]);
													ce.sort(xt);
													for (const ve of ce) {
														const me = ve.featureIndex.lookupSymbolFeatures(
															ae[ve.bucketInstanceId],
															E,
															ve.bucketIndex,
															ve.sourceLayerIndex,
															N.filter,
															N.layers,
															N.availableImages,
															P
														);
														for (const be in me) {
															const Pe = (Q[be] = Q[be] || []),
																_e = me[be];
															_e.sort((Be, rt) => {
																const Ge = ve.featureSortOrder;
																if (Ge) {
																	const Xe = Ge.indexOf(Be.featureIndex);
																	return Ge.indexOf(rt.featureIndex) - Xe;
																}
																return rt.featureIndex - Be.featureIndex;
															});
															for (const Be of _e) Pe.push(Be);
														}
													}
													return (function (ve, me, be) {
														for (const Pe in ve)
															for (const _e of ve[Pe])
																St(_e, be[me[Pe].source]);
														return ve;
													})(Q, P, R);
												})(
													this._layers,
													g,
													this.sourceCaches,
													e,
													C,
													this.placement.collisionIndex,
													this.placement.retainedQueryData
												)
											),
										this._flattenAndSortRenderedFeatures(d)
									);
								}
								querySourceFeatures(e, i) {
									i &&
										i.filter &&
										this._validate(
											s.z.filter,
											"querySourceFeatures.filter",
											i.filter,
											null,
											i
										);
									const l = this.sourceCaches[e];
									return l
										? (function (u, d) {
												const g = u
														.getRenderableIds()
														.map((P) => u.getTileByID(P)),
													w = [],
													C = {};
												for (let P = 0; P < g.length; P++) {
													const E = g[P],
														R = E.tileID.canonical.key;
													C[R] || ((C[R] = !0), E.querySourceFeatures(w, d));
												}
												return w;
										  })(l, i)
										: [];
								}
								getLight() {
									return this.light.getLight();
								}
								setLight(e, i = {}) {
									this._checkLoaded();
									const l = this.light.getLight();
									let u = !1;
									for (const g in e)
										if (!s.bH(e[g], l[g])) {
											u = !0;
											break;
										}
									if (!u) return;
									const d = {
										now: ne.now(),
										transition: s.e(
											{ duration: 300, delay: 0 },
											this.stylesheet.transition
										),
									};
									this.light.setLight(e, i), this.light.updateTransitions(d);
								}
								getProjection() {
									var e;
									return (e = this.stylesheet) === null || e === void 0
										? void 0
										: e.projection;
								}
								setProjection(e) {
									if ((this._checkLoaded(), this.projection)) {
										if (this.projection.name === e.type) return;
										this.projection.destroy(), delete this.projection;
									}
									(this.stylesheet.projection = e),
										this._setProjectionInternal(e.type);
								}
								getSky() {
									var e;
									return (e = this.stylesheet) === null || e === void 0
										? void 0
										: e.sky;
								}
								setSky(e, i = {}) {
									this._checkLoaded();
									const l = this.getSky();
									let u = !1;
									if (!e && !l) return;
									if (e && !l) u = !0;
									else if (!e && l) u = !0;
									else
										for (const g in e)
											if (!s.bH(e[g], l[g])) {
												u = !0;
												break;
											}
									if (!u) return;
									const d = {
										now: ne.now(),
										transition: s.e(
											{ duration: 300, delay: 0 },
											this.stylesheet.transition
										),
									};
									(this.stylesheet.sky = e),
										this.sky.setSky(e, i),
										this.sky.updateTransitions(d);
								}
								_setProjectionInternal(e) {
									const i = (function (l) {
										if (Array.isArray(l)) {
											const u = new gl({ type: l });
											return {
												projection: u,
												transform: new Ds(),
												cameraHelper: new Oh(u),
											};
										}
										switch (l) {
											case "mercator":
												return {
													projection: new Mr(),
													transform: new on(),
													cameraHelper: new jn(),
												};
											case "globe": {
												const u = new gl({
													type: [
														"interpolate",
														["linear"],
														["zoom"],
														11,
														"vertical-perspective",
														12,
														"mercator",
													],
												});
												return {
													projection: u,
													transform: new Ds(),
													cameraHelper: new Oh(u),
												};
											}
											case "vertical-perspective":
												return {
													projection: new Qa(),
													transform: new Ls(),
													cameraHelper: new ji(),
												};
											default:
												return (
													s.w(
														`Unknown projection name: ${l}. Falling back to mercator projection.`
													),
													{
														projection: new Mr(),
														transform: new on(),
														cameraHelper: new jn(),
													}
												);
										}
									})(e);
									(this.projection = i.projection),
										this.map.migrateProjection(i.transform, i.cameraHelper);
									for (const l in this.sourceCaches)
										this.sourceCaches[l].reload();
								}
								_validate(e, i, l, u, d = {}) {
									return (
										(!d || d.validate !== !1) &&
										yl(
											this,
											e.call(
												s.z,
												s.e(
													{
														key: i,
														style: this.serialize(),
														value: l,
														styleSpec: s.v,
													},
													u
												)
											)
										)
									);
								}
								_remove(e = !0) {
									this._frameRequest &&
										(this._frameRequest.abort(), (this._frameRequest = null)),
										this._loadStyleRequest &&
											(this._loadStyleRequest.abort(),
											(this._loadStyleRequest = null)),
										this._spriteRequest &&
											(this._spriteRequest.abort(),
											(this._spriteRequest = null)),
										Ir().off(mr, this._rtlPluginLoaded);
									for (const i in this._layers)
										this._layers[i].setEventedParent(null);
									for (const i in this.sourceCaches) {
										const l = this.sourceCaches[i];
										l.setEventedParent(null), l.onRemove(this.map);
									}
									this.imageManager.setEventedParent(null),
										this.setEventedParent(null),
										e && this.dispatcher.broadcast("RM", void 0),
										this.dispatcher.remove(e);
								}
								_clearSource(e) {
									this.sourceCaches[e].clearTiles();
								}
								_reloadSource(e) {
									this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
								}
								_updateSources(e) {
									for (const i in this.sourceCaches)
										this.sourceCaches[i].update(e, this.map.terrain);
								}
								_generateCollisionBoxes() {
									for (const e in this.sourceCaches) this._reloadSource(e);
								}
								_updatePlacement(e, i, l, u, d = !1) {
									let g = !1,
										w = !1;
									const C = {};
									for (const P of this._order) {
										const E = this._layers[P];
										if (E.type !== "symbol") continue;
										if (!C[E.source]) {
											const D = this.sourceCaches[E.source];
											C[E.source] = D.getRenderableIds(!0)
												.map((N) => D.getTileByID(N))
												.sort(
													(N, G) =>
														G.tileID.overscaledZ - N.tileID.overscaledZ ||
														(N.tileID.isLessThan(G.tileID) ? -1 : 1)
												);
										}
										const R = this.crossTileSymbolIndex.addLayer(
											E,
											C[E.source],
											e.center.lng
										);
										g = g || R;
									}
									if (
										(this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
										((d = d || this._layerOrderChanged || l === 0) ||
											!this.pauseablePlacement ||
											(this.pauseablePlacement.isDone() &&
												!this.placement.stillRecent(ne.now(), e.zoom))) &&
											((this.pauseablePlacement = new On(
												e,
												this.map.terrain,
												this._order,
												d,
												i,
												l,
												u,
												this.placement
											)),
											(this._layerOrderChanged = !1)),
										this.pauseablePlacement.isDone()
											? this.placement.setStale()
											: (this.pauseablePlacement.continuePlacement(
													this._order,
													this._layers,
													C
											  ),
											  this.pauseablePlacement.isDone() &&
													((this.placement = this.pauseablePlacement.commit(
														ne.now()
													)),
													(w = !0)),
											  g && this.pauseablePlacement.placement.setStale()),
										w || g)
									)
										for (const P of this._order) {
											const E = this._layers[P];
											E.type === "symbol" &&
												this.placement.updateLayerOpacities(E, C[E.source]);
										}
									return (
										!this.pauseablePlacement.isDone() ||
										this.placement.hasTransitions(ne.now())
									);
								}
								_releaseSymbolFadeTiles() {
									for (const e in this.sourceCaches)
										this.sourceCaches[e].releaseSymbolFadeTiles();
								}
								getImages(e, i) {
									return s._(this, void 0, void 0, function* () {
										const l = yield this.imageManager.getImages(i.icons);
										this._updateTilesForChangedImages();
										const u = this.sourceCaches[i.source];
										return (
											u && u.setDependencies(i.tileID.key, i.type, i.icons), l
										);
									});
								}
								getGlyphs(e, i) {
									return s._(this, void 0, void 0, function* () {
										const l = yield this.glyphManager.getGlyphs(i.stacks),
											u = this.sourceCaches[i.source];
										return (
											u && u.setDependencies(i.tileID.key, i.type, [""]), l
										);
									});
								}
								getGlyphsUrl() {
									return this.stylesheet.glyphs || null;
								}
								setGlyphs(e, i = {}) {
									this._checkLoaded(),
										(e && this._validate(s.z.glyphs, "glyphs", e, null, i)) ||
											((this._glyphsDidChange = !0),
											(this.stylesheet.glyphs = e),
											(this.glyphManager.entries = {}),
											this.glyphManager.setURL(e));
								}
								addSprite(e, i, l = {}, u) {
									this._checkLoaded();
									const d = [{ id: e, url: i }],
										g = [...Je(this.stylesheet.sprite), ...d];
									this._validate(s.z.sprite, "sprite", g, null, l) ||
										((this.stylesheet.sprite = g), this._loadSprite(d, !0, u));
								}
								removeSprite(e) {
									this._checkLoaded();
									const i = Je(this.stylesheet.sprite);
									if (i.find((l) => l.id === e)) {
										if (this._spritesImagesIds[e])
											for (const l of this._spritesImagesIds[e])
												this.imageManager.removeImage(l),
													(this._changedImages[l] = !0);
										i.splice(
											i.findIndex((l) => l.id === e),
											1
										),
											(this.stylesheet.sprite = i.length > 0 ? i : void 0),
											delete this._spritesImagesIds[e],
											(this._availableImages = this.imageManager.listImages()),
											(this._changed = !0),
											this.dispatcher.broadcast("SI", this._availableImages),
											this.fire(new s.l("data", { dataType: "style" }));
									} else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
								}
								getSprite() {
									return Je(this.stylesheet.sprite);
								}
								setSprite(e, i = {}, l) {
									this._checkLoaded(),
										(e && this._validate(s.z.sprite, "sprite", e, null, i)) ||
											((this.stylesheet.sprite = e),
											e
												? this._loadSprite(e, !0, l)
												: (this._unloadSprite(), l && l(null)));
								}
							}
							var Tp = s.aJ([
								{ name: "a_pos", type: "Int16", components: 2 },
								{ name: "a_texture_pos", type: "Int16", components: 2 },
							]);
							class Cp {
								constructor() {
									(this.boundProgram = null),
										(this.boundLayoutVertexBuffer = null),
										(this.boundPaintVertexBuffers = []),
										(this.boundIndexBuffer = null),
										(this.boundVertexOffset = null),
										(this.boundDynamicVertexBuffer = null),
										(this.vao = null);
								}
								bind(e, i, l, u, d, g, w, C, P) {
									this.context = e;
									let E = this.boundPaintVertexBuffers.length !== u.length;
									for (let R = 0; !E && R < u.length; R++)
										this.boundPaintVertexBuffers[R] !== u[R] && (E = !0);
									!this.vao ||
									this.boundProgram !== i ||
									this.boundLayoutVertexBuffer !== l ||
									E ||
									this.boundIndexBuffer !== d ||
									this.boundVertexOffset !== g ||
									this.boundDynamicVertexBuffer !== w ||
									this.boundDynamicVertexBuffer2 !== C ||
									this.boundDynamicVertexBuffer3 !== P
										? this.freshBind(i, l, u, d, g, w, C, P)
										: (e.bindVertexArray.set(this.vao),
										  w && w.bind(),
										  d && d.dynamicDraw && d.bind(),
										  C && C.bind(),
										  P && P.bind());
								}
								freshBind(e, i, l, u, d, g, w, C) {
									const P = e.numAttributes,
										E = this.context,
										R = E.gl;
									this.vao && this.destroy(),
										(this.vao = E.createVertexArray()),
										E.bindVertexArray.set(this.vao),
										(this.boundProgram = e),
										(this.boundLayoutVertexBuffer = i),
										(this.boundPaintVertexBuffers = l),
										(this.boundIndexBuffer = u),
										(this.boundVertexOffset = d),
										(this.boundDynamicVertexBuffer = g),
										(this.boundDynamicVertexBuffer2 = w),
										(this.boundDynamicVertexBuffer3 = C),
										i.enableAttributes(R, e);
									for (const D of l) D.enableAttributes(R, e);
									g && g.enableAttributes(R, e),
										w && w.enableAttributes(R, e),
										C && C.enableAttributes(R, e),
										i.bind(),
										i.setVertexAttribPointers(R, e, d);
									for (const D of l)
										D.bind(), D.setVertexAttribPointers(R, e, d);
									g && (g.bind(), g.setVertexAttribPointers(R, e, d)),
										u && u.bind(),
										w && (w.bind(), w.setVertexAttribPointers(R, e, d)),
										C && (C.bind(), C.setVertexAttribPointers(R, e, d)),
										(E.currentNumAttributes = P);
								}
								destroy() {
									this.vao &&
										(this.context.deleteVertexArray(this.vao),
										(this.vao = null));
								}
							}
							const xl = (h, e, i, l, u) => ({
									u_texture: 0,
									u_ele_delta: h,
									u_fog_matrix: e,
									u_fog_color: i ? i.properties.get("fog-color") : s.bf.white,
									u_fog_ground_blend: i
										? i.properties.get("fog-ground-blend")
										: 1,
									u_fog_ground_blend_opacity: u
										? 0
										: i
										? i.calculateFogBlendOpacity(l)
										: 0,
									u_horizon_color: i
										? i.properties.get("horizon-color")
										: s.bf.white,
									u_horizon_fog_blend: i
										? i.properties.get("horizon-fog-blend")
										: 1,
									u_is_globe_mode: u ? 1 : 0,
								}),
								Lc = {
									mainMatrix: "u_projection_matrix",
									tileMercatorCoords: "u_projection_tile_mercator_coords",
									clippingPlane: "u_projection_clipping_plane",
									projectionTransition: "u_projection_transition",
									fallbackMatrix: "u_projection_fallback_matrix",
								};
							function ko(h) {
								const e = [];
								for (let i = 0; i < h.length; i++) {
									if (h[i] === null) continue;
									const l = h[i].split(" ");
									e.push(l.pop());
								}
								return e;
							}
							class Dc {
								constructor(e, i, l, u, d, g, w, C, P = []) {
									const E = e.gl;
									this.program = E.createProgram();
									const R = ko(i.staticAttributes),
										D = l ? l.getBinderAttributes() : [],
										N = R.concat(D),
										G = $r.prelude.staticUniforms
											? ko($r.prelude.staticUniforms)
											: [],
										te = w.staticUniforms ? ko(w.staticUniforms) : [],
										Q = i.staticUniforms ? ko(i.staticUniforms) : [],
										ae = l ? l.getBinderUniforms() : [],
										ce = G.concat(te).concat(Q).concat(ae),
										ve = [];
									for (const Ge of ce) ve.indexOf(Ge) < 0 && ve.push(Ge);
									const me = l ? l.defines() : [];
									ga(E) && me.unshift("#version 300 es"),
										d && me.push("#define OVERDRAW_INSPECTOR;"),
										g && me.push("#define TERRAIN3D;"),
										C && me.push(C),
										P && me.push(...P);
									let be = me.concat(
											$r.prelude.fragmentSource,
											w.fragmentSource,
											i.fragmentSource
										).join(`
`),
										Pe = me.concat(
											$r.prelude.vertexSource,
											w.vertexSource,
											i.vertexSource
										).join(`
`);
									ga(E) ||
										((be = (function (Ge) {
											return Ge.replace(/\bin\s/g, "varying ")
												.replace("out highp vec4 fragColor;", "")
												.replace(/fragColor/g, "gl_FragColor")
												.replace(/texture\(/g, "texture2D(");
										})(be)),
										(Pe = (function (Ge) {
											return Ge.replace(/\bin\s/g, "attribute ")
												.replace(/\bout\s/g, "varying ")
												.replace(/texture\(/g, "texture2D(");
										})(Pe)));
									const _e = E.createShader(E.FRAGMENT_SHADER);
									if (E.isContextLost()) return void (this.failedToCreate = !0);
									if (
										(E.shaderSource(_e, be),
										E.compileShader(_e),
										!E.getShaderParameter(_e, E.COMPILE_STATUS))
									)
										throw new Error(
											`Could not compile fragment shader: ${E.getShaderInfoLog(
												_e
											)}`
										);
									E.attachShader(this.program, _e);
									const Be = E.createShader(E.VERTEX_SHADER);
									if (E.isContextLost()) return void (this.failedToCreate = !0);
									if (
										(E.shaderSource(Be, Pe),
										E.compileShader(Be),
										!E.getShaderParameter(Be, E.COMPILE_STATUS))
									)
										throw new Error(
											`Could not compile vertex shader: ${E.getShaderInfoLog(
												Be
											)}`
										);
									E.attachShader(this.program, Be), (this.attributes = {});
									const rt = {};
									this.numAttributes = N.length;
									for (let Ge = 0; Ge < this.numAttributes; Ge++)
										N[Ge] &&
											(E.bindAttribLocation(this.program, Ge, N[Ge]),
											(this.attributes[N[Ge]] = Ge));
									if (
										(E.linkProgram(this.program),
										!E.getProgramParameter(this.program, E.LINK_STATUS))
									)
										throw new Error(
											`Program failed to link: ${E.getProgramInfoLog(
												this.program
											)}`
										);
									E.deleteShader(Be), E.deleteShader(_e);
									for (let Ge = 0; Ge < ve.length; Ge++) {
										const Xe = ve[Ge];
										if (Xe && !rt[Xe]) {
											const tt = E.getUniformLocation(this.program, Xe);
											tt && (rt[Xe] = tt);
										}
									}
									(this.fixedUniforms = u(e, rt)),
										(this.terrainUniforms = ((Ge, Xe) => ({
											u_depth: new s.bP(Ge, Xe.u_depth),
											u_terrain: new s.bP(Ge, Xe.u_terrain),
											u_terrain_dim: new s.bg(Ge, Xe.u_terrain_dim),
											u_terrain_matrix: new s.bR(Ge, Xe.u_terrain_matrix),
											u_terrain_unpack: new s.bS(Ge, Xe.u_terrain_unpack),
											u_terrain_exaggeration: new s.bg(
												Ge,
												Xe.u_terrain_exaggeration
											),
										}))(e, rt)),
										(this.projectionUniforms = ((Ge, Xe) => ({
											u_projection_matrix: new s.bR(Ge, Xe.u_projection_matrix),
											u_projection_tile_mercator_coords: new s.bS(
												Ge,
												Xe.u_projection_tile_mercator_coords
											),
											u_projection_clipping_plane: new s.bS(
												Ge,
												Xe.u_projection_clipping_plane
											),
											u_projection_transition: new s.bg(
												Ge,
												Xe.u_projection_transition
											),
											u_projection_fallback_matrix: new s.bR(
												Ge,
												Xe.u_projection_fallback_matrix
											),
										}))(e, rt)),
										(this.binderUniforms = l ? l.getUniforms(e, rt) : []);
								}
								draw(
									e,
									i,
									l,
									u,
									d,
									g,
									w,
									C,
									P,
									E,
									R,
									D,
									N,
									G,
									te,
									Q,
									ae,
									ce,
									ve
								) {
									const me = e.gl;
									if (this.failedToCreate) return;
									if (
										(e.program.set(this.program),
										e.setDepthMode(l),
										e.setStencilMode(u),
										e.setColorMode(d),
										e.setCullFace(g),
										C)
									) {
										e.activeTexture.set(me.TEXTURE2),
											me.bindTexture(me.TEXTURE_2D, C.depthTexture),
											e.activeTexture.set(me.TEXTURE3),
											me.bindTexture(me.TEXTURE_2D, C.texture);
										for (const Pe in this.terrainUniforms)
											this.terrainUniforms[Pe].set(C[Pe]);
									}
									if (P)
										for (const Pe in P)
											this.projectionUniforms[Lc[Pe]].set(P[Pe]);
									if (w)
										for (const Pe in this.fixedUniforms)
											this.fixedUniforms[Pe].set(w[Pe]);
									Q && Q.setUniforms(e, this.binderUniforms, G, { zoom: te });
									let be = 0;
									switch (i) {
										case me.LINES:
											be = 2;
											break;
										case me.TRIANGLES:
											be = 3;
											break;
										case me.LINE_STRIP:
											be = 1;
									}
									for (const Pe of N.get()) {
										const _e = Pe.vaos || (Pe.vaos = {});
										(_e[E] || (_e[E] = new Cp())).bind(
											e,
											this,
											R,
											Q ? Q.getPaintVertexBuffers() : [],
											D,
											Pe.vertexOffset,
											ae,
											ce,
											ve
										),
											me.drawElements(
												i,
												Pe.primitiveLength * be,
												me.UNSIGNED_SHORT,
												Pe.primitiveOffset * be * 2
											);
									}
								}
							}
							function bl(h, e, i) {
								const l = 1 / s.aC(i, 1, e.transform.tileZoom),
									u = Math.pow(2, i.tileID.overscaledZ),
									d = (i.tileSize * Math.pow(2, e.transform.tileZoom)) / u,
									g = d * (i.tileID.canonical.x + i.tileID.wrap * u),
									w = d * i.tileID.canonical.y;
								return {
									u_image: 0,
									u_texsize: i.imageAtlasTexture.size,
									u_scale: [l, h.fromScale, h.toScale],
									u_fade: h.t,
									u_pixel_coord_upper: [g >> 16, w >> 16],
									u_pixel_coord_lower: [65535 & g, 65535 & w],
								};
							}
							const Pa = (h, e, i, l) => {
									const u = h.style.light,
										d = u.properties.get("position"),
										g = [d.x, d.y, d.z],
										w = s.bV();
									u.properties.get("anchor") === "viewport" &&
										s.bW(w, h.transform.bearingInRadians),
										s.bX(g, g, w);
									const C = h.transform.transformLightDirection(g),
										P = u.properties.get("color");
									return {
										u_lightpos: g,
										u_lightpos_globe: C,
										u_lightintensity: u.properties.get("intensity"),
										u_lightcolor: [P.r, P.g, P.b],
										u_vertical_gradient: +e,
										u_opacity: i,
										u_fill_translate: l,
									};
								},
								Sp = (h, e, i, l, u, d, g) =>
									s.e(Pa(h, e, i, l), bl(d, h, g), {
										u_height_factor:
											-Math.pow(2, u.overscaledZ) / g.tileSize / 8,
									}),
								wl = (h, e, i, l) => s.e(bl(e, h, i), { u_fill_translate: l }),
								Rs = (h, e) => ({ u_world: h, u_fill_translate: e }),
								Bs = (h, e, i, l, u) => s.e(wl(h, e, i, u), { u_world: l }),
								Pp = (h, e, i, l, u) => {
									const d = h.transform;
									let g,
										w,
										C = 0;
									if (i.paint.get("circle-pitch-alignment") === "map") {
										const P = s.aC(e, 1, d.zoom);
										(g = !0),
											(w = [P, P]),
											(C =
												(P / (s.$ * Math.pow(2, e.tileID.overscaledZ))) *
												2 *
												Math.PI *
												u);
									} else (g = !1), (w = d.pixelsToGLUnits);
									return {
										u_camera_to_center_distance: d.cameraToCenterDistance,
										u_scale_with_map: +(
											i.paint.get("circle-pitch-scale") === "map"
										),
										u_pitch_with_map: +g,
										u_device_pixel_ratio: h.pixelRatio,
										u_extrude_scale: w,
										u_globe_extrude_scale: C,
										u_translate: l,
									};
								},
								Tl = (h) => ({
									u_pixel_extrude_scale: [1 / h.width, 1 / h.height],
								}),
								Ip = (h) => ({ u_viewport_size: [h.width, h.height] }),
								Ao = (h, e = 1) => ({
									u_color: h,
									u_overlay: 0,
									u_overlay_scale: e,
								}),
								Nh = (h, e, i, l) => {
									const u =
										(s.aC(h, 1, e) /
											(s.$ * Math.pow(2, h.tileID.overscaledZ))) *
										2 *
										Math.PI *
										l;
									return {
										u_extrude_scale: s.aC(h, 1, e),
										u_intensity: i,
										u_globe_extrude_scale: u,
									};
								},
								Rc = (h, e, i, l) => {
									const u = s.L();
									s.bY(u, 0, h.width, h.height, 0, 0, 1);
									const d = h.context.gl;
									return {
										u_matrix: u,
										u_world: [d.drawingBufferWidth, d.drawingBufferHeight],
										u_image: i,
										u_color_ramp: l,
										u_opacity: e.paint.get("heatmap-opacity"),
									};
								},
								Mp = (h, e, i) => {
									const l = i.paint.get("hillshade-accent-color");
									let u;
									switch (i.paint.get("hillshade-method")) {
										case "basic":
											u = 4;
											break;
										case "combined":
											u = 1;
											break;
										case "igor":
											u = 2;
											break;
										case "multidirectional":
											u = 3;
											break;
										default:
											u = 0;
									}
									const d = i.getIlluminationProperties();
									for (let g = 0; g < d.directionRadians.length; g++)
										i.paint.get("hillshade-illumination-anchor") ===
											"viewport" &&
											(d.directionRadians[g] += h.transform.bearingInRadians);
									return {
										u_image: 0,
										u_latrange: Bc(0, e.tileID),
										u_exaggeration: i.paint.get("hillshade-exaggeration"),
										u_altitudes: d.altitudeRadians,
										u_azimuths: d.directionRadians,
										u_accent: l,
										u_method: u,
										u_highlights: d.highlightColor,
										u_shadows: d.shadowColor,
									};
								},
								jh = (h, e) => {
									const i = e.stride,
										l = s.L();
									return (
										s.bY(l, 0, s.$, -s.$, 0, 0, 1),
										s.M(l, l, [0, -s.$, 0]),
										{
											u_matrix: l,
											u_image: 1,
											u_dimension: [i, i],
											u_zoom: h.overscaledZ,
											u_unpack: e.getUnpackVector(),
										}
									);
								};
							function Bc(h, e) {
								const i = Math.pow(2, e.canonical.z),
									l = e.canonical.y;
								return [
									new s.a1(0, l / i).toLngLat().lat,
									new s.a1(0, (l + 1) / i).toLngLat().lat,
								];
							}
							const Vh = (h, e, i = 0) => ({
									u_image: 0,
									u_unpack: e.getUnpackVector(),
									u_dimension: [e.stride, e.stride],
									u_elevation_stops: 1,
									u_color_stops: 4,
									u_color_ramp_size: i,
									u_opacity: h.paint.get("color-relief-opacity"),
								}),
								Cl = (h, e, i, l) => {
									const u = h.transform;
									return {
										u_translation: Oc(h, e, i),
										u_ratio: l / s.aC(e, 1, u.zoom),
										u_device_pixel_ratio: h.pixelRatio,
										u_units_to_pixels: [
											1 / u.pixelsToGLUnits[0],
											1 / u.pixelsToGLUnits[1],
										],
									};
								},
								qh = (h, e, i, l, u) =>
									s.e(Cl(h, e, i, l), { u_image: 0, u_image_height: u }),
								Zh = (h, e, i, l, u) => {
									const d = h.transform,
										g = Fc(e, d);
									return {
										u_translation: Oc(h, e, i),
										u_texsize: e.imageAtlasTexture.size,
										u_ratio: l / s.aC(e, 1, d.zoom),
										u_device_pixel_ratio: h.pixelRatio,
										u_image: 0,
										u_scale: [g, u.fromScale, u.toScale],
										u_fade: u.t,
										u_units_to_pixels: [
											1 / d.pixelsToGLUnits[0],
											1 / d.pixelsToGLUnits[1],
										],
									};
								},
								Eo = (h, e, i, l, u, d) => {
									const g = h.lineAtlas,
										w = Fc(e, h.transform),
										C = i.layout.get("line-cap") === "round",
										P = g.getDash(u.from, C),
										E = g.getDash(u.to, C),
										R = P.width * d.fromScale,
										D = E.width * d.toScale;
									return s.e(Cl(h, e, i, l), {
										u_patternscale_a: [w / R, -P.height / 2],
										u_patternscale_b: [w / D, -E.height / 2],
										u_sdfgamma:
											g.width / (256 * Math.min(R, D) * h.pixelRatio) / 2,
										u_image: 0,
										u_tex_y_a: P.y,
										u_tex_y_b: E.y,
										u_mix: d.t,
									});
								};
							function Fc(h, e) {
								return 1 / s.aC(h, 1, e.tileZoom);
							}
							function Oc(h, e, i) {
								return s.aD(
									h.transform,
									e,
									i.paint.get("line-translate"),
									i.paint.get("line-translate-anchor")
								);
							}
							const Fs = (h, e, i, l, u) => {
								return {
									u_tl_parent: h,
									u_scale_parent: e,
									u_buffer_scale: 1,
									u_fade_t: i.mix,
									u_opacity: i.opacity * l.paint.get("raster-opacity"),
									u_image0: 0,
									u_image1: 1,
									u_brightness_low: l.paint.get("raster-brightness-min"),
									u_brightness_high: l.paint.get("raster-brightness-max"),
									u_saturation_factor:
										((g = l.paint.get("raster-saturation")),
										g > 0 ? 1 - 1 / (1.001 - g) : -g),
									u_contrast_factor:
										((d = l.paint.get("raster-contrast")),
										d > 0 ? 1 / (1 - d) : 1 + d),
									u_spin_weights: kp(l.paint.get("raster-hue-rotate")),
									u_coords_top: [u[0].x, u[0].y, u[1].x, u[1].y],
									u_coords_bottom: [u[3].x, u[3].y, u[2].x, u[2].y],
								};
								var d, g;
							};
							function kp(h) {
								h *= Math.PI / 180;
								const e = Math.sin(h),
									i = Math.cos(h);
								return [
									(2 * i + 1) / 3,
									(-Math.sqrt(3) * e - i + 1) / 3,
									(Math.sqrt(3) * e - i + 1) / 3,
								];
							}
							const Os = (h, e, i, l, u, d, g, w, C, P, E, R, D) => {
									const N = g.transform;
									return {
										u_is_size_zoom_constant: +(
											h === "constant" || h === "source"
										),
										u_is_size_feature_constant: +(
											h === "constant" || h === "camera"
										),
										u_size_t: e ? e.uSizeT : 0,
										u_size: e ? e.uSize : 0,
										u_camera_to_center_distance: N.cameraToCenterDistance,
										u_pitch: (N.pitch / 360) * 2 * Math.PI,
										u_rotate_symbol: +i,
										u_aspect_ratio: N.width / N.height,
										u_fade_change: g.options.fadeDuration
											? g.symbolFadeChange
											: 1,
										u_label_plane_matrix: w,
										u_coord_matrix: C,
										u_is_text: +E,
										u_pitch_with_map: +l,
										u_is_along_line: u,
										u_is_variable_anchor: d,
										u_texsize: R,
										u_texture: 0,
										u_translation: P,
										u_pitched_scale: D,
									};
								},
								Uh = (h, e, i, l, u, d, g, w, C, P, E, R, D, N) => {
									const G = g.transform;
									return s.e(Os(h, e, i, l, u, d, g, w, C, P, E, R, N), {
										u_gamma_scale: l
											? Math.cos((G.pitch * Math.PI) / 180) *
											  G.cameraToCenterDistance
											: 1,
										u_device_pixel_ratio: g.pixelRatio,
										u_is_halo: 1,
									});
								},
								Ap = (h, e, i, l, u, d, g, w, C, P, E, R, D) =>
									s.e(Uh(h, e, i, l, u, d, g, w, C, P, !0, E, 0, D), {
										u_texsize_icon: R,
										u_texture_icon: 1,
									}),
								$h = (h, e) => ({ u_opacity: h, u_color: e }),
								Gh = (h, e, i, l, u) =>
									s.e(
										(function (d, g, w, C) {
											const P = w.imageManager.getPattern(d.from.toString()),
												E = w.imageManager.getPattern(d.to.toString()),
												{ width: R, height: D } = w.imageManager.getPixelSize(),
												N = Math.pow(2, C.tileID.overscaledZ),
												G =
													(C.tileSize * Math.pow(2, w.transform.tileZoom)) / N,
												te = G * (C.tileID.canonical.x + C.tileID.wrap * N),
												Q = G * C.tileID.canonical.y;
											return {
												u_image: 0,
												u_pattern_tl_a: P.tl,
												u_pattern_br_a: P.br,
												u_pattern_tl_b: E.tl,
												u_pattern_br_b: E.br,
												u_texsize: [R, D],
												u_mix: g.t,
												u_pattern_size_a: P.displaySize,
												u_pattern_size_b: E.displaySize,
												u_scale_a: g.fromScale,
												u_scale_b: g.toScale,
												u_tile_units_to_pixels:
													1 / s.aC(C, 1, w.transform.tileZoom),
												u_pixel_coord_upper: [te >> 16, Q >> 16],
												u_pixel_coord_lower: [65535 & te, 65535 & Q],
											};
										})(i, u, e, l),
										{ u_opacity: h }
									),
								Nc = (h, e) => {},
								jc = {
									fillExtrusion: (h, e) => ({
										u_lightpos: new s.bT(h, e.u_lightpos),
										u_lightpos_globe: new s.bT(h, e.u_lightpos_globe),
										u_lightintensity: new s.bg(h, e.u_lightintensity),
										u_lightcolor: new s.bT(h, e.u_lightcolor),
										u_vertical_gradient: new s.bg(h, e.u_vertical_gradient),
										u_opacity: new s.bg(h, e.u_opacity),
										u_fill_translate: new s.bU(h, e.u_fill_translate),
									}),
									fillExtrusionPattern: (h, e) => ({
										u_lightpos: new s.bT(h, e.u_lightpos),
										u_lightpos_globe: new s.bT(h, e.u_lightpos_globe),
										u_lightintensity: new s.bg(h, e.u_lightintensity),
										u_lightcolor: new s.bT(h, e.u_lightcolor),
										u_vertical_gradient: new s.bg(h, e.u_vertical_gradient),
										u_height_factor: new s.bg(h, e.u_height_factor),
										u_opacity: new s.bg(h, e.u_opacity),
										u_fill_translate: new s.bU(h, e.u_fill_translate),
										u_image: new s.bP(h, e.u_image),
										u_texsize: new s.bU(h, e.u_texsize),
										u_pixel_coord_upper: new s.bU(h, e.u_pixel_coord_upper),
										u_pixel_coord_lower: new s.bU(h, e.u_pixel_coord_lower),
										u_scale: new s.bT(h, e.u_scale),
										u_fade: new s.bg(h, e.u_fade),
									}),
									fill: (h, e) => ({
										u_fill_translate: new s.bU(h, e.u_fill_translate),
									}),
									fillPattern: (h, e) => ({
										u_image: new s.bP(h, e.u_image),
										u_texsize: new s.bU(h, e.u_texsize),
										u_pixel_coord_upper: new s.bU(h, e.u_pixel_coord_upper),
										u_pixel_coord_lower: new s.bU(h, e.u_pixel_coord_lower),
										u_scale: new s.bT(h, e.u_scale),
										u_fade: new s.bg(h, e.u_fade),
										u_fill_translate: new s.bU(h, e.u_fill_translate),
									}),
									fillOutline: (h, e) => ({
										u_world: new s.bU(h, e.u_world),
										u_fill_translate: new s.bU(h, e.u_fill_translate),
									}),
									fillOutlinePattern: (h, e) => ({
										u_world: new s.bU(h, e.u_world),
										u_image: new s.bP(h, e.u_image),
										u_texsize: new s.bU(h, e.u_texsize),
										u_pixel_coord_upper: new s.bU(h, e.u_pixel_coord_upper),
										u_pixel_coord_lower: new s.bU(h, e.u_pixel_coord_lower),
										u_scale: new s.bT(h, e.u_scale),
										u_fade: new s.bg(h, e.u_fade),
										u_fill_translate: new s.bU(h, e.u_fill_translate),
									}),
									circle: (h, e) => ({
										u_camera_to_center_distance: new s.bg(
											h,
											e.u_camera_to_center_distance
										),
										u_scale_with_map: new s.bP(h, e.u_scale_with_map),
										u_pitch_with_map: new s.bP(h, e.u_pitch_with_map),
										u_extrude_scale: new s.bU(h, e.u_extrude_scale),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_globe_extrude_scale: new s.bg(h, e.u_globe_extrude_scale),
										u_translate: new s.bU(h, e.u_translate),
									}),
									collisionBox: (h, e) => ({
										u_pixel_extrude_scale: new s.bU(h, e.u_pixel_extrude_scale),
									}),
									collisionCircle: (h, e) => ({
										u_viewport_size: new s.bU(h, e.u_viewport_size),
									}),
									debug: (h, e) => ({
										u_color: new s.bQ(h, e.u_color),
										u_overlay: new s.bP(h, e.u_overlay),
										u_overlay_scale: new s.bg(h, e.u_overlay_scale),
									}),
									depth: Nc,
									clippingMask: Nc,
									heatmap: (h, e) => ({
										u_extrude_scale: new s.bg(h, e.u_extrude_scale),
										u_intensity: new s.bg(h, e.u_intensity),
										u_globe_extrude_scale: new s.bg(h, e.u_globe_extrude_scale),
									}),
									heatmapTexture: (h, e) => ({
										u_matrix: new s.bR(h, e.u_matrix),
										u_world: new s.bU(h, e.u_world),
										u_image: new s.bP(h, e.u_image),
										u_color_ramp: new s.bP(h, e.u_color_ramp),
										u_opacity: new s.bg(h, e.u_opacity),
									}),
									hillshade: (h, e) => ({
										u_image: new s.bP(h, e.u_image),
										u_latrange: new s.bU(h, e.u_latrange),
										u_exaggeration: new s.bg(h, e.u_exaggeration),
										u_altitudes: new s.b_(h, e.u_altitudes),
										u_azimuths: new s.b_(h, e.u_azimuths),
										u_accent: new s.bQ(h, e.u_accent),
										u_method: new s.bP(h, e.u_method),
										u_shadows: new s.bZ(h, e.u_shadows),
										u_highlights: new s.bZ(h, e.u_highlights),
									}),
									hillshadePrepare: (h, e) => ({
										u_matrix: new s.bR(h, e.u_matrix),
										u_image: new s.bP(h, e.u_image),
										u_dimension: new s.bU(h, e.u_dimension),
										u_zoom: new s.bg(h, e.u_zoom),
										u_unpack: new s.bS(h, e.u_unpack),
									}),
									colorRelief: (h, e) => ({
										u_image: new s.bP(h, e.u_image),
										u_unpack: new s.bS(h, e.u_unpack),
										u_dimension: new s.bU(h, e.u_dimension),
										u_elevation_stops: new s.bP(h, e.u_elevation_stops),
										u_color_stops: new s.bP(h, e.u_color_stops),
										u_color_ramp_size: new s.bP(h, e.u_color_ramp_size),
										u_opacity: new s.bg(h, e.u_opacity),
									}),
									line: (h, e) => ({
										u_translation: new s.bU(h, e.u_translation),
										u_ratio: new s.bg(h, e.u_ratio),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_units_to_pixels: new s.bU(h, e.u_units_to_pixels),
									}),
									lineGradient: (h, e) => ({
										u_translation: new s.bU(h, e.u_translation),
										u_ratio: new s.bg(h, e.u_ratio),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_units_to_pixels: new s.bU(h, e.u_units_to_pixels),
										u_image: new s.bP(h, e.u_image),
										u_image_height: new s.bg(h, e.u_image_height),
									}),
									linePattern: (h, e) => ({
										u_translation: new s.bU(h, e.u_translation),
										u_texsize: new s.bU(h, e.u_texsize),
										u_ratio: new s.bg(h, e.u_ratio),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_image: new s.bP(h, e.u_image),
										u_units_to_pixels: new s.bU(h, e.u_units_to_pixels),
										u_scale: new s.bT(h, e.u_scale),
										u_fade: new s.bg(h, e.u_fade),
									}),
									lineSDF: (h, e) => ({
										u_translation: new s.bU(h, e.u_translation),
										u_ratio: new s.bg(h, e.u_ratio),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_units_to_pixels: new s.bU(h, e.u_units_to_pixels),
										u_patternscale_a: new s.bU(h, e.u_patternscale_a),
										u_patternscale_b: new s.bU(h, e.u_patternscale_b),
										u_sdfgamma: new s.bg(h, e.u_sdfgamma),
										u_image: new s.bP(h, e.u_image),
										u_tex_y_a: new s.bg(h, e.u_tex_y_a),
										u_tex_y_b: new s.bg(h, e.u_tex_y_b),
										u_mix: new s.bg(h, e.u_mix),
									}),
									raster: (h, e) => ({
										u_tl_parent: new s.bU(h, e.u_tl_parent),
										u_scale_parent: new s.bg(h, e.u_scale_parent),
										u_buffer_scale: new s.bg(h, e.u_buffer_scale),
										u_fade_t: new s.bg(h, e.u_fade_t),
										u_opacity: new s.bg(h, e.u_opacity),
										u_image0: new s.bP(h, e.u_image0),
										u_image1: new s.bP(h, e.u_image1),
										u_brightness_low: new s.bg(h, e.u_brightness_low),
										u_brightness_high: new s.bg(h, e.u_brightness_high),
										u_saturation_factor: new s.bg(h, e.u_saturation_factor),
										u_contrast_factor: new s.bg(h, e.u_contrast_factor),
										u_spin_weights: new s.bT(h, e.u_spin_weights),
										u_coords_top: new s.bS(h, e.u_coords_top),
										u_coords_bottom: new s.bS(h, e.u_coords_bottom),
									}),
									symbolIcon: (h, e) => ({
										u_is_size_zoom_constant: new s.bP(
											h,
											e.u_is_size_zoom_constant
										),
										u_is_size_feature_constant: new s.bP(
											h,
											e.u_is_size_feature_constant
										),
										u_size_t: new s.bg(h, e.u_size_t),
										u_size: new s.bg(h, e.u_size),
										u_camera_to_center_distance: new s.bg(
											h,
											e.u_camera_to_center_distance
										),
										u_pitch: new s.bg(h, e.u_pitch),
										u_rotate_symbol: new s.bP(h, e.u_rotate_symbol),
										u_aspect_ratio: new s.bg(h, e.u_aspect_ratio),
										u_fade_change: new s.bg(h, e.u_fade_change),
										u_label_plane_matrix: new s.bR(h, e.u_label_plane_matrix),
										u_coord_matrix: new s.bR(h, e.u_coord_matrix),
										u_is_text: new s.bP(h, e.u_is_text),
										u_pitch_with_map: new s.bP(h, e.u_pitch_with_map),
										u_is_along_line: new s.bP(h, e.u_is_along_line),
										u_is_variable_anchor: new s.bP(h, e.u_is_variable_anchor),
										u_texsize: new s.bU(h, e.u_texsize),
										u_texture: new s.bP(h, e.u_texture),
										u_translation: new s.bU(h, e.u_translation),
										u_pitched_scale: new s.bg(h, e.u_pitched_scale),
									}),
									symbolSDF: (h, e) => ({
										u_is_size_zoom_constant: new s.bP(
											h,
											e.u_is_size_zoom_constant
										),
										u_is_size_feature_constant: new s.bP(
											h,
											e.u_is_size_feature_constant
										),
										u_size_t: new s.bg(h, e.u_size_t),
										u_size: new s.bg(h, e.u_size),
										u_camera_to_center_distance: new s.bg(
											h,
											e.u_camera_to_center_distance
										),
										u_pitch: new s.bg(h, e.u_pitch),
										u_rotate_symbol: new s.bP(h, e.u_rotate_symbol),
										u_aspect_ratio: new s.bg(h, e.u_aspect_ratio),
										u_fade_change: new s.bg(h, e.u_fade_change),
										u_label_plane_matrix: new s.bR(h, e.u_label_plane_matrix),
										u_coord_matrix: new s.bR(h, e.u_coord_matrix),
										u_is_text: new s.bP(h, e.u_is_text),
										u_pitch_with_map: new s.bP(h, e.u_pitch_with_map),
										u_is_along_line: new s.bP(h, e.u_is_along_line),
										u_is_variable_anchor: new s.bP(h, e.u_is_variable_anchor),
										u_texsize: new s.bU(h, e.u_texsize),
										u_texture: new s.bP(h, e.u_texture),
										u_gamma_scale: new s.bg(h, e.u_gamma_scale),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_is_halo: new s.bP(h, e.u_is_halo),
										u_translation: new s.bU(h, e.u_translation),
										u_pitched_scale: new s.bg(h, e.u_pitched_scale),
									}),
									symbolTextAndIcon: (h, e) => ({
										u_is_size_zoom_constant: new s.bP(
											h,
											e.u_is_size_zoom_constant
										),
										u_is_size_feature_constant: new s.bP(
											h,
											e.u_is_size_feature_constant
										),
										u_size_t: new s.bg(h, e.u_size_t),
										u_size: new s.bg(h, e.u_size),
										u_camera_to_center_distance: new s.bg(
											h,
											e.u_camera_to_center_distance
										),
										u_pitch: new s.bg(h, e.u_pitch),
										u_rotate_symbol: new s.bP(h, e.u_rotate_symbol),
										u_aspect_ratio: new s.bg(h, e.u_aspect_ratio),
										u_fade_change: new s.bg(h, e.u_fade_change),
										u_label_plane_matrix: new s.bR(h, e.u_label_plane_matrix),
										u_coord_matrix: new s.bR(h, e.u_coord_matrix),
										u_is_text: new s.bP(h, e.u_is_text),
										u_pitch_with_map: new s.bP(h, e.u_pitch_with_map),
										u_is_along_line: new s.bP(h, e.u_is_along_line),
										u_is_variable_anchor: new s.bP(h, e.u_is_variable_anchor),
										u_texsize: new s.bU(h, e.u_texsize),
										u_texsize_icon: new s.bU(h, e.u_texsize_icon),
										u_texture: new s.bP(h, e.u_texture),
										u_texture_icon: new s.bP(h, e.u_texture_icon),
										u_gamma_scale: new s.bg(h, e.u_gamma_scale),
										u_device_pixel_ratio: new s.bg(h, e.u_device_pixel_ratio),
										u_is_halo: new s.bP(h, e.u_is_halo),
										u_translation: new s.bU(h, e.u_translation),
										u_pitched_scale: new s.bg(h, e.u_pitched_scale),
									}),
									background: (h, e) => ({
										u_opacity: new s.bg(h, e.u_opacity),
										u_color: new s.bQ(h, e.u_color),
									}),
									backgroundPattern: (h, e) => ({
										u_opacity: new s.bg(h, e.u_opacity),
										u_image: new s.bP(h, e.u_image),
										u_pattern_tl_a: new s.bU(h, e.u_pattern_tl_a),
										u_pattern_br_a: new s.bU(h, e.u_pattern_br_a),
										u_pattern_tl_b: new s.bU(h, e.u_pattern_tl_b),
										u_pattern_br_b: new s.bU(h, e.u_pattern_br_b),
										u_texsize: new s.bU(h, e.u_texsize),
										u_mix: new s.bg(h, e.u_mix),
										u_pattern_size_a: new s.bU(h, e.u_pattern_size_a),
										u_pattern_size_b: new s.bU(h, e.u_pattern_size_b),
										u_scale_a: new s.bg(h, e.u_scale_a),
										u_scale_b: new s.bg(h, e.u_scale_b),
										u_pixel_coord_upper: new s.bU(h, e.u_pixel_coord_upper),
										u_pixel_coord_lower: new s.bU(h, e.u_pixel_coord_lower),
										u_tile_units_to_pixels: new s.bg(
											h,
											e.u_tile_units_to_pixels
										),
									}),
									terrain: (h, e) => ({
										u_texture: new s.bP(h, e.u_texture),
										u_ele_delta: new s.bg(h, e.u_ele_delta),
										u_fog_matrix: new s.bR(h, e.u_fog_matrix),
										u_fog_color: new s.bQ(h, e.u_fog_color),
										u_fog_ground_blend: new s.bg(h, e.u_fog_ground_blend),
										u_fog_ground_blend_opacity: new s.bg(
											h,
											e.u_fog_ground_blend_opacity
										),
										u_horizon_color: new s.bQ(h, e.u_horizon_color),
										u_horizon_fog_blend: new s.bg(h, e.u_horizon_fog_blend),
										u_is_globe_mode: new s.bg(h, e.u_is_globe_mode),
									}),
									terrainDepth: (h, e) => ({
										u_ele_delta: new s.bg(h, e.u_ele_delta),
									}),
									terrainCoords: (h, e) => ({
										u_texture: new s.bP(h, e.u_texture),
										u_terrain_coords_id: new s.bg(h, e.u_terrain_coords_id),
										u_ele_delta: new s.bg(h, e.u_ele_delta),
									}),
									projectionErrorMeasurement: (h, e) => ({
										u_input: new s.bg(h, e.u_input),
										u_output_expected: new s.bg(h, e.u_output_expected),
									}),
									atmosphere: (h, e) => ({
										u_sun_pos: new s.bT(h, e.u_sun_pos),
										u_atmosphere_blend: new s.bg(h, e.u_atmosphere_blend),
										u_globe_position: new s.bT(h, e.u_globe_position),
										u_globe_radius: new s.bg(h, e.u_globe_radius),
										u_inv_proj_matrix: new s.bR(h, e.u_inv_proj_matrix),
									}),
									sky: (h, e) => ({
										u_sky_color: new s.bQ(h, e.u_sky_color),
										u_horizon_color: new s.bQ(h, e.u_horizon_color),
										u_horizon: new s.bU(h, e.u_horizon),
										u_horizon_normal: new s.bU(h, e.u_horizon_normal),
										u_sky_horizon_blend: new s.bg(h, e.u_sky_horizon_blend),
										u_sky_blend: new s.bg(h, e.u_sky_blend),
									}),
								};
							class Hh {
								constructor(e, i, l) {
									this.context = e;
									const u = e.gl;
									(this.buffer = u.createBuffer()),
										(this.dynamicDraw = !!l),
										this.context.unbindVAO(),
										e.bindElementBuffer.set(this.buffer),
										u.bufferData(
											u.ELEMENT_ARRAY_BUFFER,
											i.arrayBuffer,
											this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW
										),
										this.dynamicDraw || delete i.arrayBuffer;
								}
								bind() {
									this.context.bindElementBuffer.set(this.buffer);
								}
								updateData(e) {
									const i = this.context.gl;
									if (!this.dynamicDraw)
										throw new Error(
											"Attempted to update data while not in dynamic mode."
										);
									this.context.unbindVAO(),
										this.bind(),
										i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
								}
								destroy() {
									this.buffer &&
										(this.context.gl.deleteBuffer(this.buffer),
										delete this.buffer);
								}
							}
							const Sl = {
								Int8: "BYTE",
								Uint8: "UNSIGNED_BYTE",
								Int16: "SHORT",
								Uint16: "UNSIGNED_SHORT",
								Int32: "INT",
								Uint32: "UNSIGNED_INT",
								Float32: "FLOAT",
							};
							class eo {
								constructor(e, i, l, u) {
									(this.length = i.length),
										(this.attributes = l),
										(this.itemSize = i.bytesPerElement),
										(this.dynamicDraw = u),
										(this.context = e);
									const d = e.gl;
									(this.buffer = d.createBuffer()),
										e.bindVertexBuffer.set(this.buffer),
										d.bufferData(
											d.ARRAY_BUFFER,
											i.arrayBuffer,
											this.dynamicDraw ? d.DYNAMIC_DRAW : d.STATIC_DRAW
										),
										this.dynamicDraw || delete i.arrayBuffer;
								}
								bind() {
									this.context.bindVertexBuffer.set(this.buffer);
								}
								updateData(e) {
									if (e.length !== this.length)
										throw new Error(
											`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`
										);
									const i = this.context.gl;
									this.bind(),
										i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer);
								}
								enableAttributes(e, i) {
									for (let l = 0; l < this.attributes.length; l++) {
										const u = i.attributes[this.attributes[l].name];
										u !== void 0 && e.enableVertexAttribArray(u);
									}
								}
								setVertexAttribPointers(e, i, l) {
									for (let u = 0; u < this.attributes.length; u++) {
										const d = this.attributes[u],
											g = i.attributes[d.name];
										g !== void 0 &&
											e.vertexAttribPointer(
												g,
												d.components,
												e[Sl[d.type]],
												!1,
												this.itemSize,
												d.offset + this.itemSize * (l || 0)
											);
									}
								}
								destroy() {
									this.buffer &&
										(this.context.gl.deleteBuffer(this.buffer),
										delete this.buffer);
								}
							}
							class Pn {
								constructor(e) {
									(this.gl = e.gl),
										(this.default = this.getDefault()),
										(this.current = this.default),
										(this.dirty = !1);
								}
								get() {
									return this.current;
								}
								set(e) {}
								getDefault() {
									return this.default;
								}
								setDefault() {
									this.set(this.default);
								}
							}
							class Vc extends Pn {
								getDefault() {
									return s.bf.transparent;
								}
								set(e) {
									const i = this.current;
									(e.r !== i.r ||
										e.g !== i.g ||
										e.b !== i.b ||
										e.a !== i.a ||
										this.dirty) &&
										(this.gl.clearColor(e.r, e.g, e.b, e.a),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class qc extends Pn {
								getDefault() {
									return 1;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.clearDepth(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Wh extends Pn {
								getDefault() {
									return 0;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.clearStencil(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Zc extends Pn {
								getDefault() {
									return [!0, !0, !0, !0];
								}
								set(e) {
									const i = this.current;
									(e[0] !== i[0] ||
										e[1] !== i[1] ||
										e[2] !== i[2] ||
										e[3] !== i[3] ||
										this.dirty) &&
										(this.gl.colorMask(e[0], e[1], e[2], e[3]),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class zo extends Pn {
								getDefault() {
									return !0;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.depthMask(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Uc extends Pn {
								getDefault() {
									return 255;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.stencilMask(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Ep extends Pn {
								getDefault() {
									return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
								}
								set(e) {
									const i = this.current;
									(e.func !== i.func ||
										e.ref !== i.ref ||
										e.mask !== i.mask ||
										this.dirty) &&
										(this.gl.stencilFunc(e.func, e.ref, e.mask),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class zp extends Pn {
								getDefault() {
									const e = this.gl;
									return [e.KEEP, e.KEEP, e.KEEP];
								}
								set(e) {
									const i = this.current;
									(e[0] !== i[0] ||
										e[1] !== i[1] ||
										e[2] !== i[2] ||
										this.dirty) &&
										(this.gl.stencilOp(e[0], e[1], e[2]),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Lp extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Dp extends Pn {
								getDefault() {
									return [0, 1];
								}
								set(e) {
									const i = this.current;
									(e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
										(this.gl.depthRange(e[0], e[1]),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Xh extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Rp extends Pn {
								getDefault() {
									return this.gl.LESS;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.depthFunc(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Yh extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									e ? i.enable(i.BLEND) : i.disable(i.BLEND),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Pl extends Pn {
								getDefault() {
									const e = this.gl;
									return [e.ONE, e.ZERO];
								}
								set(e) {
									const i = this.current;
									(e[0] !== i[0] || e[1] !== i[1] || this.dirty) &&
										(this.gl.blendFunc(e[0], e[1]),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Il extends Pn {
								getDefault() {
									return s.bf.transparent;
								}
								set(e) {
									const i = this.current;
									(e.r !== i.r ||
										e.g !== i.g ||
										e.b !== i.b ||
										e.a !== i.a ||
										this.dirty) &&
										(this.gl.blendColor(e.r, e.g, e.b, e.a),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Ml extends Pn {
								getDefault() {
									return this.gl.FUNC_ADD;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.blendEquation(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class $c extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Lo extends Pn {
								getDefault() {
									return this.gl.BACK;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.cullFace(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Ns extends Pn {
								getDefault() {
									return this.gl.CCW;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.frontFace(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class ts extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.useProgram(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class va extends Pn {
								getDefault() {
									return this.gl.TEXTURE0;
								}
								set(e) {
									(e !== this.current || this.dirty) &&
										(this.gl.activeTexture(e),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Kh extends Pn {
								getDefault() {
									const e = this.gl;
									return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
								}
								set(e) {
									const i = this.current;
									(e[0] !== i[0] ||
										e[1] !== i[1] ||
										e[2] !== i[2] ||
										e[3] !== i[3] ||
										this.dirty) &&
										(this.gl.viewport(e[0], e[1], e[2], e[3]),
										(this.current = e),
										(this.dirty = !1));
								}
							}
							class Jh extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.bindFramebuffer(i.FRAMEBUFFER, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Gc extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.bindRenderbuffer(i.RENDERBUFFER, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Do extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.bindTexture(i.TEXTURE_2D, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class kl extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.bindBuffer(i.ARRAY_BUFFER, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Al extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									const i = this.gl;
									i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class js extends Pn {
								getDefault() {
									return null;
								}
								set(e) {
									var i;
									if (e === this.current && !this.dirty) return;
									const l = this.gl;
									ga(l)
										? l.bindVertexArray(e)
										: (i = l.getExtension("OES_vertex_array_object")) ===
												null ||
										  i === void 0 ||
										  i.bindVertexArrayOES(e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class El extends Pn {
								getDefault() {
									return 4;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.pixelStorei(i.UNPACK_ALIGNMENT, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Qh extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class rs extends Pn {
								getDefault() {
									return !1;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									const i = this.gl;
									i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class fo extends Pn {
								constructor(e, i) {
									super(e), (this.context = e), (this.parent = i);
								}
								getDefault() {
									return null;
								}
							}
							class ed extends fo {
								setDirty() {
									this.dirty = !0;
								}
								set(e) {
									if (e === this.current && !this.dirty) return;
									this.context.bindFramebuffer.set(this.parent);
									const i = this.gl;
									i.framebufferTexture2D(
										i.FRAMEBUFFER,
										i.COLOR_ATTACHMENT0,
										i.TEXTURE_2D,
										e,
										0
									),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class Hc extends fo {
								set(e) {
									if (e === this.current && !this.dirty) return;
									this.context.bindFramebuffer.set(this.parent);
									const i = this.gl;
									i.framebufferRenderbuffer(
										i.FRAMEBUFFER,
										i.DEPTH_ATTACHMENT,
										i.RENDERBUFFER,
										e
									),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							class sn extends fo {
								set(e) {
									if (e === this.current && !this.dirty) return;
									this.context.bindFramebuffer.set(this.parent);
									const i = this.gl;
									i.framebufferRenderbuffer(
										i.FRAMEBUFFER,
										i.DEPTH_STENCIL_ATTACHMENT,
										i.RENDERBUFFER,
										e
									),
										(this.current = e),
										(this.dirty = !1);
								}
							}
							const Vs = "Framebuffer is not complete";
							class Bp {
								constructor(e, i, l, u, d) {
									(this.context = e), (this.width = i), (this.height = l);
									const g = e.gl,
										w = (this.framebuffer = g.createFramebuffer());
									if (((this.colorAttachment = new ed(e, w)), u))
										this.depthAttachment = d ? new sn(e, w) : new Hc(e, w);
									else if (d)
										throw new Error("Stencil cannot be set without depth");
									if (
										g.checkFramebufferStatus(g.FRAMEBUFFER) !==
										g.FRAMEBUFFER_COMPLETE
									)
										throw new Error(Vs);
								}
								destroy() {
									const e = this.context.gl,
										i = this.colorAttachment.get();
									if ((i && e.deleteTexture(i), this.depthAttachment)) {
										const l = this.depthAttachment.get();
										l && e.deleteRenderbuffer(l);
									}
									e.deleteFramebuffer(this.framebuffer);
								}
							}
							class td {
								constructor(e) {
									var i, l;
									if (
										((this.gl = e),
										(this.clearColor = new Vc(this)),
										(this.clearDepth = new qc(this)),
										(this.clearStencil = new Wh(this)),
										(this.colorMask = new Zc(this)),
										(this.depthMask = new zo(this)),
										(this.stencilMask = new Uc(this)),
										(this.stencilFunc = new Ep(this)),
										(this.stencilOp = new zp(this)),
										(this.stencilTest = new Lp(this)),
										(this.depthRange = new Dp(this)),
										(this.depthTest = new Xh(this)),
										(this.depthFunc = new Rp(this)),
										(this.blend = new Yh(this)),
										(this.blendFunc = new Pl(this)),
										(this.blendColor = new Il(this)),
										(this.blendEquation = new Ml(this)),
										(this.cullFace = new $c(this)),
										(this.cullFaceSide = new Lo(this)),
										(this.frontFace = new Ns(this)),
										(this.program = new ts(this)),
										(this.activeTexture = new va(this)),
										(this.viewport = new Kh(this)),
										(this.bindFramebuffer = new Jh(this)),
										(this.bindRenderbuffer = new Gc(this)),
										(this.bindTexture = new Do(this)),
										(this.bindVertexBuffer = new kl(this)),
										(this.bindElementBuffer = new Al(this)),
										(this.bindVertexArray = new js(this)),
										(this.pixelStoreUnpack = new El(this)),
										(this.pixelStoreUnpackPremultiplyAlpha = new Qh(this)),
										(this.pixelStoreUnpackFlipY = new rs(this)),
										(this.extTextureFilterAnisotropic =
											e.getExtension("EXT_texture_filter_anisotropic") ||
											e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
											e.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
										this.extTextureFilterAnisotropic &&
											(this.extTextureFilterAnisotropicMax = e.getParameter(
												this.extTextureFilterAnisotropic
													.MAX_TEXTURE_MAX_ANISOTROPY_EXT
											)),
										(this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)),
										ga(e))
									) {
										this.HALF_FLOAT = e.HALF_FLOAT;
										const u = e.getExtension("EXT_color_buffer_half_float");
										(this.RGBA16F =
											(i = e.RGBA16F) !== null && i !== void 0
												? i
												: u == null
												? void 0
												: u.RGBA16F_EXT),
											(this.RGB16F =
												(l = e.RGB16F) !== null && l !== void 0
													? l
													: u == null
													? void 0
													: u.RGB16F_EXT),
											e.getExtension("EXT_color_buffer_float");
									} else {
										e.getExtension("EXT_color_buffer_half_float"),
											e.getExtension("OES_texture_half_float_linear");
										const u = e.getExtension("OES_texture_half_float");
										this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES;
									}
								}
								setDefault() {
									this.unbindVAO(),
										this.clearColor.setDefault(),
										this.clearDepth.setDefault(),
										this.clearStencil.setDefault(),
										this.colorMask.setDefault(),
										this.depthMask.setDefault(),
										this.stencilMask.setDefault(),
										this.stencilFunc.setDefault(),
										this.stencilOp.setDefault(),
										this.stencilTest.setDefault(),
										this.depthRange.setDefault(),
										this.depthTest.setDefault(),
										this.depthFunc.setDefault(),
										this.blend.setDefault(),
										this.blendFunc.setDefault(),
										this.blendColor.setDefault(),
										this.blendEquation.setDefault(),
										this.cullFace.setDefault(),
										this.cullFaceSide.setDefault(),
										this.frontFace.setDefault(),
										this.program.setDefault(),
										this.activeTexture.setDefault(),
										this.bindFramebuffer.setDefault(),
										this.pixelStoreUnpack.setDefault(),
										this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
										this.pixelStoreUnpackFlipY.setDefault();
								}
								setDirty() {
									(this.clearColor.dirty = !0),
										(this.clearDepth.dirty = !0),
										(this.clearStencil.dirty = !0),
										(this.colorMask.dirty = !0),
										(this.depthMask.dirty = !0),
										(this.stencilMask.dirty = !0),
										(this.stencilFunc.dirty = !0),
										(this.stencilOp.dirty = !0),
										(this.stencilTest.dirty = !0),
										(this.depthRange.dirty = !0),
										(this.depthTest.dirty = !0),
										(this.depthFunc.dirty = !0),
										(this.blend.dirty = !0),
										(this.blendFunc.dirty = !0),
										(this.blendColor.dirty = !0),
										(this.blendEquation.dirty = !0),
										(this.cullFace.dirty = !0),
										(this.cullFaceSide.dirty = !0),
										(this.frontFace.dirty = !0),
										(this.program.dirty = !0),
										(this.activeTexture.dirty = !0),
										(this.viewport.dirty = !0),
										(this.bindFramebuffer.dirty = !0),
										(this.bindRenderbuffer.dirty = !0),
										(this.bindTexture.dirty = !0),
										(this.bindVertexBuffer.dirty = !0),
										(this.bindElementBuffer.dirty = !0),
										(this.bindVertexArray.dirty = !0),
										(this.pixelStoreUnpack.dirty = !0),
										(this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
										(this.pixelStoreUnpackFlipY.dirty = !0);
								}
								createIndexBuffer(e, i) {
									return new Hh(this, e, i);
								}
								createVertexBuffer(e, i, l) {
									return new eo(this, e, i, l);
								}
								createRenderbuffer(e, i, l) {
									const u = this.gl,
										d = u.createRenderbuffer();
									return (
										this.bindRenderbuffer.set(d),
										u.renderbufferStorage(u.RENDERBUFFER, e, i, l),
										this.bindRenderbuffer.set(null),
										d
									);
								}
								createFramebuffer(e, i, l, u) {
									return new Bp(this, e, i, l, u);
								}
								clear({ color: e, depth: i, stencil: l }) {
									const u = this.gl;
									let d = 0;
									e &&
										((d |= u.COLOR_BUFFER_BIT),
										this.clearColor.set(e),
										this.colorMask.set([!0, !0, !0, !0])),
										i !== void 0 &&
											((d |= u.DEPTH_BUFFER_BIT),
											this.depthRange.set([0, 1]),
											this.clearDepth.set(i),
											this.depthMask.set(!0)),
										l !== void 0 &&
											((d |= u.STENCIL_BUFFER_BIT),
											this.clearStencil.set(l),
											this.stencilMask.set(255)),
										u.clear(d);
								}
								setCullFace(e) {
									e.enable === !1
										? this.cullFace.set(!1)
										: (this.cullFace.set(!0),
										  this.cullFaceSide.set(e.mode),
										  this.frontFace.set(e.frontFace));
								}
								setDepthMode(e) {
									e.func !== this.gl.ALWAYS || e.mask
										? (this.depthTest.set(!0),
										  this.depthFunc.set(e.func),
										  this.depthMask.set(e.mask),
										  this.depthRange.set(e.range))
										: this.depthTest.set(!1);
								}
								setStencilMode(e) {
									e.test.func !== this.gl.ALWAYS || e.mask
										? (this.stencilTest.set(!0),
										  this.stencilMask.set(e.mask),
										  this.stencilOp.set([e.fail, e.depthFail, e.pass]),
										  this.stencilFunc.set({
												func: e.test.func,
												ref: e.ref,
												mask: e.test.mask,
										  }))
										: this.stencilTest.set(!1);
								}
								setColorMode(e) {
									s.bH(e.blendFunction, zn.Replace)
										? this.blend.set(!1)
										: (this.blend.set(!0),
										  this.blendFunc.set(e.blendFunction),
										  this.blendColor.set(e.blendColor)),
										this.colorMask.set(e.mask);
								}
								createVertexArray() {
									var e;
									return ga(this.gl)
										? this.gl.createVertexArray()
										: (e = this.gl.getExtension("OES_vertex_array_object")) ===
												null || e === void 0
										? void 0
										: e.createVertexArrayOES();
								}
								deleteVertexArray(e) {
									var i;
									return ga(this.gl)
										? this.gl.deleteVertexArray(e)
										: (i = this.gl.getExtension("OES_vertex_array_object")) ===
												null || i === void 0
										? void 0
										: i.deleteVertexArrayOES(e);
								}
								unbindVAO() {
									this.bindVertexArray.set(null);
								}
							}
							let mo;
							function rd(h, e, i, l, u) {
								const d = h.context,
									g = h.transform,
									w = d.gl,
									C = h.useProgram("collisionBox"),
									P = [];
								let E = 0,
									R = 0;
								for (let ae = 0; ae < l.length; ae++) {
									const ce = l[ae],
										ve = e.getTile(ce).getBucket(i);
									if (!ve) continue;
									const me = u ? ve.textCollisionBox : ve.iconCollisionBox,
										be = ve.collisionCircleArray;
									be.length > 0 &&
										(P.push({ circleArray: be, circleOffset: R, coord: ce }),
										(E += be.length / 4),
										(R = E)),
										me &&
											C.draw(
												d,
												w.LINES,
												Gr.disabled,
												un.disabled,
												h.colorModeForRenderPass(),
												Rr.disabled,
												Tl(h.transform),
												h.style.map.terrain &&
													h.style.map.terrain.getTerrainData(ce),
												g.getProjectionData({
													overscaledTileID: ce,
													applyGlobeMatrix: !0,
													applyTerrainMatrix: !0,
												}),
												i.id,
												me.layoutVertexBuffer,
												me.indexBuffer,
												me.segments,
												null,
												h.transform.zoom,
												null,
												null,
												me.collisionVertexBuffer
											);
								}
								if (!u || !P.length) return;
								const D = h.useProgram("collisionCircle"),
									N = new s.b$();
								N.resize(4 * E), N._trim();
								let G = 0;
								for (const ae of P)
									for (let ce = 0; ce < ae.circleArray.length / 4; ce++) {
										const ve = 4 * ce,
											me = ae.circleArray[ve + 0],
											be = ae.circleArray[ve + 1],
											Pe = ae.circleArray[ve + 2],
											_e = ae.circleArray[ve + 3];
										N.emplace(G++, me, be, Pe, _e, 0),
											N.emplace(G++, me, be, Pe, _e, 1),
											N.emplace(G++, me, be, Pe, _e, 2),
											N.emplace(G++, me, be, Pe, _e, 3);
									}
								(!mo || mo.length < 2 * E) &&
									(mo = (function (ae) {
										const ce = 2 * ae,
											ve = new s.c1();
										ve.resize(ce), ve._trim();
										for (let me = 0; me < ce; me++) {
											const be = 6 * me;
											(ve.uint16[be + 0] = 4 * me + 0),
												(ve.uint16[be + 1] = 4 * me + 1),
												(ve.uint16[be + 2] = 4 * me + 2),
												(ve.uint16[be + 3] = 4 * me + 2),
												(ve.uint16[be + 4] = 4 * me + 3),
												(ve.uint16[be + 5] = 4 * me + 0);
										}
										return ve;
									})(E));
								const te = d.createIndexBuffer(mo, !0),
									Q = d.createVertexBuffer(N, s.c0.members, !0);
								for (const ae of P) {
									const ce = Ip(h.transform);
									D.draw(
										d,
										w.TRIANGLES,
										Gr.disabled,
										un.disabled,
										h.colorModeForRenderPass(),
										Rr.disabled,
										ce,
										h.style.map.terrain &&
											h.style.map.terrain.getTerrainData(ae.coord),
										null,
										i.id,
										Q,
										te,
										s.aM.simpleSegment(
											0,
											2 * ae.circleOffset,
											ae.circleArray.length,
											ae.circleArray.length / 2
										),
										null,
										h.transform.zoom,
										null,
										null,
										null
									);
								}
								Q.destroy(), te.destroy();
							}
							const Fp = s.ag(new Float32Array(16));
							function nd(h, e, i, l, u, d) {
								const { horizontalAlign: g, verticalAlign: w } = s.aH(h);
								return new s.P(
									((-(g - 0.5) * e) / u + l[0]) * d,
									((-(w - 0.5) * i) / u + l[1]) * d
								);
							}
							function Op(h, e, i, l, u, d) {
								const g = e.tileAnchorPoint.add(
									new s.P(e.translation[0], e.translation[1])
								);
								if (e.pitchWithMap) {
									let w = l.mult(d);
									i || (w = w.rotate(-u));
									const C = g.add(w);
									return dr(C.x, C.y, e.pitchedLabelPlaneMatrix, e.getElevation)
										.point;
								}
								if (i) {
									const w = Jt(
											e.tileAnchorPoint.x + 1,
											e.tileAnchorPoint.y,
											e
										).point.sub(h),
										C = Math.atan(w.y / w.x) + (w.x < 0 ? Math.PI : 0);
									return h.add(l.rotate(C));
								}
								return h.add(l);
							}
							function Wc(h, e, i, l, u, d, g, w, C, P, E, R) {
								const D = h.text.placedSymbolArray,
									N = h.text.dynamicLayoutVertexArray,
									G = h.icon.dynamicLayoutVertexArray,
									te = {};
								N.clear();
								for (let Q = 0; Q < D.length; Q++) {
									const ae = D.get(Q),
										ce =
											ae.hidden ||
											!ae.crossTileID ||
											(h.allowVerticalPlacement && !ae.placedOrientation)
												? null
												: l[ae.crossTileID];
									if (ce) {
										const ve = new s.P(ae.anchorX, ae.anchorY),
											me = {
												getElevation: R,
												width: u.width,
												height: u.height,
												pitchedLabelPlaneMatrix: d,
												pitchWithMap: i,
												transform: u,
												tileAnchorPoint: ve,
												translation: P,
												unwrappedTileID: E,
											},
											be = i ? Er(ve.x, ve.y, me) : Jt(ve.x, ve.y, me),
											Pe = ht(
												u.cameraToCenterDistance,
												be.signedDistanceFromCamera
											);
										let _e = (s.ap(h.textSizeData, w, ae) * Pe) / s.aB;
										i && (_e *= h.tilePixelRatio / g);
										const {
												width: Be,
												height: rt,
												anchor: Ge,
												textOffset: Xe,
												textBoxScale: tt,
											} = ce,
											jt = nd(Ge, Be, rt, Xe, tt, _e),
											Zt = u.getPitchedTextCorrection(
												ve.x + P[0],
												ve.y + P[1],
												E
											),
											Tt = Op(be.point, me, e, jt, -u.bearingInRadians, Zt),
											vr =
												h.allowVerticalPlacement &&
												ae.placedOrientation === s.ao.vertical
													? Math.PI / 2
													: 0;
										for (let Jr = 0; Jr < ae.numGlyphs; Jr++) s.av(N, Tt, vr);
										C &&
											ae.associatedIconIndex >= 0 &&
											(te[ae.associatedIconIndex] = {
												shiftedAnchor: Tt,
												angle: vr,
											});
									} else ln(ae.numGlyphs, N);
								}
								if (C) {
									G.clear();
									const Q = h.icon.placedSymbolArray;
									for (let ae = 0; ae < Q.length; ae++) {
										const ce = Q.get(ae);
										if (ce.hidden) ln(ce.numGlyphs, G);
										else {
											const ve = te[ae];
											if (ve)
												for (let me = 0; me < ce.numGlyphs; me++)
													s.av(G, ve.shiftedAnchor, ve.angle);
											else ln(ce.numGlyphs, G);
										}
									}
									h.icon.dynamicLayoutVertexBuffer.updateData(G);
								}
								h.text.dynamicLayoutVertexBuffer.updateData(N);
							}
							function zl(h, e, i) {
								return i.iconsInText && e
									? "symbolTextAndIcon"
									: h
									? "symbolSDF"
									: "symbolIcon";
							}
							function qs(h, e, i, l, u, d, g, w, C, P, E, R, D) {
								const N = h.context,
									G = N.gl,
									te = h.transform,
									Q = w === "map",
									ae = C === "map",
									ce =
										w !== "viewport" &&
										i.layout.get("symbol-placement") !== "point",
									ve = Q && !ae && !ce,
									me = !i.layout.get("symbol-sort-key").isConstant();
								let be = !1;
								const Pe = h.getDepthModeForSublayer(0, Gr.ReadOnly),
									_e =
										i._unevaluatedLayout.hasValue("text-variable-anchor") ||
										i._unevaluatedLayout.hasValue(
											"text-variable-anchor-offset"
										),
									Be = [],
									rt = te.getCircleRadiusCorrection();
								for (const Ge of l) {
									const Xe = e.getTile(Ge),
										tt = Xe.getBucket(i);
									if (!tt) continue;
									const jt = u ? tt.text : tt.icon;
									if (
										!jt ||
										!jt.segments.get().length ||
										!jt.hasVisibleVertices
									)
										continue;
									const Zt = jt.programConfigurations.get(i.id),
										Tt = u || tt.sdfIcons,
										vr = u ? tt.textSizeData : tt.iconSizeData,
										Jr = ae || te.pitch !== 0,
										An = h.useProgram(zl(Tt, u, tt), Zt),
										Rn = s.an(vr, te.zoom),
										Ln =
											h.style.map.terrain &&
											h.style.map.terrain.getTerrainData(Ge);
									let Wn,
										Jn,
										Kr,
										Bn,
										si = [0, 0],
										mi = null;
									if (u)
										(Jn = Xe.glyphAtlasTexture),
											(Kr = G.LINEAR),
											(Wn = Xe.glyphAtlasTexture.size),
											tt.iconsInText &&
												((si = Xe.imageAtlasTexture.size),
												(mi = Xe.imageAtlasTexture),
												(Bn =
													Jr ||
													h.options.rotating ||
													h.options.zooming ||
													vr.kind === "composite" ||
													vr.kind === "camera"
														? G.LINEAR
														: G.NEAREST));
									else {
										const li =
											i.layout.get("icon-size").constantOr(0) !== 1 ||
											tt.iconsNeedLinear;
										(Jn = Xe.imageAtlasTexture),
											(Kr =
												Tt ||
												h.options.rotating ||
												h.options.zooming ||
												li ||
												Jr
													? G.LINEAR
													: G.NEAREST),
											(Wn = Xe.imageAtlasTexture.size);
									}
									const Ci = s.aC(Xe, 1, h.transform.zoom),
										$i = _n(Q, h.transform, Ci),
										za = s.L();
									s.aq(za, $i);
									const go = Vt(ae, Q, h.transform, Ci),
										vo = s.aD(te, Xe, d, g),
										fs = te.getProjectionData({
											overscaledTileID: Ge,
											applyGlobeMatrix: !D,
											applyTerrainMatrix: !0,
										}),
										ms = _e && tt.hasTextData(),
										Vo =
											i.layout.get("icon-text-fit") !== "none" &&
											ms &&
											tt.hasIconData();
									if (ce) {
										const li = h.style.map.terrain
												? (ba, ci) =>
														h.style.map.terrain.getElevation(Ge, ba, ci)
												: null,
											_i = i.layout.get("text-rotation-alignment") === "map";
										Yr(
											tt,
											h,
											u,
											$i,
											za,
											ae,
											P,
											_i,
											Ge.toUnwrapped(),
											te.width,
											te.height,
											vo,
											li
										);
									}
									const qo = (u && _e) || Vo,
										ta =
											ce || qo
												? Fp
												: ae
												? $i
												: h.transform.clipSpaceToPixelsMatrix,
										La =
											Tt &&
											i.paint
												.get(u ? "text-halo-width" : "icon-halo-width")
												.constantOr(1) !== 0;
									let Gi;
									Gi = Tt
										? tt.iconsInText
											? Ap(
													vr.kind,
													Rn,
													ve,
													ae,
													ce,
													qo,
													h,
													ta,
													go,
													vo,
													Wn,
													si,
													rt
											  )
											: Uh(
													vr.kind,
													Rn,
													ve,
													ae,
													ce,
													qo,
													h,
													ta,
													go,
													vo,
													u,
													Wn,
													0,
													rt
											  )
										: Os(vr.kind, Rn, ve, ae, ce, qo, h, ta, go, vo, u, Wn, rt);
									const yo = {
										program: An,
										buffers: jt,
										uniformValues: Gi,
										projectionData: fs,
										atlasTexture: Jn,
										atlasTextureIcon: mi,
										atlasInterpolation: Kr,
										atlasInterpolationIcon: Bn,
										isSDF: Tt,
										hasHalo: La,
									};
									if (me && tt.canOverlap) {
										be = !0;
										const li = jt.segments.get();
										for (const _i of li)
											Be.push({
												segments: new s.aM([_i]),
												sortKey: _i.sortKey,
												state: yo,
												terrainData: Ln,
											});
									} else
										Be.push({
											segments: jt.segments,
											sortKey: 0,
											state: yo,
											terrainData: Ln,
										});
								}
								be && Be.sort((Ge, Xe) => Ge.sortKey - Xe.sortKey);
								for (const Ge of Be) {
									const Xe = Ge.state;
									if (
										(N.activeTexture.set(G.TEXTURE0),
										Xe.atlasTexture.bind(
											Xe.atlasInterpolation,
											G.CLAMP_TO_EDGE
										),
										Xe.atlasTextureIcon &&
											(N.activeTexture.set(G.TEXTURE1),
											Xe.atlasTextureIcon &&
												Xe.atlasTextureIcon.bind(
													Xe.atlasInterpolationIcon,
													G.CLAMP_TO_EDGE
												)),
										Xe.isSDF)
									) {
										const tt = Xe.uniformValues;
										Xe.hasHalo &&
											((tt.u_is_halo = 1),
											Zs(
												Xe.buffers,
												Ge.segments,
												i,
												h,
												Xe.program,
												Pe,
												E,
												R,
												tt,
												Xe.projectionData,
												Ge.terrainData
											)),
											(tt.u_is_halo = 0);
									}
									Zs(
										Xe.buffers,
										Ge.segments,
										i,
										h,
										Xe.program,
										Pe,
										E,
										R,
										Xe.uniformValues,
										Xe.projectionData,
										Ge.terrainData
									);
								}
							}
							function Zs(h, e, i, l, u, d, g, w, C, P, E) {
								const R = l.context;
								u.draw(
									R,
									R.gl.TRIANGLES,
									d,
									g,
									w,
									Rr.backCCW,
									C,
									E,
									P,
									i.id,
									h.layoutVertexBuffer,
									h.indexBuffer,
									e,
									i.paint,
									l.transform.zoom,
									h.programConfigurations.get(i.id),
									h.dynamicLayoutVertexBuffer,
									h.opacityVertexBuffer
								);
							}
							function Xc(h, e, i, l, u) {
								const d = h.context,
									g = d.gl,
									w = un.disabled,
									C = new zn([g.ONE, g.ONE], s.bf.transparent, [
										!0,
										!0,
										!0,
										!0,
									]),
									P = e.getBucket(i);
								if (!P) return;
								const E = l.key;
								let R = i.heatmapFbos.get(E);
								R ||
									((R = Us(d, e.tileSize, e.tileSize)),
									i.heatmapFbos.set(E, R)),
									d.bindFramebuffer.set(R.framebuffer),
									d.viewport.set([0, 0, e.tileSize, e.tileSize]),
									d.clear({ color: s.bf.transparent });
								const D = P.programConfigurations.get(i.id),
									N = h.useProgram("heatmap", D, !u),
									G = h.transform.getProjectionData({
										overscaledTileID: e.tileID,
										applyGlobeMatrix: !0,
										applyTerrainMatrix: !0,
									}),
									te = h.style.map.terrain.getTerrainData(l);
								N.draw(
									d,
									g.TRIANGLES,
									Gr.disabled,
									w,
									C,
									Rr.disabled,
									Nh(e, h.transform.zoom, i.paint.get("heatmap-intensity"), 1),
									te,
									G,
									i.id,
									P.layoutVertexBuffer,
									P.indexBuffer,
									P.segments,
									i.paint,
									h.transform.zoom,
									D
								);
							}
							function id(h, e, i, l, u) {
								const d = h.context,
									g = d.gl,
									w = h.transform;
								d.setColorMode(h.colorModeForRenderPass());
								const C = $s(d, e),
									P = i.key,
									E = e.heatmapFbos.get(P);
								if (!E) return;
								d.activeTexture.set(g.TEXTURE0),
									g.bindTexture(g.TEXTURE_2D, E.colorAttachment.get()),
									d.activeTexture.set(g.TEXTURE1),
									C.bind(g.LINEAR, g.CLAMP_TO_EDGE);
								const R = w.getProjectionData({
									overscaledTileID: i,
									applyTerrainMatrix: u,
									applyGlobeMatrix: !l,
								});
								h
									.useProgram("heatmapTexture")
									.draw(
										d,
										g.TRIANGLES,
										Gr.disabled,
										un.disabled,
										h.colorModeForRenderPass(),
										Rr.disabled,
										Rc(h, e, 0, 1),
										null,
										R,
										e.id,
										h.rasterBoundsBuffer,
										h.quadTriangleIndexBuffer,
										h.rasterBoundsSegments,
										e.paint,
										w.zoom
									),
									E.destroy(),
									e.heatmapFbos.delete(P);
							}
							function Us(h, e, i) {
								var l, u;
								const d = h.gl,
									g = d.createTexture();
								d.bindTexture(d.TEXTURE_2D, g),
									d.texParameteri(
										d.TEXTURE_2D,
										d.TEXTURE_WRAP_S,
										d.CLAMP_TO_EDGE
									),
									d.texParameteri(
										d.TEXTURE_2D,
										d.TEXTURE_WRAP_T,
										d.CLAMP_TO_EDGE
									),
									d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.LINEAR),
									d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.LINEAR);
								const w =
										(l = h.HALF_FLOAT) !== null && l !== void 0
											? l
											: d.UNSIGNED_BYTE,
									C = (u = h.RGBA16F) !== null && u !== void 0 ? u : d.RGBA;
								d.texImage2D(d.TEXTURE_2D, 0, C, e, i, 0, d.RGBA, w, null);
								const P = h.createFramebuffer(e, i, !1, !1);
								return P.colorAttachment.set(g), P;
							}
							function $s(h, e) {
								return (
									e.colorRampTexture ||
										(e.colorRampTexture = new s.T(h, e.colorRamp, h.gl.RGBA)),
									e.colorRampTexture
								);
							}
							function Gs(h, e, i, l, u) {
								if (!i || !l || !l.imageAtlas) return;
								const d = l.imageAtlas.patternPositions;
								let g = d[i.to.toString()],
									w = d[i.from.toString()];
								if ((!g && w && (g = w), !w && g && (w = g), !g || !w)) {
									const C = u.getPaintProperty(e);
									(g = d[C]), (w = d[C]);
								}
								g && w && h.setConstantPatternPositions(g, w);
							}
							function Ll(h, e, i, l, u, d, g, w) {
								const C = h.context.gl,
									P = "fill-pattern",
									E = i.paint.get(P),
									R = E && E.constantOr(1),
									D = i.getCrossfadeParameters();
								let N, G, te, Q, ae;
								const ce = h.transform,
									ve = i.paint.get("fill-translate"),
									me = i.paint.get("fill-translate-anchor");
								g
									? ((G =
											R && !i.getPaintProperty("fill-outline-color")
												? "fillOutlinePattern"
												: "fillOutline"),
									  (N = C.LINES))
									: ((G = R ? "fillPattern" : "fill"), (N = C.TRIANGLES));
								const be = E.constantOr(null);
								for (const Pe of l) {
									const _e = e.getTile(Pe);
									if (R && !_e.patternsLoaded()) continue;
									const Be = _e.getBucket(i);
									if (!Be) continue;
									const rt = Be.programConfigurations.get(i.id),
										Ge = h.useProgram(G, rt),
										Xe =
											h.style.map.terrain &&
											h.style.map.terrain.getTerrainData(Pe);
									R &&
										(h.context.activeTexture.set(C.TEXTURE0),
										_e.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE),
										rt.updatePaintBuffers(D)),
										Gs(rt, P, be, _e, i);
									const tt = ce.getProjectionData({
											overscaledTileID: Pe,
											applyGlobeMatrix: !w,
											applyTerrainMatrix: !0,
										}),
										jt = s.aD(ce, _e, ve, me);
									if (g) {
										(Q = Be.indexBuffer2), (ae = Be.segments2);
										const Tt = [C.drawingBufferWidth, C.drawingBufferHeight];
										te =
											G === "fillOutlinePattern" && R
												? Bs(h, D, _e, Tt, jt)
												: Rs(Tt, jt);
									} else
										(Q = Be.indexBuffer),
											(ae = Be.segments),
											(te = R ? wl(h, D, _e, jt) : { u_fill_translate: jt });
									const Zt = h.stencilModeForClipping(Pe);
									Ge.draw(
										h.context,
										N,
										u,
										Zt,
										d,
										Rr.backCCW,
										te,
										Xe,
										tt,
										i.id,
										Be.layoutVertexBuffer,
										Q,
										ae,
										i.paint,
										h.transform.zoom,
										rt
									);
								}
							}
							function Yc(h, e, i, l, u, d, g, w) {
								const C = h.context,
									P = C.gl,
									E = "fill-extrusion-pattern",
									R = i.paint.get(E),
									D = R.constantOr(1),
									N = i.getCrossfadeParameters(),
									G = i.paint.get("fill-extrusion-opacity"),
									te = R.constantOr(null),
									Q = h.transform;
								for (const ae of l) {
									const ce = e.getTile(ae),
										ve = ce.getBucket(i);
									if (!ve) continue;
									const me =
											h.style.map.terrain &&
											h.style.map.terrain.getTerrainData(ae),
										be = ve.programConfigurations.get(i.id),
										Pe = h.useProgram(
											D ? "fillExtrusionPattern" : "fillExtrusion",
											be
										);
									D &&
										(h.context.activeTexture.set(P.TEXTURE0),
										ce.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE),
										be.updatePaintBuffers(N));
									const _e = Q.getProjectionData({
										overscaledTileID: ae,
										applyGlobeMatrix: !w,
										applyTerrainMatrix: !0,
									});
									Gs(be, E, te, ce, i);
									const Be = s.aD(
											Q,
											ce,
											i.paint.get("fill-extrusion-translate"),
											i.paint.get("fill-extrusion-translate-anchor")
										),
										rt = i.paint.get("fill-extrusion-vertical-gradient"),
										Ge = D ? Sp(h, rt, G, Be, ae, N, ce) : Pa(h, rt, G, Be);
									Pe.draw(
										C,
										C.gl.TRIANGLES,
										u,
										d,
										g,
										Rr.backCCW,
										Ge,
										me,
										_e,
										i.id,
										ve.layoutVertexBuffer,
										ve.indexBuffer,
										ve.segments,
										i.paint,
										h.transform.zoom,
										be,
										h.style.map.terrain && ve.centroidVertexBuffer
									);
								}
							}
							function Ro(h, e, i, l, u, d, g, w, C) {
								var P;
								const E = h.style.projection,
									R = h.context,
									D = h.transform,
									N = R.gl,
									G = [
										`#define NUM_ILLUMINATION_SOURCES ${
											i.paint.get("hillshade-highlight-color").values.length
										}`,
									],
									te = h.useProgram("hillshade", null, !1, G),
									Q = !h.options.moving;
								for (const ae of l) {
									const ce = e.getTile(ae),
										ve = ce.fbo;
									if (!ve) continue;
									const me = E.getMeshFromTileID(
											R,
											ae.canonical,
											w,
											!0,
											"raster"
										),
										be =
											(P = h.style.map.terrain) === null || P === void 0
												? void 0
												: P.getTerrainData(ae);
									R.activeTexture.set(N.TEXTURE0),
										N.bindTexture(N.TEXTURE_2D, ve.colorAttachment.get());
									const Pe = D.getProjectionData({
										overscaledTileID: ae,
										aligned: Q,
										applyGlobeMatrix: !C,
										applyTerrainMatrix: !0,
									});
									te.draw(
										R,
										N.TRIANGLES,
										d,
										u[ae.overscaledZ],
										g,
										Rr.backCCW,
										Mp(h, ce, i),
										be,
										Pe,
										i.id,
										me.vertexBuffer,
										me.indexBuffer,
										me.segments
									);
								}
							}
							function Kc(h, e, i, l, u, d, g, w, C) {
								var P;
								const E = h.style.projection,
									R = h.context,
									D = h.transform,
									N = R.gl,
									G = h.useProgram("colorRelief"),
									te = !h.options.moving;
								let Q = !0,
									ae = 0;
								for (const ce of l) {
									const ve = e.getTile(ce),
										me = ve.dem;
									if (Q) {
										const Ge = N.getParameter(N.MAX_TEXTURE_SIZE),
											{ elevationTexture: Xe, colorTexture: tt } =
												i.getColorRampTextures(R, Ge, me.getUnpackVector());
										R.activeTexture.set(N.TEXTURE1),
											Xe.bind(N.NEAREST, N.CLAMP_TO_EDGE),
											R.activeTexture.set(N.TEXTURE4),
											tt.bind(N.LINEAR, N.CLAMP_TO_EDGE),
											(Q = !1),
											(ae = Xe.size[0]);
									}
									if (!me || !me.data) continue;
									const be = me.stride,
										Pe = me.getPixels();
									if (
										(R.activeTexture.set(N.TEXTURE0),
										R.pixelStoreUnpackPremultiplyAlpha.set(!1),
										(ve.demTexture = ve.demTexture || h.getTileTexture(be)),
										ve.demTexture)
									) {
										const Ge = ve.demTexture;
										Ge.update(Pe, { premultiply: !1 }),
											Ge.bind(N.LINEAR, N.CLAMP_TO_EDGE);
									} else
										(ve.demTexture = new s.T(R, Pe, N.RGBA, {
											premultiply: !1,
										})),
											ve.demTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
									const _e = E.getMeshFromTileID(
											R,
											ce.canonical,
											w,
											!0,
											"raster"
										),
										Be =
											(P = h.style.map.terrain) === null || P === void 0
												? void 0
												: P.getTerrainData(ce),
										rt = D.getProjectionData({
											overscaledTileID: ce,
											aligned: te,
											applyGlobeMatrix: !C,
											applyTerrainMatrix: !0,
										});
									G.draw(
										R,
										N.TRIANGLES,
										d,
										u[ce.overscaledZ],
										g,
										Rr.backCCW,
										Vh(i, ve.dem, ae),
										Be,
										rt,
										i.id,
										_e.vertexBuffer,
										_e.indexBuffer,
										_e.segments
									);
								}
							}
							const Dl = [
								new s.P(0, 0),
								new s.P(s.$, 0),
								new s.P(s.$, s.$),
								new s.P(0, s.$),
							];
							function Bo(h, e, i, l, u, d, g, w, C = !1, P = !1) {
								const E = l[l.length - 1].overscaledZ,
									R = h.context,
									D = R.gl,
									N = h.useProgram("raster"),
									G = h.transform,
									te = h.style.projection,
									Q = h.colorModeForRenderPass(),
									ae = !h.options.moving;
								for (const ce of l) {
									const ve = h.getDepthModeForSublayer(
											ce.overscaledZ - E,
											i.paint.get("raster-opacity") === 1
												? Gr.ReadWrite
												: Gr.ReadOnly,
											D.LESS
										),
										me = e.getTile(ce);
									me.registerFadeDuration(i.paint.get("raster-fade-duration"));
									const be = e.findLoadedParent(ce, 0),
										Pe = e.findLoadedSibling(ce),
										_e = Jc(
											me,
											be || Pe || null,
											e,
											i,
											h.transform,
											h.style.map.terrain
										);
									let Be, rt;
									const Ge =
										i.paint.get("raster-resampling") === "nearest"
											? D.NEAREST
											: D.LINEAR;
									R.activeTexture.set(D.TEXTURE0),
										me.texture.bind(
											Ge,
											D.CLAMP_TO_EDGE,
											D.LINEAR_MIPMAP_NEAREST
										),
										R.activeTexture.set(D.TEXTURE1),
										be
											? (be.texture.bind(
													Ge,
													D.CLAMP_TO_EDGE,
													D.LINEAR_MIPMAP_NEAREST
											  ),
											  (Be = Math.pow(
													2,
													be.tileID.overscaledZ - me.tileID.overscaledZ
											  )),
											  (rt = [
													(me.tileID.canonical.x * Be) % 1,
													(me.tileID.canonical.y * Be) % 1,
											  ]))
											: me.texture.bind(
													Ge,
													D.CLAMP_TO_EDGE,
													D.LINEAR_MIPMAP_NEAREST
											  ),
										me.texture.useMipmap &&
											R.extTextureFilterAnisotropic &&
											h.transform.pitch > 20 &&
											D.texParameterf(
												D.TEXTURE_2D,
												R.extTextureFilterAnisotropic
													.TEXTURE_MAX_ANISOTROPY_EXT,
												R.extTextureFilterAnisotropicMax
											);
									const Xe =
											h.style.map.terrain &&
											h.style.map.terrain.getTerrainData(ce),
										tt = G.getProjectionData({
											overscaledTileID: ce,
											aligned: ae,
											applyGlobeMatrix: !P,
											applyTerrainMatrix: !0,
										}),
										jt = Fs(rt || [0, 0], Be || 1, _e, i, w),
										Zt = te.getMeshFromTileID(R, ce.canonical, d, g, "raster");
									N.draw(
										R,
										D.TRIANGLES,
										ve,
										u ? u[ce.overscaledZ] : un.disabled,
										Q,
										C ? Rr.frontCCW : Rr.backCCW,
										jt,
										Xe,
										tt,
										i.id,
										Zt.vertexBuffer,
										Zt.indexBuffer,
										Zt.segments
									);
								}
							}
							function Jc(h, e, i, l, u, d) {
								const g = l.paint.get("raster-fade-duration");
								if (!d && g > 0) {
									const w = ne.now(),
										C = (w - h.timeAdded) / g,
										P = e ? (w - e.timeAdded) / g : -1,
										E = i.getSource(),
										R = kt(u, { tileSize: E.tileSize, roundZoom: E.roundZoom }),
										D =
											!e ||
											Math.abs(e.tileID.overscaledZ - R) >
												Math.abs(h.tileID.overscaledZ - R),
										N =
											D && h.refreshedUponExpiration
												? 1
												: s.ah(D ? C : 1 - P, 0, 1);
									return (
										h.refreshedUponExpiration &&
											C >= 1 &&
											(h.refreshedUponExpiration = !1),
										e ? { opacity: 1, mix: 1 - N } : { opacity: N, mix: 0 }
									);
								}
								return { opacity: 1, mix: 0 };
							}
							const ad = new s.bf(1, 0, 0, 1),
								od = new s.bf(0, 1, 0, 1),
								Rl = new s.bf(0, 0, 1, 1),
								Qc = new s.bf(1, 0, 1, 1),
								Np = new s.bf(0, 1, 1, 1);
							function eu(h, e, i, l) {
								Ua(h, 0, e + i / 2, h.transform.width, i, l);
							}
							function Kn(h, e, i, l) {
								Ua(h, e - i / 2, 0, i, h.transform.height, l);
							}
							function Ua(h, e, i, l, u, d) {
								const g = h.context,
									w = g.gl;
								w.enable(w.SCISSOR_TEST),
									w.scissor(
										e * h.pixelRatio,
										i * h.pixelRatio,
										l * h.pixelRatio,
										u * h.pixelRatio
									),
									g.clear({ color: d }),
									w.disable(w.SCISSOR_TEST);
							}
							function ya(h, e, i) {
								const l = h.context,
									u = l.gl,
									d = h.useProgram("debug"),
									g = Gr.disabled,
									w = un.disabled,
									C = h.colorModeForRenderPass(),
									P = "$debug",
									E =
										h.style.map.terrain &&
										h.style.map.terrain.getTerrainData(i);
								l.activeTexture.set(u.TEXTURE0);
								const R = e.getTileByID(i.key).latestRawTileData,
									D = Math.floor(((R && R.byteLength) || 0) / 1024),
									N = e.getTile(i).tileSize,
									G =
										(512 / Math.min(N, 512)) *
										(i.overscaledZ / h.transform.zoom) *
										0.5;
								let te = i.canonical.toString();
								i.overscaledZ !== i.canonical.z &&
									(te += ` => ${i.overscaledZ}`),
									(function (ae, ce) {
										ae.initDebugOverlayCanvas();
										const ve = ae.debugOverlayCanvas,
											me = ae.context.gl,
											be = ae.debugOverlayCanvas.getContext("2d");
										be.clearRect(0, 0, ve.width, ve.height),
											(be.shadowColor = "white"),
											(be.shadowBlur = 2),
											(be.lineWidth = 1.5),
											(be.strokeStyle = "white"),
											(be.textBaseline = "top"),
											(be.font = "bold 36px Open Sans, sans-serif"),
											be.fillText(ce, 5, 5),
											be.strokeText(ce, 5, 5),
											ae.debugOverlayTexture.update(ve),
											ae.debugOverlayTexture.bind(me.LINEAR, me.CLAMP_TO_EDGE);
									})(h, `${te} ${D}kB`);
								const Q = h.transform.getProjectionData({
									overscaledTileID: i,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !0,
								});
								d.draw(
									l,
									u.TRIANGLES,
									g,
									w,
									zn.alphaBlended,
									Rr.disabled,
									Ao(s.bf.transparent, G),
									null,
									Q,
									P,
									h.debugBuffer,
									h.quadTriangleIndexBuffer,
									h.debugSegments
								),
									d.draw(
										l,
										u.LINE_STRIP,
										g,
										w,
										C,
										Rr.disabled,
										Ao(s.bf.red),
										E,
										Q,
										P,
										h.debugBuffer,
										h.tileBorderIndexBuffer,
										h.debugSegments
									);
							}
							function Bl(h, e, i, l) {
								const { isRenderingGlobe: u } = l,
									d = h.context,
									g = d.gl,
									w = h.transform,
									C = h.colorModeForRenderPass(),
									P = h.getDepthModeFor3D(),
									E = h.useProgram("terrain");
								d.bindFramebuffer.set(null),
									d.viewport.set([0, 0, h.width, h.height]);
								for (const R of i) {
									const D = e.getTerrainMesh(R.tileID),
										N = h.renderToTexture.getTexture(R),
										G = e.getTerrainData(R.tileID);
									d.activeTexture.set(g.TEXTURE0),
										g.bindTexture(g.TEXTURE_2D, N.texture);
									const te = e.getMeshFrameDelta(w.zoom),
										Q = w.calculateFogMatrix(R.tileID.toUnwrapped()),
										ae = xl(te, Q, h.style.sky, w.pitch, u),
										ce = w.getProjectionData({
											overscaledTileID: R.tileID,
											applyTerrainMatrix: !1,
											applyGlobeMatrix: !0,
										});
									E.draw(
										d,
										g.TRIANGLES,
										P,
										un.disabled,
										C,
										Rr.backCCW,
										ae,
										G,
										ce,
										"terrain",
										D.vertexBuffer,
										D.indexBuffer,
										D.segments
									);
								}
							}
							function Hs(h, e) {
								if (!e.mesh) {
									const i = new s.aL();
									i.emplaceBack(-1, -1),
										i.emplaceBack(1, -1),
										i.emplaceBack(1, 1),
										i.emplaceBack(-1, 1);
									const l = new s.aN();
									l.emplaceBack(0, 1, 2),
										l.emplaceBack(0, 2, 3),
										(e.mesh = new Tn(
											h.createVertexBuffer(i, an.members),
											h.createIndexBuffer(l),
											s.aM.simpleSegment(0, 0, i.length, l.length)
										));
								}
								return e.mesh;
							}
							class sd {
								constructor(e, i) {
									(this.context = new td(e)),
										(this.transform = i),
										(this._tileTextures = {}),
										(this.terrainFacilitator = {
											dirty: !0,
											matrix: s.ag(new Float64Array(16)),
											renderTime: 0,
										}),
										this.setup(),
										(this.numSublayers =
											rr.maxUnderzooming + rr.maxOverzooming + 1),
										(this.depthEpsilon = 1 / Math.pow(2, 16)),
										(this.crossTileSymbolIndex = new sr());
								}
								resize(e, i, l) {
									if (
										((this.width = Math.floor(e * l)),
										(this.height = Math.floor(i * l)),
										(this.pixelRatio = l),
										this.context.viewport.set([0, 0, this.width, this.height]),
										this.style)
									)
										for (const u of this.style._order)
											this.style._layers[u].resize();
								}
								setup() {
									const e = this.context,
										i = new s.aL();
									i.emplaceBack(0, 0),
										i.emplaceBack(s.$, 0),
										i.emplaceBack(0, s.$),
										i.emplaceBack(s.$, s.$),
										(this.tileExtentBuffer = e.createVertexBuffer(
											i,
											an.members
										)),
										(this.tileExtentSegments = s.aM.simpleSegment(0, 0, 4, 2));
									const l = new s.aL();
									l.emplaceBack(0, 0),
										l.emplaceBack(s.$, 0),
										l.emplaceBack(0, s.$),
										l.emplaceBack(s.$, s.$),
										(this.debugBuffer = e.createVertexBuffer(l, an.members)),
										(this.debugSegments = s.aM.simpleSegment(0, 0, 4, 5));
									const u = new s.c6();
									u.emplaceBack(0, 0, 0, 0),
										u.emplaceBack(s.$, 0, s.$, 0),
										u.emplaceBack(0, s.$, 0, s.$),
										u.emplaceBack(s.$, s.$, s.$, s.$),
										(this.rasterBoundsBuffer = e.createVertexBuffer(
											u,
											Tp.members
										)),
										(this.rasterBoundsSegments = s.aM.simpleSegment(
											0,
											0,
											4,
											2
										));
									const d = new s.aL();
									d.emplaceBack(0, 0),
										d.emplaceBack(s.$, 0),
										d.emplaceBack(0, s.$),
										d.emplaceBack(s.$, s.$),
										(this.rasterBoundsBufferPosOnly = e.createVertexBuffer(
											d,
											an.members
										)),
										(this.rasterBoundsSegmentsPosOnly = s.aM.simpleSegment(
											0,
											0,
											4,
											5
										));
									const g = new s.aL();
									g.emplaceBack(0, 0),
										g.emplaceBack(1, 0),
										g.emplaceBack(0, 1),
										g.emplaceBack(1, 1),
										(this.viewportBuffer = e.createVertexBuffer(g, an.members)),
										(this.viewportSegments = s.aM.simpleSegment(0, 0, 4, 2));
									const w = new s.c7();
									w.emplaceBack(0),
										w.emplaceBack(1),
										w.emplaceBack(3),
										w.emplaceBack(2),
										w.emplaceBack(0),
										(this.tileBorderIndexBuffer = e.createIndexBuffer(w));
									const C = new s.aN();
									C.emplaceBack(1, 0, 2),
										C.emplaceBack(1, 2, 3),
										(this.quadTriangleIndexBuffer = e.createIndexBuffer(C));
									const P = this.context.gl;
									(this.stencilClearMode = new un(
										{ func: P.ALWAYS, mask: 0 },
										0,
										255,
										P.ZERO,
										P.ZERO,
										P.ZERO
									)),
										(this.tileExtentMesh = new Tn(
											this.tileExtentBuffer,
											this.quadTriangleIndexBuffer,
											this.tileExtentSegments
										));
								}
								clearStencil() {
									const e = this.context,
										i = e.gl;
									(this.nextStencilID = 1),
										(this.currentStencilSource = void 0);
									const l = s.L();
									s.bY(l, 0, this.width, this.height, 0, 0, 1),
										s.N(l, l, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
									const u = {
										mainMatrix: l,
										tileMercatorCoords: [0, 0, 1, 1],
										clippingPlane: [0, 0, 0, 0],
										projectionTransition: 0,
										fallbackMatrix: l,
									};
									this.useProgram("clippingMask", null, !0).draw(
										e,
										i.TRIANGLES,
										Gr.disabled,
										this.stencilClearMode,
										zn.disabled,
										Rr.disabled,
										null,
										null,
										u,
										"$clipping",
										this.viewportBuffer,
										this.quadTriangleIndexBuffer,
										this.viewportSegments
									);
								}
								_renderTileClippingMasks(e, i, l) {
									if (
										this.currentStencilSource === e.source ||
										!e.isTileClipped() ||
										!i ||
										!i.length
									)
										return;
									(this.currentStencilSource = e.source),
										this.nextStencilID + i.length > 256 && this.clearStencil();
									const u = this.context;
									u.setColorMode(zn.disabled), u.setDepthMode(Gr.disabled);
									const d = {};
									for (const g of i) d[g.key] = this.nextStencilID++;
									this._renderTileMasks(d, i, l, !0),
										this._renderTileMasks(d, i, l, !1),
										(this._tileClippingMaskIDs = d);
								}
								_renderTileMasks(e, i, l, u) {
									const d = this.context,
										g = d.gl,
										w = this.style.projection,
										C = this.transform,
										P = this.useProgram("clippingMask");
									for (const E of i) {
										const R = e[E.key],
											D =
												this.style.map.terrain &&
												this.style.map.terrain.getTerrainData(E),
											N = w.getMeshFromTileID(
												this.context,
												E.canonical,
												u,
												!0,
												"stencil"
											),
											G = C.getProjectionData({
												overscaledTileID: E,
												applyGlobeMatrix: !l,
												applyTerrainMatrix: !0,
											});
										P.draw(
											d,
											g.TRIANGLES,
											Gr.disabled,
											new un(
												{ func: g.ALWAYS, mask: 0 },
												R,
												255,
												g.KEEP,
												g.KEEP,
												g.REPLACE
											),
											zn.disabled,
											l ? Rr.disabled : Rr.backCCW,
											null,
											D,
											G,
											"$clipping",
											N.vertexBuffer,
											N.indexBuffer,
											N.segments
										);
									}
								}
								_renderTilesDepthBuffer() {
									const e = this.context,
										i = e.gl,
										l = this.style.projection,
										u = this.transform,
										d = this.useProgram("depth"),
										g = this.getDepthModeFor3D(),
										w = ye(u, { tileSize: u.tileSize });
									for (const C of w) {
										const P =
												this.style.map.terrain &&
												this.style.map.terrain.getTerrainData(C),
											E = l.getMeshFromTileID(
												this.context,
												C.canonical,
												!0,
												!0,
												"raster"
											),
											R = u.getProjectionData({
												overscaledTileID: C,
												applyGlobeMatrix: !0,
												applyTerrainMatrix: !0,
											});
										d.draw(
											e,
											i.TRIANGLES,
											g,
											un.disabled,
											zn.disabled,
											Rr.backCCW,
											null,
											P,
											R,
											"$clipping",
											E.vertexBuffer,
											E.indexBuffer,
											E.segments
										);
									}
								}
								stencilModeFor3D() {
									(this.currentStencilSource = void 0),
										this.nextStencilID + 1 > 256 && this.clearStencil();
									const e = this.nextStencilID++,
										i = this.context.gl;
									return new un(
										{ func: i.NOTEQUAL, mask: 255 },
										e,
										255,
										i.KEEP,
										i.KEEP,
										i.REPLACE
									);
								}
								stencilModeForClipping(e) {
									const i = this.context.gl;
									return new un(
										{ func: i.EQUAL, mask: 255 },
										this._tileClippingMaskIDs[e.key],
										0,
										i.KEEP,
										i.KEEP,
										i.REPLACE
									);
								}
								getStencilConfigForOverlapAndUpdateStencilID(e) {
									const i = this.context.gl,
										l = e.sort((g, w) => w.overscaledZ - g.overscaledZ),
										u = l[l.length - 1].overscaledZ,
										d = l[0].overscaledZ - u + 1;
									if (d > 1) {
										(this.currentStencilSource = void 0),
											this.nextStencilID + d > 256 && this.clearStencil();
										const g = {};
										for (let w = 0; w < d; w++)
											g[w + u] = new un(
												{ func: i.GEQUAL, mask: 255 },
												w + this.nextStencilID,
												255,
												i.KEEP,
												i.KEEP,
												i.REPLACE
											);
										return (this.nextStencilID += d), [g, l];
									}
									return [{ [u]: un.disabled }, l];
								}
								stencilConfigForOverlapTwoPass(e) {
									const i = this.context.gl,
										l = e.sort((g, w) => w.overscaledZ - g.overscaledZ),
										u = l[l.length - 1].overscaledZ,
										d = l[0].overscaledZ - u + 1;
									if ((this.clearStencil(), d > 1)) {
										const g = {},
											w = {};
										for (let C = 0; C < d; C++)
											(g[C + u] = new un(
												{ func: i.GREATER, mask: 255 },
												d + 1 + C,
												255,
												i.KEEP,
												i.KEEP,
												i.REPLACE
											)),
												(w[C + u] = new un(
													{ func: i.GREATER, mask: 255 },
													1 + C,
													255,
													i.KEEP,
													i.KEEP,
													i.REPLACE
												));
										return (this.nextStencilID = 2 * d + 1), [g, w, l];
									}
									return (
										(this.nextStencilID = 3),
										[
											{
												[u]: new un(
													{ func: i.GREATER, mask: 255 },
													2,
													255,
													i.KEEP,
													i.KEEP,
													i.REPLACE
												),
											},
											{
												[u]: new un(
													{ func: i.GREATER, mask: 255 },
													1,
													255,
													i.KEEP,
													i.KEEP,
													i.REPLACE
												),
											},
											l,
										]
									);
								}
								colorModeForRenderPass() {
									const e = this.context.gl;
									return this._showOverdrawInspector
										? new zn(
												[e.CONSTANT_COLOR, e.ONE],
												new s.bf(0.125, 0.125, 0.125, 0),
												[!0, !0, !0, !0]
										  )
										: this.renderPass === "opaque"
										? zn.unblended
										: zn.alphaBlended;
								}
								getDepthModeForSublayer(e, i, l) {
									if (!this.opaquePassEnabledForLayer()) return Gr.disabled;
									const u =
										1 -
										((1 + this.currentLayer) * this.numSublayers + e) *
											this.depthEpsilon;
									return new Gr(l || this.context.gl.LEQUAL, i, [u, u]);
								}
								getDepthModeFor3D() {
									return new Gr(
										this.context.gl.LEQUAL,
										Gr.ReadWrite,
										this.depthRangeFor3D
									);
								}
								opaquePassEnabledForLayer() {
									return this.currentLayer < this.opaquePassCutoff;
								}
								render(e, i) {
									var l, u;
									(this.style = e),
										(this.options = i),
										(this.lineAtlas = e.lineAtlas),
										(this.imageManager = e.imageManager),
										(this.glyphManager = e.glyphManager),
										(this.symbolFadeChange = e.placement.symbolFadeChange(
											ne.now()
										)),
										this.imageManager.beginFrame();
									const d = this.style._order,
										g = this.style.sourceCaches,
										w = {},
										C = {},
										P = {},
										E = {
											isRenderingToTexture: !1,
											isRenderingGlobe:
												((l = e.projection) === null || l === void 0
													? void 0
													: l.transitionState) > 0,
										};
									for (const D in g) {
										const N = g[D];
										N.used && N.prepare(this.context),
											(w[D] = N.getVisibleCoordinates(!1)),
											(C[D] = w[D].slice().reverse()),
											(P[D] = N.getVisibleCoordinates(!0).reverse());
									}
									this.opaquePassCutoff = 1 / 0;
									for (let D = 0; D < d.length; D++)
										if (this.style._layers[d[D]].is3D()) {
											this.opaquePassCutoff = D;
											break;
										}
									this.maybeDrawDepthAndCoords(!1),
										this.renderToTexture &&
											(this.renderToTexture.prepareForRender(
												this.style,
												this.transform.zoom
											),
											(this.opaquePassCutoff = 0)),
										(this.renderPass = "offscreen");
									for (const D of d) {
										const N = this.style._layers[D];
										if (
											!N.hasOffscreenPass() ||
											N.isHidden(this.transform.zoom)
										)
											continue;
										const G = C[N.source];
										(N.type === "custom" || G.length) &&
											this.renderLayer(this, g[N.source], N, G, E);
									}
									if (
										((u = this.style.projection) === null ||
											u === void 0 ||
											u.updateGPUdependent({
												context: this.context,
												useProgram: (D) => this.useProgram(D),
											}),
										this.context.viewport.set([0, 0, this.width, this.height]),
										this.context.bindFramebuffer.set(null),
										this.context.clear({
											color: i.showOverdrawInspector
												? s.bf.black
												: s.bf.transparent,
											depth: 1,
										}),
										this.clearStencil(),
										this.style.sky &&
											(function (D, N) {
												const G = D.context,
													te = G.gl,
													Q = ((Pe, _e, Be) => {
														const rt = Math.cos(_e.rollInRadians),
															Ge = Math.sin(_e.rollInRadians),
															Xe = pe(_e),
															tt = _e.getProjectionData({
																overscaledTileID: null,
																applyGlobeMatrix: !0,
																applyTerrainMatrix: !0,
															}).projectionTransition;
														return {
															u_sky_color: Pe.properties.get("sky-color"),
															u_horizon_color:
																Pe.properties.get("horizon-color"),
															u_horizon: [
																(_e.width / 2 - Xe * Ge) * Be,
																(_e.height / 2 + Xe * rt) * Be,
															],
															u_horizon_normal: [-Ge, rt],
															u_sky_horizon_blend:
																((Pe.properties.get("sky-horizon-blend") *
																	_e.height) /
																	2) *
																Be,
															u_sky_blend: tt,
														};
													})(N, D.style.map.transform, D.pixelRatio),
													ae = new Gr(te.LEQUAL, Gr.ReadWrite, [0, 1]),
													ce = un.disabled,
													ve = D.colorModeForRenderPass(),
													me = D.useProgram("sky"),
													be = Hs(G, N);
												me.draw(
													G,
													te.TRIANGLES,
													ae,
													ce,
													ve,
													Rr.disabled,
													Q,
													null,
													void 0,
													"sky",
													be.vertexBuffer,
													be.indexBuffer,
													be.segments
												);
											})(this, this.style.sky),
										(this._showOverdrawInspector = i.showOverdrawInspector),
										(this.depthRangeFor3D = [
											0,
											1 -
												(e._order.length + 2) *
													this.numSublayers *
													this.depthEpsilon,
										]),
										!this.renderToTexture)
									)
										for (
											this.renderPass = "opaque",
												this.currentLayer = d.length - 1;
											this.currentLayer >= 0;
											this.currentLayer--
										) {
											const D = this.style._layers[d[this.currentLayer]],
												N = g[D.source],
												G = w[D.source];
											this._renderTileClippingMasks(D, G, !1),
												this.renderLayer(this, N, D, G, E);
										}
									this.renderPass = "translucent";
									let R = !1;
									for (
										this.currentLayer = 0;
										this.currentLayer < d.length;
										this.currentLayer++
									) {
										const D = this.style._layers[d[this.currentLayer]],
											N = g[D.source];
										if (
											this.renderToTexture &&
											this.renderToTexture.renderLayer(D, E)
										)
											continue;
										this.opaquePassEnabledForLayer() ||
											R ||
											((R = !0),
											E.isRenderingGlobe &&
												!this.style.map.terrain &&
												this._renderTilesDepthBuffer());
										const G = (D.type === "symbol" ? P : C)[D.source];
										this._renderTileClippingMasks(
											D,
											w[D.source],
											!!this.renderToTexture
										),
											this.renderLayer(this, N, D, G, E);
									}
									if (
										(E.isRenderingGlobe &&
											(function (D, N, G) {
												const te = D.context,
													Q = te.gl,
													ae = D.useProgram("atmosphere"),
													ce = new Gr(Q.LEQUAL, Gr.ReadOnly, [0, 1]),
													ve = D.transform,
													me = (function (tt, jt) {
														const Zt = tt.properties.get("position"),
															Tt = [-Zt.x, -Zt.y, -Zt.z],
															vr = s.ag(new Float64Array(16));
														return (
															tt.properties.get("anchor") === "map" &&
																(s.b6(vr, vr, jt.rollInRadians),
																s.b7(vr, vr, -jt.pitchInRadians),
																s.b6(vr, vr, jt.bearingInRadians),
																s.b7(vr, vr, (jt.center.lat * Math.PI) / 180),
																s.bz(vr, vr, (-jt.center.lng * Math.PI) / 180)),
															s.c5(Tt, Tt, vr),
															Tt
														);
													})(G, D.transform),
													be = ve.getProjectionData({
														overscaledTileID: null,
														applyGlobeMatrix: !0,
														applyTerrainMatrix: !0,
													}),
													Pe =
														N.properties.get("atmosphere-blend") *
														be.projectionTransition;
												if (Pe === 0) return;
												const _e = Qo(ve.worldSize, ve.center.lat),
													Be = ve.inverseProjectionMatrix,
													rt = new Float64Array(4);
												(rt[3] = 1),
													s.aw(rt, rt, ve.modelViewProjectionMatrix),
													(rt[0] /= rt[3]),
													(rt[1] /= rt[3]),
													(rt[2] /= rt[3]),
													(rt[3] = 1),
													s.aw(rt, rt, Be),
													(rt[0] /= rt[3]),
													(rt[1] /= rt[3]),
													(rt[2] /= rt[3]),
													(rt[3] = 1);
												const Ge = ((tt, jt, Zt, Tt, vr) => ({
														u_sun_pos: tt,
														u_atmosphere_blend: jt,
														u_globe_position: Zt,
														u_globe_radius: Tt,
														u_inv_proj_matrix: vr,
													}))(me, Pe, [rt[0], rt[1], rt[2]], _e, Be),
													Xe = Hs(te, N);
												ae.draw(
													te,
													Q.TRIANGLES,
													ce,
													un.disabled,
													zn.alphaBlended,
													Rr.disabled,
													Ge,
													null,
													null,
													"atmosphere",
													Xe.vertexBuffer,
													Xe.indexBuffer,
													Xe.segments
												);
											})(this, this.style.sky, this.style.light),
										this.options.showTileBoundaries)
									) {
										const D = (function (N, G) {
											let te = null;
											const Q = Object.values(N._layers).flatMap((me) =>
													me.source && !me.isHidden(G)
														? [N.sourceCaches[me.source]]
														: []
												),
												ae = Q.filter((me) => me.getSource().type === "vector"),
												ce = Q.filter((me) => me.getSource().type !== "vector"),
												ve = (me) => {
													(!te ||
														te.getSource().maxzoom < me.getSource().maxzoom) &&
														(te = me);
												};
											return (
												ae.forEach((me) => ve(me)),
												te || ce.forEach((me) => ve(me)),
												te
											);
										})(this.style, this.transform.zoom);
										D &&
											(function (N, G, te) {
												for (let Q = 0; Q < te.length; Q++) ya(N, G, te[Q]);
											})(this, D, D.getVisibleCoordinates());
									}
									this.options.showPadding &&
										(function (D) {
											const N = D.transform.padding;
											eu(D, D.transform.height - (N.top || 0), 3, ad),
												eu(D, N.bottom || 0, 3, od),
												Kn(D, N.left || 0, 3, Rl),
												Kn(D, D.transform.width - (N.right || 0), 3, Qc);
											const G = D.transform.centerPoint;
											(function (te, Q, ae, ce) {
												Ua(te, Q - 1, ae - 10, 2, 20, ce),
													Ua(te, Q - 10, ae - 1, 20, 2, ce);
											})(D, G.x, D.transform.height - G.y, Np);
										})(this),
										this.context.setDefault();
								}
								maybeDrawDepthAndCoords(e) {
									if (!this.style || !this.style.map || !this.style.map.terrain)
										return;
									const i = this.terrainFacilitator.matrix,
										l = this.transform.modelViewProjectionMatrix;
									let u = this.terrainFacilitator.dirty;
									u || (u = e ? !s.c8(i, l) : !s.c9(i, l)),
										u ||
											(u = this.style.map.terrain.sourceCache.anyTilesAfterTime(
												this.terrainFacilitator.renderTime
											)),
										u &&
											(s.ca(i, l),
											(this.terrainFacilitator.renderTime = Date.now()),
											(this.terrainFacilitator.dirty = !1),
											(function (d, g) {
												const w = d.context,
													C = w.gl,
													P = d.transform,
													E = zn.unblended,
													R = new Gr(C.LEQUAL, Gr.ReadWrite, [0, 1]),
													D = g.sourceCache.getRenderableTiles(),
													N = d.useProgram("terrainDepth");
												w.bindFramebuffer.set(
													g.getFramebuffer("depth").framebuffer
												),
													w.viewport.set([
														0,
														0,
														d.width / devicePixelRatio,
														d.height / devicePixelRatio,
													]),
													w.clear({ color: s.bf.transparent, depth: 1 });
												for (const G of D) {
													const te = g.getTerrainMesh(G.tileID),
														Q = g.getTerrainData(G.tileID),
														ae = P.getProjectionData({
															overscaledTileID: G.tileID,
															applyTerrainMatrix: !1,
															applyGlobeMatrix: !0,
														}),
														ce = { u_ele_delta: g.getMeshFrameDelta(P.zoom) };
													N.draw(
														w,
														C.TRIANGLES,
														R,
														un.disabled,
														E,
														Rr.backCCW,
														ce,
														Q,
														ae,
														"terrain",
														te.vertexBuffer,
														te.indexBuffer,
														te.segments
													);
												}
												w.bindFramebuffer.set(null),
													w.viewport.set([0, 0, d.width, d.height]);
											})(this, this.style.map.terrain),
											(function (d, g) {
												const w = d.context,
													C = w.gl,
													P = d.transform,
													E = zn.unblended,
													R = new Gr(C.LEQUAL, Gr.ReadWrite, [0, 1]),
													D = g.getCoordsTexture(),
													N = g.sourceCache.getRenderableTiles(),
													G = d.useProgram("terrainCoords");
												w.bindFramebuffer.set(
													g.getFramebuffer("coords").framebuffer
												),
													w.viewport.set([
														0,
														0,
														d.width / devicePixelRatio,
														d.height / devicePixelRatio,
													]),
													w.clear({ color: s.bf.transparent, depth: 1 }),
													(g.coordsIndex = []);
												for (const te of N) {
													const Q = g.getTerrainMesh(te.tileID),
														ae = g.getTerrainData(te.tileID);
													w.activeTexture.set(C.TEXTURE0),
														C.bindTexture(C.TEXTURE_2D, D.texture);
													const ce = {
															u_terrain_coords_id:
																(255 - g.coordsIndex.length) / 255,
															u_texture: 0,
															u_ele_delta: g.getMeshFrameDelta(P.zoom),
														},
														ve = P.getProjectionData({
															overscaledTileID: te.tileID,
															applyTerrainMatrix: !1,
															applyGlobeMatrix: !0,
														});
													G.draw(
														w,
														C.TRIANGLES,
														R,
														un.disabled,
														E,
														Rr.backCCW,
														ce,
														ae,
														ve,
														"terrain",
														Q.vertexBuffer,
														Q.indexBuffer,
														Q.segments
													),
														g.coordsIndex.push(te.tileID.key);
												}
												w.bindFramebuffer.set(null),
													w.viewport.set([0, 0, d.width, d.height]);
											})(this, this.style.map.terrain));
								}
								renderLayer(e, i, l, u, d) {
									l.isHidden(this.transform.zoom) ||
										((l.type === "background" ||
											l.type === "custom" ||
											(u || []).length) &&
											((this.id = l.id),
											s.cb(l)
												? (function (g, w, C, P, E, R) {
														if (g.renderPass !== "translucent") return;
														const { isRenderingToTexture: D } = R,
															N = un.disabled,
															G = g.colorModeForRenderPass();
														(C._unevaluatedLayout.hasValue(
															"text-variable-anchor"
														) ||
															C._unevaluatedLayout.hasValue(
																"text-variable-anchor-offset"
															)) &&
															(function (te, Q, ae, ce, ve, me, be, Pe, _e) {
																const Be = Q.transform,
																	rt = Q.style.map.terrain,
																	Ge = ve === "map",
																	Xe = me === "map";
																for (const tt of te) {
																	const jt = ce.getTile(tt),
																		Zt = jt.getBucket(ae);
																	if (
																		!Zt ||
																		!Zt.text ||
																		!Zt.text.segments.get().length
																	)
																		continue;
																	const Tt = s.an(Zt.textSizeData, Be.zoom),
																		vr = s.aC(jt, 1, Q.transform.zoom),
																		Jr = _n(Ge, Q.transform, vr),
																		An =
																			ae.layout.get("icon-text-fit") !==
																				"none" && Zt.hasIconData();
																	if (Tt) {
																		const Rn = Math.pow(
																				2,
																				Be.zoom - jt.tileID.overscaledZ
																			),
																			Ln = rt
																				? (Wn, Jn) =>
																						rt.getElevation(tt, Wn, Jn)
																				: null;
																		Wc(
																			Zt,
																			Ge,
																			Xe,
																			_e,
																			Be,
																			Jr,
																			Rn,
																			Tt,
																			An,
																			s.aD(Be, jt, be, Pe),
																			tt.toUnwrapped(),
																			Ln
																		);
																	}
																}
															})(
																P,
																g,
																C,
																w,
																C.layout.get("text-rotation-alignment"),
																C.layout.get("text-pitch-alignment"),
																C.paint.get("text-translate"),
																C.paint.get("text-translate-anchor"),
																E
															),
															C.paint.get("icon-opacity").constantOr(1) !== 0 &&
																qs(
																	g,
																	w,
																	C,
																	P,
																	!1,
																	C.paint.get("icon-translate"),
																	C.paint.get("icon-translate-anchor"),
																	C.layout.get("icon-rotation-alignment"),
																	C.layout.get("icon-pitch-alignment"),
																	C.layout.get("icon-keep-upright"),
																	N,
																	G,
																	D
																),
															C.paint.get("text-opacity").constantOr(1) !== 0 &&
																qs(
																	g,
																	w,
																	C,
																	P,
																	!0,
																	C.paint.get("text-translate"),
																	C.paint.get("text-translate-anchor"),
																	C.layout.get("text-rotation-alignment"),
																	C.layout.get("text-pitch-alignment"),
																	C.layout.get("text-keep-upright"),
																	N,
																	G,
																	D
																),
															w.map.showCollisionBoxes &&
																(rd(g, w, C, P, !0), rd(g, w, C, P, !1));
												  })(
														e,
														i,
														l,
														u,
														this.style.placement.variableOffsets,
														d
												  )
												: s.cc(l)
												? (function (g, w, C, P, E) {
														if (g.renderPass !== "translucent") return;
														const { isRenderingToTexture: R } = E,
															D = C.paint.get("circle-opacity"),
															N = C.paint.get("circle-stroke-width"),
															G = C.paint.get("circle-stroke-opacity"),
															te = !C.layout
																.get("circle-sort-key")
																.isConstant();
														if (
															D.constantOr(1) === 0 &&
															(N.constantOr(1) === 0 || G.constantOr(1) === 0)
														)
															return;
														const Q = g.context,
															ae = Q.gl,
															ce = g.transform,
															ve = g.getDepthModeForSublayer(0, Gr.ReadOnly),
															me = un.disabled,
															be = g.colorModeForRenderPass(),
															Pe = [],
															_e = ce.getCircleRadiusCorrection();
														for (let Be = 0; Be < P.length; Be++) {
															const rt = P[Be],
																Ge = w.getTile(rt),
																Xe = Ge.getBucket(C);
															if (!Xe) continue;
															const tt = C.paint.get("circle-translate"),
																jt = C.paint.get("circle-translate-anchor"),
																Zt = s.aD(ce, Ge, tt, jt),
																Tt = Xe.programConfigurations.get(C.id),
																vr = g.useProgram("circle", Tt),
																Jr = Xe.layoutVertexBuffer,
																An = Xe.indexBuffer,
																Rn =
																	g.style.map.terrain &&
																	g.style.map.terrain.getTerrainData(rt),
																Ln = {
																	programConfiguration: Tt,
																	program: vr,
																	layoutVertexBuffer: Jr,
																	indexBuffer: An,
																	uniformValues: Pp(g, Ge, C, Zt, _e),
																	terrainData: Rn,
																	projectionData: ce.getProjectionData({
																		overscaledTileID: rt,
																		applyGlobeMatrix: !R,
																		applyTerrainMatrix: !0,
																	}),
																};
															if (te) {
																const Wn = Xe.segments.get();
																for (const Jn of Wn)
																	Pe.push({
																		segments: new s.aM([Jn]),
																		sortKey: Jn.sortKey,
																		state: Ln,
																	});
															} else
																Pe.push({
																	segments: Xe.segments,
																	sortKey: 0,
																	state: Ln,
																});
														}
														te && Pe.sort((Be, rt) => Be.sortKey - rt.sortKey);
														for (const Be of Pe) {
															const {
																programConfiguration: rt,
																program: Ge,
																layoutVertexBuffer: Xe,
																indexBuffer: tt,
																uniformValues: jt,
																terrainData: Zt,
																projectionData: Tt,
															} = Be.state;
															Ge.draw(
																Q,
																ae.TRIANGLES,
																ve,
																me,
																be,
																Rr.backCCW,
																jt,
																Zt,
																Tt,
																C.id,
																Xe,
																tt,
																Be.segments,
																C.paint,
																g.transform.zoom,
																rt
															);
														}
												  })(e, i, l, u, d)
												: s.cd(l)
												? (function (g, w, C, P, E) {
														if (C.paint.get("heatmap-opacity") === 0) return;
														const R = g.context,
															{ isRenderingToTexture: D, isRenderingGlobe: N } =
																E;
														if (g.style.map.terrain) {
															for (const G of P) {
																const te = w.getTile(G);
																w.hasRenderableParent(G) ||
																	(g.renderPass === "offscreen"
																		? Xc(g, te, C, G, N)
																		: g.renderPass === "translucent" &&
																		  id(g, C, G, D, N));
															}
															R.viewport.set([0, 0, g.width, g.height]);
														} else
															g.renderPass === "offscreen"
																? (function (G, te, Q, ae) {
																		const ce = G.context,
																			ve = ce.gl,
																			me = G.transform,
																			be = un.disabled,
																			Pe = new zn(
																				[ve.ONE, ve.ONE],
																				s.bf.transparent,
																				[!0, !0, !0, !0]
																			);
																		(function (_e, Be, rt) {
																			const Ge = _e.gl;
																			_e.activeTexture.set(Ge.TEXTURE1),
																				_e.viewport.set([
																					0,
																					0,
																					Be.width / 4,
																					Be.height / 4,
																				]);
																			let Xe = rt.heatmapFbos.get(s.c2);
																			Xe
																				? (Ge.bindTexture(
																						Ge.TEXTURE_2D,
																						Xe.colorAttachment.get()
																				  ),
																				  _e.bindFramebuffer.set(
																						Xe.framebuffer
																				  ))
																				: ((Xe = Us(
																						_e,
																						Be.width / 4,
																						Be.height / 4
																				  )),
																				  rt.heatmapFbos.set(s.c2, Xe));
																		})(ce, G, Q),
																			ce.clear({ color: s.bf.transparent });
																		for (let _e = 0; _e < ae.length; _e++) {
																			const Be = ae[_e];
																			if (te.hasRenderableParent(Be)) continue;
																			const rt = te.getTile(Be),
																				Ge = rt.getBucket(Q);
																			if (!Ge) continue;
																			const Xe = Ge.programConfigurations.get(
																					Q.id
																				),
																				tt = G.useProgram("heatmap", Xe),
																				jt = me.getProjectionData({
																					overscaledTileID: Be,
																					applyGlobeMatrix: !0,
																					applyTerrainMatrix: !1,
																				}),
																				Zt = me.getCircleRadiusCorrection();
																			tt.draw(
																				ce,
																				ve.TRIANGLES,
																				Gr.disabled,
																				be,
																				Pe,
																				Rr.backCCW,
																				Nh(
																					rt,
																					me.zoom,
																					Q.paint.get("heatmap-intensity"),
																					Zt
																				),
																				null,
																				jt,
																				Q.id,
																				Ge.layoutVertexBuffer,
																				Ge.indexBuffer,
																				Ge.segments,
																				Q.paint,
																				me.zoom,
																				Xe
																			);
																		}
																		ce.viewport.set([0, 0, G.width, G.height]);
																  })(g, w, C, P)
																: g.renderPass === "translucent" &&
																  (function (G, te) {
																		const Q = G.context,
																			ae = Q.gl;
																		Q.setColorMode(G.colorModeForRenderPass());
																		const ce = te.heatmapFbos.get(s.c2);
																		ce &&
																			(Q.activeTexture.set(ae.TEXTURE0),
																			ae.bindTexture(
																				ae.TEXTURE_2D,
																				ce.colorAttachment.get()
																			),
																			Q.activeTexture.set(ae.TEXTURE1),
																			$s(Q, te).bind(
																				ae.LINEAR,
																				ae.CLAMP_TO_EDGE
																			),
																			G.useProgram("heatmapTexture").draw(
																				Q,
																				ae.TRIANGLES,
																				Gr.disabled,
																				un.disabled,
																				G.colorModeForRenderPass(),
																				Rr.disabled,
																				Rc(G, te, 0, 1),
																				null,
																				null,
																				te.id,
																				G.viewportBuffer,
																				G.quadTriangleIndexBuffer,
																				G.viewportSegments,
																				te.paint,
																				G.transform.zoom
																			));
																  })(g, C);
												  })(e, i, l, u, d)
												: s.ce(l)
												? (function (g, w, C, P, E) {
														if (g.renderPass !== "translucent") return;
														const { isRenderingToTexture: R } = E,
															D = C.paint.get("line-opacity"),
															N = C.paint.get("line-width");
														if (D.constantOr(1) === 0 || N.constantOr(1) === 0)
															return;
														const G = g.getDepthModeForSublayer(0, Gr.ReadOnly),
															te = g.colorModeForRenderPass(),
															Q = C.paint.get("line-dasharray"),
															ae = C.paint.get("line-pattern"),
															ce = ae.constantOr(1),
															ve = C.paint.get("line-gradient"),
															me = C.getCrossfadeParameters(),
															be = ce
																? "linePattern"
																: Q
																? "lineSDF"
																: ve
																? "lineGradient"
																: "line",
															Pe = g.context,
															_e = Pe.gl,
															Be = g.transform;
														let rt = !0;
														for (const Ge of P) {
															const Xe = w.getTile(Ge);
															if (ce && !Xe.patternsLoaded()) continue;
															const tt = Xe.getBucket(C);
															if (!tt) continue;
															const jt = tt.programConfigurations.get(C.id),
																Zt = g.context.program.get(),
																Tt = g.useProgram(be, jt),
																vr = rt || Tt.program !== Zt,
																Jr =
																	g.style.map.terrain &&
																	g.style.map.terrain.getTerrainData(Ge),
																An = ae.constantOr(null);
															if (An && Xe.imageAtlas) {
																const Kr = Xe.imageAtlas,
																	Bn = Kr.patternPositions[An.to.toString()],
																	si = Kr.patternPositions[An.from.toString()];
																Bn &&
																	si &&
																	jt.setConstantPatternPositions(Bn, si);
															}
															const Rn = Be.getProjectionData({
																	overscaledTileID: Ge,
																	applyGlobeMatrix: !R,
																	applyTerrainMatrix: !0,
																}),
																Ln = Be.getPixelScale(),
																Wn = ce
																	? Zh(g, Xe, C, Ln, me)
																	: Q
																	? Eo(g, Xe, C, Ln, Q, me)
																	: ve
																	? qh(g, Xe, C, Ln, tt.lineClipsArray.length)
																	: Cl(g, Xe, C, Ln);
															if (ce)
																Pe.activeTexture.set(_e.TEXTURE0),
																	Xe.imageAtlasTexture.bind(
																		_e.LINEAR,
																		_e.CLAMP_TO_EDGE
																	),
																	jt.updatePaintBuffers(me);
															else if (Q && (vr || g.lineAtlas.dirty))
																Pe.activeTexture.set(_e.TEXTURE0),
																	g.lineAtlas.bind(Pe);
															else if (ve) {
																const Kr = tt.gradients[C.id];
																let Bn = Kr.texture;
																if (C.gradientVersion !== Kr.version) {
																	let si = 256;
																	if (C.stepInterpolant) {
																		const mi = w.getSource().maxzoom,
																			Ci =
																				Ge.canonical.z === mi
																					? Math.ceil(
																							1 <<
																								(g.transform.maxZoom -
																									Ge.canonical.z)
																					  )
																					: 1;
																		si = s.ah(
																			s.c3(
																				(tt.maxLineLength / s.$) * 1024 * Ci
																			),
																			256,
																			Pe.maxTextureSize
																		);
																	}
																	(Kr.gradient = s.c4({
																		expression: C.gradientExpression(),
																		evaluationKey: "lineProgress",
																		resolution: si,
																		image: Kr.gradient || void 0,
																		clips: tt.lineClipsArray,
																	})),
																		Kr.texture
																			? Kr.texture.update(Kr.gradient)
																			: (Kr.texture = new s.T(
																					Pe,
																					Kr.gradient,
																					_e.RGBA
																			  )),
																		(Kr.version = C.gradientVersion),
																		(Bn = Kr.texture);
																}
																Pe.activeTexture.set(_e.TEXTURE0),
																	Bn.bind(
																		C.stepInterpolant ? _e.NEAREST : _e.LINEAR,
																		_e.CLAMP_TO_EDGE
																	);
															}
															const Jn = g.stencilModeForClipping(Ge);
															Tt.draw(
																Pe,
																_e.TRIANGLES,
																G,
																Jn,
																te,
																Rr.disabled,
																Wn,
																Jr,
																Rn,
																C.id,
																tt.layoutVertexBuffer,
																tt.indexBuffer,
																tt.segments,
																C.paint,
																g.transform.zoom,
																jt,
																tt.layoutVertexBuffer2
															),
																(rt = !1);
														}
												  })(e, i, l, u, d)
												: s.cf(l)
												? (function (g, w, C, P, E) {
														const R = C.paint.get("fill-color"),
															D = C.paint.get("fill-opacity");
														if (D.constantOr(1) === 0) return;
														const { isRenderingToTexture: N } = E,
															G = g.colorModeForRenderPass(),
															te = C.paint.get("fill-pattern"),
															Q =
																g.opaquePassEnabledForLayer() &&
																!te.constantOr(1) &&
																R.constantOr(s.bf.transparent).a === 1 &&
																D.constantOr(0) === 1
																	? "opaque"
																	: "translucent";
														if (g.renderPass === Q) {
															const ae = g.getDepthModeForSublayer(
																1,
																g.renderPass === "opaque"
																	? Gr.ReadWrite
																	: Gr.ReadOnly
															);
															Ll(g, w, C, P, ae, G, !1, N);
														}
														if (
															g.renderPass === "translucent" &&
															C.paint.get("fill-antialias")
														) {
															const ae = g.getDepthModeForSublayer(
																C.getPaintProperty("fill-outline-color")
																	? 2
																	: 0,
																Gr.ReadOnly
															);
															Ll(g, w, C, P, ae, G, !0, N);
														}
												  })(e, i, l, u, d)
												: s.cg(l)
												? (function (g, w, C, P, E) {
														const R = C.paint.get("fill-extrusion-opacity");
														if (R === 0) return;
														const { isRenderingToTexture: D } = E;
														if (g.renderPass === "translucent") {
															const N = new Gr(
																g.context.gl.LEQUAL,
																Gr.ReadWrite,
																g.depthRangeFor3D
															);
															if (
																R !== 1 ||
																C.paint
																	.get("fill-extrusion-pattern")
																	.constantOr(1)
															)
																Yc(g, w, C, P, N, un.disabled, zn.disabled, D),
																	Yc(
																		g,
																		w,
																		C,
																		P,
																		N,
																		g.stencilModeFor3D(),
																		g.colorModeForRenderPass(),
																		D
																	);
															else {
																const G = g.colorModeForRenderPass();
																Yc(g, w, C, P, N, un.disabled, G, D);
															}
														}
												  })(e, i, l, u, d)
												: s.ch(l)
												? (function (g, w, C, P, E) {
														if (
															g.renderPass !== "offscreen" &&
															g.renderPass !== "translucent"
														)
															return;
														const { isRenderingToTexture: R } = E,
															D = g.context,
															N = g.style.projection.useSubdivision,
															G = g.getDepthModeForSublayer(0, Gr.ReadOnly),
															te = g.colorModeForRenderPass();
														if (g.renderPass === "offscreen")
															(function (Q, ae, ce, ve, me, be, Pe) {
																const _e = Q.context,
																	Be = _e.gl;
																for (const rt of ce) {
																	const Ge = ae.getTile(rt),
																		Xe = Ge.dem;
																	if (
																		!Xe ||
																		!Xe.data ||
																		!Ge.needsHillshadePrepare
																	)
																		continue;
																	const tt = Xe.dim,
																		jt = Xe.stride,
																		Zt = Xe.getPixels();
																	if (
																		(_e.activeTexture.set(Be.TEXTURE1),
																		_e.pixelStoreUnpackPremultiplyAlpha.set(!1),
																		(Ge.demTexture =
																			Ge.demTexture || Q.getTileTexture(jt)),
																		Ge.demTexture)
																	) {
																		const vr = Ge.demTexture;
																		vr.update(Zt, { premultiply: !1 }),
																			vr.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
																	} else
																		(Ge.demTexture = new s.T(_e, Zt, Be.RGBA, {
																			premultiply: !1,
																		})),
																			Ge.demTexture.bind(
																				Be.NEAREST,
																				Be.CLAMP_TO_EDGE
																			);
																	_e.activeTexture.set(Be.TEXTURE0);
																	let Tt = Ge.fbo;
																	if (!Tt) {
																		const vr = new s.T(
																			_e,
																			{ width: tt, height: tt, data: null },
																			Be.RGBA
																		);
																		vr.bind(Be.LINEAR, Be.CLAMP_TO_EDGE),
																			(Tt = Ge.fbo =
																				_e.createFramebuffer(tt, tt, !0, !1)),
																			Tt.colorAttachment.set(vr.texture);
																	}
																	_e.bindFramebuffer.set(Tt.framebuffer),
																		_e.viewport.set([0, 0, tt, tt]),
																		Q.useProgram("hillshadePrepare").draw(
																			_e,
																			Be.TRIANGLES,
																			me,
																			be,
																			Pe,
																			Rr.disabled,
																			jh(Ge.tileID, Xe),
																			null,
																			null,
																			ve.id,
																			Q.rasterBoundsBuffer,
																			Q.quadTriangleIndexBuffer,
																			Q.rasterBoundsSegments
																		),
																		(Ge.needsHillshadePrepare = !1);
																}
															})(g, w, P, C, G, un.disabled, te),
																D.viewport.set([0, 0, g.width, g.height]);
														else if (g.renderPass === "translucent")
															if (N) {
																const [Q, ae, ce] =
																	g.stencilConfigForOverlapTwoPass(P);
																Ro(g, w, C, ce, Q, G, te, !1, R),
																	Ro(g, w, C, ce, ae, G, te, !0, R);
															} else {
																const [Q, ae] =
																	g.getStencilConfigForOverlapAndUpdateStencilID(
																		P
																	);
																Ro(g, w, C, ae, Q, G, te, !1, R);
															}
												  })(e, i, l, u, d)
												: s.ci(l)
												? (function (g, w, C, P, E) {
														if (g.renderPass !== "translucent" || !P.length)
															return;
														const { isRenderingToTexture: R } = E,
															D = g.style.projection.useSubdivision,
															N = g.getDepthModeForSublayer(0, Gr.ReadOnly),
															G = g.colorModeForRenderPass();
														if (D) {
															const [te, Q, ae] =
																g.stencilConfigForOverlapTwoPass(P);
															Kc(g, w, C, ae, te, N, G, !1, R),
																Kc(g, w, C, ae, Q, N, G, !0, R);
														} else {
															const [te, Q] =
																g.getStencilConfigForOverlapAndUpdateStencilID(
																	P
																);
															Kc(g, w, C, Q, te, N, G, !1, R);
														}
												  })(e, i, l, u, d)
												: s.cj(l)
												? (function (g, w, C, P, E) {
														if (
															g.renderPass !== "translucent" ||
															C.paint.get("raster-opacity") === 0 ||
															!P.length
														)
															return;
														const { isRenderingToTexture: R } = E,
															D = w.getSource(),
															N = g.style.projection.useSubdivision;
														if (D instanceof Ot)
															Bo(
																g,
																w,
																C,
																P,
																null,
																!1,
																!1,
																D.tileCoords,
																D.flippedWindingOrder,
																R
															);
														else if (N) {
															const [G, te, Q] =
																g.stencilConfigForOverlapTwoPass(P);
															Bo(g, w, C, Q, G, !1, !0, Dl, !1, R),
																Bo(g, w, C, Q, te, !0, !0, Dl, !1, R);
														} else {
															const [G, te] =
																g.getStencilConfigForOverlapAndUpdateStencilID(
																	P
																);
															Bo(g, w, C, te, G, !1, !0, Dl, !1, R);
														}
												  })(e, i, l, u, d)
												: s.ck(l)
												? (function (g, w, C, P, E) {
														const R = C.paint.get("background-color"),
															D = C.paint.get("background-opacity");
														if (D === 0) return;
														const { isRenderingToTexture: N } = E,
															G = g.context,
															te = G.gl,
															Q = g.style.projection,
															ae = g.transform,
															ce = ae.tileSize,
															ve = C.paint.get("background-pattern");
														if (g.isPatternMissing(ve)) return;
														const me =
															!ve &&
															R.a === 1 &&
															D === 1 &&
															g.opaquePassEnabledForLayer()
																? "opaque"
																: "translucent";
														if (g.renderPass !== me) return;
														const be = un.disabled,
															Pe = g.getDepthModeForSublayer(
																0,
																me === "opaque" ? Gr.ReadWrite : Gr.ReadOnly
															),
															_e = g.colorModeForRenderPass(),
															Be = g.useProgram(
																ve ? "backgroundPattern" : "background"
															),
															rt =
																P ||
																ye(ae, {
																	tileSize: ce,
																	terrain: g.style.map.terrain,
																});
														ve &&
															(G.activeTexture.set(te.TEXTURE0),
															g.imageManager.bind(g.context));
														const Ge = C.getCrossfadeParameters();
														for (const Xe of rt) {
															const tt = ae.getProjectionData({
																	overscaledTileID: Xe,
																	applyGlobeMatrix: !N,
																	applyTerrainMatrix: !0,
																}),
																jt = ve
																	? Gh(
																			D,
																			g,
																			ve,
																			{ tileID: Xe, tileSize: ce },
																			Ge
																	  )
																	: $h(D, R),
																Zt =
																	g.style.map.terrain &&
																	g.style.map.terrain.getTerrainData(Xe),
																Tt = Q.getMeshFromTileID(
																	G,
																	Xe.canonical,
																	!1,
																	!0,
																	"raster"
																);
															Be.draw(
																G,
																te.TRIANGLES,
																Pe,
																be,
																_e,
																Rr.backCCW,
																jt,
																Zt,
																tt,
																C.id,
																Tt.vertexBuffer,
																Tt.indexBuffer,
																Tt.segments
															);
														}
												  })(e, 0, l, u, d)
												: s.cl(l) &&
												  (function (g, w, C, P) {
														const { isRenderingGlobe: E } = P,
															R = g.context,
															D = C.implementation,
															N = g.style.projection,
															G = g.transform,
															te = G.getProjectionDataForCustomLayer(E),
															Q = {
																farZ: G.farZ,
																nearZ: G.nearZ,
																fov: (G.fov * Math.PI) / 180,
																modelViewProjectionMatrix:
																	G.modelViewProjectionMatrix,
																projectionMatrix: G.projectionMatrix,
																shaderData: {
																	variantName: N.shaderVariantName,
																	vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${N.shaderPreludeCode.vertexSource}`,
																	define: N.shaderDefine,
																},
																defaultProjectionData: te,
															},
															ae = D.renderingMode ? D.renderingMode : "2d";
														if (g.renderPass === "offscreen") {
															const ce = D.prerender;
															ce &&
																(g.setCustomLayerDefaults(),
																R.setColorMode(g.colorModeForRenderPass()),
																ce.call(D, R.gl, Q),
																R.setDirty(),
																g.setBaseState());
														} else if (g.renderPass === "translucent") {
															g.setCustomLayerDefaults(),
																R.setColorMode(g.colorModeForRenderPass()),
																R.setStencilMode(un.disabled);
															const ce =
																ae === "3d"
																	? g.getDepthModeFor3D()
																	: g.getDepthModeForSublayer(0, Gr.ReadOnly);
															R.setDepthMode(ce),
																D.render(R.gl, Q),
																R.setDirty(),
																g.setBaseState(),
																R.bindFramebuffer.set(null);
														}
												  })(e, 0, l, d)));
								}
								saveTileTexture(e) {
									const i = this._tileTextures[e.size[0]];
									i ? i.push(e) : (this._tileTextures[e.size[0]] = [e]);
								}
								getTileTexture(e) {
									const i = this._tileTextures[e];
									return i && i.length > 0 ? i.pop() : null;
								}
								isPatternMissing(e) {
									if (!e) return !1;
									if (!e.from || !e.to) return !0;
									const i = this.imageManager.getPattern(e.from.toString()),
										l = this.imageManager.getPattern(e.to.toString());
									return !i || !l;
								}
								useProgram(e, i, l = !1, u = []) {
									this.cache = this.cache || {};
									const d = !!this.style.map.terrain,
										g = this.style.projection,
										w = l ? $r.projectionMercator : g.shaderPreludeCode,
										C = l ? Cn : g.shaderDefine,
										P =
											e +
											(i ? i.cacheKey : "") +
											`/${l ? Gn : g.shaderVariantName}` +
											(this._showOverdrawInspector ? "/overdraw" : "") +
											(d ? "/terrain" : "") +
											(u ? `/${u.join("/")}` : "");
									return (
										this.cache[P] ||
											(this.cache[P] = new Dc(
												this.context,
												$r[e],
												i,
												jc[e],
												this._showOverdrawInspector,
												d,
												w,
												C,
												u
											)),
										this.cache[P]
									);
								}
								setCustomLayerDefaults() {
									this.context.unbindVAO(),
										this.context.cullFace.setDefault(),
										this.context.activeTexture.setDefault(),
										this.context.pixelStoreUnpack.setDefault(),
										this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
										this.context.pixelStoreUnpackFlipY.setDefault();
								}
								setBaseState() {
									const e = this.context.gl;
									this.context.cullFace.set(!1),
										this.context.viewport.set([0, 0, this.width, this.height]),
										this.context.blendEquation.set(e.FUNC_ADD);
								}
								initDebugOverlayCanvas() {
									this.debugOverlayCanvas == null &&
										((this.debugOverlayCanvas =
											document.createElement("canvas")),
										(this.debugOverlayCanvas.width = 512),
										(this.debugOverlayCanvas.height = 512),
										(this.debugOverlayTexture = new s.T(
											this.context,
											this.debugOverlayCanvas,
											this.context.gl.RGBA
										)));
								}
								destroy() {
									this.debugOverlayTexture &&
										this.debugOverlayTexture.destroy();
								}
								overLimit() {
									const { drawingBufferWidth: e, drawingBufferHeight: i } =
										this.context.gl;
									return this.width !== e || this.height !== i;
								}
							}
							function Fo(h, e) {
								let i,
									l = !1,
									u = null,
									d = null;
								const g = () => {
									(u = null),
										l && (h.apply(d, i), (u = setTimeout(g, e)), (l = !1));
								};
								return (...w) => ((l = !0), (d = this), (i = w), u || g(), u);
							}
							class Fl {
								constructor(e) {
									(this._getCurrentHash = () => {
										const i = window.location.hash.replace("#", "");
										if (this._hashName) {
											let l;
											return (
												i
													.split("&")
													.map((u) => u.split("="))
													.forEach((u) => {
														u[0] === this._hashName && (l = u);
													}),
												((l && l[1]) || "").split("/")
											);
										}
										return i.split("/");
									}),
										(this._onHashChange = () => {
											const i = this._getCurrentHash();
											if (!this._isValidHash(i)) return !1;
											const l =
												this._map.dragRotate.isEnabled() &&
												this._map.touchZoomRotate.isEnabled()
													? +(i[3] || 0)
													: this._map.getBearing();
											return (
												this._map.jumpTo({
													center: [+i[2], +i[1]],
													zoom: +i[0],
													bearing: l,
													pitch: +(i[4] || 0),
												}),
												!0
											);
										}),
										(this._updateHashUnthrottled = () => {
											const i = window.location.href.replace(
												/(#.*)?$/,
												this.getHashString()
											);
											window.history.replaceState(
												window.history.state,
												null,
												i
											);
										}),
										(this._removeHash = () => {
											const i = this._getCurrentHash();
											if (i.length === 0) return;
											const l = i.join("/");
											let u = l;
											u.split("&").length > 0 && (u = u.split("&")[0]),
												this._hashName && (u = `${this._hashName}=${l}`);
											let d = window.location.hash.replace(u, "");
											d.startsWith("#&")
												? (d = d.slice(0, 1) + d.slice(2))
												: d === "#" && (d = "");
											let g = window.location.href.replace(/(#.+)?$/, d);
											(g = g.replace("&&", "&")),
												window.history.replaceState(
													window.history.state,
													null,
													g
												);
										}),
										(this._updateHash = Fo(this._updateHashUnthrottled, 300)),
										(this._hashName = e && encodeURIComponent(e));
								}
								addTo(e) {
									return (
										(this._map = e),
										addEventListener("hashchange", this._onHashChange, !1),
										this._map.on("moveend", this._updateHash),
										this
									);
								}
								remove() {
									return (
										removeEventListener("hashchange", this._onHashChange, !1),
										this._map.off("moveend", this._updateHash),
										clearTimeout(this._updateHash()),
										this._removeHash(),
										delete this._map,
										this
									);
								}
								getHashString(e) {
									const i = this._map.getCenter(),
										l = Math.round(100 * this._map.getZoom()) / 100,
										u = Math.ceil(
											(l * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
										),
										d = Math.pow(10, u),
										g = Math.round(i.lng * d) / d,
										w = Math.round(i.lat * d) / d,
										C = this._map.getBearing(),
										P = this._map.getPitch();
									let E = "";
									if (
										((E += e ? `/${g}/${w}/${l}` : `${l}/${w}/${g}`),
										(C || P) && (E += "/" + Math.round(10 * C) / 10),
										P && (E += `/${Math.round(P)}`),
										this._hashName)
									) {
										const R = this._hashName;
										let D = !1;
										const N = window.location.hash
											.slice(1)
											.split("&")
											.map((G) => {
												const te = G.split("=")[0];
												return te === R ? ((D = !0), `${te}=${E}`) : G;
											})
											.filter((G) => G);
										return D || N.push(`${R}=${E}`), `#${N.join("&")}`;
									}
									return `#${E}`;
								}
								_isValidHash(e) {
									if (e.length < 3 || e.some(isNaN)) return !1;
									try {
										new s.S(+e[2], +e[1]);
									} catch {
										return !1;
									}
									const i = +e[0],
										l = +(e[3] || 0),
										u = +(e[4] || 0);
									return (
										i >= this._map.getMinZoom() &&
										i <= this._map.getMaxZoom() &&
										l >= -180 &&
										l <= 180 &&
										u >= this._map.getMinPitch() &&
										u <= this._map.getMaxPitch()
									);
								}
							}
							const to = { linearity: 0.3, easing: s.cm(0, 0, 0.3, 1) },
								tu = s.e({ deceleration: 2500, maxSpeed: 1400 }, to),
								ld = s.e({ deceleration: 20, maxSpeed: 1400 }, to),
								cd = s.e({ deceleration: 1e3, maxSpeed: 360 }, to),
								ud = s.e({ deceleration: 1e3, maxSpeed: 90 }, to),
								hd = s.e({ deceleration: 1e3, maxSpeed: 360 }, to);
							class dd {
								constructor(e) {
									(this._map = e), this.clear();
								}
								clear() {
									this._inertiaBuffer = [];
								}
								record(e) {
									this._drainInertiaBuffer(),
										this._inertiaBuffer.push({ time: ne.now(), settings: e });
								}
								_drainInertiaBuffer() {
									const e = this._inertiaBuffer,
										i = ne.now();
									for (; e.length > 0 && i - e[0].time > 160; ) e.shift();
								}
								_onMoveEnd(e) {
									if (
										(this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
									)
										return;
									const i = {
										zoom: 0,
										bearing: 0,
										pitch: 0,
										roll: 0,
										pan: new s.P(0, 0),
										pinchAround: void 0,
										around: void 0,
									};
									for (const { settings: d } of this._inertiaBuffer)
										(i.zoom += d.zoomDelta || 0),
											(i.bearing += d.bearingDelta || 0),
											(i.pitch += d.pitchDelta || 0),
											(i.roll += d.rollDelta || 0),
											d.panDelta && i.pan._add(d.panDelta),
											d.around && (i.around = d.around),
											d.pinchAround && (i.pinchAround = d.pinchAround);
									const l =
											this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
											this._inertiaBuffer[0].time,
										u = {};
									if (i.pan.mag()) {
										const d = ns(i.pan.mag(), l, s.e({}, tu, e || {})),
											g = i.pan.mult(d.amount / i.pan.mag()),
											w = this._map.cameraHelper.handlePanInertia(
												g,
												this._map.transform
											);
										(u.center = w.easingCenter),
											(u.offset = w.easingOffset),
											Ia(u, d);
									}
									if (i.zoom) {
										const d = ns(i.zoom, l, ld);
										(u.zoom = this._map.transform.zoom + d.amount), Ia(u, d);
									}
									if (i.bearing) {
										const d = ns(i.bearing, l, cd);
										(u.bearing =
											this._map.transform.bearing + s.ah(d.amount, -179, 179)),
											Ia(u, d);
									}
									if (i.pitch) {
										const d = ns(i.pitch, l, ud);
										(u.pitch = this._map.transform.pitch + d.amount), Ia(u, d);
									}
									if (i.roll) {
										const d = ns(i.roll, l, hd);
										(u.roll =
											this._map.transform.roll + s.ah(d.amount, -179, 179)),
											Ia(u, d);
									}
									if (u.zoom || u.bearing) {
										const d =
											i.pinchAround === void 0 ? i.around : i.pinchAround;
										u.around = d
											? this._map.unproject(d)
											: this._map.getCenter();
									}
									return this.clear(), s.e(u, { noMoveStart: !0 });
								}
							}
							function Ia(h, e) {
								(!h.duration || h.duration < e.duration) &&
									((h.duration = e.duration), (h.easing = e.easing));
							}
							function ns(h, e, i) {
								const { maxSpeed: l, linearity: u, deceleration: d } = i,
									g = s.ah((h * u) / (e / 1e3), -l, l),
									w = Math.abs(g) / (d * u);
								return {
									easing: i.easing,
									duration: 1e3 * w,
									amount: g * (w / 2),
								};
							}
							class Qi extends s.l {
								preventDefault() {
									this._defaultPrevented = !0;
								}
								get defaultPrevented() {
									return this._defaultPrevented;
								}
								constructor(e, i, l, u = {}) {
									l = l instanceof MouseEvent ? l : new MouseEvent(e, l);
									const d = H.mousePos(i.getCanvas(), l),
										g = i.unproject(d);
									super(e, s.e({ point: d, lngLat: g, originalEvent: l }, u)),
										(this._defaultPrevented = !1),
										(this.target = i);
								}
							}
							class is extends s.l {
								preventDefault() {
									this._defaultPrevented = !0;
								}
								get defaultPrevented() {
									return this._defaultPrevented;
								}
								constructor(e, i, l) {
									const u = e === "touchend" ? l.changedTouches : l.touches,
										d = H.touchPos(i.getCanvasContainer(), u),
										g = d.map((C) => i.unproject(C)),
										w = d.reduce(
											(C, P, E, R) => C.add(P.div(R.length)),
											new s.P(0, 0)
										);
									super(e, {
										points: d,
										point: w,
										lngLats: g,
										lngLat: i.unproject(w),
										originalEvent: l,
									}),
										(this._defaultPrevented = !1);
								}
							}
							class ru extends s.l {
								preventDefault() {
									this._defaultPrevented = !0;
								}
								get defaultPrevented() {
									return this._defaultPrevented;
								}
								constructor(e, i, l) {
									super(e, { originalEvent: l }), (this._defaultPrevented = !1);
								}
							}
							class pd {
								constructor(e, i) {
									(this._map = e), (this._clickTolerance = i.clickTolerance);
								}
								reset() {
									delete this._mousedownPos;
								}
								wheel(e) {
									return this._firePreventable(new ru(e.type, this._map, e));
								}
								mousedown(e, i) {
									return (
										(this._mousedownPos = i),
										this._firePreventable(new Qi(e.type, this._map, e))
									);
								}
								mouseup(e) {
									this._map.fire(new Qi(e.type, this._map, e));
								}
								click(e, i) {
									(this._mousedownPos &&
										this._mousedownPos.dist(i) >= this._clickTolerance) ||
										this._map.fire(new Qi(e.type, this._map, e));
								}
								dblclick(e) {
									return this._firePreventable(new Qi(e.type, this._map, e));
								}
								mouseover(e) {
									this._map.fire(new Qi(e.type, this._map, e));
								}
								mouseout(e) {
									this._map.fire(new Qi(e.type, this._map, e));
								}
								touchstart(e) {
									return this._firePreventable(new is(e.type, this._map, e));
								}
								touchmove(e) {
									this._map.fire(new is(e.type, this._map, e));
								}
								touchend(e) {
									this._map.fire(new is(e.type, this._map, e));
								}
								touchcancel(e) {
									this._map.fire(new is(e.type, this._map, e));
								}
								_firePreventable(e) {
									if ((this._map.fire(e), e.defaultPrevented)) return {};
								}
								isEnabled() {
									return !0;
								}
								isActive() {
									return !1;
								}
								enable() {}
								disable() {}
							}
							class fd {
								constructor(e) {
									this._map = e;
								}
								reset() {
									(this._delayContextMenu = !1),
										(this._ignoreContextMenu = !0),
										delete this._contextMenuEvent;
								}
								mousemove(e) {
									this._map.fire(new Qi(e.type, this._map, e));
								}
								mousedown() {
									(this._delayContextMenu = !0), (this._ignoreContextMenu = !1);
								}
								mouseup() {
									(this._delayContextMenu = !1),
										this._contextMenuEvent &&
											(this._map.fire(
												new Qi("contextmenu", this._map, this._contextMenuEvent)
											),
											delete this._contextMenuEvent);
								}
								contextmenu(e) {
									this._delayContextMenu
										? (this._contextMenuEvent = e)
										: this._ignoreContextMenu ||
										  this._map.fire(new Qi(e.type, this._map, e)),
										this._map.listens("contextmenu") && e.preventDefault();
								}
								isEnabled() {
									return !0;
								}
								isActive() {
									return !1;
								}
								enable() {}
								disable() {}
							}
							class as {
								constructor(e) {
									this._map = e;
								}
								get transform() {
									return this._map._requestedCameraState || this._map.transform;
								}
								get center() {
									return {
										lng: this.transform.center.lng,
										lat: this.transform.center.lat,
									};
								}
								get zoom() {
									return this.transform.zoom;
								}
								get pitch() {
									return this.transform.pitch;
								}
								get bearing() {
									return this.transform.bearing;
								}
								unproject(e) {
									return this.transform.screenPointToLocation(
										s.P.convert(e),
										this._map.terrain
									);
								}
							}
							class nu {
								constructor(e, i) {
									(this._map = e),
										(this._tr = new as(e)),
										(this._el = e.getCanvasContainer()),
										(this._container = e.getContainer()),
										(this._clickTolerance = i.clickTolerance || 1);
								}
								isEnabled() {
									return !!this._enabled;
								}
								isActive() {
									return !!this._active;
								}
								enable() {
									this.isEnabled() || (this._enabled = !0);
								}
								disable() {
									this.isEnabled() && (this._enabled = !1);
								}
								mousedown(e, i) {
									this.isEnabled() &&
										e.shiftKey &&
										e.button === 0 &&
										(H.disableDrag(),
										(this._startPos = this._lastPos = i),
										(this._active = !0));
								}
								mousemoveWindow(e, i) {
									if (!this._active) return;
									const l = i;
									if (
										this._lastPos.equals(l) ||
										(!this._box &&
											l.dist(this._startPos) < this._clickTolerance)
									)
										return;
									const u = this._startPos;
									(this._lastPos = l),
										this._box ||
											((this._box = H.create(
												"div",
												"maplibregl-boxzoom",
												this._container
											)),
											this._container.classList.add("maplibregl-crosshair"),
											this._fireEvent("boxzoomstart", e));
									const d = Math.min(u.x, l.x),
										g = Math.max(u.x, l.x),
										w = Math.min(u.y, l.y),
										C = Math.max(u.y, l.y);
									H.setTransform(this._box, `translate(${d}px,${w}px)`),
										(this._box.style.width = g - d + "px"),
										(this._box.style.height = C - w + "px");
								}
								mouseupWindow(e, i) {
									if (!this._active || e.button !== 0) return;
									const l = this._startPos,
										u = i;
									if (
										(this.reset(),
										H.suppressClick(),
										l.x !== u.x || l.y !== u.y)
									)
										return (
											this._map.fire(
												new s.l("boxzoomend", { originalEvent: e })
											),
											{
												cameraAnimation: (d) =>
													d.fitScreenCoordinates(l, u, this._tr.bearing, {
														linear: !0,
													}),
											}
										);
									this._fireEvent("boxzoomcancel", e);
								}
								keydown(e) {
									this._active &&
										e.keyCode === 27 &&
										(this.reset(), this._fireEvent("boxzoomcancel", e));
								}
								reset() {
									(this._active = !1),
										this._container.classList.remove("maplibregl-crosshair"),
										this._box && (H.remove(this._box), (this._box = null)),
										H.enableDrag(),
										delete this._startPos,
										delete this._lastPos;
								}
								_fireEvent(e, i) {
									return this._map.fire(new s.l(e, { originalEvent: i }));
								}
							}
							function os(h, e) {
								if (h.length !== e.length)
									throw new Error(
										`The number of touches and points are not equal - touches ${h.length}, points ${e.length}`
									);
								const i = {};
								for (let l = 0; l < h.length; l++) i[h[l].identifier] = e[l];
								return i;
							}
							class md {
								constructor(e) {
									this.reset(), (this.numTouches = e.numTouches);
								}
								reset() {
									delete this.centroid,
										delete this.startTime,
										delete this.touches,
										(this.aborted = !1);
								}
								touchstart(e, i, l) {
									(this.centroid || l.length > this.numTouches) &&
										(this.aborted = !0),
										this.aborted ||
											(this.startTime === void 0 &&
												(this.startTime = e.timeStamp),
											l.length === this.numTouches &&
												((this.centroid = (function (u) {
													const d = new s.P(0, 0);
													for (const g of u) d._add(g);
													return d.div(u.length);
												})(i)),
												(this.touches = os(l, i))));
								}
								touchmove(e, i, l) {
									if (this.aborted || !this.centroid) return;
									const u = os(l, i);
									for (const d in this.touches) {
										const g = u[d];
										(!g || g.dist(this.touches[d]) > 30) && (this.aborted = !0);
									}
								}
								touchend(e, i, l) {
									if (
										((!this.centroid || e.timeStamp - this.startTime > 500) &&
											(this.aborted = !0),
										l.length === 0)
									) {
										const u = !this.aborted && this.centroid;
										if ((this.reset(), u)) return u;
									}
								}
							}
							class ea {
								constructor(e) {
									(this.singleTap = new md(e)),
										(this.numTaps = e.numTaps),
										this.reset();
								}
								reset() {
									(this.lastTime = 1 / 0),
										delete this.lastTap,
										(this.count = 0),
										this.singleTap.reset();
								}
								touchstart(e, i, l) {
									this.singleTap.touchstart(e, i, l);
								}
								touchmove(e, i, l) {
									this.singleTap.touchmove(e, i, l);
								}
								touchend(e, i, l) {
									const u = this.singleTap.touchend(e, i, l);
									if (u) {
										const d = e.timeStamp - this.lastTime < 500,
											g = !this.lastTap || this.lastTap.dist(u) < 30;
										if (
											((d && g) || this.reset(),
											this.count++,
											(this.lastTime = e.timeStamp),
											(this.lastTap = u),
											this.count === this.numTaps)
										)
											return this.reset(), u;
									}
								}
							}
							class Ma {
								constructor(e) {
									(this._tr = new as(e)),
										(this._zoomIn = new ea({ numTouches: 1, numTaps: 2 })),
										(this._zoomOut = new ea({ numTouches: 2, numTaps: 1 })),
										this.reset();
								}
								reset() {
									(this._active = !1),
										this._zoomIn.reset(),
										this._zoomOut.reset();
								}
								touchstart(e, i, l) {
									this._zoomIn.touchstart(e, i, l),
										this._zoomOut.touchstart(e, i, l);
								}
								touchmove(e, i, l) {
									this._zoomIn.touchmove(e, i, l),
										this._zoomOut.touchmove(e, i, l);
								}
								touchend(e, i, l) {
									const u = this._zoomIn.touchend(e, i, l),
										d = this._zoomOut.touchend(e, i, l),
										g = this._tr;
									return u
										? ((this._active = !0),
										  e.preventDefault(),
										  setTimeout(() => this.reset(), 0),
										  {
												cameraAnimation: (w) =>
													w.easeTo(
														{
															duration: 300,
															zoom: g.zoom + 1,
															around: g.unproject(u),
														},
														{ originalEvent: e }
													),
										  })
										: d
										? ((this._active = !0),
										  e.preventDefault(),
										  setTimeout(() => this.reset(), 0),
										  {
												cameraAnimation: (w) =>
													w.easeTo(
														{
															duration: 300,
															zoom: g.zoom - 1,
															around: g.unproject(d),
														},
														{ originalEvent: e }
													),
										  })
										: void 0;
								}
								touchcancel() {
									this.reset();
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
							}
							class ss {
								constructor(e) {
									(this._enabled = !!e.enable),
										(this._moveStateManager = e.moveStateManager),
										(this._clickTolerance = e.clickTolerance || 1),
										(this._moveFunction = e.move),
										(this._activateOnStart = !!e.activateOnStart),
										e.assignEvents(this),
										this.reset();
								}
								reset(e) {
									(this._active = !1),
										(this._moved = !1),
										delete this._lastPoint,
										this._moveStateManager.endMove(e);
								}
								_move(...e) {
									const i = this._moveFunction(...e);
									if (
										i.bearingDelta ||
										i.pitchDelta ||
										i.rollDelta ||
										i.around ||
										i.panDelta
									)
										return (this._active = !0), i;
								}
								dragStart(e, i) {
									this.isEnabled() &&
										!this._lastPoint &&
										this._moveStateManager.isValidStartEvent(e) &&
										(this._moveStateManager.startMove(e),
										(this._lastPoint = Array.isArray(i) ? i[0] : i),
										this._activateOnStart &&
											this._lastPoint &&
											(this._active = !0));
								}
								dragMove(e, i) {
									if (!this.isEnabled()) return;
									const l = this._lastPoint;
									if (!l) return;
									if (
										(e.preventDefault(),
										!this._moveStateManager.isValidMoveEvent(e))
									)
										return void this.reset(e);
									const u = Array.isArray(i) ? i[0] : i;
									return !this._moved && u.dist(l) < this._clickTolerance
										? void 0
										: ((this._moved = !0),
										  (this._lastPoint = u),
										  this._move(l, u));
								}
								dragEnd(e) {
									this.isEnabled() &&
										this._lastPoint &&
										this._moveStateManager.isValidEndEvent(e) &&
										(this._moved && H.suppressClick(), this.reset(e));
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
								getClickTolerance() {
									return this._clickTolerance;
								}
							}
							const ka = 0,
								ls = 2,
								jp = { [ka]: 1, [ls]: 2 };
							class Ws {
								constructor(e) {
									this._correctEvent = e.checkCorrectEvent;
								}
								startMove(e) {
									const i = H.mouseButton(e);
									this._eventButton = i;
								}
								endMove(e) {
									delete this._eventButton;
								}
								isValidStartEvent(e) {
									return this._correctEvent(e);
								}
								isValidMoveEvent(e) {
									return !(function (i, l) {
										const u = jp[l];
										return i.buttons === void 0 || (i.buttons & u) !== u;
									})(e, this._eventButton);
								}
								isValidEndEvent(e) {
									return H.mouseButton(e) === this._eventButton;
								}
							}
							class Vp {
								constructor() {
									this._firstTouch = void 0;
								}
								_isOneFingerTouch(e) {
									return e.targetTouches.length === 1;
								}
								_isSameTouchEvent(e) {
									return e.targetTouches[0].identifier === this._firstTouch;
								}
								startMove(e) {
									this._firstTouch = e.targetTouches[0].identifier;
								}
								endMove(e) {
									delete this._firstTouch;
								}
								isValidStartEvent(e) {
									return this._isOneFingerTouch(e);
								}
								isValidMoveEvent(e) {
									return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
								}
								isValidEndEvent(e) {
									return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
								}
							}
							class qp {
								constructor(
									e = new Ws({ checkCorrectEvent: () => !0 }),
									i = new Vp()
								) {
									(this.mouseMoveStateManager = e),
										(this.oneFingerTouchMoveStateManager = i);
								}
								_executeRelevantHandler(e, i, l) {
									return e instanceof MouseEvent
										? i(e)
										: typeof TouchEvent < "u" && e instanceof TouchEvent
										? l(e)
										: void 0;
								}
								startMove(e) {
									this._executeRelevantHandler(
										e,
										(i) => this.mouseMoveStateManager.startMove(i),
										(i) => this.oneFingerTouchMoveStateManager.startMove(i)
									);
								}
								endMove(e) {
									this._executeRelevantHandler(
										e,
										(i) => this.mouseMoveStateManager.endMove(i),
										(i) => this.oneFingerTouchMoveStateManager.endMove(i)
									);
								}
								isValidStartEvent(e) {
									return this._executeRelevantHandler(
										e,
										(i) => this.mouseMoveStateManager.isValidStartEvent(i),
										(i) =>
											this.oneFingerTouchMoveStateManager.isValidStartEvent(i)
									);
								}
								isValidMoveEvent(e) {
									return this._executeRelevantHandler(
										e,
										(i) => this.mouseMoveStateManager.isValidMoveEvent(i),
										(i) =>
											this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)
									);
								}
								isValidEndEvent(e) {
									return this._executeRelevantHandler(
										e,
										(i) => this.mouseMoveStateManager.isValidEndEvent(i),
										(i) =>
											this.oneFingerTouchMoveStateManager.isValidEndEvent(i)
									);
								}
							}
							const Xs = (h) => {
								(h.mousedown = h.dragStart),
									(h.mousemoveWindow = h.dragMove),
									(h.mouseup = h.dragEnd),
									(h.contextmenu = (e) => {
										e.preventDefault();
									});
							};
							class Ys {
								constructor(e, i) {
									(this._clickTolerance = e.clickTolerance || 1),
										(this._map = i),
										this.reset();
								}
								reset() {
									(this._active = !1),
										(this._touches = {}),
										(this._sum = new s.P(0, 0));
								}
								_shouldBePrevented(e) {
									return (
										e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
									);
								}
								touchstart(e, i, l) {
									return this._calculateTransform(e, i, l);
								}
								touchmove(e, i, l) {
									if (this._active) {
										if (!this._shouldBePrevented(l.length))
											return (
												e.preventDefault(), this._calculateTransform(e, i, l)
											);
										this._map.cooperativeGestures.notifyGestureBlocked(
											"touch_pan",
											e
										);
									}
								}
								touchend(e, i, l) {
									this._calculateTransform(e, i, l),
										this._active &&
											this._shouldBePrevented(l.length) &&
											this.reset();
								}
								touchcancel() {
									this.reset();
								}
								_calculateTransform(e, i, l) {
									l.length > 0 && (this._active = !0);
									const u = os(l, i),
										d = new s.P(0, 0),
										g = new s.P(0, 0);
									let w = 0;
									for (const P in u) {
										const E = u[P],
											R = this._touches[P];
										R && (d._add(E), g._add(E.sub(R)), w++, (u[P] = E));
									}
									if (
										((this._touches = u),
										this._shouldBePrevented(w) || !g.mag())
									)
										return;
									const C = g.div(w);
									return (
										this._sum._add(C),
										this._sum.mag() < this._clickTolerance
											? void 0
											: { around: d.div(w), panDelta: C }
									);
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
							}
							class Aa {
								constructor() {
									this.reset();
								}
								reset() {
									(this._active = !1), delete this._firstTwoTouches;
								}
								touchstart(e, i, l) {
									this._firstTwoTouches ||
										l.length < 2 ||
										((this._firstTwoTouches = [
											l[0].identifier,
											l[1].identifier,
										]),
										this._start([i[0], i[1]]));
								}
								touchmove(e, i, l) {
									if (!this._firstTwoTouches) return;
									e.preventDefault();
									const [u, d] = this._firstTwoTouches,
										g = ir(l, i, u),
										w = ir(l, i, d);
									if (!g || !w) return;
									const C = this._aroundCenter ? null : g.add(w).div(2);
									return this._move([g, w], C, e);
								}
								touchend(e, i, l) {
									if (!this._firstTwoTouches) return;
									const [u, d] = this._firstTwoTouches,
										g = ir(l, i, u),
										w = ir(l, i, d);
									(g && w) || (this._active && H.suppressClick(), this.reset());
								}
								touchcancel() {
									this.reset();
								}
								enable(e) {
									(this._enabled = !0),
										(this._aroundCenter = !!e && e.around === "center");
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return !!this._enabled;
								}
								isActive() {
									return !!this._active;
								}
							}
							function ir(h, e, i) {
								for (let l = 0; l < h.length; l++)
									if (h[l].identifier === i) return e[l];
							}
							function iu(h, e) {
								return Math.log(h / e) / Math.LN2;
							}
							class Ol extends Aa {
								reset() {
									super.reset(),
										delete this._distance,
										delete this._startDistance;
								}
								_start(e) {
									this._startDistance = this._distance = e[0].dist(e[1]);
								}
								_move(e, i) {
									const l = this._distance;
									if (
										((this._distance = e[0].dist(e[1])),
										this._active ||
											!(
												Math.abs(iu(this._distance, this._startDistance)) < 0.1
											))
									)
										return (
											(this._active = !0),
											{ zoomDelta: iu(this._distance, l), pinchAround: i }
										);
								}
							}
							function au(h, e) {
								return (180 * h.angleWith(e)) / Math.PI;
							}
							class cs extends Aa {
								reset() {
									super.reset(),
										delete this._minDiameter,
										delete this._startVector,
										delete this._vector;
								}
								_start(e) {
									(this._startVector = this._vector = e[0].sub(e[1])),
										(this._minDiameter = e[0].dist(e[1]));
								}
								_move(e, i, l) {
									const u = this._vector;
									if (
										((this._vector = e[0].sub(e[1])),
										this._active || !this._isBelowThreshold(this._vector))
									)
										return (
											(this._active = !0),
											{ bearingDelta: au(this._vector, u), pinchAround: i }
										);
								}
								_isBelowThreshold(e) {
									this._minDiameter = Math.min(this._minDiameter, e.mag());
									const i = (25 / (Math.PI * this._minDiameter)) * 360,
										l = au(e, this._startVector);
									return Math.abs(l) < i;
								}
							}
							function Oo(h) {
								return Math.abs(h.y) > Math.abs(h.x);
							}
							class Nl extends Aa {
								constructor(e) {
									super(), (this._currentTouchCount = 0), (this._map = e);
								}
								reset() {
									super.reset(),
										(this._valid = void 0),
										delete this._firstMove,
										delete this._lastPoints;
								}
								touchstart(e, i, l) {
									super.touchstart(e, i, l),
										(this._currentTouchCount = l.length);
								}
								_start(e) {
									(this._lastPoints = e),
										Oo(e[0].sub(e[1])) && (this._valid = !1);
								}
								_move(e, i, l) {
									if (
										this._map.cooperativeGestures.isEnabled() &&
										this._currentTouchCount < 3
									)
										return;
									const u = e[0].sub(this._lastPoints[0]),
										d = e[1].sub(this._lastPoints[1]);
									return (
										(this._valid = this.gestureBeginsVertically(
											u,
											d,
											l.timeStamp
										)),
										this._valid
											? ((this._lastPoints = e),
											  (this._active = !0),
											  { pitchDelta: ((u.y + d.y) / 2) * -0.5 })
											: void 0
									);
								}
								gestureBeginsVertically(e, i, l) {
									if (this._valid !== void 0) return this._valid;
									const u = e.mag() >= 2,
										d = i.mag() >= 2;
									if (!u && !d) return;
									if (!u || !d)
										return (
											this._firstMove === void 0 && (this._firstMove = l),
											l - this._firstMove < 100 && void 0
										);
									const g = e.y > 0 == i.y > 0;
									return Oo(e) && Oo(i) && g;
								}
							}
							const hn = { panStep: 100, bearingStep: 15, pitchStep: 10 };
							class jl {
								constructor(e) {
									this._tr = new as(e);
									const i = hn;
									(this._panStep = i.panStep),
										(this._bearingStep = i.bearingStep),
										(this._pitchStep = i.pitchStep),
										(this._rotationDisabled = !1);
								}
								reset() {
									this._active = !1;
								}
								keydown(e) {
									if (e.altKey || e.ctrlKey || e.metaKey) return;
									let i = 0,
										l = 0,
										u = 0,
										d = 0,
										g = 0;
									switch (e.keyCode) {
										case 61:
										case 107:
										case 171:
										case 187:
											i = 1;
											break;
										case 189:
										case 109:
										case 173:
											i = -1;
											break;
										case 37:
											e.shiftKey ? (l = -1) : (e.preventDefault(), (d = -1));
											break;
										case 39:
											e.shiftKey ? (l = 1) : (e.preventDefault(), (d = 1));
											break;
										case 38:
											e.shiftKey ? (u = 1) : (e.preventDefault(), (g = -1));
											break;
										case 40:
											e.shiftKey ? (u = -1) : (e.preventDefault(), (g = 1));
											break;
										default:
											return;
									}
									return (
										this._rotationDisabled && ((l = 0), (u = 0)),
										{
											cameraAnimation: (w) => {
												const C = this._tr;
												w.easeTo(
													{
														duration: 300,
														easeId: "keyboardHandler",
														easing: Zp,
														zoom: i
															? Math.round(C.zoom) + i * (e.shiftKey ? 2 : 1)
															: C.zoom,
														bearing: C.bearing + l * this._bearingStep,
														pitch: C.pitch + u * this._pitchStep,
														offset: [-d * this._panStep, -g * this._panStep],
														center: C.center,
													},
													{ originalEvent: e }
												);
											},
										}
									);
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
								disableRotation() {
									this._rotationDisabled = !0;
								}
								enableRotation() {
									this._rotationDisabled = !1;
								}
							}
							function Zp(h) {
								return h * (2 - h);
							}
							const Vl = 4.000244140625,
								Up = 1 / 450;
							class _d {
								constructor(e, i) {
									(this._onTimeout = (l) => {
										(this._type = "wheel"),
											(this._delta -= this._lastValue),
											this._active || this._start(l);
									}),
										(this._map = e),
										(this._tr = new as(e)),
										(this._triggerRenderFrame = i),
										(this._delta = 0),
										(this._defaultZoomRate = 0.01),
										(this._wheelZoomRate = Up);
								}
								setZoomRate(e) {
									this._defaultZoomRate = e;
								}
								setWheelZoomRate(e) {
									this._wheelZoomRate = e;
								}
								isEnabled() {
									return !!this._enabled;
								}
								isActive() {
									return !!this._active || this._finishTimeout !== void 0;
								}
								isZooming() {
									return !!this._zooming;
								}
								enable(e) {
									this.isEnabled() ||
										((this._enabled = !0),
										(this._aroundCenter = !!e && e.around === "center"));
								}
								disable() {
									this.isEnabled() && (this._enabled = !1);
								}
								_shouldBePrevented(e) {
									return (
										!!this._map.cooperativeGestures.isEnabled() &&
										!(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
									);
								}
								wheel(e) {
									if (!this.isEnabled()) return;
									if (this._shouldBePrevented(e))
										return void this._map.cooperativeGestures.notifyGestureBlocked(
											"wheel_zoom",
											e
										);
									let i =
										e.deltaMode === WheelEvent.DOM_DELTA_LINE
											? 40 * e.deltaY
											: e.deltaY;
									const l = ne.now(),
										u = l - (this._lastWheelEventTime || 0);
									(this._lastWheelEventTime = l),
										i !== 0 && i % Vl == 0
											? (this._type = "wheel")
											: i !== 0 && Math.abs(i) < 4
											? (this._type = "trackpad")
											: u > 400
											? ((this._type = null),
											  (this._lastValue = i),
											  (this._timeout = setTimeout(this._onTimeout, 40, e)))
											: this._type ||
											  ((this._type =
													Math.abs(u * i) < 200 ? "trackpad" : "wheel"),
											  this._timeout &&
													(clearTimeout(this._timeout),
													(this._timeout = null),
													(i += this._lastValue))),
										e.shiftKey && i && (i /= 4),
										this._type &&
											((this._lastWheelEvent = e),
											(this._delta -= i),
											this._active || this._start(e)),
										e.preventDefault();
								}
								_start(e) {
									if (!this._delta) return;
									this._frameId && (this._frameId = null),
										(this._active = !0),
										this.isZooming() || (this._zooming = !0),
										this._finishTimeout &&
											(clearTimeout(this._finishTimeout),
											delete this._finishTimeout);
									const i = H.mousePos(this._map.getCanvas(), e),
										l = this._tr;
									(this._aroundPoint = this._aroundCenter
										? l.transform.locationToScreenPoint(s.S.convert(l.center))
										: i),
										this._frameId ||
											((this._frameId = !0), this._triggerRenderFrame());
								}
								renderFrame() {
									if (
										!this._frameId ||
										((this._frameId = null), !this.isActive())
									)
										return;
									const e = this._tr.transform;
									if (typeof this._lastExpectedZoom == "number") {
										const w = e.zoom - this._lastExpectedZoom;
										typeof this._startZoom == "number" &&
											(this._startZoom += w),
											typeof this._targetZoom == "number" &&
												(this._targetZoom += w);
									}
									if (this._delta !== 0) {
										const w =
											this._type === "wheel" && Math.abs(this._delta) > Vl
												? this._wheelZoomRate
												: this._defaultZoomRate;
										let C = 2 / (1 + Math.exp(-Math.abs(this._delta * w)));
										this._delta < 0 && C !== 0 && (C = 1 / C);
										const P =
											typeof this._targetZoom != "number"
												? e.scale
												: s.af(this._targetZoom);
										(this._targetZoom = e.getConstrained(
											e.getCameraLngLat(),
											s.ak(P * C)
										).zoom),
											this._type === "wheel" &&
												((this._startZoom = e.zoom),
												(this._easing = this._smoothOutEasing(200))),
											(this._delta = 0);
									}
									const i =
											typeof this._targetZoom != "number"
												? e.zoom
												: this._targetZoom,
										l = this._startZoom,
										u = this._easing;
									let d,
										g = !1;
									if (this._type === "wheel" && l && u) {
										const w = ne.now() - this._lastWheelEventTime,
											C = Math.min((w + 5) / 200, 1),
											P = u(C);
										(d = s.C.number(l, i, P)),
											C < 1 ? this._frameId || (this._frameId = !0) : (g = !0);
									} else (d = i), (g = !0);
									return (
										(this._active = !0),
										g &&
											((this._active = !1),
											(this._finishTimeout = setTimeout(() => {
												(this._zooming = !1),
													this._triggerRenderFrame(),
													delete this._targetZoom,
													delete this._lastExpectedZoom,
													delete this._finishTimeout;
											}, 200))),
										(this._lastExpectedZoom = d),
										{
											noInertia: !0,
											needsRenderFrame: !g,
											zoomDelta: d - e.zoom,
											around: this._aroundPoint,
											originalEvent: this._lastWheelEvent,
										}
									);
								}
								_smoothOutEasing(e) {
									let i = s.co;
									if (this._prevEase) {
										const l = this._prevEase,
											u = (ne.now() - l.start) / l.duration,
											d = l.easing(u + 0.01) - l.easing(u),
											g = (0.27 / Math.sqrt(d * d + 1e-4)) * 0.01,
											w = Math.sqrt(0.0729 - g * g);
										i = s.cm(g, w, 0.25, 1);
									}
									return (
										(this._prevEase = {
											start: ne.now(),
											duration: e,
											easing: i,
										}),
										i
									);
								}
								reset() {
									(this._active = !1),
										(this._zooming = !1),
										delete this._targetZoom,
										delete this._lastExpectedZoom,
										this._finishTimeout &&
											(clearTimeout(this._finishTimeout),
											delete this._finishTimeout);
								}
							}
							class ou {
								constructor(e, i) {
									(this._clickZoom = e), (this._tapZoom = i);
								}
								enable() {
									this._clickZoom.enable(), this._tapZoom.enable();
								}
								disable() {
									this._clickZoom.disable(), this._tapZoom.disable();
								}
								isEnabled() {
									return (
										this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
									);
								}
								isActive() {
									return this._clickZoom.isActive() || this._tapZoom.isActive();
								}
							}
							class su {
								constructor(e) {
									(this._tr = new as(e)), this.reset();
								}
								reset() {
									this._active = !1;
								}
								dblclick(e, i) {
									return (
										e.preventDefault(),
										{
											cameraAnimation: (l) => {
												l.easeTo(
													{
														duration: 300,
														zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
														around: this._tr.unproject(i),
													},
													{ originalEvent: e }
												);
											},
										}
									);
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
							}
							class gd {
								constructor() {
									(this._tap = new ea({ numTouches: 1, numTaps: 1 })),
										this.reset();
								}
								reset() {
									(this._active = !1),
										delete this._swipePoint,
										delete this._swipeTouch,
										delete this._tapTime,
										delete this._tapPoint,
										this._tap.reset();
								}
								touchstart(e, i, l) {
									if (!this._swipePoint)
										if (this._tapTime) {
											const u = i[0],
												d = e.timeStamp - this._tapTime < 500,
												g = this._tapPoint.dist(u) < 30;
											d && g
												? l.length > 0 &&
												  ((this._swipePoint = u),
												  (this._swipeTouch = l[0].identifier))
												: this.reset();
										} else this._tap.touchstart(e, i, l);
								}
								touchmove(e, i, l) {
									if (this._tapTime) {
										if (this._swipePoint) {
											if (l[0].identifier !== this._swipeTouch) return;
											const u = i[0],
												d = u.y - this._swipePoint.y;
											return (
												(this._swipePoint = u),
												e.preventDefault(),
												(this._active = !0),
												{ zoomDelta: d / 128 }
											);
										}
									} else this._tap.touchmove(e, i, l);
								}
								touchend(e, i, l) {
									if (this._tapTime)
										this._swipePoint && l.length === 0 && this.reset();
									else {
										const u = this._tap.touchend(e, i, l);
										u && ((this._tapTime = e.timeStamp), (this._tapPoint = u));
									}
								}
								touchcancel() {
									this.reset();
								}
								enable() {
									this._enabled = !0;
								}
								disable() {
									(this._enabled = !1), this.reset();
								}
								isEnabled() {
									return this._enabled;
								}
								isActive() {
									return this._active;
								}
							}
							class vd {
								constructor(e, i, l) {
									(this._el = e), (this._mousePan = i), (this._touchPan = l);
								}
								enable(e) {
									(this._inertiaOptions = e || {}),
										this._mousePan.enable(),
										this._touchPan.enable(),
										this._el.classList.add("maplibregl-touch-drag-pan");
								}
								disable() {
									this._mousePan.disable(),
										this._touchPan.disable(),
										this._el.classList.remove("maplibregl-touch-drag-pan");
								}
								isEnabled() {
									return (
										this._mousePan.isEnabled() && this._touchPan.isEnabled()
									);
								}
								isActive() {
									return this._mousePan.isActive() || this._touchPan.isActive();
								}
							}
							class lu {
								constructor(e, i, l, u) {
									(this._pitchWithRotate = e.pitchWithRotate),
										(this._rollEnabled = e.rollEnabled),
										(this._mouseRotate = i),
										(this._mousePitch = l),
										(this._mouseRoll = u);
								}
								enable() {
									this._mouseRotate.enable(),
										this._pitchWithRotate && this._mousePitch.enable(),
										this._rollEnabled && this._mouseRoll.enable();
								}
								disable() {
									this._mouseRotate.disable(),
										this._mousePitch.disable(),
										this._mouseRoll.disable();
								}
								isEnabled() {
									return (
										this._mouseRotate.isEnabled() &&
										(!this._pitchWithRotate || this._mousePitch.isEnabled()) &&
										(!this._rollEnabled || this._mouseRoll.isEnabled())
									);
								}
								isActive() {
									return (
										this._mouseRotate.isActive() ||
										this._mousePitch.isActive() ||
										this._mouseRoll.isActive()
									);
								}
							}
							class yd {
								constructor(e, i, l, u) {
									(this._el = e),
										(this._touchZoom = i),
										(this._touchRotate = l),
										(this._tapDragZoom = u),
										(this._rotationDisabled = !1),
										(this._enabled = !0);
								}
								enable(e) {
									this._touchZoom.enable(e),
										this._rotationDisabled || this._touchRotate.enable(e),
										this._tapDragZoom.enable(),
										this._el.classList.add("maplibregl-touch-zoom-rotate");
								}
								disable() {
									this._touchZoom.disable(),
										this._touchRotate.disable(),
										this._tapDragZoom.disable(),
										this._el.classList.remove("maplibregl-touch-zoom-rotate");
								}
								isEnabled() {
									return (
										this._touchZoom.isEnabled() &&
										(this._rotationDisabled || this._touchRotate.isEnabled()) &&
										this._tapDragZoom.isEnabled()
									);
								}
								isActive() {
									return (
										this._touchZoom.isActive() ||
										this._touchRotate.isActive() ||
										this._tapDragZoom.isActive()
									);
								}
								disableRotation() {
									(this._rotationDisabled = !0), this._touchRotate.disable();
								}
								enableRotation() {
									(this._rotationDisabled = !1),
										this._touchZoom.isEnabled() && this._touchRotate.enable();
								}
							}
							class xd {
								constructor(e, i) {
									(this._bypassKey =
										navigator.userAgent.indexOf("Mac") !== -1
											? "metaKey"
											: "ctrlKey"),
										(this._map = e),
										(this._options = i),
										(this._enabled = !1);
								}
								isActive() {
									return !1;
								}
								reset() {}
								_setupUI() {
									if (this._container) return;
									const e = this._map.getCanvasContainer();
									e.classList.add("maplibregl-cooperative-gestures"),
										(this._container = H.create(
											"div",
											"maplibregl-cooperative-gesture-screen",
											e
										));
									let i = this._map._getUIString(
										"CooperativeGesturesHandler.WindowsHelpText"
									);
									this._bypassKey === "metaKey" &&
										(i = this._map._getUIString(
											"CooperativeGesturesHandler.MacHelpText"
										));
									const l = this._map._getUIString(
											"CooperativeGesturesHandler.MobileHelpText"
										),
										u = document.createElement("div");
									(u.className = "maplibregl-desktop-message"),
										(u.textContent = i),
										this._container.appendChild(u);
									const d = document.createElement("div");
									(d.className = "maplibregl-mobile-message"),
										(d.textContent = l),
										this._container.appendChild(d),
										this._container.setAttribute("aria-hidden", "true");
								}
								_destroyUI() {
									this._container &&
										(H.remove(this._container),
										this._map
											.getCanvasContainer()
											.classList.remove("maplibregl-cooperative-gestures")),
										delete this._container;
								}
								enable() {
									this._setupUI(), (this._enabled = !0);
								}
								disable() {
									(this._enabled = !1), this._destroyUI();
								}
								isEnabled() {
									return this._enabled;
								}
								isBypassed(e) {
									return e[this._bypassKey];
								}
								notifyGestureBlocked(e, i) {
									this._enabled &&
										(this._map.fire(
											new s.l("cooperativegestureprevented", {
												gestureType: e,
												originalEvent: i,
											})
										),
										this._container.classList.add("maplibregl-show"),
										setTimeout(() => {
											this._container.classList.remove("maplibregl-show");
										}, 100));
								}
							}
							const Ea = (h) =>
								h.zoom || h.drag || h.roll || h.pitch || h.rotate;
							class Un extends s.l {}
							function us(h) {
								return (
									(h.panDelta && h.panDelta.mag()) ||
									h.zoomDelta ||
									h.bearingDelta ||
									h.pitchDelta ||
									h.rollDelta
								);
							}
							class cu {
								constructor(e, i) {
									(this.handleWindowEvent = (u) => {
										this.handleEvent(u, `${u.type}Window`);
									}),
										(this.handleEvent = (u, d) => {
											if (u.type === "blur") return void this.stop(!0);
											this._updatingCamera = !0;
											const g = u.type === "renderFrame" ? void 0 : u,
												w = { needsRenderFrame: !1 },
												C = {},
												P = {};
											for (const {
												handlerName: D,
												handler: N,
												allowed: G,
											} of this._handlers) {
												if (!N.isEnabled()) continue;
												let te;
												if (this._blockedByActive(P, G, D)) N.reset();
												else if (N[d || u.type]) {
													if (s.cp(u, d || u.type)) {
														const Q = H.mousePos(this._map.getCanvas(), u);
														te = N[d || u.type](u, Q);
													} else if (s.cq(u, d || u.type)) {
														const Q = this._getMapTouches(u.touches),
															ae = H.touchPos(this._map.getCanvas(), Q);
														te = N[d || u.type](u, ae, Q);
													} else s.cr(d || u.type) || (te = N[d || u.type](u));
													this.mergeHandlerResult(w, C, te, D, g),
														te &&
															te.needsRenderFrame &&
															this._triggerRenderFrame();
												}
												(te || N.isActive()) && (P[D] = N);
											}
											const E = {};
											for (const D in this._previousActiveHandlers)
												P[D] || (E[D] = g);
											(this._previousActiveHandlers = P),
												(Object.keys(E).length || us(w)) &&
													(this._changes.push([w, C, E]),
													this._triggerRenderFrame()),
												(Object.keys(P).length || us(w)) && this._map._stop(!0),
												(this._updatingCamera = !1);
											const { cameraAnimation: R } = w;
											R &&
												(this._inertia.clear(),
												this._fireEvents({}, {}, !0),
												(this._changes = []),
												R(this._map));
										}),
										(this._map = e),
										(this._el = this._map.getCanvasContainer()),
										(this._handlers = []),
										(this._handlersById = {}),
										(this._changes = []),
										(this._inertia = new dd(e)),
										(this._bearingSnap = i.bearingSnap),
										(this._previousActiveHandlers = {}),
										(this._eventsInProgress = {}),
										this._addDefaultHandlers(i);
									const l = this._el;
									this._listeners = [
										[l, "touchstart", { passive: !0 }],
										[l, "touchmove", { passive: !1 }],
										[l, "touchend", void 0],
										[l, "touchcancel", void 0],
										[l, "mousedown", void 0],
										[l, "mousemove", void 0],
										[l, "mouseup", void 0],
										[document, "mousemove", { capture: !0 }],
										[document, "mouseup", void 0],
										[l, "mouseover", void 0],
										[l, "mouseout", void 0],
										[l, "dblclick", void 0],
										[l, "click", void 0],
										[l, "keydown", { capture: !1 }],
										[l, "keyup", void 0],
										[l, "wheel", { passive: !1 }],
										[l, "contextmenu", void 0],
										[window, "blur", void 0],
									];
									for (const [u, d, g] of this._listeners)
										H.addEventListener(
											u,
											d,
											u === document
												? this.handleWindowEvent
												: this.handleEvent,
											g
										);
								}
								destroy() {
									for (const [e, i, l] of this._listeners)
										H.removeEventListener(
											e,
											i,
											e === document
												? this.handleWindowEvent
												: this.handleEvent,
											l
										);
								}
								_addDefaultHandlers(e) {
									const i = this._map,
										l = i.getCanvasContainer();
									this._add("mapEvent", new pd(i, e));
									const u = (i.boxZoom = new nu(i, e));
									this._add("boxZoom", u),
										e.interactive && e.boxZoom && u.enable();
									const d = (i.cooperativeGestures = new xd(
										i,
										e.cooperativeGestures
									));
									this._add("cooperativeGestures", d),
										e.cooperativeGestures && d.enable();
									const g = new Ma(i),
										w = new su(i);
									(i.doubleClickZoom = new ou(w, g)),
										this._add("tapZoom", g),
										this._add("clickZoom", w),
										e.interactive &&
											e.doubleClickZoom &&
											i.doubleClickZoom.enable();
									const C = new gd();
									this._add("tapDragZoom", C);
									const P = (i.touchPitch = new Nl(i));
									this._add("touchPitch", P),
										e.interactive &&
											e.touchPitch &&
											i.touchPitch.enable(e.touchPitch);
									const E = () => i.project(i.getCenter()),
										R = (function (
											{
												enable: me,
												clickTolerance: be,
												aroundCenter: Pe = !0,
												minPixelCenterThreshold: _e = 100,
												rotateDegreesPerPixelMoved: Be = 0.8,
											},
											rt
										) {
											const Ge = new Ws({
												checkCorrectEvent: (Xe) =>
													(H.mouseButton(Xe) === 0 && Xe.ctrlKey) ||
													(H.mouseButton(Xe) === 2 && !Xe.ctrlKey),
											});
											return new ss({
												clickTolerance: be,
												move: (Xe, tt) => {
													const jt = rt();
													if (Pe && Math.abs(jt.y - Xe.y) > _e)
														return {
															bearingDelta: s.cn(new s.P(Xe.x, tt.y), tt, jt),
														};
													let Zt = (tt.x - Xe.x) * Be;
													return (
														Pe && tt.y < jt.y && (Zt = -Zt),
														{ bearingDelta: Zt }
													);
												},
												moveStateManager: Ge,
												enable: me,
												assignEvents: Xs,
											});
										})(e, E),
										D = (function ({
											enable: me,
											clickTolerance: be,
											pitchDegreesPerPixelMoved: Pe = -0.5,
										}) {
											const _e = new Ws({
												checkCorrectEvent: (Be) =>
													(H.mouseButton(Be) === 0 && Be.ctrlKey) ||
													H.mouseButton(Be) === 2,
											});
											return new ss({
												clickTolerance: be,
												move: (Be, rt) => ({ pitchDelta: (rt.y - Be.y) * Pe }),
												moveStateManager: _e,
												enable: me,
												assignEvents: Xs,
											});
										})(e),
										N = (function (
											{
												enable: me,
												clickTolerance: be,
												rollDegreesPerPixelMoved: Pe = 0.3,
											},
											_e
										) {
											const Be = new Ws({
												checkCorrectEvent: (rt) =>
													H.mouseButton(rt) === 2 && rt.ctrlKey,
											});
											return new ss({
												clickTolerance: be,
												move: (rt, Ge) => {
													const Xe = _e();
													let tt = (Ge.x - rt.x) * Pe;
													return Ge.y < Xe.y && (tt = -tt), { rollDelta: tt };
												},
												moveStateManager: Be,
												enable: me,
												assignEvents: Xs,
											});
										})(e, E);
									(i.dragRotate = new lu(e, R, D, N)),
										this._add("mouseRotate", R, ["mousePitch"]),
										this._add("mousePitch", D, ["mouseRotate", "mouseRoll"]),
										this._add("mouseRoll", N, ["mousePitch"]),
										e.interactive && e.dragRotate && i.dragRotate.enable();
									const G = (function ({ enable: me, clickTolerance: be }) {
											const Pe = new Ws({
												checkCorrectEvent: (_e) =>
													H.mouseButton(_e) === 0 && !_e.ctrlKey,
											});
											return new ss({
												clickTolerance: be,
												move: (_e, Be) => ({
													around: Be,
													panDelta: Be.sub(_e),
												}),
												activateOnStart: !0,
												moveStateManager: Pe,
												enable: me,
												assignEvents: Xs,
											});
										})(e),
										te = new Ys(e, i);
									(i.dragPan = new vd(l, G, te)),
										this._add("mousePan", G),
										this._add("touchPan", te, ["touchZoom", "touchRotate"]),
										e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
									const Q = new cs(),
										ae = new Ol();
									(i.touchZoomRotate = new yd(l, ae, Q, C)),
										this._add("touchRotate", Q, ["touchPan", "touchZoom"]),
										this._add("touchZoom", ae, ["touchPan", "touchRotate"]),
										e.interactive &&
											e.touchZoomRotate &&
											i.touchZoomRotate.enable(e.touchZoomRotate);
									const ce = (i.scrollZoom = new _d(i, () =>
										this._triggerRenderFrame()
									));
									this._add("scrollZoom", ce, ["mousePan"]),
										e.interactive &&
											e.scrollZoom &&
											i.scrollZoom.enable(e.scrollZoom);
									const ve = (i.keyboard = new jl(i));
									this._add("keyboard", ve),
										e.interactive && e.keyboard && i.keyboard.enable(),
										this._add("blockableMapEvent", new fd(i));
								}
								_add(e, i, l) {
									this._handlers.push({
										handlerName: e,
										handler: i,
										allowed: l,
									}),
										(this._handlersById[e] = i);
								}
								stop(e) {
									if (!this._updatingCamera) {
										for (const { handler: i } of this._handlers) i.reset();
										this._inertia.clear(),
											this._fireEvents({}, {}, e),
											(this._changes = []);
									}
								}
								isActive() {
									for (const { handler: e } of this._handlers)
										if (e.isActive()) return !0;
									return !1;
								}
								isZooming() {
									return (
										!!this._eventsInProgress.zoom ||
										this._map.scrollZoom.isZooming()
									);
								}
								isRotating() {
									return !!this._eventsInProgress.rotate;
								}
								isMoving() {
									return !!Ea(this._eventsInProgress) || this.isZooming();
								}
								_blockedByActive(e, i, l) {
									for (const u in e)
										if (u !== l && (!i || i.indexOf(u) < 0)) return !0;
									return !1;
								}
								_getMapTouches(e) {
									const i = [];
									for (const l of e) this._el.contains(l.target) && i.push(l);
									return i;
								}
								mergeHandlerResult(e, i, l, u, d) {
									if (!l) return;
									s.e(e, l);
									const g = {
										handlerName: u,
										originalEvent: l.originalEvent || d,
									};
									l.zoomDelta !== void 0 && (i.zoom = g),
										l.panDelta !== void 0 && (i.drag = g),
										l.rollDelta !== void 0 && (i.roll = g),
										l.pitchDelta !== void 0 && (i.pitch = g),
										l.bearingDelta !== void 0 && (i.rotate = g);
								}
								_applyChanges() {
									const e = {},
										i = {},
										l = {};
									for (const [u, d, g] of this._changes)
										u.panDelta &&
											(e.panDelta = (e.panDelta || new s.P(0, 0))._add(
												u.panDelta
											)),
											u.zoomDelta &&
												(e.zoomDelta = (e.zoomDelta || 0) + u.zoomDelta),
											u.bearingDelta &&
												(e.bearingDelta =
													(e.bearingDelta || 0) + u.bearingDelta),
											u.pitchDelta &&
												(e.pitchDelta = (e.pitchDelta || 0) + u.pitchDelta),
											u.rollDelta &&
												(e.rollDelta = (e.rollDelta || 0) + u.rollDelta),
											u.around !== void 0 && (e.around = u.around),
											u.pinchAround !== void 0 &&
												(e.pinchAround = u.pinchAround),
											u.noInertia && (e.noInertia = u.noInertia),
											s.e(i, d),
											s.e(l, g);
									this._updateMapTransform(e, i, l), (this._changes = []);
								}
								_updateMapTransform(e, i, l) {
									const u = this._map,
										d = u._getTransformForUpdate(),
										g = u.terrain;
									if (!(us(e) || (g && this._terrainMovement)))
										return this._fireEvents(i, l, !0);
									u._stop(!0);
									let {
										panDelta: w,
										zoomDelta: C,
										bearingDelta: P,
										pitchDelta: E,
										rollDelta: R,
										around: D,
										pinchAround: N,
									} = e;
									N !== void 0 && (D = N),
										(D = D || u.transform.centerPoint),
										g && !d.isPointOnMapSurface(D) && (D = d.centerPoint);
									const G = {
										panDelta: w,
										zoomDelta: C,
										rollDelta: R,
										pitchDelta: E,
										bearingDelta: P,
										around: D,
									};
									this._map.cameraHelper.useGlobeControls &&
										!d.isPointOnMapSurface(D) &&
										(D = d.centerPoint);
									const te =
										D.distSqr(d.centerPoint) < 0.01
											? d.center
											: d.screenPointToLocation(w ? D.sub(w) : D);
									g
										? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(
												G,
												d
										  ),
										  this._terrainMovement || (!i.drag && !i.zoom)
												? i.drag && this._terrainMovement
													? d.setCenter(
															d.screenPointToLocation(d.centerPoint.sub(w))
													  )
													: this._map.cameraHelper.handleMapControlsPan(
															G,
															d,
															te
													  )
												: ((this._terrainMovement = !0),
												  (this._map._elevationFreeze = !0),
												  this._map.cameraHelper.handleMapControlsPan(
														G,
														d,
														te
												  )))
										: (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(
												G,
												d
										  ),
										  this._map.cameraHelper.handleMapControlsPan(G, d, te)),
										u._applyUpdatedTransform(d),
										this._map._update(),
										e.noInertia || this._inertia.record(e),
										this._fireEvents(i, l, !0);
								}
								_fireEvents(e, i, l) {
									const u = Ea(this._eventsInProgress),
										d = Ea(e),
										g = {};
									for (const R in e) {
										const { originalEvent: D } = e[R];
										this._eventsInProgress[R] || (g[`${R}start`] = D),
											(this._eventsInProgress[R] = e[R]);
									}
									!u && d && this._fireEvent("movestart", d.originalEvent);
									for (const R in g) this._fireEvent(R, g[R]);
									d && this._fireEvent("move", d.originalEvent);
									for (const R in e) {
										const { originalEvent: D } = e[R];
										this._fireEvent(R, D);
									}
									const w = {};
									let C;
									for (const R in this._eventsInProgress) {
										const { handlerName: D, originalEvent: N } =
											this._eventsInProgress[R];
										this._handlersById[D].isActive() ||
											(delete this._eventsInProgress[R],
											(C = i[D] || N),
											(w[`${R}end`] = C));
									}
									for (const R in w) this._fireEvent(R, w[R]);
									const P = Ea(this._eventsInProgress),
										E = (u || d) && !P;
									if (E && this._terrainMovement) {
										(this._map._elevationFreeze = !1),
											(this._terrainMovement = !1);
										const R = this._map._getTransformForUpdate();
										this._map.getCenterClampedToGround() &&
											R.recalculateZoomAndCenter(this._map.terrain),
											this._map._applyUpdatedTransform(R);
									}
									if (l && E) {
										this._updatingCamera = !0;
										const R = this._inertia._onMoveEnd(
												this._map.dragPan._inertiaOptions
											),
											D = (N) =>
												N !== 0 &&
												-this._bearingSnap < N &&
												N < this._bearingSnap;
										!R || (!R.essential && ne.prefersReducedMotion)
											? (this._map.fire(
													new s.l("moveend", { originalEvent: C })
											  ),
											  D(this._map.getBearing()) && this._map.resetNorth())
											: (D(R.bearing || this._map.getBearing()) &&
													(R.bearing = 0),
											  (R.freezeElevation = !0),
											  this._map.easeTo(R, { originalEvent: C })),
											(this._updatingCamera = !1);
									}
								}
								_fireEvent(e, i) {
									this._map.fire(new s.l(e, i ? { originalEvent: i } : {}));
								}
								_requestFrame() {
									return (
										this._map.triggerRepaint(),
										this._map._renderTaskQueue.add((e) => {
											delete this._frameId,
												this.handleEvent(
													new Un("renderFrame", { timeStamp: e })
												),
												this._applyChanges();
										})
									);
								}
								_triggerRenderFrame() {
									this._frameId === void 0 &&
										(this._frameId = this._requestFrame());
								}
							}
							class bd extends s.E {
								constructor(e, i, l) {
									super(),
										(this._renderFrameCallback = () => {
											const u = Math.min(
												(ne.now() - this._easeStart) /
													this._easeOptions.duration,
												1
											);
											this._onEaseFrame(this._easeOptions.easing(u)),
												u < 1 && this._easeFrameId
													? (this._easeFrameId = this._requestRenderFrame(
															this._renderFrameCallback
													  ))
													: this.stop();
										}),
										(this._moving = !1),
										(this._zooming = !1),
										(this.transform = e),
										(this._bearingSnap = l.bearingSnap),
										(this.cameraHelper = i),
										this.on("moveend", () => {
											delete this._requestedCameraState;
										});
								}
								migrateProjection(e, i) {
									e.apply(this.transform),
										(this.transform = e),
										(this.cameraHelper = i);
								}
								getCenter() {
									return new s.S(
										this.transform.center.lng,
										this.transform.center.lat
									);
								}
								setCenter(e, i) {
									return this.jumpTo({ center: e }, i);
								}
								getCenterElevation() {
									return this.transform.elevation;
								}
								setCenterElevation(e, i) {
									return this.jumpTo({ elevation: e }, i), this;
								}
								getCenterClampedToGround() {
									return this._centerClampedToGround;
								}
								setCenterClampedToGround(e) {
									this._centerClampedToGround = e;
								}
								panBy(e, i, l) {
									return (
										(e = s.P.convert(e).mult(-1)),
										this.panTo(this.transform.center, s.e({ offset: e }, i), l)
									);
								}
								panTo(e, i, l) {
									return this.easeTo(s.e({ center: e }, i), l);
								}
								getZoom() {
									return this.transform.zoom;
								}
								setZoom(e, i) {
									return this.jumpTo({ zoom: e }, i), this;
								}
								zoomTo(e, i, l) {
									return this.easeTo(s.e({ zoom: e }, i), l);
								}
								zoomIn(e, i) {
									return this.zoomTo(this.getZoom() + 1, e, i), this;
								}
								zoomOut(e, i) {
									return this.zoomTo(this.getZoom() - 1, e, i), this;
								}
								getVerticalFieldOfView() {
									return this.transform.fov;
								}
								setVerticalFieldOfView(e, i) {
									return (
										e != this.transform.fov &&
											(this.transform.setFov(e),
											this.fire(new s.l("movestart", i))
												.fire(new s.l("move", i))
												.fire(new s.l("moveend", i))),
										this
									);
								}
								getBearing() {
									return this.transform.bearing;
								}
								setBearing(e, i) {
									return this.jumpTo({ bearing: e }, i), this;
								}
								getPadding() {
									return this.transform.padding;
								}
								setPadding(e, i) {
									return this.jumpTo({ padding: e }, i), this;
								}
								rotateTo(e, i, l) {
									return this.easeTo(s.e({ bearing: e }, i), l);
								}
								resetNorth(e, i) {
									return this.rotateTo(0, s.e({ duration: 1e3 }, e), i), this;
								}
								resetNorthPitch(e, i) {
									return (
										this.easeTo(
											s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e),
											i
										),
										this
									);
								}
								snapToNorth(e, i) {
									return Math.abs(this.getBearing()) < this._bearingSnap
										? this.resetNorth(e, i)
										: this;
								}
								getPitch() {
									return this.transform.pitch;
								}
								setPitch(e, i) {
									return this.jumpTo({ pitch: e }, i), this;
								}
								getRoll() {
									return this.transform.roll;
								}
								setRoll(e, i) {
									return this.jumpTo({ roll: e }, i), this;
								}
								cameraForBounds(e, i) {
									e = _t.convert(e).adjustAntiMeridian();
									const l = (i && i.bearing) || 0;
									return this._cameraForBoxAndBearing(
										e.getNorthWest(),
										e.getSouthEast(),
										l,
										i
									);
								}
								_cameraForBoxAndBearing(e, i, l, u) {
									const d = { top: 0, bottom: 0, right: 0, left: 0 };
									if (
										typeof (u = s.e(
											{
												padding: d,
												offset: [0, 0],
												maxZoom: this.transform.maxZoom,
											},
											u
										)).padding == "number"
									) {
										const P = u.padding;
										u.padding = { top: P, bottom: P, right: P, left: P };
									}
									const g = s.e(d, u.padding);
									u.padding = g;
									const w = this.transform,
										C = new _t(e, i);
									return this.cameraHelper.cameraForBoxAndBearing(
										u,
										g,
										C,
										l,
										w
									);
								}
								fitBounds(e, i, l) {
									return this._fitInternal(this.cameraForBounds(e, i), i, l);
								}
								fitScreenCoordinates(e, i, l, u, d) {
									return this._fitInternal(
										this._cameraForBoxAndBearing(
											this.transform.screenPointToLocation(s.P.convert(e)),
											this.transform.screenPointToLocation(s.P.convert(i)),
											l,
											u
										),
										u,
										d
									);
								}
								_fitInternal(e, i, l) {
									return e
										? (delete (i = s.e(e, i)).padding,
										  i.linear ? this.easeTo(i, l) : this.flyTo(i, l))
										: this;
								}
								jumpTo(e, i) {
									this.stop();
									const l = this._getTransformForUpdate();
									let u = !1,
										d = !1,
										g = !1;
									const w = l.zoom;
									this.cameraHelper.handleJumpToCenterZoom(l, e);
									const C = l.zoom !== w;
									return (
										"elevation" in e &&
											l.elevation !== +e.elevation &&
											l.setElevation(+e.elevation),
										"bearing" in e &&
											l.bearing !== +e.bearing &&
											((u = !0), l.setBearing(+e.bearing)),
										"pitch" in e &&
											l.pitch !== +e.pitch &&
											((d = !0), l.setPitch(+e.pitch)),
										"roll" in e &&
											l.roll !== +e.roll &&
											((g = !0), l.setRoll(+e.roll)),
										e.padding == null ||
											l.isPaddingEqual(e.padding) ||
											l.setPadding(e.padding),
										this._applyUpdatedTransform(l),
										this.fire(new s.l("movestart", i)).fire(new s.l("move", i)),
										C &&
											this.fire(new s.l("zoomstart", i))
												.fire(new s.l("zoom", i))
												.fire(new s.l("zoomend", i)),
										u &&
											this.fire(new s.l("rotatestart", i))
												.fire(new s.l("rotate", i))
												.fire(new s.l("rotateend", i)),
										d &&
											this.fire(new s.l("pitchstart", i))
												.fire(new s.l("pitch", i))
												.fire(new s.l("pitchend", i)),
										g &&
											this.fire(new s.l("rollstart", i))
												.fire(new s.l("roll", i))
												.fire(new s.l("rollend", i)),
										this.fire(new s.l("moveend", i))
									);
								}
								calculateCameraOptionsFromTo(e, i, l, u = 0) {
									const d = s.a1.fromLngLat(e, i),
										g = s.a1.fromLngLat(l, u),
										w = g.x - d.x,
										C = g.y - d.y,
										P = g.z - d.z,
										E = Math.hypot(w, C, P);
									if (E === 0)
										throw new Error(
											"Can't calculate camera options with same From and To"
										);
									const R = Math.hypot(w, C),
										D = s.ak(
											this.transform.cameraToCenterDistance /
												E /
												this.transform.tileSize
										),
										N = (180 * Math.atan2(w, -C)) / Math.PI;
									let G = (180 * Math.acos(R / E)) / Math.PI;
									return (
										(G = P < 0 ? 90 - G : 90 + G),
										{
											center: g.toLngLat(),
											elevation: u,
											zoom: D,
											pitch: G,
											bearing: N,
										}
									);
								}
								calculateCameraOptionsFromCameraLngLatAltRotation(
									e,
									i,
									l,
									u,
									d
								) {
									const g = this.transform.calculateCenterFromCameraLngLatAlt(
										e,
										i,
										l,
										u
									);
									return {
										center: g.center,
										elevation: g.elevation,
										zoom: g.zoom,
										bearing: l,
										pitch: u,
										roll: d,
									};
								}
								easeTo(e, i) {
									this._stop(!1, e.easeId),
										((e = s.e(
											{ offset: [0, 0], duration: 500, easing: s.co },
											e
										)).animate === !1 ||
											(!e.essential && ne.prefersReducedMotion)) &&
											(e.duration = 0);
									const l = this._getTransformForUpdate(),
										u = this.getBearing(),
										d = l.pitch,
										g = l.roll,
										w =
											"bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
										C = "pitch" in e ? +e.pitch : d,
										P = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
										E = "padding" in e ? e.padding : l.padding,
										R = s.P.convert(e.offset);
									let D, N;
									e.around &&
										((D = s.S.convert(e.around)),
										(N = l.locationToScreenPoint(D)));
									const G = {
											moving: this._moving,
											zooming: this._zooming,
											rotating: this._rotating,
											pitching: this._pitching,
											rolling: this._rolling,
										},
										te = this.cameraHelper.handleEaseTo(l, {
											bearing: w,
											pitch: C,
											roll: P,
											padding: E,
											around: D,
											aroundPoint: N,
											offsetAsPoint: R,
											offset: e.offset,
											zoom: e.zoom,
											center: e.center,
										});
									return (
										(this._rotating = this._rotating || u !== w),
										(this._pitching = this._pitching || C !== d),
										(this._rolling = this._rolling || P !== g),
										(this._padding = !l.isPaddingEqual(E)),
										(this._zooming = this._zooming || te.isZooming),
										(this._easeId = e.easeId),
										this._prepareEase(i, e.noMoveStart, G),
										this.terrain && this._prepareElevation(te.elevationCenter),
										this._ease(
											(Q) => {
												te.easeFunc(Q),
													this.terrain &&
														!e.freezeElevation &&
														this._updateElevation(Q),
													this._applyUpdatedTransform(l),
													this._fireMoveEvents(i);
											},
											(Q) => {
												this.terrain &&
													e.freezeElevation &&
													this._finalizeElevation(),
													this._afterEase(i, Q);
											},
											e
										),
										this
									);
								}
								_prepareEase(e, i, l = {}) {
									(this._moving = !0),
										i || l.moving || this.fire(new s.l("movestart", e)),
										this._zooming &&
											!l.zooming &&
											this.fire(new s.l("zoomstart", e)),
										this._rotating &&
											!l.rotating &&
											this.fire(new s.l("rotatestart", e)),
										this._pitching &&
											!l.pitching &&
											this.fire(new s.l("pitchstart", e)),
										this._rolling &&
											!l.rolling &&
											this.fire(new s.l("rollstart", e));
								}
								_prepareElevation(e) {
									(this._elevationCenter = e),
										(this._elevationStart = this.transform.elevation),
										(this._elevationTarget =
											this.terrain.getElevationForLngLatZoom(
												e,
												this.transform.tileZoom
											)),
										(this._elevationFreeze = !0);
								}
								_updateElevation(e) {
									this.transform.setMinElevationForCurrentTile(
										this.terrain.getMinTileElevationForLngLatZoom(
											this._elevationCenter,
											this.transform.tileZoom
										)
									);
									const i = this.terrain.getElevationForLngLatZoom(
										this._elevationCenter,
										this.transform.tileZoom
									);
									if (e < 1 && i !== this._elevationTarget) {
										const l = this._elevationTarget - this._elevationStart;
										(this._elevationStart +=
											e * (l - (i - (l * e + this._elevationStart)) / (1 - e))),
											(this._elevationTarget = i);
									}
									this.transform.setElevation(
										s.C.number(this._elevationStart, this._elevationTarget, e)
									);
								}
								_finalizeElevation() {
									(this._elevationFreeze = !1),
										this.getCenterClampedToGround() &&
											this.transform.recalculateZoomAndCenter(this.terrain);
								}
								_getTransformForUpdate() {
									return this.transformCameraUpdate || this.terrain
										? (this._requestedCameraState ||
												(this._requestedCameraState = this.transform.clone()),
										  this._requestedCameraState)
										: this.transform;
								}
								_elevateCameraIfInsideTerrain(e) {
									if (!this.terrain && e.elevation >= 0 && e.pitch <= 90)
										return {};
									const i = e.getCameraLngLat(),
										l = e.getCameraAltitude(),
										u = this.terrain
											? this.terrain.getElevationForLngLatZoom(i, e.zoom)
											: 0;
									if (l < u) {
										const d = this.calculateCameraOptionsFromTo(
											i,
											u,
											e.center,
											e.elevation
										);
										return { pitch: d.pitch, zoom: d.zoom };
									}
									return {};
								}
								_applyUpdatedTransform(e) {
									const i = [];
									if (
										(i.push((u) => this._elevateCameraIfInsideTerrain(u)),
										this.transformCameraUpdate &&
											i.push((u) => this.transformCameraUpdate(u)),
										!i.length)
									)
										return;
									const l = e.clone();
									for (const u of i) {
										const d = l.clone(),
											{
												center: g,
												zoom: w,
												roll: C,
												pitch: P,
												bearing: E,
												elevation: R,
											} = u(d);
										g && d.setCenter(g),
											R !== void 0 && d.setElevation(R),
											w !== void 0 && d.setZoom(w),
											C !== void 0 && d.setRoll(C),
											P !== void 0 && d.setPitch(P),
											E !== void 0 && d.setBearing(E),
											l.apply(d);
									}
									this.transform.apply(l);
								}
								_fireMoveEvents(e) {
									this.fire(new s.l("move", e)),
										this._zooming && this.fire(new s.l("zoom", e)),
										this._rotating && this.fire(new s.l("rotate", e)),
										this._pitching && this.fire(new s.l("pitch", e)),
										this._rolling && this.fire(new s.l("roll", e));
								}
								_afterEase(e, i) {
									if (this._easeId && i && this._easeId === i) return;
									delete this._easeId;
									const l = this._zooming,
										u = this._rotating,
										d = this._pitching,
										g = this._rolling;
									(this._moving = !1),
										(this._zooming = !1),
										(this._rotating = !1),
										(this._pitching = !1),
										(this._rolling = !1),
										(this._padding = !1),
										l && this.fire(new s.l("zoomend", e)),
										u && this.fire(new s.l("rotateend", e)),
										d && this.fire(new s.l("pitchend", e)),
										g && this.fire(new s.l("rollend", e)),
										this.fire(new s.l("moveend", e));
								}
								flyTo(e, i) {
									if (!e.essential && ne.prefersReducedMotion) {
										const tt = s.Q(e, [
											"center",
											"zoom",
											"bearing",
											"pitch",
											"roll",
											"elevation",
										]);
										return this.jumpTo(tt, i);
									}
									this.stop(),
										(e = s.e(
											{ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.co },
											e
										));
									const l = this._getTransformForUpdate(),
										u = l.bearing,
										d = l.pitch,
										g = l.roll,
										w = l.padding,
										C =
											"bearing" in e ? this._normalizeBearing(e.bearing, u) : u,
										P = "pitch" in e ? +e.pitch : d,
										E = "roll" in e ? this._normalizeBearing(e.roll, g) : g,
										R = "padding" in e ? e.padding : l.padding,
										D = s.P.convert(e.offset);
									let N = l.centerPoint.add(D);
									const G = l.screenPointToLocation(N),
										te = this.cameraHelper.handleFlyTo(l, {
											bearing: C,
											pitch: P,
											roll: E,
											padding: R,
											locationAtOffset: G,
											offsetAsPoint: D,
											center: e.center,
											minZoom: e.minZoom,
											zoom: e.zoom,
										});
									let Q = e.curve;
									const ae = Math.max(l.width, l.height),
										ce = ae / te.scaleOfZoom,
										ve = te.pixelPathLength;
									typeof te.scaleOfMinZoom == "number" &&
										(Q = Math.sqrt((ae / te.scaleOfMinZoom / ve) * 2));
									const me = Q * Q;
									function be(tt) {
										const jt =
											(ce * ce - ae * ae + (tt ? -1 : 1) * me * me * ve * ve) /
											(2 * (tt ? ce : ae) * me * ve);
										return Math.log(Math.sqrt(jt * jt + 1) - jt);
									}
									function Pe(tt) {
										return (Math.exp(tt) - Math.exp(-tt)) / 2;
									}
									function _e(tt) {
										return (Math.exp(tt) + Math.exp(-tt)) / 2;
									}
									const Be = be(!1);
									let rt = function (tt) {
											return _e(Be) / _e(Be + Q * tt);
										},
										Ge = function (tt) {
											return (
												(ae *
													((_e(Be) * (Pe((jt = Be + Q * tt)) / _e(jt)) -
														Pe(Be)) /
														me)) /
												ve
											);
											var jt;
										},
										Xe = (be(!0) - Be) / Q;
									if (Math.abs(ve) < 2e-6 || !isFinite(Xe)) {
										if (Math.abs(ae - ce) < 1e-6) return this.easeTo(e, i);
										const tt = ce < ae ? -1 : 1;
										(Xe = Math.abs(Math.log(ce / ae)) / Q),
											(Ge = () => 0),
											(rt = (jt) => Math.exp(tt * Q * jt));
									}
									return (
										(e.duration =
											"duration" in e
												? +e.duration
												: (1e3 * Xe) /
												  ("screenSpeed" in e ? +e.screenSpeed / Q : +e.speed)),
										e.maxDuration &&
											e.duration > e.maxDuration &&
											(e.duration = 0),
										(this._zooming = !0),
										(this._rotating = u !== C),
										(this._pitching = P !== d),
										(this._rolling = E !== g),
										(this._padding = !l.isPaddingEqual(R)),
										this._prepareEase(i, !1),
										this.terrain && this._prepareElevation(te.targetCenter),
										this._ease(
											(tt) => {
												const jt = tt * Xe,
													Zt = 1 / rt(jt),
													Tt = Ge(jt);
												this._rotating && l.setBearing(s.C.number(u, C, tt)),
													this._pitching && l.setPitch(s.C.number(d, P, tt)),
													this._rolling && l.setRoll(s.C.number(g, E, tt)),
													this._padding &&
														(l.interpolatePadding(w, R, tt),
														(N = l.centerPoint.add(D))),
													te.easeFunc(tt, Zt, Tt, N),
													this.terrain &&
														!e.freezeElevation &&
														this._updateElevation(tt),
													this._applyUpdatedTransform(l),
													this._fireMoveEvents(i);
											},
											() => {
												this.terrain &&
													e.freezeElevation &&
													this._finalizeElevation(),
													this._afterEase(i);
											},
											e
										),
										this
									);
								}
								isEasing() {
									return !!this._easeFrameId;
								}
								stop() {
									return this._stop();
								}
								_stop(e, i) {
									var l;
									if (
										(this._easeFrameId &&
											(this._cancelRenderFrame(this._easeFrameId),
											delete this._easeFrameId,
											delete this._onEaseFrame),
										this._onEaseEnd)
									) {
										const u = this._onEaseEnd;
										delete this._onEaseEnd, u.call(this, i);
									}
									return (
										e ||
											(l = this.handlers) === null ||
											l === void 0 ||
											l.stop(!1),
										this
									);
								}
								_ease(e, i, l) {
									l.animate === !1 || l.duration === 0
										? (e(1), i())
										: ((this._easeStart = ne.now()),
										  (this._easeOptions = l),
										  (this._onEaseFrame = e),
										  (this._onEaseEnd = i),
										  (this._easeFrameId = this._requestRenderFrame(
												this._renderFrameCallback
										  )));
								}
								_normalizeBearing(e, i) {
									e = s.aO(e, -180, 180);
									const l = Math.abs(e - i);
									return (
										Math.abs(e - 360 - i) < l && (e -= 360),
										Math.abs(e + 360 - i) < l && (e += 360),
										e
									);
								}
								queryTerrainElevation(e) {
									return this.terrain
										? this.terrain.getElevationForLngLatZoom(
												s.S.convert(e),
												this.transform.tileZoom
										  )
										: null;
								}
							}
							const uu = {
								compact: !0,
								customAttribution:
									'<a href="https://maplibre.org/" target="_blank">MapLibre</a>',
							};
							class hu {
								constructor(e = uu) {
									(this._toggleAttribution = () => {
										this._container.classList.contains("maplibregl-compact") &&
											(this._container.classList.contains(
												"maplibregl-compact-show"
											)
												? (this._container.setAttribute("open", ""),
												  this._container.classList.remove(
														"maplibregl-compact-show"
												  ))
												: (this._container.classList.add(
														"maplibregl-compact-show"
												  ),
												  this._container.removeAttribute("open")));
									}),
										(this._updateData = (i) => {
											!i ||
												(i.sourceDataType !== "metadata" &&
													i.sourceDataType !== "visibility" &&
													i.dataType !== "style" &&
													i.type !== "terrain") ||
												this._updateAttributions();
										}),
										(this._updateCompact = () => {
											this._map.getCanvasContainer().offsetWidth <= 640 ||
											this._compact
												? this._compact === !1
													? this._container.setAttribute("open", "")
													: this._container.classList.contains(
															"maplibregl-compact"
													  ) ||
													  this._container.classList.contains(
															"maplibregl-attrib-empty"
													  ) ||
													  (this._container.setAttribute("open", ""),
													  this._container.classList.add(
															"maplibregl-compact",
															"maplibregl-compact-show"
													  ))
												: (this._container.setAttribute("open", ""),
												  this._container.classList.contains(
														"maplibregl-compact"
												  ) &&
														this._container.classList.remove(
															"maplibregl-compact",
															"maplibregl-compact-show"
														));
										}),
										(this._updateCompactMinimize = () => {
											this._container.classList.contains(
												"maplibregl-compact"
											) &&
												this._container.classList.contains(
													"maplibregl-compact-show"
												) &&
												this._container.classList.remove(
													"maplibregl-compact-show"
												);
										}),
										(this.options = e);
								}
								getDefaultPosition() {
									return "bottom-right";
								}
								onAdd(e) {
									return (
										(this._map = e),
										(this._compact = this.options.compact),
										(this._container = H.create(
											"details",
											"maplibregl-ctrl maplibregl-ctrl-attrib"
										)),
										(this._compactButton = H.create(
											"summary",
											"maplibregl-ctrl-attrib-button",
											this._container
										)),
										this._compactButton.addEventListener(
											"click",
											this._toggleAttribution
										),
										this._setElementTitle(
											this._compactButton,
											"ToggleAttribution"
										),
										(this._innerContainer = H.create(
											"div",
											"maplibregl-ctrl-attrib-inner",
											this._container
										)),
										this._updateAttributions(),
										this._updateCompact(),
										this._map.on("styledata", this._updateData),
										this._map.on("sourcedata", this._updateData),
										this._map.on("terrain", this._updateData),
										this._map.on("resize", this._updateCompact),
										this._map.on("drag", this._updateCompactMinimize),
										this._container
									);
								}
								onRemove() {
									H.remove(this._container),
										this._map.off("styledata", this._updateData),
										this._map.off("sourcedata", this._updateData),
										this._map.off("terrain", this._updateData),
										this._map.off("resize", this._updateCompact),
										this._map.off("drag", this._updateCompactMinimize),
										(this._map = void 0),
										(this._compact = void 0),
										(this._attribHTML = void 0);
								}
								_setElementTitle(e, i) {
									const l = this._map._getUIString(`AttributionControl.${i}`);
									(e.title = l), e.setAttribute("aria-label", l);
								}
								_updateAttributions() {
									if (!this._map.style) return;
									let e = [];
									if (
										(this.options.customAttribution &&
											(Array.isArray(this.options.customAttribution)
												? (e = e.concat(
														this.options.customAttribution.map((u) =>
															typeof u != "string" ? "" : u
														)
												  ))
												: typeof this.options.customAttribution == "string" &&
												  e.push(this.options.customAttribution)),
										this._map.style.stylesheet)
									) {
										const u = this._map.style.stylesheet;
										(this.styleOwner = u.owner), (this.styleId = u.id);
									}
									const i = this._map.style.sourceCaches;
									for (const u in i) {
										const d = i[u];
										if (d.used || d.usedForTerrain) {
											const g = d.getSource();
											g.attribution &&
												e.indexOf(g.attribution) < 0 &&
												e.push(g.attribution);
										}
									}
									(e = e.filter((u) => String(u).trim())),
										e.sort((u, d) => u.length - d.length),
										(e = e.filter((u, d) => {
											for (let g = d + 1; g < e.length; g++)
												if (e[g].indexOf(u) >= 0) return !1;
											return !0;
										}));
									const l = e.join(" | ");
									l !== this._attribHTML &&
										((this._attribHTML = l),
										e.length
											? ((this._innerContainer.innerHTML = H.sanitize(l)),
											  this._container.classList.remove(
													"maplibregl-attrib-empty"
											  ))
											: this._container.classList.add(
													"maplibregl-attrib-empty"
											  ),
										this._updateCompact(),
										(this._editLink = null));
								}
							}
							class wd {
								constructor(e = {}) {
									(this._updateCompact = () => {
										const i = this._container.children;
										if (i.length) {
											const l = i[0];
											this._map.getCanvasContainer().offsetWidth <= 640 ||
											this._compact
												? this._compact !== !1 &&
												  l.classList.add("maplibregl-compact")
												: l.classList.remove("maplibregl-compact");
										}
									}),
										(this.options = e);
								}
								getDefaultPosition() {
									return "bottom-left";
								}
								onAdd(e) {
									(this._map = e),
										(this._compact = this.options && this.options.compact),
										(this._container = H.create("div", "maplibregl-ctrl"));
									const i = H.create("a", "maplibregl-ctrl-logo");
									return (
										(i.target = "_blank"),
										(i.rel = "noopener nofollow"),
										(i.href = "https://maplibre.org/"),
										i.setAttribute(
											"aria-label",
											this._map._getUIString("LogoControl.Title")
										),
										i.setAttribute("rel", "noopener nofollow"),
										this._container.appendChild(i),
										(this._container.style.display = "block"),
										this._map.on("resize", this._updateCompact),
										this._updateCompact(),
										this._container
									);
								}
								onRemove() {
									H.remove(this._container),
										this._map.off("resize", this._updateCompact),
										(this._map = void 0),
										(this._compact = void 0);
								}
							}
							class $a {
								constructor() {
									(this._queue = []),
										(this._id = 0),
										(this._cleared = !1),
										(this._currentlyRunning = !1);
								}
								add(e) {
									const i = ++this._id;
									return (
										this._queue.push({ callback: e, id: i, cancelled: !1 }), i
									);
								}
								remove(e) {
									const i = this._currentlyRunning,
										l = i ? this._queue.concat(i) : this._queue;
									for (const u of l)
										if (u.id === e) return void (u.cancelled = !0);
								}
								run(e = 0) {
									if (this._currentlyRunning)
										throw new Error(
											"Attempting to run(), but is already running."
										);
									const i = (this._currentlyRunning = this._queue);
									this._queue = [];
									for (const l of i)
										if (!l.cancelled && (l.callback(e), this._cleared)) break;
									(this._cleared = !1), (this._currentlyRunning = !1);
								}
								clear() {
									this._currentlyRunning && (this._cleared = !0),
										(this._queue = []);
								}
							}
							var ql = s.aJ([
								{ name: "a_pos3d", type: "Int16", components: 3 },
							]);
							class wr extends s.E {
								constructor(e) {
									super(),
										(this._lastTilesetChange = ne.now()),
										(this.sourceCache = e),
										(this._tiles = {}),
										(this._renderableTilesKeys = []),
										(this._sourceTileCache = {}),
										(this.minzoom = 0),
										(this.maxzoom = 22),
										(this.deltaZoom = 1),
										(this.tileSize = e._source.tileSize * 2 ** this.deltaZoom),
										(e.usedForTerrain = !0),
										(e.tileSize = this.tileSize);
								}
								destruct() {
									(this.sourceCache.usedForTerrain = !1),
										(this.sourceCache.tileSize = null);
								}
								update(e, i) {
									this.sourceCache.update(e, i),
										(this._renderableTilesKeys = []);
									const l = {};
									for (const u of ye(e, {
										tileSize: this.tileSize,
										minzoom: this.minzoom,
										maxzoom: this.maxzoom,
										reparseOverscaled: !1,
										terrain: i,
										calculateTileZoom:
											this.sourceCache._source.calculateTileZoom,
									}))
										(l[u.key] = !0),
											this._renderableTilesKeys.push(u.key),
											this._tiles[u.key] ||
												((u.terrainRttPosMatrix32f = new Float64Array(16)),
												s.bY(u.terrainRttPosMatrix32f, 0, s.$, s.$, 0, 0, 1),
												(this._tiles[u.key] = new qr(u, this.tileSize)),
												(this._lastTilesetChange = ne.now()));
									for (const u in this._tiles) l[u] || delete this._tiles[u];
								}
								freeRtt(e) {
									for (const i in this._tiles) {
										const l = this._tiles[i];
										(!e ||
											l.tileID.equals(e) ||
											l.tileID.isChildOf(e) ||
											e.isChildOf(l.tileID)) &&
											(l.rtt = []);
									}
								}
								getRenderableTiles() {
									return this._renderableTilesKeys.map((e) =>
										this.getTileByID(e)
									);
								}
								getTileByID(e) {
									return this._tiles[e];
								}
								getTerrainCoords(e, i) {
									return i
										? this._getTerrainCoordsForTileRanges(e, i)
										: this._getTerrainCoordsForRegularTile(e);
								}
								_getTerrainCoordsForRegularTile(e) {
									const i = {};
									for (const l of this._renderableTilesKeys) {
										const u = this._tiles[l].tileID,
											d = e.clone(),
											g = s.ba();
										if (u.canonical.equals(e.canonical))
											s.bY(g, 0, s.$, s.$, 0, 0, 1);
										else if (u.canonical.isChildOf(e.canonical)) {
											const w = u.canonical.z - e.canonical.z,
												C = u.canonical.x - ((u.canonical.x >> w) << w),
												P = u.canonical.y - ((u.canonical.y >> w) << w),
												E = s.$ >> w;
											s.bY(g, 0, E, E, 0, 0, 1), s.M(g, g, [-C * E, -P * E, 0]);
										} else {
											if (!e.canonical.isChildOf(u.canonical)) continue;
											{
												const w = e.canonical.z - u.canonical.z,
													C = e.canonical.x - ((e.canonical.x >> w) << w),
													P = e.canonical.y - ((e.canonical.y >> w) << w),
													E = s.$ >> w;
												s.bY(g, 0, s.$, s.$, 0, 0, 1),
													s.M(g, g, [C * E, P * E, 0]),
													s.N(g, g, [1 / 2 ** w, 1 / 2 ** w, 0]);
											}
										}
										(d.terrainRttPosMatrix32f = new Float32Array(g)),
											(i[l] = d);
									}
									return i;
								}
								_getTerrainCoordsForTileRanges(e, i) {
									const l = {};
									for (const u of this._renderableTilesKeys) {
										const d = this._tiles[u].tileID;
										if (!this._isWithinTileRanges(d, i)) continue;
										const g = e.clone(),
											w = s.ba();
										if (d.canonical.z === e.canonical.z) {
											const C = e.canonical.x - d.canonical.x,
												P = e.canonical.y - d.canonical.y;
											s.bY(w, 0, s.$, s.$, 0, 0, 1),
												s.M(w, w, [C * s.$, P * s.$, 0]);
										} else if (d.canonical.z > e.canonical.z) {
											const C = d.canonical.z - e.canonical.z,
												P = d.canonical.x - ((d.canonical.x >> C) << C),
												E = d.canonical.y - ((d.canonical.y >> C) << C),
												R = e.canonical.x - (d.canonical.x >> C),
												D = e.canonical.y - (d.canonical.y >> C),
												N = s.$ >> C;
											s.bY(w, 0, N, N, 0, 0, 1),
												s.M(w, w, [-P * N + R * s.$, -E * N + D * s.$, 0]);
										} else {
											const C = e.canonical.z - d.canonical.z,
												P = e.canonical.x - ((e.canonical.x >> C) << C),
												E = e.canonical.y - ((e.canonical.y >> C) << C),
												R = (e.canonical.x >> C) - d.canonical.x,
												D = (e.canonical.y >> C) - d.canonical.y,
												N = s.$ << C;
											s.bY(w, 0, N, N, 0, 0, 1),
												s.M(w, w, [P * s.$ + R * N, E * s.$ + D * N, 0]);
										}
										(g.terrainRttPosMatrix32f = new Float32Array(w)),
											(l[u] = g);
									}
									return l;
								}
								getSourceTile(e, i) {
									const l = this.sourceCache._source;
									let u = e.overscaledZ - this.deltaZoom;
									if ((u > l.maxzoom && (u = l.maxzoom), u < l.minzoom))
										return null;
									this._sourceTileCache[e.key] ||
										(this._sourceTileCache[e.key] = e.scaledTo(u).key);
									let d = this.sourceCache.getTileByID(
										this._sourceTileCache[e.key]
									);
									if ((!d || !d.dem) && i)
										for (; u >= l.minzoom && (!d || !d.dem); )
											d = this.sourceCache.getTileByID(e.scaledTo(u--).key);
									return d;
								}
								anyTilesAfterTime(e = Date.now()) {
									return this._lastTilesetChange >= e;
								}
								_isWithinTileRanges(e, i) {
									return (
										i[e.canonical.z] &&
										e.canonical.x >= i[e.canonical.z].minTileX &&
										e.canonical.x <= i[e.canonical.z].maxTileX &&
										e.canonical.y >= i[e.canonical.z].minTileY &&
										e.canonical.y <= i[e.canonical.z].maxTileY
									);
								}
							}
							class Or {
								constructor(e, i, l) {
									(this._meshCache = {}),
										(this.painter = e),
										(this.sourceCache = new wr(i)),
										(this.options = l),
										(this.exaggeration =
											typeof l.exaggeration == "number" ? l.exaggeration : 1),
										(this.qualityFactor = 2),
										(this.meshSize = 128),
										(this._demMatrixCache = {}),
										(this.coordsIndex = []),
										(this._coordsTextureSize = 1024);
								}
								getDEMElevation(e, i, l, u = s.$) {
									var d;
									if (!(i >= 0 && i < u && l >= 0 && l < u)) return 0;
									const g = this.getTerrainData(e),
										w = (d = g.tile) === null || d === void 0 ? void 0 : d.dem;
									if (!w) return 0;
									const C = s.cs(
											[],
											[(i / u) * s.$, (l / u) * s.$],
											g.u_terrain_matrix
										),
										P = [C[0] * w.dim, C[1] * w.dim],
										E = Math.floor(P[0]),
										R = Math.floor(P[1]),
										D = P[0] - E,
										N = P[1] - R;
									return (
										w.get(E, R) * (1 - D) * (1 - N) +
										w.get(E + 1, R) * D * (1 - N) +
										w.get(E, R + 1) * (1 - D) * N +
										w.get(E + 1, R + 1) * D * N
									);
								}
								getElevationForLngLatZoom(e, i) {
									if (!s.ct(i, e.wrap())) return 0;
									const {
										tileID: l,
										mercatorX: u,
										mercatorY: d,
									} = this._getOverscaledTileIDFromLngLatZoom(e, i);
									return this.getElevation(l, u % s.$, d % s.$, s.$);
								}
								getElevation(e, i, l, u = s.$) {
									return this.getDEMElevation(e, i, l, u) * this.exaggeration;
								}
								getTerrainData(e) {
									if (!this._emptyDemTexture) {
										const u = this.painter.context,
											d = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
										(this._emptyDepthTexture = new s.T(u, d, u.gl.RGBA, {
											premultiply: !1,
										})),
											(this._emptyDemUnpack = [0, 0, 0, 0]),
											(this._emptyDemTexture = new s.T(
												u,
												new s.R({ width: 1, height: 1 }),
												u.gl.RGBA,
												{ premultiply: !1 }
											)),
											this._emptyDemTexture.bind(
												u.gl.NEAREST,
												u.gl.CLAMP_TO_EDGE
											),
											(this._emptyDemMatrix = s.ag([]));
									}
									const i = this.sourceCache.getSourceTile(e, !0);
									if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
										const u = this.painter.context;
										(i.demTexture = this.painter.getTileTexture(i.dem.stride)),
											i.demTexture
												? i.demTexture.update(i.dem.getPixels(), {
														premultiply: !1,
												  })
												: (i.demTexture = new s.T(
														u,
														i.dem.getPixels(),
														u.gl.RGBA,
														{ premultiply: !1 }
												  )),
											i.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE),
											(i.needsTerrainPrepare = !1);
									}
									const l = i && i + i.tileID.key + e.key;
									if (l && !this._demMatrixCache[l]) {
										const u = this.sourceCache.sourceCache._source.maxzoom;
										let d = e.canonical.z - i.tileID.canonical.z;
										e.overscaledZ > e.canonical.z &&
											(e.canonical.z >= u
												? (d = e.canonical.z - u)
												: s.w(
														"cannot calculate elevation if elevation maxzoom > source.maxzoom"
												  ));
										const g = e.canonical.x - ((e.canonical.x >> d) << d),
											w = e.canonical.y - ((e.canonical.y >> d) << d),
											C = s.cu(new Float64Array(16), [
												1 / (s.$ << d),
												1 / (s.$ << d),
												0,
											]);
										s.M(C, C, [g * s.$, w * s.$, 0]),
											(this._demMatrixCache[e.key] = { matrix: C, coord: e });
									}
									return {
										u_depth: 2,
										u_terrain: 3,
										u_terrain_dim: (i && i.dem && i.dem.dim) || 1,
										u_terrain_matrix: l
											? this._demMatrixCache[e.key].matrix
											: this._emptyDemMatrix,
										u_terrain_unpack:
											(i && i.dem && i.dem.getUnpackVector()) ||
											this._emptyDemUnpack,
										u_terrain_exaggeration: this.exaggeration,
										texture: ((i && i.demTexture) || this._emptyDemTexture)
											.texture,
										depthTexture: (
											this._fboDepthTexture || this._emptyDepthTexture
										).texture,
										tile: i,
									};
								}
								getFramebuffer(e) {
									const i = this.painter,
										l = i.width / devicePixelRatio,
										u = i.height / devicePixelRatio;
									return (
										!this._fbo ||
											(this._fbo.width === l && this._fbo.height === u) ||
											(this._fbo.destroy(),
											this._fboCoordsTexture.destroy(),
											this._fboDepthTexture.destroy(),
											delete this._fbo,
											delete this._fboDepthTexture,
											delete this._fboCoordsTexture),
										this._fboCoordsTexture ||
											((this._fboCoordsTexture = new s.T(
												i.context,
												{ width: l, height: u, data: null },
												i.context.gl.RGBA,
												{ premultiply: !1 }
											)),
											this._fboCoordsTexture.bind(
												i.context.gl.NEAREST,
												i.context.gl.CLAMP_TO_EDGE
											)),
										this._fboDepthTexture ||
											((this._fboDepthTexture = new s.T(
												i.context,
												{ width: l, height: u, data: null },
												i.context.gl.RGBA,
												{ premultiply: !1 }
											)),
											this._fboDepthTexture.bind(
												i.context.gl.NEAREST,
												i.context.gl.CLAMP_TO_EDGE
											)),
										this._fbo ||
											((this._fbo = i.context.createFramebuffer(l, u, !0, !1)),
											this._fbo.depthAttachment.set(
												i.context.createRenderbuffer(
													i.context.gl.DEPTH_COMPONENT16,
													l,
													u
												)
											)),
										this._fbo.colorAttachment.set(
											e === "coords"
												? this._fboCoordsTexture.texture
												: this._fboDepthTexture.texture
										),
										this._fbo
									);
								}
								getCoordsTexture() {
									const e = this.painter.context;
									if (this._coordsTexture) return this._coordsTexture;
									const i = new Uint8Array(
										this._coordsTextureSize * this._coordsTextureSize * 4
									);
									for (let d = 0, g = 0; d < this._coordsTextureSize; d++)
										for (let w = 0; w < this._coordsTextureSize; w++, g += 4)
											(i[g + 0] = 255 & w),
												(i[g + 1] = 255 & d),
												(i[g + 2] = ((w >> 8) << 4) | (d >> 8)),
												(i[g + 3] = 0);
									const l = new s.R(
											{
												width: this._coordsTextureSize,
												height: this._coordsTextureSize,
											},
											new Uint8Array(i.buffer)
										),
										u = new s.T(e, l, e.gl.RGBA, { premultiply: !1 });
									return (
										u.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
										(this._coordsTexture = u),
										u
									);
								}
								pointCoordinate(e) {
									this.painter.maybeDrawDepthAndCoords(!0);
									const i = new Uint8Array(4),
										l = this.painter.context,
										u = l.gl,
										d = Math.round(
											(e.x * this.painter.pixelRatio) / devicePixelRatio
										),
										g = Math.round(
											(e.y * this.painter.pixelRatio) / devicePixelRatio
										),
										w = Math.round(this.painter.height / devicePixelRatio);
									l.bindFramebuffer.set(
										this.getFramebuffer("coords").framebuffer
									),
										u.readPixels(
											d,
											w - g - 1,
											1,
											1,
											u.RGBA,
											u.UNSIGNED_BYTE,
											i
										),
										l.bindFramebuffer.set(null);
									const C = i[0] + ((i[2] >> 4) << 8),
										P = i[1] + ((15 & i[2]) << 8),
										E = this.coordsIndex[255 - i[3]],
										R = E && this.sourceCache.getTileByID(E);
									if (!R) return null;
									const D = this._coordsTextureSize,
										N = (1 << R.tileID.canonical.z) * D;
									return new s.a1(
										(R.tileID.canonical.x * D + C) / N + R.tileID.wrap,
										(R.tileID.canonical.y * D + P) / N,
										this.getElevation(R.tileID, C, P, D)
									);
								}
								depthAtPoint(e) {
									const i = new Uint8Array(4),
										l = this.painter.context,
										u = l.gl;
									return (
										l.bindFramebuffer.set(
											this.getFramebuffer("depth").framebuffer
										),
										u.readPixels(
											e.x,
											this.painter.height / devicePixelRatio - e.y - 1,
											1,
											1,
											u.RGBA,
											u.UNSIGNED_BYTE,
											i
										),
										l.bindFramebuffer.set(null),
										(i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
									);
								}
								getTerrainMesh(e) {
									var i;
									const l =
											((i = this.painter.style.projection) === null ||
											i === void 0
												? void 0
												: i.transitionState) > 0,
										u = l && e.canonical.y === 0,
										d = l && e.canonical.y === (1 << e.canonical.z) - 1,
										g = `m_${u ? "n" : ""}_${d ? "s" : ""}`;
									if (this._meshCache[g]) return this._meshCache[g];
									const w = this.painter.context,
										C = new s.cv(),
										P = new s.aN(),
										E = this.meshSize,
										R = s.$ / E,
										D = E * E;
									for (let _e = 0; _e <= E; _e++)
										for (let Be = 0; Be <= E; Be++)
											C.emplaceBack(Be * R, _e * R, 0);
									for (let _e = 0; _e < D; _e += E + 1)
										for (let Be = 0; Be < E; Be++)
											P.emplaceBack(Be + _e, E + Be + _e + 1, E + Be + _e + 2),
												P.emplaceBack(Be + _e, E + Be + _e + 2, Be + _e + 1);
									const N = C.length,
										G = N + (E + 1),
										te = (E + 1) * E,
										Q = u ? s.bh : 0,
										ae = u ? 0 : 1,
										ce = d ? s.bi : s.$,
										ve = d ? 0 : 1;
									for (let _e = 0; _e <= E; _e++) C.emplaceBack(_e * R, Q, ae);
									for (let _e = 0; _e <= E; _e++) C.emplaceBack(_e * R, ce, ve);
									for (let _e = 0; _e < E; _e++)
										P.emplaceBack(te + _e, G + _e, G + _e + 1),
											P.emplaceBack(te + _e, G + _e + 1, te + _e + 1),
											P.emplaceBack(0 + _e, N + _e + 1, N + _e),
											P.emplaceBack(0 + _e, 0 + _e + 1, N + _e + 1);
									const me = C.length,
										be = me + 2 * (E + 1);
									for (const _e of [0, 1])
										for (let Be = 0; Be <= E; Be++)
											for (const rt of [0, 1])
												C.emplaceBack(_e * s.$, Be * R, rt);
									for (let _e = 0; _e < 2 * E; _e += 2)
										P.emplaceBack(me + _e, me + _e + 1, me + _e + 3),
											P.emplaceBack(me + _e, me + _e + 3, me + _e + 2),
											P.emplaceBack(be + _e, be + _e + 3, be + _e + 1),
											P.emplaceBack(be + _e, be + _e + 2, be + _e + 3);
									const Pe = new Tn(
										w.createVertexBuffer(C, ql.members),
										w.createIndexBuffer(P),
										s.aM.simpleSegment(0, 0, C.length, P.length)
									);
									return (this._meshCache[g] = Pe), Pe;
								}
								getMeshFrameDelta(e) {
									return (2 * Math.PI * s.bu) / Math.pow(2, Math.max(e, 0)) / 5;
								}
								getMinTileElevationForLngLatZoom(e, i) {
									var l;
									const { tileID: u } = this._getOverscaledTileIDFromLngLatZoom(
										e,
										i
									);
									return (l = this.getMinMaxElevation(u).minElevation) !==
										null && l !== void 0
										? l
										: 0;
								}
								getMinMaxElevation(e) {
									const i = this.getTerrainData(e).tile,
										l = { minElevation: null, maxElevation: null };
									return (
										i &&
											i.dem &&
											((l.minElevation = i.dem.min * this.exaggeration),
											(l.maxElevation = i.dem.max * this.exaggeration)),
										l
									);
								}
								_getOverscaledTileIDFromLngLatZoom(e, i) {
									const l = s.a1.fromLngLat(e.wrap()),
										u = (1 << i) * s.$,
										d = l.x * u,
										g = l.y * u,
										w = Math.floor(d / s.$),
										C = Math.floor(g / s.$);
									return {
										tileID: new s.Z(i, 0, i, w, C),
										mercatorX: d,
										mercatorY: g,
									};
								}
							}
							class Zl {
								constructor(e, i, l) {
									(this._context = e),
										(this._size = i),
										(this._tileSize = l),
										(this._objects = []),
										(this._recentlyUsed = []),
										(this._stamp = 0);
								}
								destruct() {
									for (const e of this._objects)
										e.texture.destroy(), e.fbo.destroy();
								}
								_createObject(e) {
									const i = this._context.createFramebuffer(
											this._tileSize,
											this._tileSize,
											!0,
											!0
										),
										l = new s.T(
											this._context,
											{
												width: this._tileSize,
												height: this._tileSize,
												data: null,
											},
											this._context.gl.RGBA
										);
									return (
										l.bind(
											this._context.gl.LINEAR,
											this._context.gl.CLAMP_TO_EDGE
										),
										this._context.extTextureFilterAnisotropic &&
											this._context.gl.texParameterf(
												this._context.gl.TEXTURE_2D,
												this._context.extTextureFilterAnisotropic
													.TEXTURE_MAX_ANISOTROPY_EXT,
												this._context.extTextureFilterAnisotropicMax
											),
										i.depthAttachment.set(
											this._context.createRenderbuffer(
												this._context.gl.DEPTH_STENCIL,
												this._tileSize,
												this._tileSize
											)
										),
										i.colorAttachment.set(l.texture),
										{ id: e, fbo: i, texture: l, stamp: -1, inUse: !1 }
									);
								}
								getObjectForId(e) {
									return this._objects[e];
								}
								useObject(e) {
									(e.inUse = !0),
										(this._recentlyUsed = this._recentlyUsed.filter(
											(i) => e.id !== i
										)),
										this._recentlyUsed.push(e.id);
								}
								stampObject(e) {
									e.stamp = ++this._stamp;
								}
								getOrCreateFreeObject() {
									for (const i of this._recentlyUsed)
										if (!this._objects[i].inUse) return this._objects[i];
									if (this._objects.length >= this._size)
										throw new Error(
											"No free RenderPool available, call freeAllObjects() required!"
										);
									const e = this._createObject(this._objects.length);
									return this._objects.push(e), e;
								}
								freeObject(e) {
									e.inUse = !1;
								}
								freeAllObjects() {
									for (const e of this._objects) this.freeObject(e);
								}
								isFull() {
									return (
										!(this._objects.length < this._size) &&
										this._objects.some((e) => !e.inUse) === !1
									);
								}
							}
							const _o = {
								background: !0,
								fill: !0,
								line: !0,
								raster: !0,
								hillshade: !0,
								"color-relief": !0,
							};
							class Ul {
								constructor(e, i) {
									(this.painter = e),
										(this.terrain = i),
										(this.pool = new Zl(
											e.context,
											30,
											i.sourceCache.tileSize * i.qualityFactor
										));
								}
								destruct() {
									this.pool.destruct();
								}
								getTexture(e) {
									return this.pool.getObjectForId(
										e.rtt[this._stacks.length - 1].id
									).texture;
								}
								prepareForRender(e, i) {
									(this._stacks = []),
										(this._prevType = null),
										(this._rttTiles = []),
										(this._renderableTiles =
											this.terrain.sourceCache.getRenderableTiles()),
										(this._renderableLayerIds = e._order.filter(
											(l) => !e._layers[l].isHidden(i)
										)),
										(this._coordsAscending = {});
									for (const l in e.sourceCaches) {
										this._coordsAscending[l] = {};
										const u = e.sourceCaches[l].getVisibleCoordinates(),
											d = e.sourceCaches[l].getSource(),
											g = d instanceof Ot ? d.terrainTileRanges : null;
										for (const w of u) {
											const C = this.terrain.sourceCache.getTerrainCoords(w, g);
											for (const P in C)
												this._coordsAscending[l][P] ||
													(this._coordsAscending[l][P] = []),
													this._coordsAscending[l][P].push(C[P]);
										}
									}
									this._coordsAscendingStr = {};
									for (const l of e._order) {
										const u = e._layers[l],
											d = u.source;
										if (_o[u.type] && !this._coordsAscendingStr[d]) {
											this._coordsAscendingStr[d] = {};
											for (const g in this._coordsAscending[d])
												this._coordsAscendingStr[d][g] = this._coordsAscending[
													d
												][g]
													.map((w) => w.key)
													.sort()
													.join();
										}
									}
									for (const l of this._renderableTiles)
										for (const u in this._coordsAscendingStr) {
											const d = this._coordsAscendingStr[u][l.tileID.key];
											d && d !== l.rttCoords[u] && (l.rtt = []);
										}
								}
								renderLayer(e, i) {
									if (e.isHidden(this.painter.transform.zoom)) return !1;
									const l = Object.assign(Object.assign({}, i), {
											isRenderingToTexture: !0,
										}),
										u = e.type,
										d = this.painter,
										g =
											this._renderableLayerIds[
												this._renderableLayerIds.length - 1
											] === e.id;
									if (
										_o[u] &&
										((this._prevType && _o[this._prevType]) ||
											this._stacks.push([]),
										(this._prevType = u),
										this._stacks[this._stacks.length - 1].push(e.id),
										!g)
									)
										return !0;
									if (_o[this._prevType] || (_o[u] && g)) {
										this._prevType = u;
										const w = this._stacks.length - 1,
											C = this._stacks[w] || [];
										for (const P of this._renderableTiles) {
											if (
												(this.pool.isFull() &&
													(Bl(this.painter, this.terrain, this._rttTiles, l),
													(this._rttTiles = []),
													this.pool.freeAllObjects()),
												this._rttTiles.push(P),
												P.rtt[w])
											) {
												const R = this.pool.getObjectForId(P.rtt[w].id);
												if (R.stamp === P.rtt[w].stamp) {
													this.pool.useObject(R);
													continue;
												}
											}
											const E = this.pool.getOrCreateFreeObject();
											this.pool.useObject(E),
												this.pool.stampObject(E),
												(P.rtt[w] = { id: E.id, stamp: E.stamp }),
												d.context.bindFramebuffer.set(E.fbo.framebuffer),
												d.context.clear({
													color: s.bf.transparent,
													stencil: 0,
												}),
												(d.currentStencilSource = void 0);
											for (let R = 0; R < C.length; R++) {
												const D = d.style._layers[C[R]],
													N = D.source
														? this._coordsAscending[D.source][P.tileID.key]
														: [P.tileID];
												d.context.viewport.set([
													0,
													0,
													E.fbo.width,
													E.fbo.height,
												]),
													d._renderTileClippingMasks(D, N, !0),
													d.renderLayer(
														d,
														d.style.sourceCaches[D.source],
														D,
														N,
														l
													),
													D.source &&
														(P.rttCoords[D.source] =
															this._coordsAscendingStr[D.source][P.tileID.key]);
											}
										}
										return (
											Bl(this.painter, this.terrain, this._rttTiles, l),
											(this._rttTiles = []),
											this.pool.freeAllObjects(),
											_o[u]
										);
									}
									return !1;
								}
							}
							const Ui = {
									"AttributionControl.ToggleAttribution": "Toggle attribution",
									"AttributionControl.MapFeedback": "Map feedback",
									"FullscreenControl.Enter": "Enter fullscreen",
									"FullscreenControl.Exit": "Exit fullscreen",
									"GeolocateControl.FindMyLocation": "Find my location",
									"GeolocateControl.LocationNotAvailable":
										"Location not available",
									"LogoControl.Title": "MapLibre logo",
									"Map.Title": "Map",
									"Marker.Title": "Map marker",
									"NavigationControl.ResetBearing": "Reset bearing to north",
									"NavigationControl.ZoomIn": "Zoom in",
									"NavigationControl.ZoomOut": "Zoom out",
									"Popup.Close": "Close popup",
									"ScaleControl.Feet": "ft",
									"ScaleControl.Meters": "m",
									"ScaleControl.Kilometers": "km",
									"ScaleControl.Miles": "mi",
									"ScaleControl.NauticalMiles": "nm",
									"GlobeControl.Enable": "Enable globe",
									"GlobeControl.Disable": "Disable globe",
									"TerrainControl.Enable": "Enable terrain",
									"TerrainControl.Disable": "Disable terrain",
									"CooperativeGesturesHandler.WindowsHelpText":
										"Use Ctrl + scroll to zoom the map",
									"CooperativeGesturesHandler.MacHelpText":
										"Use ⌘ + scroll to zoom the map",
									"CooperativeGesturesHandler.MobileHelpText":
										"Use two fingers to move the map",
								},
								Td = B,
								xa = {
									hash: !1,
									interactive: !0,
									bearingSnap: 7,
									attributionControl: uu,
									maplibreLogo: !1,
									refreshExpiredTiles: !0,
									canvasContextAttributes: {
										antialias: !1,
										preserveDrawingBuffer: !1,
										powerPreference: "high-performance",
										failIfMajorPerformanceCaveat: !1,
										desynchronized: !1,
										contextType: void 0,
									},
									scrollZoom: !0,
									minZoom: -2,
									maxZoom: 22,
									minPitch: 0,
									maxPitch: 60,
									boxZoom: !0,
									dragRotate: !0,
									dragPan: !0,
									keyboard: !0,
									doubleClickZoom: !0,
									touchZoomRotate: !0,
									touchPitch: !0,
									cooperativeGestures: !1,
									trackResize: !0,
									center: [0, 0],
									elevation: 0,
									zoom: 0,
									bearing: 0,
									pitch: 0,
									roll: 0,
									renderWorldCopies: !0,
									maxTileCacheSize: null,
									maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS,
									transformRequest: null,
									transformCameraUpdate: null,
									fadeDuration: 300,
									crossSourceCollisions: !0,
									clickTolerance: 3,
									localIdeographFontFamily: "sans-serif",
									pitchWithRotate: !0,
									rollEnabled: !1,
									validateStyle: !0,
									maxCanvasSize: [4096, 4096],
									cancelPendingTileRequestsWhileZooming: !0,
									centerClampedToGround: !0,
								},
								$p = {
									showCompass: !0,
									showZoom: !0,
									visualizePitch: !1,
									visualizeRoll: !0,
								};
							class Ks {
								constructor(e, i, l = !1) {
									(this.mousedown = (d) => {
										this.startMove(d, H.mousePos(this.element, d)),
											H.addEventListener(window, "mousemove", this.mousemove),
											H.addEventListener(window, "mouseup", this.mouseup);
									}),
										(this.mousemove = (d) => {
											this.move(d, H.mousePos(this.element, d));
										}),
										(this.mouseup = (d) => {
											this._rotatePitchHandler.dragEnd(d), this.offTemp();
										}),
										(this.touchstart = (d) => {
											d.targetTouches.length !== 1
												? this.reset()
												: ((this._startPos = this._lastPos =
														H.touchPos(this.element, d.targetTouches)[0]),
												  this.startMove(d, this._startPos),
												  H.addEventListener(
														window,
														"touchmove",
														this.touchmove,
														{ passive: !1 }
												  ),
												  H.addEventListener(
														window,
														"touchend",
														this.touchend
												  ));
										}),
										(this.touchmove = (d) => {
											d.targetTouches.length !== 1
												? this.reset()
												: ((this._lastPos = H.touchPos(
														this.element,
														d.targetTouches
												  )[0]),
												  this.move(d, this._lastPos));
										}),
										(this.touchend = (d) => {
											d.targetTouches.length === 0 &&
												this._startPos &&
												this._lastPos &&
												this._startPos.dist(this._lastPos) <
													this._clickTolerance &&
												this.element.click(),
												delete this._startPos,
												delete this._lastPos,
												this.offTemp();
										}),
										(this.reset = () => {
											this._rotatePitchHandler.reset(),
												delete this._startPos,
												delete this._lastPos,
												this.offTemp();
										}),
										(this._clickTolerance = 10),
										(this.element = i);
									const u = new qp();
									(this._rotatePitchHandler = new ss({
										clickTolerance: 3,
										move: (d, g) => {
											const w = i.getBoundingClientRect(),
												C = new s.P(
													(w.bottom - w.top) / 2,
													(w.right - w.left) / 2
												);
											return {
												bearingDelta: s.cn(new s.P(d.x, g.y), g, C),
												pitchDelta: l ? -0.5 * (g.y - d.y) : void 0,
											};
										},
										moveStateManager: u,
										enable: !0,
										assignEvents: () => {},
									})),
										(this.map = e),
										H.addEventListener(i, "mousedown", this.mousedown),
										H.addEventListener(i, "touchstart", this.touchstart, {
											passive: !1,
										}),
										H.addEventListener(i, "touchcancel", this.reset);
								}
								startMove(e, i) {
									this._rotatePitchHandler.dragStart(e, i), H.disableDrag();
								}
								move(e, i) {
									const l = this.map,
										{ bearingDelta: u, pitchDelta: d } =
											this._rotatePitchHandler.dragMove(e, i) || {};
									u && l.setBearing(l.getBearing() + u),
										d && l.setPitch(l.getPitch() + d);
								}
								off() {
									const e = this.element;
									H.removeEventListener(e, "mousedown", this.mousedown),
										H.removeEventListener(e, "touchstart", this.touchstart, {
											passive: !1,
										}),
										H.removeEventListener(window, "touchmove", this.touchmove, {
											passive: !1,
										}),
										H.removeEventListener(window, "touchend", this.touchend),
										H.removeEventListener(e, "touchcancel", this.reset),
										this.offTemp();
								}
								offTemp() {
									H.enableDrag(),
										H.removeEventListener(window, "mousemove", this.mousemove),
										H.removeEventListener(window, "mouseup", this.mouseup),
										H.removeEventListener(window, "touchmove", this.touchmove, {
											passive: !1,
										}),
										H.removeEventListener(window, "touchend", this.touchend);
								}
							}
							let Dn;
							function ti(h, e, i, l = !1) {
								if (
									l ||
									!i.getCoveringTilesDetailsProvider().allowWorldCopies()
								)
									return h == null ? void 0 : h.wrap();
								const u = new s.S(h.lng, h.lat);
								if (((h = new s.S(h.lng, h.lat)), e)) {
									const d = new s.S(h.lng - 360, h.lat),
										g = new s.S(h.lng + 360, h.lat),
										w = i.locationToScreenPoint(h).distSqr(e);
									i.locationToScreenPoint(d).distSqr(e) < w
										? (h = d)
										: i.locationToScreenPoint(g).distSqr(e) < w && (h = g);
								}
								for (; Math.abs(h.lng - i.center.lng) > 180; ) {
									const d = i.locationToScreenPoint(h);
									if (d.x >= 0 && d.y >= 0 && d.x <= i.width && d.y <= i.height)
										break;
									h.lng > i.center.lng ? (h.lng -= 360) : (h.lng += 360);
								}
								return h.lng !== u.lng &&
									i.isPointOnMapSurface(i.locationToScreenPoint(h))
									? h
									: u;
							}
							const $l = {
								center: "translate(-50%,-50%)",
								top: "translate(-50%,0)",
								"top-left": "translate(0,0)",
								"top-right": "translate(-100%,0)",
								bottom: "translate(-50%,-100%)",
								"bottom-left": "translate(0,-100%)",
								"bottom-right": "translate(-100%,-100%)",
								left: "translate(0,-50%)",
								right: "translate(-100%,-50%)",
							};
							function hs(h, e, i) {
								const l = h.classList;
								for (const u in $l) l.remove(`maplibregl-${i}-anchor-${u}`);
								l.add(`maplibregl-${i}-anchor-${e}`);
							}
							class ds extends s.E {
								constructor(e) {
									if (
										(super(),
										(this._onKeyPress = (i) => {
											const l = i.code,
												u = i.charCode || i.keyCode;
											(l !== "Space" &&
												l !== "Enter" &&
												u !== 32 &&
												u !== 13) ||
												this.togglePopup();
										}),
										(this._onMapClick = (i) => {
											const l = i.originalEvent.target,
												u = this._element;
											this._popup &&
												(l === u || u.contains(l)) &&
												this.togglePopup();
										}),
										(this._update = (i) => {
											if (!this._map) return;
											const l = this._map.loaded() && !this._map.isMoving();
											((i == null ? void 0 : i.type) === "terrain" ||
												((i == null ? void 0 : i.type) === "render" && !l)) &&
												this._map.once("render", this._update),
												(this._lngLat = ti(
													this._lngLat,
													this._flatPos,
													this._map.transform
												)),
												(this._flatPos = this._pos =
													this._map.project(this._lngLat)._add(this._offset)),
												this._map.terrain &&
													(this._flatPos = this._map.transform
														.locationToScreenPoint(this._lngLat)
														._add(this._offset));
											let u = "";
											this._rotationAlignment === "viewport" ||
											this._rotationAlignment === "auto"
												? (u = `rotateZ(${this._rotation}deg)`)
												: this._rotationAlignment === "map" &&
												  (u = `rotateZ(${
														this._rotation - this._map.getBearing()
												  }deg)`);
											let d = "";
											this._pitchAlignment === "viewport" ||
											this._pitchAlignment === "auto"
												? (d = "rotateX(0deg)")
												: this._pitchAlignment === "map" &&
												  (d = `rotateX(${this._map.getPitch()}deg)`),
												this._subpixelPositioning ||
													(i && i.type !== "moveend") ||
													(this._pos = this._pos.round()),
												H.setTransform(
													this._element,
													`${$l[this._anchor]} translate(${this._pos.x}px, ${
														this._pos.y
													}px) ${d} ${u}`
												),
												ne
													.frameAsync(new AbortController())
													.then(() => {
														this._updateOpacity(i && i.type === "moveend");
													})
													.catch(() => {});
										}),
										(this._onMove = (i) => {
											if (!this._isDragging) {
												const l =
													this._clickTolerance || this._map._clickTolerance;
												this._isDragging =
													i.point.dist(this._pointerdownPos) >= l;
											}
											this._isDragging &&
												((this._pos = i.point.sub(this._positionDelta)),
												(this._lngLat = this._map.unproject(this._pos)),
												this.setLngLat(this._lngLat),
												(this._element.style.pointerEvents = "none"),
												this._state === "pending" &&
													((this._state = "active"),
													this.fire(new s.l("dragstart"))),
												this.fire(new s.l("drag")));
										}),
										(this._onUp = () => {
											(this._element.style.pointerEvents = "auto"),
												(this._positionDelta = null),
												(this._pointerdownPos = null),
												(this._isDragging = !1),
												this._map.off("mousemove", this._onMove),
												this._map.off("touchmove", this._onMove),
												this._state === "active" &&
													this.fire(new s.l("dragend")),
												(this._state = "inactive");
										}),
										(this._addDragHandler = (i) => {
											this._element.contains(i.originalEvent.target) &&
												(i.preventDefault(),
												(this._positionDelta = i.point
													.sub(this._pos)
													.add(this._offset)),
												(this._pointerdownPos = i.point),
												(this._state = "pending"),
												this._map.on("mousemove", this._onMove),
												this._map.on("touchmove", this._onMove),
												this._map.once("mouseup", this._onUp),
												this._map.once("touchend", this._onUp));
										}),
										(this._anchor = (e && e.anchor) || "center"),
										(this._color = (e && e.color) || "#3FB1CE"),
										(this._scale = (e && e.scale) || 1),
										(this._draggable = (e && e.draggable) || !1),
										(this._clickTolerance = (e && e.clickTolerance) || 0),
										(this._subpixelPositioning =
											(e && e.subpixelPositioning) || !1),
										(this._isDragging = !1),
										(this._state = "inactive"),
										(this._rotation = (e && e.rotation) || 0),
										(this._rotationAlignment =
											(e && e.rotationAlignment) || "auto"),
										(this._pitchAlignment =
											e && e.pitchAlignment && e.pitchAlignment !== "auto"
												? e.pitchAlignment
												: this._rotationAlignment),
										this.setOpacity(
											e == null ? void 0 : e.opacity,
											e == null ? void 0 : e.opacityWhenCovered
										),
										e && e.element)
									)
										(this._element = e.element),
											(this._offset = s.P.convert((e && e.offset) || [0, 0]));
									else {
										(this._defaultMarker = !0),
											(this._element = H.create("div"));
										const i = H.createNS("http://www.w3.org/2000/svg", "svg"),
											l = 41,
											u = 27;
										i.setAttributeNS(null, "display", "block"),
											i.setAttributeNS(null, "height", `${l}px`),
											i.setAttributeNS(null, "width", `${u}px`),
											i.setAttributeNS(null, "viewBox", `0 0 ${u} ${l}`);
										const d = H.createNS("http://www.w3.org/2000/svg", "g");
										d.setAttributeNS(null, "stroke", "none"),
											d.setAttributeNS(null, "stroke-width", "1"),
											d.setAttributeNS(null, "fill", "none"),
											d.setAttributeNS(null, "fill-rule", "evenodd");
										const g = H.createNS("http://www.w3.org/2000/svg", "g");
										g.setAttributeNS(null, "fill-rule", "nonzero");
										const w = H.createNS("http://www.w3.org/2000/svg", "g");
										w.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
											w.setAttributeNS(null, "fill", "#000000");
										const C = [
											{ rx: "10.5", ry: "5.25002273" },
											{ rx: "10.5", ry: "5.25002273" },
											{ rx: "9.5", ry: "4.77275007" },
											{ rx: "8.5", ry: "4.29549936" },
											{ rx: "7.5", ry: "3.81822308" },
											{ rx: "6.5", ry: "3.34094679" },
											{ rx: "5.5", ry: "2.86367051" },
											{ rx: "4.5", ry: "2.38636864" },
										];
										for (const ae of C) {
											const ce = H.createNS(
												"http://www.w3.org/2000/svg",
												"ellipse"
											);
											ce.setAttributeNS(null, "opacity", "0.04"),
												ce.setAttributeNS(null, "cx", "10.5"),
												ce.setAttributeNS(null, "cy", "5.80029008"),
												ce.setAttributeNS(null, "rx", ae.rx),
												ce.setAttributeNS(null, "ry", ae.ry),
												w.appendChild(ce);
										}
										const P = H.createNS("http://www.w3.org/2000/svg", "g");
										P.setAttributeNS(null, "fill", this._color);
										const E = H.createNS("http://www.w3.org/2000/svg", "path");
										E.setAttributeNS(
											null,
											"d",
											"M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"
										),
											P.appendChild(E);
										const R = H.createNS("http://www.w3.org/2000/svg", "g");
										R.setAttributeNS(null, "opacity", "0.25"),
											R.setAttributeNS(null, "fill", "#000000");
										const D = H.createNS("http://www.w3.org/2000/svg", "path");
										D.setAttributeNS(
											null,
											"d",
											"M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"
										),
											R.appendChild(D);
										const N = H.createNS("http://www.w3.org/2000/svg", "g");
										N.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
											N.setAttributeNS(null, "fill", "#FFFFFF");
										const G = H.createNS("http://www.w3.org/2000/svg", "g");
										G.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
										const te = H.createNS(
											"http://www.w3.org/2000/svg",
											"circle"
										);
										te.setAttributeNS(null, "fill", "#000000"),
											te.setAttributeNS(null, "opacity", "0.25"),
											te.setAttributeNS(null, "cx", "5.5"),
											te.setAttributeNS(null, "cy", "5.5"),
											te.setAttributeNS(null, "r", "5.4999962");
										const Q = H.createNS(
											"http://www.w3.org/2000/svg",
											"circle"
										);
										Q.setAttributeNS(null, "fill", "#FFFFFF"),
											Q.setAttributeNS(null, "cx", "5.5"),
											Q.setAttributeNS(null, "cy", "5.5"),
											Q.setAttributeNS(null, "r", "5.4999962"),
											G.appendChild(te),
											G.appendChild(Q),
											g.appendChild(w),
											g.appendChild(P),
											g.appendChild(R),
											g.appendChild(N),
											g.appendChild(G),
											i.appendChild(g),
											i.setAttributeNS(null, "height", l * this._scale + "px"),
											i.setAttributeNS(null, "width", u * this._scale + "px"),
											this._element.appendChild(i),
											(this._offset = s.P.convert((e && e.offset) || [0, -14]));
									}
									if (
										(this._element.classList.add("maplibregl-marker"),
										this._element.addEventListener("dragstart", (i) => {
											i.preventDefault();
										}),
										this._element.addEventListener("mousedown", (i) => {
											i.preventDefault();
										}),
										hs(this._element, this._anchor, "marker"),
										e && e.className)
									)
										for (const i of e.className.split(" "))
											this._element.classList.add(i);
									this._popup = null;
								}
								addTo(e) {
									return (
										this.remove(),
										(this._map = e),
										this._element.hasAttribute("aria-label") ||
											this._element.setAttribute(
												"aria-label",
												e._getUIString("Marker.Title")
											),
										e.getCanvasContainer().appendChild(this._element),
										e.on("move", this._update),
										e.on("moveend", this._update),
										e.on("terrain", this._update),
										e.on("projectiontransition", this._update),
										this.setDraggable(this._draggable),
										this._update(),
										this._map.on("click", this._onMapClick),
										this
									);
								}
								remove() {
									return (
										this._opacityTimeout &&
											(clearTimeout(this._opacityTimeout),
											delete this._opacityTimeout),
										this._map &&
											(this._map.off("click", this._onMapClick),
											this._map.off("move", this._update),
											this._map.off("moveend", this._update),
											this._map.off("terrain", this._update),
											this._map.off("projectiontransition", this._update),
											this._map.off("mousedown", this._addDragHandler),
											this._map.off("touchstart", this._addDragHandler),
											this._map.off("mouseup", this._onUp),
											this._map.off("touchend", this._onUp),
											this._map.off("mousemove", this._onMove),
											this._map.off("touchmove", this._onMove),
											delete this._map),
										H.remove(this._element),
										this._popup && this._popup.remove(),
										this
									);
								}
								getLngLat() {
									return this._lngLat;
								}
								setLngLat(e) {
									return (
										(this._lngLat = s.S.convert(e)),
										(this._pos = null),
										this._popup && this._popup.setLngLat(this._lngLat),
										this._update(),
										this
									);
								}
								getElement() {
									return this._element;
								}
								setPopup(e) {
									if (
										(this._popup &&
											(this._popup.remove(),
											(this._popup = null),
											this._element.removeEventListener(
												"keypress",
												this._onKeyPress
											),
											this._originalTabIndex ||
												this._element.removeAttribute("tabindex")),
										e)
									) {
										if (!("offset" in e.options)) {
											const u = Math.abs(13.5) / Math.SQRT2;
											e.options.offset = this._defaultMarker
												? {
														top: [0, 0],
														"top-left": [0, 0],
														"top-right": [0, 0],
														bottom: [0, -38.1],
														"bottom-left": [u, -1 * (38.1 - 13.5 + u)],
														"bottom-right": [-u, -1 * (38.1 - 13.5 + u)],
														left: [13.5, -1 * (38.1 - 13.5)],
														right: [-13.5, -1 * (38.1 - 13.5)],
												  }
												: this._offset;
										}
										(this._popup = e),
											(this._originalTabIndex =
												this._element.getAttribute("tabindex")),
											this._originalTabIndex ||
												this._element.setAttribute("tabindex", "0"),
											this._element.addEventListener(
												"keypress",
												this._onKeyPress
											);
									}
									return this;
								}
								setSubpixelPositioning(e) {
									return (this._subpixelPositioning = e), this;
								}
								getPopup() {
									return this._popup;
								}
								togglePopup() {
									const e = this._popup;
									return this._element.style.opacity ===
										this._opacityWhenCovered
										? this
										: e
										? (e.isOpen()
												? e.remove()
												: (e.setLngLat(this._lngLat), e.addTo(this._map)),
										  this)
										: this;
								}
								_updateOpacity(e = !1) {
									var i, l;
									const u =
											(i = this._map) === null || i === void 0
												? void 0
												: i.terrain,
										d = this._map.transform.isLocationOccluded(this._lngLat);
									if (!u || d) {
										const N = d ? this._opacityWhenCovered : this._opacity;
										return void (
											this._element.style.opacity !== N &&
											(this._element.style.opacity = N)
										);
									}
									if (e) this._opacityTimeout = null;
									else {
										if (this._opacityTimeout) return;
										this._opacityTimeout = setTimeout(() => {
											this._opacityTimeout = null;
										}, 100);
									}
									const g = this._map,
										w = g.terrain.depthAtPoint(this._pos),
										C = g.terrain.getElevationForLngLatZoom(
											this._lngLat,
											g.transform.tileZoom
										);
									if (
										g.transform.lngLatToCameraDepth(this._lngLat, C) - w <
										0.006
									)
										return void (this._element.style.opacity = this._opacity);
									const P = -this._offset.y / g.transform.pixelsPerMeter,
										E = Math.sin((g.getPitch() * Math.PI) / 180) * P,
										R = g.terrain.depthAtPoint(
											new s.P(this._pos.x, this._pos.y - this._offset.y)
										),
										D =
											g.transform.lngLatToCameraDepth(this._lngLat, C + E) - R >
											0.006;
									!((l = this._popup) === null || l === void 0) &&
										l.isOpen() &&
										D &&
										this._popup.remove(),
										(this._element.style.opacity = D
											? this._opacityWhenCovered
											: this._opacity);
								}
								getOffset() {
									return this._offset;
								}
								setOffset(e) {
									return (this._offset = s.P.convert(e)), this._update(), this;
								}
								addClassName(e) {
									this._element.classList.add(e);
								}
								removeClassName(e) {
									this._element.classList.remove(e);
								}
								toggleClassName(e) {
									return this._element.classList.toggle(e);
								}
								setDraggable(e) {
									return (
										(this._draggable = !!e),
										this._map &&
											(e
												? (this._map.on("mousedown", this._addDragHandler),
												  this._map.on("touchstart", this._addDragHandler))
												: (this._map.off("mousedown", this._addDragHandler),
												  this._map.off("touchstart", this._addDragHandler))),
										this
									);
								}
								isDraggable() {
									return this._draggable;
								}
								setRotation(e) {
									return (this._rotation = e || 0), this._update(), this;
								}
								getRotation() {
									return this._rotation;
								}
								setRotationAlignment(e) {
									return (
										(this._rotationAlignment = e || "auto"),
										this._update(),
										this
									);
								}
								getRotationAlignment() {
									return this._rotationAlignment;
								}
								setPitchAlignment(e) {
									return (
										(this._pitchAlignment =
											e && e !== "auto" ? e : this._rotationAlignment),
										this._update(),
										this
									);
								}
								getPitchAlignment() {
									return this._pitchAlignment;
								}
								setOpacity(e, i) {
									return (
										(this._opacity === void 0 ||
											(e === void 0 && i === void 0)) &&
											((this._opacity = "1"),
											(this._opacityWhenCovered = "0.2")),
										e !== void 0 && (this._opacity = e),
										i !== void 0 && (this._opacityWhenCovered = i),
										this._map && this._updateOpacity(!0),
										this
									);
								}
							}
							const du = {
								positionOptions: {
									enableHighAccuracy: !1,
									maximumAge: 0,
									timeout: 6e3,
								},
								fitBoundsOptions: { maxZoom: 15 },
								trackUserLocation: !1,
								showAccuracyCircle: !0,
								showUserLocation: !0,
							};
							let ps = 0,
								No = !1;
							const Js = { maxWidth: 100, unit: "metric" };
							function Gl(h, e, i) {
								const l = (i && i.maxWidth) || 100,
									u = h._container.clientHeight / 2,
									d = h._container.clientWidth / 2,
									g = h.unproject([d - l / 2, u]),
									w = h.unproject([d + l / 2, u]),
									C = Math.round(h.project(w).x - h.project(g).x),
									P = Math.min(l, C, h._container.clientWidth),
									E = g.distanceTo(w);
								if (i && i.unit === "imperial") {
									const R = 3.2808 * E;
									R > 5280
										? jo(e, P, R / 5280, h._getUIString("ScaleControl.Miles"))
										: jo(e, P, R, h._getUIString("ScaleControl.Feet"));
								} else i && i.unit === "nautical" ? jo(e, P, E / 1852, h._getUIString("ScaleControl.NauticalMiles")) : E >= 1e3 ? jo(e, P, E / 1e3, h._getUIString("ScaleControl.Kilometers")) : jo(e, P, E, h._getUIString("ScaleControl.Meters"));
							}
							function jo(h, e, i, l) {
								const u = (function (d) {
									const g = Math.pow(10, `${Math.floor(d)}`.length - 1);
									let w = d / g;
									return (
										(w =
											w >= 10
												? 10
												: w >= 5
												? 5
												: w >= 3
												? 3
												: w >= 2
												? 2
												: w >= 1
												? 1
												: (function (C) {
														const P = Math.pow(
															10,
															Math.ceil(-Math.log(C) / Math.LN10)
														);
														return Math.round(C * P) / P;
												  })(w)),
										g * w
									);
								})(i);
								(h.style.width = e * (u / i) + "px"),
									(h.innerHTML = `${u}&nbsp;${l}`);
							}
							const pu = {
									closeButton: !0,
									closeOnClick: !0,
									focusAfterOpen: !0,
									className: "",
									maxWidth: "240px",
									subpixelPositioning: !1,
									locationOccludedOpacity: void 0,
								},
								fu = [
									"a[href]",
									"[tabindex]:not([tabindex='-1'])",
									"[contenteditable]:not([contenteditable='false'])",
									"button:not([disabled])",
									"input:not([disabled])",
									"select:not([disabled])",
									"textarea:not([disabled])",
								].join(", ");
							function Hl(h) {
								if (h) {
									if (typeof h == "number") {
										const e = Math.round(Math.abs(h) / Math.SQRT2);
										return {
											center: new s.P(0, 0),
											top: new s.P(0, h),
											"top-left": new s.P(e, e),
											"top-right": new s.P(-e, e),
											bottom: new s.P(0, -h),
											"bottom-left": new s.P(e, -e),
											"bottom-right": new s.P(-e, -e),
											left: new s.P(h, 0),
											right: new s.P(-h, 0),
										};
									}
									if (h instanceof s.P || Array.isArray(h)) {
										const e = s.P.convert(h);
										return {
											center: e,
											top: e,
											"top-left": e,
											"top-right": e,
											bottom: e,
											"bottom-left": e,
											"bottom-right": e,
											left: e,
											right: e,
										};
									}
									return {
										center: s.P.convert(h.center || [0, 0]),
										top: s.P.convert(h.top || [0, 0]),
										"top-left": s.P.convert(h["top-left"] || [0, 0]),
										"top-right": s.P.convert(h["top-right"] || [0, 0]),
										bottom: s.P.convert(h.bottom || [0, 0]),
										"bottom-left": s.P.convert(h["bottom-left"] || [0, 0]),
										"bottom-right": s.P.convert(h["bottom-right"] || [0, 0]),
										left: s.P.convert(h.left || [0, 0]),
										right: s.P.convert(h.right || [0, 0]),
									};
								}
								return Hl(new s.P(0, 0));
							}
							const mu = B;
							(T.AJAXError = s.cz),
								(T.Event = s.l),
								(T.Evented = s.E),
								(T.LngLat = s.S),
								(T.MercatorCoordinate = s.a1),
								(T.Point = s.P),
								(T.addProtocol = s.cA),
								(T.config = s.a),
								(T.removeProtocol = s.cB),
								(T.AttributionControl = hu),
								(T.BoxZoomHandler = nu),
								(T.CanvasSource = or),
								(T.CooperativeGesturesHandler = xd),
								(T.DoubleClickZoomHandler = ou),
								(T.DragPanHandler = vd),
								(T.DragRotateHandler = lu),
								(T.EdgeInsets = Mn),
								(T.FullscreenControl = class extends s.E {
									constructor(h = {}) {
										super(),
											(this._onFullscreenChange = () => {
												var e;
												let i =
													window.document.fullscreenElement ||
													window.document.mozFullScreenElement ||
													window.document.webkitFullscreenElement ||
													window.document.msFullscreenElement;
												for (
													;
													!(
														(e = i == null ? void 0 : i.shadowRoot) === null ||
														e === void 0
													) && e.fullscreenElement;

												)
													i = i.shadowRoot.fullscreenElement;
												(i === this._container) !== this._fullscreen &&
													this._handleFullscreenChange();
											}),
											(this._onClickFullscreen = () => {
												this._isFullscreen()
													? this._exitFullscreen()
													: this._requestFullscreen();
											}),
											(this._fullscreen = !1),
											h &&
												h.container &&
												(h.container instanceof HTMLElement
													? (this._container = h.container)
													: s.w(
															"Full screen control 'container' must be a DOM element."
													  )),
											"onfullscreenchange" in document
												? (this._fullscreenchange = "fullscreenchange")
												: "onmozfullscreenchange" in document
												? (this._fullscreenchange = "mozfullscreenchange")
												: "onwebkitfullscreenchange" in document
												? (this._fullscreenchange = "webkitfullscreenchange")
												: "onmsfullscreenchange" in document &&
												  (this._fullscreenchange = "MSFullscreenChange");
									}
									onAdd(h) {
										return (
											(this._map = h),
											this._container ||
												(this._container = this._map.getContainer()),
											(this._controlContainer = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-group"
											)),
											this._setupUI(),
											this._controlContainer
										);
									}
									onRemove() {
										H.remove(this._controlContainer),
											(this._map = null),
											window.document.removeEventListener(
												this._fullscreenchange,
												this._onFullscreenChange
											);
									}
									_setupUI() {
										const h = (this._fullscreenButton = H.create(
											"button",
											"maplibregl-ctrl-fullscreen",
											this._controlContainer
										));
										H.create("span", "maplibregl-ctrl-icon", h).setAttribute(
											"aria-hidden",
											"true"
										),
											(h.type = "button"),
											this._updateTitle(),
											this._fullscreenButton.addEventListener(
												"click",
												this._onClickFullscreen
											),
											window.document.addEventListener(
												this._fullscreenchange,
												this._onFullscreenChange
											);
									}
									_updateTitle() {
										const h = this._getTitle();
										this._fullscreenButton.setAttribute("aria-label", h),
											(this._fullscreenButton.title = h);
									}
									_getTitle() {
										return this._map._getUIString(
											this._isFullscreen()
												? "FullscreenControl.Exit"
												: "FullscreenControl.Enter"
										);
									}
									_isFullscreen() {
										return this._fullscreen;
									}
									_handleFullscreenChange() {
										(this._fullscreen = !this._fullscreen),
											this._fullscreenButton.classList.toggle(
												"maplibregl-ctrl-shrink"
											),
											this._fullscreenButton.classList.toggle(
												"maplibregl-ctrl-fullscreen"
											),
											this._updateTitle(),
											this._fullscreen
												? (this.fire(new s.l("fullscreenstart")),
												  (this._prevCooperativeGesturesEnabled =
														this._map.cooperativeGestures.isEnabled()),
												  this._map.cooperativeGestures.disable())
												: (this.fire(new s.l("fullscreenend")),
												  this._prevCooperativeGesturesEnabled &&
														this._map.cooperativeGestures.enable());
									}
									_exitFullscreen() {
										window.document.exitFullscreen
											? window.document.exitFullscreen()
											: window.document.mozCancelFullScreen
											? window.document.mozCancelFullScreen()
											: window.document.msExitFullscreen
											? window.document.msExitFullscreen()
											: window.document.webkitCancelFullScreen
											? window.document.webkitCancelFullScreen()
											: this._togglePseudoFullScreen();
									}
									_requestFullscreen() {
										this._container.requestFullscreen
											? this._container.requestFullscreen()
											: this._container.mozRequestFullScreen
											? this._container.mozRequestFullScreen()
											: this._container.msRequestFullscreen
											? this._container.msRequestFullscreen()
											: this._container.webkitRequestFullscreen
											? this._container.webkitRequestFullscreen()
											: this._togglePseudoFullScreen();
									}
									_togglePseudoFullScreen() {
										this._container.classList.toggle(
											"maplibregl-pseudo-fullscreen"
										),
											this._handleFullscreenChange(),
											this._map.resize();
									}
								}),
								(T.GeoJSONSource = Qt),
								(T.GeolocateControl = class extends s.E {
									constructor(h) {
										super(),
											(this._onSuccess = (e) => {
												if (this._map) {
													if (this._isOutOfMapMaxBounds(e))
														return (
															this._setErrorState(),
															this.fire(new s.l("outofmaxbounds", e)),
															this._updateMarker(),
															void this._finish()
														);
													if (this.options.trackUserLocation)
														switch (
															((this._lastKnownPosition = e), this._watchState)
														) {
															case "WAITING_ACTIVE":
															case "ACTIVE_LOCK":
															case "ACTIVE_ERROR":
																(this._watchState = "ACTIVE_LOCK"),
																	this._geolocateButton.classList.remove(
																		"maplibregl-ctrl-geolocate-waiting"
																	),
																	this._geolocateButton.classList.remove(
																		"maplibregl-ctrl-geolocate-active-error"
																	),
																	this._geolocateButton.classList.add(
																		"maplibregl-ctrl-geolocate-active"
																	);
																break;
															case "BACKGROUND":
															case "BACKGROUND_ERROR":
																(this._watchState = "BACKGROUND"),
																	this._geolocateButton.classList.remove(
																		"maplibregl-ctrl-geolocate-waiting"
																	),
																	this._geolocateButton.classList.remove(
																		"maplibregl-ctrl-geolocate-background-error"
																	),
																	this._geolocateButton.classList.add(
																		"maplibregl-ctrl-geolocate-background"
																	);
																break;
															default:
																throw new Error(
																	`Unexpected watchState ${this._watchState}`
																);
														}
													this.options.showUserLocation &&
														this._watchState !== "OFF" &&
														this._updateMarker(e),
														(this.options.trackUserLocation &&
															this._watchState !== "ACTIVE_LOCK") ||
															this._updateCamera(e),
														this.options.showUserLocation &&
															this._dotElement.classList.remove(
																"maplibregl-user-location-dot-stale"
															),
														this.fire(new s.l("geolocate", e)),
														this._finish();
												}
											}),
											(this._updateCamera = (e) => {
												const i = new s.S(
														e.coords.longitude,
														e.coords.latitude
													),
													l = e.coords.accuracy,
													u = this._map.getBearing(),
													d = s.e(
														{ bearing: u },
														this.options.fitBoundsOptions
													),
													g = _t.fromLngLat(i, l);
												this._map.fitBounds(g, d, { geolocateSource: !0 });
											}),
											(this._updateMarker = (e) => {
												if (e) {
													const i = new s.S(
														e.coords.longitude,
														e.coords.latitude
													);
													this._accuracyCircleMarker
														.setLngLat(i)
														.addTo(this._map),
														this._userLocationDotMarker
															.setLngLat(i)
															.addTo(this._map),
														(this._accuracy = e.coords.accuracy),
														this.options.showUserLocation &&
															this.options.showAccuracyCircle &&
															this._updateCircleRadius();
												} else
													this._userLocationDotMarker.remove(),
														this._accuracyCircleMarker.remove();
											}),
											(this._onZoom = () => {
												this.options.showUserLocation &&
													this.options.showAccuracyCircle &&
													this._updateCircleRadius();
											}),
											(this._onError = (e) => {
												if (this._map) {
													if (e.code === 1) {
														(this._watchState = "OFF"),
															this._geolocateButton.classList.remove(
																"maplibregl-ctrl-geolocate-waiting"
															),
															this._geolocateButton.classList.remove(
																"maplibregl-ctrl-geolocate-active"
															),
															this._geolocateButton.classList.remove(
																"maplibregl-ctrl-geolocate-active-error"
															),
															this._geolocateButton.classList.remove(
																"maplibregl-ctrl-geolocate-background"
															),
															this._geolocateButton.classList.remove(
																"maplibregl-ctrl-geolocate-background-error"
															),
															(this._geolocateButton.disabled = !0);
														const i = this._map._getUIString(
															"GeolocateControl.LocationNotAvailable"
														);
														(this._geolocateButton.title = i),
															this._geolocateButton.setAttribute(
																"aria-label",
																i
															),
															this._geolocationWatchID !== void 0 &&
																this._clearWatch();
													} else {
														if (e.code === 3 && No) return;
														this.options.trackUserLocation &&
															this._setErrorState();
													}
													this._watchState !== "OFF" &&
														this.options.showUserLocation &&
														this._dotElement.classList.add(
															"maplibregl-user-location-dot-stale"
														),
														this.fire(new s.l("error", e)),
														this._finish();
												}
											}),
											(this._finish = () => {
												this._timeoutId && clearTimeout(this._timeoutId),
													(this._timeoutId = void 0);
											}),
											(this._setupUI = () => {
												this._map &&
													(this._container.addEventListener(
														"contextmenu",
														(e) => e.preventDefault()
													),
													(this._geolocateButton = H.create(
														"button",
														"maplibregl-ctrl-geolocate",
														this._container
													)),
													H.create(
														"span",
														"maplibregl-ctrl-icon",
														this._geolocateButton
													).setAttribute("aria-hidden", "true"),
													(this._geolocateButton.type = "button"),
													(this._geolocateButton.disabled = !0));
											}),
											(this._finishSetupUI = (e) => {
												if (this._map) {
													if (e === !1) {
														s.w(
															"Geolocation support is not available so the GeolocateControl will be disabled."
														);
														const i = this._map._getUIString(
															"GeolocateControl.LocationNotAvailable"
														);
														(this._geolocateButton.disabled = !0),
															(this._geolocateButton.title = i),
															this._geolocateButton.setAttribute(
																"aria-label",
																i
															);
													} else {
														const i = this._map._getUIString(
															"GeolocateControl.FindMyLocation"
														);
														(this._geolocateButton.disabled = !1),
															(this._geolocateButton.title = i),
															this._geolocateButton.setAttribute(
																"aria-label",
																i
															);
													}
													this.options.trackUserLocation &&
														(this._geolocateButton.setAttribute(
															"aria-pressed",
															"false"
														),
														(this._watchState = "OFF")),
														this.options.showUserLocation &&
															((this._dotElement = H.create(
																"div",
																"maplibregl-user-location-dot"
															)),
															(this._userLocationDotMarker = new ds({
																element: this._dotElement,
															})),
															(this._circleElement = H.create(
																"div",
																"maplibregl-user-location-accuracy-circle"
															)),
															(this._accuracyCircleMarker = new ds({
																element: this._circleElement,
																pitchAlignment: "map",
															})),
															this.options.trackUserLocation &&
																(this._watchState = "OFF"),
															this._map.on("zoom", this._onZoom)),
														this._geolocateButton.addEventListener(
															"click",
															() => this.trigger()
														),
														(this._setup = !0),
														this.options.trackUserLocation &&
															this._map.on("movestart", (i) => {
																const l =
																	(i == null ? void 0 : i[0]) instanceof
																	ResizeObserverEntry;
																i.geolocateSource ||
																	this._watchState !== "ACTIVE_LOCK" ||
																	l ||
																	this._map.isZooming() ||
																	((this._watchState = "BACKGROUND"),
																	this._geolocateButton.classList.add(
																		"maplibregl-ctrl-geolocate-background"
																	),
																	this._geolocateButton.classList.remove(
																		"maplibregl-ctrl-geolocate-active"
																	),
																	this.fire(new s.l("trackuserlocationend")),
																	this.fire(new s.l("userlocationlostfocus")));
															});
												}
											}),
											(this.options = s.e({}, du, h));
									}
									onAdd(h) {
										return (
											(this._map = h),
											(this._container = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-group"
											)),
											this._setupUI(),
											(function () {
												return s._(this, arguments, void 0, function* (e = !1) {
													if (Dn !== void 0 && !e) return Dn;
													if (window.navigator.permissions === void 0)
														return (Dn = !!window.navigator.geolocation), Dn;
													try {
														Dn =
															(yield window.navigator.permissions.query({
																name: "geolocation",
															})).state !== "denied";
													} catch {
														Dn = !!window.navigator.geolocation;
													}
													return Dn;
												});
											})().then((e) => this._finishSetupUI(e)),
											this._container
										);
									}
									onRemove() {
										this._geolocationWatchID !== void 0 &&
											(window.navigator.geolocation.clearWatch(
												this._geolocationWatchID
											),
											(this._geolocationWatchID = void 0)),
											this.options.showUserLocation &&
												this._userLocationDotMarker &&
												this._userLocationDotMarker.remove(),
											this.options.showAccuracyCircle &&
												this._accuracyCircleMarker &&
												this._accuracyCircleMarker.remove(),
											H.remove(this._container),
											this._map.off("zoom", this._onZoom),
											(this._map = void 0),
											(ps = 0),
											(No = !1);
									}
									_isOutOfMapMaxBounds(h) {
										const e = this._map.getMaxBounds(),
											i = h.coords;
										return (
											e &&
											(i.longitude < e.getWest() ||
												i.longitude > e.getEast() ||
												i.latitude < e.getSouth() ||
												i.latitude > e.getNorth())
										);
									}
									_setErrorState() {
										switch (this._watchState) {
											case "WAITING_ACTIVE":
												(this._watchState = "ACTIVE_ERROR"),
													this._geolocateButton.classList.remove(
														"maplibregl-ctrl-geolocate-active"
													),
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-active-error"
													);
												break;
											case "ACTIVE_LOCK":
												(this._watchState = "ACTIVE_ERROR"),
													this._geolocateButton.classList.remove(
														"maplibregl-ctrl-geolocate-active"
													),
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-active-error"
													),
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-waiting"
													);
												break;
											case "BACKGROUND":
												(this._watchState = "BACKGROUND_ERROR"),
													this._geolocateButton.classList.remove(
														"maplibregl-ctrl-geolocate-background"
													),
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-background-error"
													),
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-waiting"
													);
												break;
											case "ACTIVE_ERROR":
												break;
											default:
												throw new Error(
													`Unexpected watchState ${this._watchState}`
												);
										}
									}
									_updateCircleRadius() {
										const h = this._map.getBounds(),
											e = h.getSouthEast(),
											i = h.getNorthEast(),
											l = e.distanceTo(i),
											u = Math.ceil(
												(this._accuracy /
													(l / this._map._container.clientHeight)) *
													2
											);
										(this._circleElement.style.width = `${u}px`),
											(this._circleElement.style.height = `${u}px`);
									}
									trigger() {
										if (!this._setup)
											return (
												s.w(
													"Geolocate control triggered before added to a map"
												),
												!1
											);
										if (this.options.trackUserLocation) {
											switch (this._watchState) {
												case "OFF":
													(this._watchState = "WAITING_ACTIVE"),
														this.fire(new s.l("trackuserlocationstart"));
													break;
												case "WAITING_ACTIVE":
												case "ACTIVE_LOCK":
												case "ACTIVE_ERROR":
												case "BACKGROUND_ERROR":
													ps--,
														(No = !1),
														(this._watchState = "OFF"),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-waiting"
														),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-active"
														),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-active-error"
														),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-background"
														),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-background-error"
														),
														this.fire(new s.l("trackuserlocationend"));
													break;
												case "BACKGROUND":
													(this._watchState = "ACTIVE_LOCK"),
														this._geolocateButton.classList.remove(
															"maplibregl-ctrl-geolocate-background"
														),
														this._lastKnownPosition &&
															this._updateCamera(this._lastKnownPosition),
														this.fire(new s.l("trackuserlocationstart")),
														this.fire(new s.l("userlocationfocus"));
													break;
												default:
													throw new Error(
														`Unexpected watchState ${this._watchState}`
													);
											}
											switch (this._watchState) {
												case "WAITING_ACTIVE":
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-waiting"
													),
														this._geolocateButton.classList.add(
															"maplibregl-ctrl-geolocate-active"
														);
													break;
												case "ACTIVE_LOCK":
													this._geolocateButton.classList.add(
														"maplibregl-ctrl-geolocate-active"
													);
													break;
												case "OFF":
													break;
												default:
													throw new Error(
														`Unexpected watchState ${this._watchState}`
													);
											}
											if (
												this._watchState === "OFF" &&
												this._geolocationWatchID !== void 0
											)
												this._clearWatch();
											else if (this._geolocationWatchID === void 0) {
												let h;
												this._geolocateButton.classList.add(
													"maplibregl-ctrl-geolocate-waiting"
												),
													this._geolocateButton.setAttribute(
														"aria-pressed",
														"true"
													),
													ps++,
													ps > 1
														? ((h = { maximumAge: 6e5, timeout: 0 }), (No = !0))
														: ((h = this.options.positionOptions), (No = !1)),
													(this._geolocationWatchID =
														window.navigator.geolocation.watchPosition(
															this._onSuccess,
															this._onError,
															h
														));
											}
										} else
											window.navigator.geolocation.getCurrentPosition(
												this._onSuccess,
												this._onError,
												this.options.positionOptions
											),
												(this._timeoutId = setTimeout(this._finish, 1e4));
										return !0;
									}
									_clearWatch() {
										window.navigator.geolocation.clearWatch(
											this._geolocationWatchID
										),
											(this._geolocationWatchID = void 0),
											this._geolocateButton.classList.remove(
												"maplibregl-ctrl-geolocate-waiting"
											),
											this._geolocateButton.setAttribute(
												"aria-pressed",
												"false"
											),
											this.options.showUserLocation && this._updateMarker(null);
									}
								}),
								(T.GlobeControl = class {
									constructor() {
										(this._toggleProjection = () => {
											var h;
											const e =
												(h = this._map.getProjection()) === null || h === void 0
													? void 0
													: h.type;
											this._map.setProjection(
												e !== "mercator" && e
													? { type: "mercator" }
													: { type: "globe" }
											),
												this._updateGlobeIcon();
										}),
											(this._updateGlobeIcon = () => {
												var h;
												this._globeButton.classList.remove(
													"maplibregl-ctrl-globe"
												),
													this._globeButton.classList.remove(
														"maplibregl-ctrl-globe-enabled"
													),
													((h = this._map.getProjection()) === null ||
													h === void 0
														? void 0
														: h.type) === "globe"
														? (this._globeButton.classList.add(
																"maplibregl-ctrl-globe-enabled"
														  ),
														  (this._globeButton.title = this._map._getUIString(
																"GlobeControl.Disable"
														  )))
														: (this._globeButton.classList.add(
																"maplibregl-ctrl-globe"
														  ),
														  (this._globeButton.title = this._map._getUIString(
																"GlobeControl.Enable"
														  )));
											});
									}
									onAdd(h) {
										return (
											(this._map = h),
											(this._container = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-group"
											)),
											(this._globeButton = H.create(
												"button",
												"maplibregl-ctrl-globe",
												this._container
											)),
											H.create(
												"span",
												"maplibregl-ctrl-icon",
												this._globeButton
											).setAttribute("aria-hidden", "true"),
											(this._globeButton.type = "button"),
											this._globeButton.addEventListener(
												"click",
												this._toggleProjection
											),
											this._updateGlobeIcon(),
											this._map.on("styledata", this._updateGlobeIcon),
											this._container
										);
									}
									onRemove() {
										H.remove(this._container),
											this._map.off("styledata", this._updateGlobeIcon),
											this._globeButton.removeEventListener(
												"click",
												this._toggleProjection
											),
											(this._map = void 0);
									}
								}),
								(T.Hash = Fl),
								(T.ImageSource = Ot),
								(T.KeyboardHandler = jl),
								(T.LngLatBounds = _t),
								(T.LogoControl = wd),
								(T.Map = class extends bd {
									constructor(h) {
										var e, i;
										s.cw.mark(s.cx.create);
										const l = Object.assign(
											Object.assign(Object.assign({}, xa), h),
											{
												canvasContextAttributes: Object.assign(
													Object.assign({}, xa.canvasContextAttributes),
													h.canvasContextAttributes
												),
											}
										);
										if (
											l.minZoom != null &&
											l.maxZoom != null &&
											l.minZoom > l.maxZoom
										)
											throw new Error(
												"maxZoom must be greater than or equal to minZoom"
											);
										if (
											l.minPitch != null &&
											l.maxPitch != null &&
											l.minPitch > l.maxPitch
										)
											throw new Error(
												"maxPitch must be greater than or equal to minPitch"
											);
										if (l.minPitch != null && l.minPitch < 0)
											throw new Error(
												"minPitch must be greater than or equal to 0"
											);
										if (l.maxPitch != null && l.maxPitch > 180)
											throw new Error(
												"maxPitch must be less than or equal to 180"
											);
										const u = new on(),
											d = new jn();
										if (
											(l.minZoom !== void 0 && u.setMinZoom(l.minZoom),
											l.maxZoom !== void 0 && u.setMaxZoom(l.maxZoom),
											l.minPitch !== void 0 && u.setMinPitch(l.minPitch),
											l.maxPitch !== void 0 && u.setMaxPitch(l.maxPitch),
											l.renderWorldCopies !== void 0 &&
												u.setRenderWorldCopies(l.renderWorldCopies),
											super(u, d, { bearingSnap: l.bearingSnap }),
											(this._idleTriggered = !1),
											(this._crossFadingFactor = 1),
											(this._renderTaskQueue = new $a()),
											(this._controls = []),
											(this._mapId = s.a7()),
											(this._contextLost = (w) => {
												w.preventDefault(),
													this._frameRequest &&
														(this._frameRequest.abort(),
														(this._frameRequest = null)),
													this.fire(
														new s.l("webglcontextlost", { originalEvent: w })
													);
											}),
											(this._contextRestored = (w) => {
												this._setupPainter(),
													this.resize(),
													this._update(),
													this.fire(
														new s.l("webglcontextrestored", {
															originalEvent: w,
														})
													);
											}),
											(this._onMapScroll = (w) => {
												if (w.target === this._container)
													return (
														(this._container.scrollTop = 0),
														(this._container.scrollLeft = 0),
														!1
													);
											}),
											(this._onWindowOnline = () => {
												this._update();
											}),
											(this._interactive = l.interactive),
											(this._maxTileCacheSize = l.maxTileCacheSize),
											(this._maxTileCacheZoomLevels = l.maxTileCacheZoomLevels),
											(this._canvasContextAttributes = Object.assign(
												{},
												l.canvasContextAttributes
											)),
											(this._trackResize = l.trackResize === !0),
											(this._bearingSnap = l.bearingSnap),
											(this._centerClampedToGround = l.centerClampedToGround),
											(this._refreshExpiredTiles =
												l.refreshExpiredTiles === !0),
											(this._fadeDuration = l.fadeDuration),
											(this._crossSourceCollisions =
												l.crossSourceCollisions === !0),
											(this._collectResourceTiming =
												l.collectResourceTiming === !0),
											(this._locale = Object.assign(
												Object.assign({}, Ui),
												l.locale
											)),
											(this._clickTolerance = l.clickTolerance),
											(this._overridePixelRatio = l.pixelRatio),
											(this._maxCanvasSize = l.maxCanvasSize),
											(this.transformCameraUpdate = l.transformCameraUpdate),
											(this.cancelPendingTileRequestsWhileZooming =
												l.cancelPendingTileRequestsWhileZooming === !0),
											(this._imageQueueHandle = Fe.addThrottleControl(() =>
												this.isMoving()
											)),
											(this._requestManager = new $e(l.transformRequest)),
											typeof l.container == "string")
										) {
											if (
												((this._container = document.getElementById(
													l.container
												)),
												!this._container)
											)
												throw new Error(
													`Container '${l.container}' not found.`
												);
										} else {
											if (!(l.container instanceof HTMLElement))
												throw new Error(
													"Invalid type: 'container' must be a String or HTMLElement."
												);
											this._container = l.container;
										}
										if (
											(l.maxBounds && this.setMaxBounds(l.maxBounds),
											this._setupContainer(),
											this._setupPainter(),
											this.on("move", () => this._update(!1)),
											this.on("moveend", () => this._update(!1)),
											this.on("zoom", () => this._update(!0)),
											this.on("terrain", () => {
												(this.painter.terrainFacilitator.dirty = !0),
													this._update(!0);
											}),
											this.once("idle", () => {
												this._idleTriggered = !0;
											}),
											typeof window < "u")
										) {
											addEventListener("online", this._onWindowOnline, !1);
											let w = !1;
											const C = Fo((P) => {
												this._trackResize &&
													!this._removed &&
													(this.resize(P), this.redraw());
											}, 50);
											(this._resizeObserver = new ResizeObserver((P) => {
												w ? C(P) : (w = !0);
											})),
												this._resizeObserver.observe(this._container);
										}
										(this.handlers = new cu(this, l)),
											(this._hash =
												l.hash &&
												new Fl(
													(typeof l.hash == "string" && l.hash) || void 0
												).addTo(this)),
											(this._hash && this._hash._onHashChange()) ||
												(this.jumpTo({
													center: l.center,
													elevation: l.elevation,
													zoom: l.zoom,
													bearing: l.bearing,
													pitch: l.pitch,
													roll: l.roll,
												}),
												l.bounds &&
													(this.resize(),
													this.fitBounds(
														l.bounds,
														s.e({}, l.fitBoundsOptions, { duration: 0 })
													)));
										const g =
											typeof l.style == "string" ||
											((i =
												(e = l.style) === null || e === void 0
													? void 0
													: e.projection) === null || i === void 0
												? void 0
												: i.type) !== "globe";
										this.resize(null, g),
											(this._localIdeographFontFamily =
												l.localIdeographFontFamily),
											(this._validateStyle = l.validateStyle),
											l.style &&
												this.setStyle(l.style, {
													localIdeographFontFamily: l.localIdeographFontFamily,
												}),
											l.attributionControl &&
												this.addControl(
													new hu(
														typeof l.attributionControl == "boolean"
															? void 0
															: l.attributionControl
													)
												),
											l.maplibreLogo &&
												this.addControl(new wd(), l.logoPosition),
											this.on("style.load", () => {
												if (
													(g || this._resizeTransform(),
													this.transform.unmodified)
												) {
													const w = s.Q(this.style.stylesheet, [
														"center",
														"zoom",
														"bearing",
														"pitch",
														"roll",
													]);
													this.jumpTo(w);
												}
											}),
											this.on("data", (w) => {
												this._update(w.dataType === "style"),
													this.fire(new s.l(`${w.dataType}data`, w));
											}),
											this.on("dataloading", (w) => {
												this.fire(new s.l(`${w.dataType}dataloading`, w));
											}),
											this.on("dataabort", (w) => {
												this.fire(new s.l("sourcedataabort", w));
											});
									}
									_getMapId() {
										return this._mapId;
									}
									setGlobalStateProperty(h, e) {
										return (
											this.style.setGlobalStateProperty(h, e), this._update(!0)
										);
									}
									getGlobalState() {
										return this.style.getGlobalState();
									}
									addControl(h, e) {
										if (
											(e === void 0 &&
												(e = h.getDefaultPosition
													? h.getDefaultPosition()
													: "top-right"),
											!h || !h.onAdd)
										)
											return this.fire(
												new s.k(
													new Error(
														"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."
													)
												)
											);
										const i = h.onAdd(this);
										this._controls.push(h);
										const l = this._controlPositions[e];
										return (
											e.indexOf("bottom") !== -1
												? l.insertBefore(i, l.firstChild)
												: l.appendChild(i),
											this
										);
									}
									removeControl(h) {
										if (!h || !h.onRemove)
											return this.fire(
												new s.k(
													new Error(
														"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."
													)
												)
											);
										const e = this._controls.indexOf(h);
										return (
											e > -1 && this._controls.splice(e, 1),
											h.onRemove(this),
											this
										);
									}
									hasControl(h) {
										return this._controls.indexOf(h) > -1;
									}
									calculateCameraOptionsFromTo(h, e, i, l) {
										return (
											l == null &&
												this.terrain &&
												(l = this.terrain.getElevationForLngLatZoom(
													i,
													this.transform.tileZoom
												)),
											super.calculateCameraOptionsFromTo(h, e, i, l)
										);
									}
									resize(h, e = !0) {
										const [i, l] = this._containerDimensions(),
											u = this._getClampedPixelRatio(i, l);
										if (
											(this._resizeCanvas(i, l, u),
											this.painter.resize(i, l, u),
											this.painter.overLimit())
										) {
											const g = this.painter.context.gl;
											this._maxCanvasSize = [
												g.drawingBufferWidth,
												g.drawingBufferHeight,
											];
											const w = this._getClampedPixelRatio(i, l);
											this._resizeCanvas(i, l, w), this.painter.resize(i, l, w);
										}
										this._resizeTransform(e);
										const d = !this._moving;
										return (
											d &&
												(this.stop(),
												this.fire(new s.l("movestart", h)).fire(
													new s.l("move", h)
												)),
											this.fire(new s.l("resize", h)),
											d && this.fire(new s.l("moveend", h)),
											this
										);
									}
									_resizeTransform(h = !0) {
										var e;
										const [i, l] = this._containerDimensions();
										this.transform.resize(i, l, h),
											(e = this._requestedCameraState) === null ||
												e === void 0 ||
												e.resize(i, l, h);
									}
									_getClampedPixelRatio(h, e) {
										const { 0: i, 1: l } = this._maxCanvasSize,
											u = this.getPixelRatio(),
											d = h * u,
											g = e * u;
										return Math.min(d > i ? i / d : 1, g > l ? l / g : 1) * u;
									}
									getPixelRatio() {
										var h;
										return (h = this._overridePixelRatio) !== null &&
											h !== void 0
											? h
											: devicePixelRatio;
									}
									setPixelRatio(h) {
										(this._overridePixelRatio = h), this.resize();
									}
									getBounds() {
										return this.transform.getBounds();
									}
									getMaxBounds() {
										return this.transform.getMaxBounds();
									}
									setMaxBounds(h) {
										return (
											this.transform.setMaxBounds(_t.convert(h)), this._update()
										);
									}
									setMinZoom(h) {
										if ((h = h ?? -2) >= -2 && h <= this.transform.maxZoom)
											return (
												this.transform.setMinZoom(h),
												this._update(),
												this.getZoom() < h && this.setZoom(h),
												this
											);
										throw new Error(
											"minZoom must be between -2 and the current maxZoom, inclusive"
										);
									}
									getMinZoom() {
										return this.transform.minZoom;
									}
									setMaxZoom(h) {
										if ((h = h ?? 22) >= this.transform.minZoom)
											return (
												this.transform.setMaxZoom(h),
												this._update(),
												this.getZoom() > h && this.setZoom(h),
												this
											);
										throw new Error(
											"maxZoom must be greater than the current minZoom"
										);
									}
									getMaxZoom() {
										return this.transform.maxZoom;
									}
									setMinPitch(h) {
										if ((h = h ?? 0) < 0)
											throw new Error(
												"minPitch must be greater than or equal to 0"
											);
										if (h >= 0 && h <= this.transform.maxPitch)
											return (
												this.transform.setMinPitch(h),
												this._update(),
												this.getPitch() < h && this.setPitch(h),
												this
											);
										throw new Error(
											"minPitch must be between 0 and the current maxPitch, inclusive"
										);
									}
									getMinPitch() {
										return this.transform.minPitch;
									}
									setMaxPitch(h) {
										if ((h = h ?? 60) > 180)
											throw new Error(
												"maxPitch must be less than or equal to 180"
											);
										if (h >= this.transform.minPitch)
											return (
												this.transform.setMaxPitch(h),
												this._update(),
												this.getPitch() > h && this.setPitch(h),
												this
											);
										throw new Error(
											"maxPitch must be greater than the current minPitch"
										);
									}
									getMaxPitch() {
										return this.transform.maxPitch;
									}
									getRenderWorldCopies() {
										return this.transform.renderWorldCopies;
									}
									setRenderWorldCopies(h) {
										return (
											this.transform.setRenderWorldCopies(h), this._update()
										);
									}
									project(h) {
										return this.transform.locationToScreenPoint(
											s.S.convert(h),
											this.style && this.terrain
										);
									}
									unproject(h) {
										return this.transform.screenPointToLocation(
											s.P.convert(h),
											this.terrain
										);
									}
									isMoving() {
										var h;
										return (
											this._moving ||
											((h = this.handlers) === null || h === void 0
												? void 0
												: h.isMoving())
										);
									}
									isZooming() {
										var h;
										return (
											this._zooming ||
											((h = this.handlers) === null || h === void 0
												? void 0
												: h.isZooming())
										);
									}
									isRotating() {
										var h;
										return (
											this._rotating ||
											((h = this.handlers) === null || h === void 0
												? void 0
												: h.isRotating())
										);
									}
									_createDelegatedListener(h, e, i) {
										if (h === "mouseenter" || h === "mouseover") {
											let l = !1;
											return {
												layers: e,
												listener: i,
												delegates: {
													mousemove: (d) => {
														const g = e.filter((C) => this.getLayer(C)),
															w =
																g.length !== 0
																	? this.queryRenderedFeatures(d.point, {
																			layers: g,
																	  })
																	: [];
														w.length
															? l ||
															  ((l = !0),
															  i.call(
																	this,
																	new Qi(h, this, d.originalEvent, {
																		features: w,
																	})
															  ))
															: (l = !1);
													},
													mouseout: () => {
														l = !1;
													},
												},
											};
										}
										if (h === "mouseleave" || h === "mouseout") {
											let l = !1;
											return {
												layers: e,
												listener: i,
												delegates: {
													mousemove: (g) => {
														const w = e.filter((C) => this.getLayer(C));
														(w.length !== 0
															? this.queryRenderedFeatures(g.point, {
																	layers: w,
															  })
															: []
														).length
															? (l = !0)
															: l &&
															  ((l = !1),
															  i.call(this, new Qi(h, this, g.originalEvent)));
													},
													mouseout: (g) => {
														l &&
															((l = !1),
															i.call(this, new Qi(h, this, g.originalEvent)));
													},
												},
											};
										}
										{
											const l = (u) => {
												const d = e.filter((w) => this.getLayer(w)),
													g =
														d.length !== 0
															? this.queryRenderedFeatures(u.point, {
																	layers: d,
															  })
															: [];
												g.length &&
													((u.features = g),
													i.call(this, u),
													delete u.features);
											};
											return { layers: e, listener: i, delegates: { [h]: l } };
										}
									}
									_saveDelegatedListener(h, e) {
										(this._delegatedListeners = this._delegatedListeners || {}),
											(this._delegatedListeners[h] =
												this._delegatedListeners[h] || []),
											this._delegatedListeners[h].push(e);
									}
									_removeDelegatedListener(h, e, i) {
										if (
											!this._delegatedListeners ||
											!this._delegatedListeners[h]
										)
											return;
										const l = this._delegatedListeners[h];
										for (let u = 0; u < l.length; u++) {
											const d = l[u];
											if (
												d.listener === i &&
												d.layers.length === e.length &&
												d.layers.every((g) => e.includes(g))
											) {
												for (const g in d.delegates)
													this.off(g, d.delegates[g]);
												return void l.splice(u, 1);
											}
										}
									}
									on(h, e, i) {
										if (i === void 0) return super.on(h, e);
										const l = typeof e == "string" ? [e] : e,
											u = this._createDelegatedListener(h, l, i);
										this._saveDelegatedListener(h, u);
										for (const d in u.delegates) this.on(d, u.delegates[d]);
										return {
											unsubscribe: () => {
												this._removeDelegatedListener(h, l, i);
											},
										};
									}
									once(h, e, i) {
										if (i === void 0) return super.once(h, e);
										const l = typeof e == "string" ? [e] : e,
											u = this._createDelegatedListener(h, l, i);
										for (const d in u.delegates) {
											const g = u.delegates[d];
											u.delegates[d] = (...w) => {
												this._removeDelegatedListener(h, l, i), g(...w);
											};
										}
										this._saveDelegatedListener(h, u);
										for (const d in u.delegates) this.once(d, u.delegates[d]);
										return this;
									}
									off(h, e, i) {
										return i === void 0
											? super.off(h, e)
											: (this._removeDelegatedListener(
													h,
													typeof e == "string" ? [e] : e,
													i
											  ),
											  this);
									}
									queryRenderedFeatures(h, e) {
										if (!this.style) return [];
										let i;
										const l = h instanceof s.P || Array.isArray(h),
											u = l
												? h
												: [
														[0, 0],
														[this.transform.width, this.transform.height],
												  ];
										if (
											((e = e || (l ? {} : h) || {}),
											u instanceof s.P || typeof u[0] == "number")
										)
											i = [s.P.convert(u)];
										else {
											const d = s.P.convert(u[0]),
												g = s.P.convert(u[1]);
											i = [d, new s.P(g.x, d.y), g, new s.P(d.x, g.y), d];
										}
										return this.style.queryRenderedFeatures(
											i,
											e,
											this.transform
										);
									}
									querySourceFeatures(h, e) {
										return this.style.querySourceFeatures(h, e);
									}
									setStyle(h, e) {
										return (e = s.e(
											{},
											{
												localIdeographFontFamily:
													this._localIdeographFontFamily,
												validate: this._validateStyle,
											},
											e
										)).diff !== !1 &&
											e.localIdeographFontFamily ===
												this._localIdeographFontFamily &&
											this.style &&
											h
											? (this._diffStyle(h, e), this)
											: ((this._localIdeographFontFamily =
													e.localIdeographFontFamily),
											  this._updateStyle(h, e));
									}
									setTransformRequest(h) {
										return this._requestManager.setTransformRequest(h), this;
									}
									_getUIString(h) {
										const e = this._locale[h];
										if (e == null) throw new Error(`Missing UI string '${h}'`);
										return e;
									}
									_updateStyle(h, e) {
										var i, l;
										if (e.transformStyle && this.style && !this.style._loaded)
											return void this.style.once("style.load", () =>
												this._updateStyle(h, e)
											);
										const u =
											this.style && e.transformStyle
												? this.style.serialize()
												: void 0;
										return (
											this.style &&
												(this.style.setEventedParent(null),
												this.style._remove(!h)),
											h
												? ((this.style = new zc(this, e || {})),
												  this.style.setEventedParent(this, {
														style: this.style,
												  }),
												  typeof h == "string"
														? this.style.loadURL(h, e, u)
														: this.style.loadJSON(h, e, u),
												  this)
												: ((l =
														(i = this.style) === null || i === void 0
															? void 0
															: i.projection) === null ||
														l === void 0 ||
														l.destroy(),
												  delete this.style,
												  this)
										);
									}
									_lazyInitEmptyStyle() {
										this.style ||
											((this.style = new zc(this, {})),
											this.style.setEventedParent(this, { style: this.style }),
											this.style.loadEmpty());
									}
									_diffStyle(h, e) {
										if (typeof h == "string") {
											const i = this._requestManager.transformRequest(
												h,
												"Style"
											);
											s.j(i, new AbortController())
												.then((l) => {
													this._updateDiff(l.data, e);
												})
												.catch((l) => {
													l && this.fire(new s.k(l));
												});
										} else typeof h == "object" && this._updateDiff(h, e);
									}
									_updateDiff(h, e) {
										try {
											this.style.setState(h, e) && this._update(!0);
										} catch (i) {
											s.w(
												`Unable to perform style diff: ${
													i.message || i.error || i
												}.  Rebuilding the style from scratch.`
											),
												this._updateStyle(h, e);
										}
									}
									getStyle() {
										if (this.style) return this.style.serialize();
									}
									isStyleLoaded() {
										return this.style
											? this.style.loaded()
											: s.w("There is no style added to the map.");
									}
									addSource(h, e) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.addSource(h, e),
											this._update(!0)
										);
									}
									isSourceLoaded(h) {
										const e = this.style && this.style.sourceCaches[h];
										if (e !== void 0) return e.loaded();
										this.fire(
											new s.k(new Error(`There is no source with ID '${h}'`))
										);
									}
									setTerrain(h) {
										if (
											(this.style._checkLoaded(),
											this._terrainDataCallback &&
												this.style.off("data", this._terrainDataCallback),
											h)
										) {
											const e = this.style.sourceCaches[h.source];
											if (!e)
												throw new Error(
													`cannot load terrain, because there exists no source with ID: ${h.source}`
												);
											this.terrain === null && e.reload();
											for (const i in this.style._layers) {
												const l = this.style._layers[i];
												l.type === "hillshade" &&
													l.source === h.source &&
													s.w(
														"You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."
													),
													l.type === "color-relief" &&
														l.source === h.source &&
														s.w(
															"You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."
														);
											}
											(this.terrain = new Or(this.painter, e, h)),
												(this.painter.renderToTexture = new Ul(
													this.painter,
													this.terrain
												)),
												this.transform.setMinElevationForCurrentTile(
													this.terrain.getMinTileElevationForLngLatZoom(
														this.transform.center,
														this.transform.tileZoom
													)
												),
												this.transform.setElevation(
													this.terrain.getElevationForLngLatZoom(
														this.transform.center,
														this.transform.tileZoom
													)
												),
												(this._terrainDataCallback = (i) => {
													var l;
													i.dataType === "style"
														? this.terrain.sourceCache.freeRtt()
														: i.dataType === "source" &&
														  i.tile &&
														  (i.sourceId !== h.source ||
																this._elevationFreeze ||
																(this.transform.setMinElevationForCurrentTile(
																	this.terrain.getMinTileElevationForLngLatZoom(
																		this.transform.center,
																		this.transform.tileZoom
																	)
																),
																this._centerClampedToGround &&
																	this.transform.setElevation(
																		this.terrain.getElevationForLngLatZoom(
																			this.transform.center,
																			this.transform.tileZoom
																		)
																	)),
														  ((l = i.source) === null || l === void 0
																? void 0
																: l.type) === "image"
																? this.terrain.sourceCache.freeRtt()
																: this.terrain.sourceCache.freeRtt(
																		i.tile.tileID
																  ));
												}),
												this.style.on("data", this._terrainDataCallback);
										} else
											this.terrain && this.terrain.sourceCache.destruct(),
												(this.terrain = null),
												this.painter.renderToTexture &&
													this.painter.renderToTexture.destruct(),
												(this.painter.renderToTexture = null),
												this.transform.setMinElevationForCurrentTile(0),
												this._centerClampedToGround &&
													this.transform.setElevation(0);
										return this.fire(new s.l("terrain", { terrain: h })), this;
									}
									getTerrain() {
										var h, e;
										return (e =
											(h = this.terrain) === null || h === void 0
												? void 0
												: h.options) !== null && e !== void 0
											? e
											: null;
									}
									areTilesLoaded() {
										const h = this.style && this.style.sourceCaches;
										for (const e in h) {
											const i = h[e]._tiles;
											for (const l in i) {
												const u = i[l];
												if (u.state !== "loaded" && u.state !== "errored")
													return !1;
											}
										}
										return !0;
									}
									removeSource(h) {
										return this.style.removeSource(h), this._update(!0);
									}
									getSource(h) {
										return this.style.getSource(h);
									}
									setSourceTileLodParams(h, e, i) {
										if (i) {
											const l = this.getSource(i);
											if (!l)
												throw new Error(
													`There is no source with ID "${i}", cannot set LOD parameters`
												);
											l.calculateTileZoom = ut(Math.max(1, h), Math.max(1, e));
										} else
											for (const l in this.style.sourceCaches)
												this.style.sourceCaches[
													l
												].getSource().calculateTileZoom = ut(
													Math.max(1, h),
													Math.max(1, e)
												);
										return this._update(!0), this;
									}
									refreshTiles(h, e) {
										const i = this.style.sourceCaches[h];
										if (!i)
											throw new Error(
												`There is no source cache with ID "${h}", cannot refresh tile`
											);
										e === void 0
											? i.reload(!0)
											: i.refreshTiles(e.map((l) => new s.a4(l.z, l.x, l.y)));
									}
									addImage(h, e, i = {}) {
										const {
											pixelRatio: l = 1,
											sdf: u = !1,
											stretchX: d,
											stretchY: g,
											content: w,
											textFitWidth: C,
											textFitHeight: P,
										} = i;
										if (
											(this._lazyInitEmptyStyle(),
											!(e instanceof HTMLImageElement || s.b(e)))
										) {
											if (e.width === void 0 || e.height === void 0)
												return this.fire(
													new s.k(
														new Error(
															"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
														)
													)
												);
											{
												const { width: E, height: R, data: D } = e,
													N = e;
												return (
													this.style.addImage(h, {
														data: new s.R(
															{ width: E, height: R },
															new Uint8Array(D)
														),
														pixelRatio: l,
														stretchX: d,
														stretchY: g,
														content: w,
														textFitWidth: C,
														textFitHeight: P,
														sdf: u,
														version: 0,
														userImage: N,
													}),
													N.onAdd && N.onAdd(this, h),
													this
												);
											}
										}
										{
											const {
												width: E,
												height: R,
												data: D,
											} = ne.getImageData(e);
											this.style.addImage(h, {
												data: new s.R({ width: E, height: R }, D),
												pixelRatio: l,
												stretchX: d,
												stretchY: g,
												content: w,
												textFitWidth: C,
												textFitHeight: P,
												sdf: u,
												version: 0,
											});
										}
									}
									updateImage(h, e) {
										const i = this.style.getImage(h);
										if (!i)
											return this.fire(
												new s.k(
													new Error(
														"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."
													)
												)
											);
										const l =
												e instanceof HTMLImageElement || s.b(e)
													? ne.getImageData(e)
													: e,
											{ width: u, height: d, data: g } = l;
										if (u === void 0 || d === void 0)
											return this.fire(
												new s.k(
													new Error(
														"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
													)
												)
											);
										if (u !== i.data.width || d !== i.data.height)
											return this.fire(
												new s.k(
													new Error(
														"The width and height of the updated image must be that same as the previous version of the image"
													)
												)
											);
										const w = !(e instanceof HTMLImageElement || s.b(e));
										return (
											i.data.replace(g, w), this.style.updateImage(h, i), this
										);
									}
									getImage(h) {
										return this.style.getImage(h);
									}
									hasImage(h) {
										return h
											? !!this.style.getImage(h)
											: (this.fire(
													new s.k(new Error("Missing required image id"))
											  ),
											  !1);
									}
									removeImage(h) {
										this.style.removeImage(h);
									}
									loadImage(h) {
										return Fe.getImage(
											this._requestManager.transformRequest(h, "Image"),
											new AbortController()
										);
									}
									listImages() {
										return this.style.listImages();
									}
									addLayer(h, e) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.addLayer(h, e),
											this._update(!0)
										);
									}
									moveLayer(h, e) {
										return this.style.moveLayer(h, e), this._update(!0);
									}
									removeLayer(h) {
										return this.style.removeLayer(h), this._update(!0);
									}
									getLayer(h) {
										return this.style.getLayer(h);
									}
									getLayersOrder() {
										return this.style.getLayersOrder();
									}
									setLayerZoomRange(h, e, i) {
										return (
											this.style.setLayerZoomRange(h, e, i), this._update(!0)
										);
									}
									setFilter(h, e, i = {}) {
										return this.style.setFilter(h, e, i), this._update(!0);
									}
									getFilter(h) {
										return this.style.getFilter(h);
									}
									setPaintProperty(h, e, i, l = {}) {
										return (
											this.style.setPaintProperty(h, e, i, l), this._update(!0)
										);
									}
									getPaintProperty(h, e) {
										return this.style.getPaintProperty(h, e);
									}
									setLayoutProperty(h, e, i, l = {}) {
										return (
											this.style.setLayoutProperty(h, e, i, l), this._update(!0)
										);
									}
									getLayoutProperty(h, e) {
										return this.style.getLayoutProperty(h, e);
									}
									setGlyphs(h, e = {}) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.setGlyphs(h, e),
											this._update(!0)
										);
									}
									getGlyphs() {
										return this.style.getGlyphsUrl();
									}
									addSprite(h, e, i = {}) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.addSprite(h, e, i, (l) => {
												l || this._update(!0);
											}),
											this
										);
									}
									removeSprite(h) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.removeSprite(h),
											this._update(!0)
										);
									}
									getSprite() {
										return this.style.getSprite();
									}
									setSprite(h, e = {}) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.setSprite(h, e, (i) => {
												i || this._update(!0);
											}),
											this
										);
									}
									setLight(h, e = {}) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.setLight(h, e),
											this._update(!0)
										);
									}
									getLight() {
										return this.style.getLight();
									}
									setSky(h, e = {}) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.setSky(h, e),
											this._update(!0)
										);
									}
									getSky() {
										return this.style.getSky();
									}
									setFeatureState(h, e) {
										return this.style.setFeatureState(h, e), this._update();
									}
									removeFeatureState(h, e) {
										return this.style.removeFeatureState(h, e), this._update();
									}
									getFeatureState(h) {
										return this.style.getFeatureState(h);
									}
									getContainer() {
										return this._container;
									}
									getCanvasContainer() {
										return this._canvasContainer;
									}
									getCanvas() {
										return this._canvas;
									}
									_containerDimensions() {
										let h = 0,
											e = 0;
										return (
											this._container &&
												((h = this._container.clientWidth || 400),
												(e = this._container.clientHeight || 300)),
											[h, e]
										);
									}
									_setupContainer() {
										const h = this._container;
										h.classList.add("maplibregl-map");
										const e = (this._canvasContainer = H.create(
											"div",
											"maplibregl-canvas-container",
											h
										));
										this._interactive &&
											e.classList.add("maplibregl-interactive"),
											(this._canvas = H.create(
												"canvas",
												"maplibregl-canvas",
												e
											)),
											this._canvas.addEventListener(
												"webglcontextlost",
												this._contextLost,
												!1
											),
											this._canvas.addEventListener(
												"webglcontextrestored",
												this._contextRestored,
												!1
											),
											this._canvas.setAttribute(
												"tabindex",
												this._interactive ? "0" : "-1"
											),
											this._canvas.setAttribute(
												"aria-label",
												this._getUIString("Map.Title")
											),
											this._canvas.setAttribute("role", "region");
										const i = this._containerDimensions(),
											l = this._getClampedPixelRatio(i[0], i[1]);
										this._resizeCanvas(i[0], i[1], l);
										const u = (this._controlContainer = H.create(
												"div",
												"maplibregl-control-container",
												h
											)),
											d = (this._controlPositions = {});
										[
											"top-left",
											"top-right",
											"bottom-left",
											"bottom-right",
										].forEach((g) => {
											d[g] = H.create("div", `maplibregl-ctrl-${g} `, u);
										}),
											this._container.addEventListener(
												"scroll",
												this._onMapScroll,
												!1
											);
									}
									_resizeCanvas(h, e, i) {
										(this._canvas.width = Math.floor(i * h)),
											(this._canvas.height = Math.floor(i * e)),
											(this._canvas.style.width = `${h}px`),
											(this._canvas.style.height = `${e}px`);
									}
									_setupPainter() {
										const h = Object.assign(
											Object.assign({}, this._canvasContextAttributes),
											{
												alpha: !0,
												depth: !0,
												stencil: !0,
												premultipliedAlpha: !0,
											}
										);
										let e = null;
										this._canvas.addEventListener(
											"webglcontextcreationerror",
											(l) => {
												(e = { requestedAttributes: h }),
													l &&
														((e.statusMessage = l.statusMessage),
														(e.type = l.type));
											},
											{ once: !0 }
										);
										let i = null;
										if (
											((i = this._canvasContextAttributes.contextType
												? this._canvas.getContext(
														this._canvasContextAttributes.contextType,
														h
												  )
												: this._canvas.getContext("webgl2", h) ||
												  this._canvas.getContext("webgl", h)),
											!i)
										) {
											const l = "Failed to initialize WebGL";
											throw e
												? ((e.message = l), new Error(JSON.stringify(e)))
												: new Error(l);
										}
										(this.painter = new sd(i, this.transform)),
											fe.testSupport(i);
									}
									migrateProjection(h, e) {
										super.migrateProjection(h, e),
											(this.painter.transform = h),
											this.fire(
												new s.l("projectiontransition", {
													newProjection: this.style.projection.name,
												})
											);
									}
									loaded() {
										return (
											!this._styleDirty &&
											!this._sourcesDirty &&
											!!this.style &&
											this.style.loaded()
										);
									}
									_update(h) {
										return this.style && this.style._loaded
											? ((this._styleDirty = this._styleDirty || h),
											  (this._sourcesDirty = !0),
											  this.triggerRepaint(),
											  this)
											: this;
									}
									_requestRenderFrame(h) {
										return this._update(), this._renderTaskQueue.add(h);
									}
									_cancelRenderFrame(h) {
										this._renderTaskQueue.remove(h);
									}
									_render(h) {
										var e, i, l, u, d;
										const g = this._idleTriggered ? this._fadeDuration : 0,
											w =
												((e = this.style.projection) === null || e === void 0
													? void 0
													: e.transitionState) > 0;
										if (
											(this.painter.context.setDirty(),
											this.painter.setBaseState(),
											this._renderTaskQueue.run(h),
											this._removed)
										)
											return;
										let C = !1;
										if (this.style && this._styleDirty) {
											this._styleDirty = !1;
											const R = this.transform.zoom,
												D = ne.now();
											this.style.zoomHistory.update(R, D);
											const N = new s.F(R, {
													now: D,
													fadeDuration: g,
													zoomHistory: this.style.zoomHistory,
													transition: this.style.getTransition(),
													globalState: this.style.getGlobalState(),
												}),
												G = N.crossFadingFactor();
											(G === 1 && G === this._crossFadingFactor) ||
												((C = !0), (this._crossFadingFactor = G)),
												this.style.update(N);
										}
										const P =
											((i = this.style.projection) === null || i === void 0
												? void 0
												: i.transitionState) >
												0 !==
											w;
										(l = this.style.projection) === null ||
											l === void 0 ||
											l.setErrorQueryLatitudeDegrees(this.transform.center.lat),
											this.transform.setTransitionState(
												(u = this.style.projection) === null || u === void 0
													? void 0
													: u.transitionState,
												(d = this.style.projection) === null || d === void 0
													? void 0
													: d.latitudeErrorCorrectionRadians
											),
											this.style &&
												(this._sourcesDirty || P) &&
												((this._sourcesDirty = !1),
												this.style._updateSources(this.transform)),
											this.terrain
												? (this.terrain.sourceCache.update(
														this.transform,
														this.terrain
												  ),
												  this.transform.setMinElevationForCurrentTile(
														this.terrain.getMinTileElevationForLngLatZoom(
															this.transform.center,
															this.transform.tileZoom
														)
												  ),
												  !this._elevationFreeze &&
														this._centerClampedToGround &&
														this.transform.setElevation(
															this.terrain.getElevationForLngLatZoom(
																this.transform.center,
																this.transform.tileZoom
															)
														))
												: (this.transform.setMinElevationForCurrentTile(0),
												  this._centerClampedToGround &&
														this.transform.setElevation(0)),
											(this._placementDirty =
												this.style &&
												this.style._updatePlacement(
													this.transform,
													this.showCollisionBoxes,
													g,
													this._crossSourceCollisions,
													P
												)),
											this.painter.render(this.style, {
												showTileBoundaries: this.showTileBoundaries,
												showOverdrawInspector: this._showOverdrawInspector,
												rotating: this.isRotating(),
												zooming: this.isZooming(),
												moving: this.isMoving(),
												fadeDuration: g,
												showPadding: this.showPadding,
											}),
											this.fire(new s.l("render")),
											this.loaded() &&
												!this._loaded &&
												((this._loaded = !0),
												s.cw.mark(s.cx.load),
												this.fire(new s.l("load"))),
											this.style &&
												(this.style.hasTransitions() || C) &&
												(this._styleDirty = !0),
											this.style &&
												!this._placementDirty &&
												this.style._releaseSymbolFadeTiles();
										const E =
											this._sourcesDirty ||
											this._styleDirty ||
											this._placementDirty;
										return (
											E || this._repaint
												? this.triggerRepaint()
												: !this.isMoving() &&
												  this.loaded() &&
												  this.fire(new s.l("idle")),
											!this._loaded ||
												this._fullyLoaded ||
												E ||
												((this._fullyLoaded = !0), s.cw.mark(s.cx.fullLoad)),
											this
										);
									}
									redraw() {
										return (
											this.style &&
												(this._frameRequest &&
													(this._frameRequest.abort(),
													(this._frameRequest = null)),
												this._render(0)),
											this
										);
									}
									remove() {
										var h;
										this._hash && this._hash.remove();
										for (const i of this._controls) i.onRemove(this);
										(this._controls = []),
											this._frameRequest &&
												(this._frameRequest.abort(),
												(this._frameRequest = null)),
											this._renderTaskQueue.clear(),
											this.painter.destroy(),
											this.handlers.destroy(),
											delete this.handlers,
											this.setStyle(null),
											typeof window < "u" &&
												removeEventListener("online", this._onWindowOnline, !1),
											Fe.removeThrottleControl(this._imageQueueHandle),
											(h = this._resizeObserver) === null ||
												h === void 0 ||
												h.disconnect();
										const e =
											this.painter.context.gl.getExtension(
												"WEBGL_lose_context"
											);
										e != null && e.loseContext && e.loseContext(),
											this._canvas.removeEventListener(
												"webglcontextrestored",
												this._contextRestored,
												!1
											),
											this._canvas.removeEventListener(
												"webglcontextlost",
												this._contextLost,
												!1
											),
											H.remove(this._canvasContainer),
											H.remove(this._controlContainer),
											this._container.removeEventListener(
												"scroll",
												this._onMapScroll,
												!1
											),
											this._container.classList.remove("maplibregl-map"),
											s.cw.clearMetrics(),
											(this._removed = !0),
											this.fire(new s.l("remove"));
									}
									triggerRepaint() {
										this.style &&
											!this._frameRequest &&
											((this._frameRequest = new AbortController()),
											ne.frame(
												this._frameRequest,
												(h) => {
													s.cw.frame(h), (this._frameRequest = null);
													try {
														this._render(h);
													} catch (e) {
														if (
															!s.cy(e) &&
															!(function (i) {
																return i.message === Vs;
															})(e)
														)
															throw e;
													}
												},
												() => {}
											));
									}
									get showTileBoundaries() {
										return !!this._showTileBoundaries;
									}
									set showTileBoundaries(h) {
										this._showTileBoundaries !== h &&
											((this._showTileBoundaries = h), this._update());
									}
									get showPadding() {
										return !!this._showPadding;
									}
									set showPadding(h) {
										this._showPadding !== h &&
											((this._showPadding = h), this._update());
									}
									get showCollisionBoxes() {
										return !!this._showCollisionBoxes;
									}
									set showCollisionBoxes(h) {
										this._showCollisionBoxes !== h &&
											((this._showCollisionBoxes = h),
											h
												? this.style._generateCollisionBoxes()
												: this._update());
									}
									get showOverdrawInspector() {
										return !!this._showOverdrawInspector;
									}
									set showOverdrawInspector(h) {
										this._showOverdrawInspector !== h &&
											((this._showOverdrawInspector = h), this._update());
									}
									get repaint() {
										return !!this._repaint;
									}
									set repaint(h) {
										this._repaint !== h &&
											((this._repaint = h), this.triggerRepaint());
									}
									get vertices() {
										return !!this._vertices;
									}
									set vertices(h) {
										(this._vertices = h), this._update();
									}
									get version() {
										return Td;
									}
									getCameraTargetElevation() {
										return this.transform.elevation;
									}
									getProjection() {
										return this.style.getProjection();
									}
									setProjection(h) {
										return (
											this._lazyInitEmptyStyle(),
											this.style.setProjection(h),
											this._update(!0)
										);
									}
								}),
								(T.MapMouseEvent = Qi),
								(T.MapTouchEvent = is),
								(T.MapWheelEvent = ru),
								(T.Marker = ds),
								(T.NavigationControl = class {
									constructor(h) {
										(this._updateZoomButtons = () => {
											const e = this._map.getZoom(),
												i = e === this._map.getMaxZoom(),
												l = e === this._map.getMinZoom();
											(this._zoomInButton.disabled = i),
												(this._zoomOutButton.disabled = l),
												this._zoomInButton.setAttribute(
													"aria-disabled",
													i.toString()
												),
												this._zoomOutButton.setAttribute(
													"aria-disabled",
													l.toString()
												);
										}),
											(this._rotateCompassArrow = () => {
												this._compassIcon.style.transform =
													this.options.visualizePitch &&
													this.options.visualizeRoll
														? `scale(${
																1 /
																Math.pow(
																	Math.cos(this._map.transform.pitchInRadians),
																	0.5
																)
														  }) rotateZ(${-this._map.transform
																.roll}deg) rotateX(${
																this._map.transform.pitch
														  }deg) rotateZ(${-this._map.transform.bearing}deg)`
														: this.options.visualizePitch
														? `scale(${
																1 /
																Math.pow(
																	Math.cos(this._map.transform.pitchInRadians),
																	0.5
																)
														  }) rotateX(${
																this._map.transform.pitch
														  }deg) rotateZ(${-this._map.transform.bearing}deg)`
														: this.options.visualizeRoll
														? `rotate(${
																-this._map.transform.bearing -
																this._map.transform.roll
														  }deg)`
														: `rotate(${-this._map.transform.bearing}deg)`;
											}),
											(this._setButtonTitle = (e, i) => {
												const l = this._map._getUIString(
													`NavigationControl.${i}`
												);
												(e.title = l), e.setAttribute("aria-label", l);
											}),
											(this.options = s.e({}, $p, h)),
											(this._container = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-group"
											)),
											this._container.addEventListener("contextmenu", (e) =>
												e.preventDefault()
											),
											this.options.showZoom &&
												((this._zoomInButton = this._createButton(
													"maplibregl-ctrl-zoom-in",
													(e) => this._map.zoomIn({}, { originalEvent: e })
												)),
												H.create(
													"span",
													"maplibregl-ctrl-icon",
													this._zoomInButton
												).setAttribute("aria-hidden", "true"),
												(this._zoomOutButton = this._createButton(
													"maplibregl-ctrl-zoom-out",
													(e) => this._map.zoomOut({}, { originalEvent: e })
												)),
												H.create(
													"span",
													"maplibregl-ctrl-icon",
													this._zoomOutButton
												).setAttribute("aria-hidden", "true")),
											this.options.showCompass &&
												((this._compass = this._createButton(
													"maplibregl-ctrl-compass",
													(e) => {
														this.options.visualizePitch
															? this._map.resetNorthPitch(
																	{},
																	{ originalEvent: e }
															  )
															: this._map.resetNorth({}, { originalEvent: e });
													}
												)),
												(this._compassIcon = H.create(
													"span",
													"maplibregl-ctrl-icon",
													this._compass
												)),
												this._compassIcon.setAttribute("aria-hidden", "true"));
									}
									onAdd(h) {
										return (
											(this._map = h),
											this.options.showZoom &&
												(this._setButtonTitle(this._zoomInButton, "ZoomIn"),
												this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
												this._map.on("zoom", this._updateZoomButtons),
												this._updateZoomButtons()),
											this.options.showCompass &&
												(this._setButtonTitle(this._compass, "ResetBearing"),
												this.options.visualizePitch &&
													this._map.on("pitch", this._rotateCompassArrow),
												this.options.visualizeRoll &&
													this._map.on("roll", this._rotateCompassArrow),
												this._map.on("rotate", this._rotateCompassArrow),
												this._rotateCompassArrow(),
												(this._handler = new Ks(
													this._map,
													this._compass,
													this.options.visualizePitch
												))),
											this._container
										);
									}
									onRemove() {
										H.remove(this._container),
											this.options.showZoom &&
												this._map.off("zoom", this._updateZoomButtons),
											this.options.showCompass &&
												(this.options.visualizePitch &&
													this._map.off("pitch", this._rotateCompassArrow),
												this.options.visualizeRoll &&
													this._map.off("roll", this._rotateCompassArrow),
												this._map.off("rotate", this._rotateCompassArrow),
												this._handler.off(),
												delete this._handler),
											delete this._map;
									}
									_createButton(h, e) {
										const i = H.create("button", h, this._container);
										return (
											(i.type = "button"), i.addEventListener("click", e), i
										);
									}
								}),
								(T.Popup = class extends s.E {
									constructor(h) {
										super(),
											(this._updateOpacity = () => {
												this.options.locationOccludedOpacity !== void 0 &&
													(this._container.style.opacity =
														this._map.transform.isLocationOccluded(
															this.getLngLat()
														)
															? `${this.options.locationOccludedOpacity}`
															: "");
											}),
											(this.remove = () => (
												this._content && H.remove(this._content),
												this._container &&
													(H.remove(this._container), delete this._container),
												this._map &&
													(this._map.off("move", this._update),
													this._map.off("move", this._onClose),
													this._map.off("click", this._onClose),
													this._map.off("remove", this.remove),
													this._map.off("mousemove", this._onMouseMove),
													this._map.off("mouseup", this._onMouseUp),
													this._map.off("drag", this._onDrag),
													this._map._canvasContainer.classList.remove(
														"maplibregl-track-pointer"
													),
													delete this._map,
													this.fire(new s.l("close"))),
												this
											)),
											(this._onMouseUp = (e) => {
												this._update(e.point);
											}),
											(this._onMouseMove = (e) => {
												this._update(e.point);
											}),
											(this._onDrag = (e) => {
												this._update(e.point);
											}),
											(this._update = (e) => {
												if (
													!this._map ||
													(!this._lngLat && !this._trackPointer) ||
													!this._content
												)
													return;
												if (!this._container) {
													if (
														((this._container = H.create(
															"div",
															"maplibregl-popup",
															this._map.getContainer()
														)),
														(this._tip = H.create(
															"div",
															"maplibregl-popup-tip",
															this._container
														)),
														this._container.appendChild(this._content),
														this.options.className)
													)
														for (const g of this.options.className.split(" "))
															this._container.classList.add(g);
													this._closeButton &&
														this._closeButton.setAttribute(
															"aria-label",
															this._map._getUIString("Popup.Close")
														),
														this._trackPointer &&
															this._container.classList.add(
																"maplibregl-popup-track-pointer"
															);
												}
												if (
													(this.options.maxWidth &&
														this._container.style.maxWidth !==
															this.options.maxWidth &&
														(this._container.style.maxWidth =
															this.options.maxWidth),
													(this._lngLat = ti(
														this._lngLat,
														this._flatPos,
														this._map.transform,
														this._trackPointer
													)),
													this._trackPointer && !e)
												)
													return;
												const i =
													(this._flatPos =
													this._pos =
														this._trackPointer && e
															? e
															: this._map.project(this._lngLat));
												this._map.terrain &&
													(this._flatPos =
														this._trackPointer && e
															? e
															: this._map.transform.locationToScreenPoint(
																	this._lngLat
															  ));
												let l = this.options.anchor;
												const u = Hl(this.options.offset);
												if (!l) {
													const g = this._container.offsetWidth,
														w = this._container.offsetHeight;
													let C;
													(C =
														i.y + u.bottom.y < w
															? ["top"]
															: i.y > this._map.transform.height - w
															? ["bottom"]
															: []),
														i.x < g / 2
															? C.push("left")
															: i.x > this._map.transform.width - g / 2 &&
															  C.push("right"),
														(l = C.length === 0 ? "bottom" : C.join("-"));
												}
												let d = i.add(u[l]);
												this.options.subpixelPositioning || (d = d.round()),
													H.setTransform(
														this._container,
														`${$l[l]} translate(${d.x}px,${d.y}px)`
													),
													hs(this._container, l, "popup"),
													this._updateOpacity();
											}),
											(this._onClose = () => {
												this.remove();
											}),
											(this.options = s.e(Object.create(pu), h));
									}
									addTo(h) {
										return (
											this._map && this.remove(),
											(this._map = h),
											this.options.closeOnClick &&
												this._map.on("click", this._onClose),
											this.options.closeOnMove &&
												this._map.on("move", this._onClose),
											this._map.on("remove", this.remove),
											this._update(),
											this._focusFirstElement(),
											this._trackPointer
												? (this._map.on("mousemove", this._onMouseMove),
												  this._map.on("mouseup", this._onMouseUp),
												  this._container &&
														this._container.classList.add(
															"maplibregl-popup-track-pointer"
														),
												  this._map._canvasContainer.classList.add(
														"maplibregl-track-pointer"
												  ))
												: this._map.on("move", this._update),
											this.fire(new s.l("open")),
											this
										);
									}
									isOpen() {
										return !!this._map;
									}
									getLngLat() {
										return this._lngLat;
									}
									setLngLat(h) {
										return (
											(this._lngLat = s.S.convert(h)),
											(this._pos = null),
											(this._flatPos = null),
											(this._trackPointer = !1),
											this._update(),
											this._map &&
												(this._map.on("move", this._update),
												this._map.off("mousemove", this._onMouseMove),
												this._container &&
													this._container.classList.remove(
														"maplibregl-popup-track-pointer"
													),
												this._map._canvasContainer.classList.remove(
													"maplibregl-track-pointer"
												)),
											this
										);
									}
									trackPointer() {
										return (
											(this._trackPointer = !0),
											(this._pos = null),
											(this._flatPos = null),
											this._update(),
											this._map &&
												(this._map.off("move", this._update),
												this._map.on("mousemove", this._onMouseMove),
												this._map.on("drag", this._onDrag),
												this._container &&
													this._container.classList.add(
														"maplibregl-popup-track-pointer"
													),
												this._map._canvasContainer.classList.add(
													"maplibregl-track-pointer"
												)),
											this
										);
									}
									getElement() {
										return this._container;
									}
									setText(h) {
										return this.setDOMContent(document.createTextNode(h));
									}
									setHTML(h) {
										const e = document.createDocumentFragment(),
											i = document.createElement("body");
										let l;
										for (i.innerHTML = h; (l = i.firstChild), l; )
											e.appendChild(l);
										return this.setDOMContent(e);
									}
									getMaxWidth() {
										var h;
										return (h = this._container) === null || h === void 0
											? void 0
											: h.style.maxWidth;
									}
									setMaxWidth(h) {
										return (this.options.maxWidth = h), this._update(), this;
									}
									setDOMContent(h) {
										if (this._content)
											for (; this._content.hasChildNodes(); )
												this._content.firstChild &&
													this._content.removeChild(this._content.firstChild);
										else
											this._content = H.create(
												"div",
												"maplibregl-popup-content",
												this._container
											);
										return (
											this._content.appendChild(h),
											this._createCloseButton(),
											this._update(),
											this._focusFirstElement(),
											this
										);
									}
									addClassName(h) {
										return (
											this._container && this._container.classList.add(h), this
										);
									}
									removeClassName(h) {
										return (
											this._container && this._container.classList.remove(h),
											this
										);
									}
									setOffset(h) {
										return (this.options.offset = h), this._update(), this;
									}
									toggleClassName(h) {
										if (this._container)
											return this._container.classList.toggle(h);
									}
									setSubpixelPositioning(h) {
										this.options.subpixelPositioning = h;
									}
									_createCloseButton() {
										this.options.closeButton &&
											((this._closeButton = H.create(
												"button",
												"maplibregl-popup-close-button",
												this._content
											)),
											(this._closeButton.type = "button"),
											(this._closeButton.innerHTML = "&#215;"),
											this._closeButton.addEventListener(
												"click",
												this._onClose
											));
									}
									_focusFirstElement() {
										if (!this.options.focusAfterOpen || !this._container)
											return;
										const h = this._container.querySelector(fu);
										h && h.focus();
									}
								}),
								(T.RasterDEMTileSource = tr),
								(T.RasterTileSource = $t),
								(T.ScaleControl = class {
									constructor(h) {
										(this._onMove = () => {
											Gl(this._map, this._container, this.options);
										}),
											(this.setUnit = (e) => {
												(this.options.unit = e),
													Gl(this._map, this._container, this.options);
											}),
											(this.options = Object.assign(Object.assign({}, Js), h));
									}
									getDefaultPosition() {
										return "bottom-left";
									}
									onAdd(h) {
										return (
											(this._map = h),
											(this._container = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-scale",
												h.getContainer()
											)),
											this._map.on("move", this._onMove),
											this._onMove(),
											this._container
										);
									}
									onRemove() {
										H.remove(this._container),
											this._map.off("move", this._onMove),
											(this._map = void 0);
									}
								}),
								(T.ScrollZoomHandler = _d),
								(T.Style = zc),
								(T.TerrainControl = class {
									constructor(h) {
										(this._toggleTerrain = () => {
											this._map.getTerrain()
												? this._map.setTerrain(null)
												: this._map.setTerrain(this.options),
												this._updateTerrainIcon();
										}),
											(this._updateTerrainIcon = () => {
												this._terrainButton.classList.remove(
													"maplibregl-ctrl-terrain"
												),
													this._terrainButton.classList.remove(
														"maplibregl-ctrl-terrain-enabled"
													),
													this._map.terrain
														? (this._terrainButton.classList.add(
																"maplibregl-ctrl-terrain-enabled"
														  ),
														  (this._terrainButton.title =
																this._map._getUIString(
																	"TerrainControl.Disable"
																)))
														: (this._terrainButton.classList.add(
																"maplibregl-ctrl-terrain"
														  ),
														  (this._terrainButton.title =
																this._map._getUIString(
																	"TerrainControl.Enable"
																)));
											}),
											(this.options = h);
									}
									onAdd(h) {
										return (
											(this._map = h),
											(this._container = H.create(
												"div",
												"maplibregl-ctrl maplibregl-ctrl-group"
											)),
											(this._terrainButton = H.create(
												"button",
												"maplibregl-ctrl-terrain",
												this._container
											)),
											H.create(
												"span",
												"maplibregl-ctrl-icon",
												this._terrainButton
											).setAttribute("aria-hidden", "true"),
											(this._terrainButton.type = "button"),
											this._terrainButton.addEventListener(
												"click",
												this._toggleTerrain
											),
											this._updateTerrainIcon(),
											this._map.on("terrain", this._updateTerrainIcon),
											this._container
										);
									}
									onRemove() {
										H.remove(this._container),
											this._map.off("terrain", this._updateTerrainIcon),
											(this._map = void 0);
									}
								}),
								(T.TwoFingersTouchPitchHandler = Nl),
								(T.TwoFingersTouchRotateHandler = cs),
								(T.TwoFingersTouchZoomHandler = Ol),
								(T.TwoFingersTouchZoomRotateHandler = yd),
								(T.VectorTileSource = Rt),
								(T.VideoSource = Nt),
								(T.addSourceType = (h, e) =>
									s._(void 0, void 0, void 0, function* () {
										if (Vr(h))
											throw new Error(
												`A source type called "${h}" already exists.`
											);
										((i, l) => {
											cr[i] = l;
										})(h, e);
									})),
								(T.clearPrewarmedResources = function () {
									const h = it;
									h &&
										(h.isPreloaded() && h.numActive() === 1
											? (h.release(ze), (it = null))
											: console.warn(
													"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"
											  ));
								}),
								(T.createTileMesh = Ms),
								(T.getMaxParallelImageRequests = function () {
									return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
								}),
								(T.getRTLTextPluginStatus = function () {
									return Ir().getRTLTextPluginStatus();
								}),
								(T.getVersion = function () {
									return mu;
								}),
								(T.getWorkerCount = function () {
									return je.workerCount;
								}),
								(T.getWorkerUrl = function () {
									return s.a.WORKER_URL;
								}),
								(T.importScriptInWorkers = function (h) {
									return at().broadcast("IS", h);
								}),
								(T.prewarm = function () {
									It().acquire(ze);
								}),
								(T.setMaxParallelImageRequests = function (h) {
									s.a.MAX_PARALLEL_IMAGE_REQUESTS = h;
								}),
								(T.setRTLTextPlugin = function (h, e) {
									return Ir().setRTLTextPlugin(h, e);
								}),
								(T.setWorkerCount = function (h) {
									je.workerCount = h;
								}),
								(T.setWorkerUrl = function (h) {
									s.a.WORKER_URL = h;
								});
						});
					var z = p;
					return z;
				});
			})(Xd)),
		Xd.exports
	);
}
var m4 = f4();
const qd = Zm(m4);
class ev {
	constructor(a) {
		xr(this, "gm");
		xr(this, "markers", new Map());
		xr(this, "canvases", new Map());
		xr(this, "canvasSize");
		xr(this, "canvasOpacity", 0.8);
		(this.input = a), (this.gm = new fl(this.input.tileSize));
		const p = n0(a.img);
		this.canvasSize = Math.ceil(2e3 / p);
	}
	place([a, p]) {
		const y = this.gm.latLonToPixelsFloor(a, p, this.input.zoom),
			M = this.getMarkerId(y),
			z = this.gm.latLonToPixelBoundsLatLon(a, p, this.input.zoom),
			T = this.input.map;
		if (this.input.markerFn && !this.markers.has(M)) {
			const K = this.input.markerFn();
			K.setLngLat({ lat: z.min[0], lng: (z.max[1] + z.min[1]) / 2 }).addTo(T),
				this.markers.set(M, K);
		}
		const { key: s, pos: B, innerPos: O } = this.getCanvasPos(y);
		let X = this.canvases.get(s);
		if (!X) {
			const K = this.canvasSize,
				ne = B.x * K,
				H = B.y * K,
				fe = ne + K - 1,
				ge = H + K - 1,
				Ie = this.gm.pixelsToLatLon(ne, ge + 1, this.input.zoom),
				Ae = this.gm.pixelsToLatLon(fe + 1, H, this.input.zoom);
			(X = new _4({
				id: `${this.input.id}-${s}`,
				img: this.input.img,
				canvasSize: this.canvasSize,
				coordinates: Vm({ min: Ie, max: Ae }),
				layerPaint: {
					"raster-resampling": "nearest",
					"raster-opacity": this.canvasOpacity,
				},
			})),
				X.addTo(this.input.map),
				this.canvases.set(s, X);
		}
		X.place(O.x, O.y);
	}
	clear() {
		const a = this.input.map;
		for (const p of this.canvases.values()) p.removeFrom(a), p.removeDOM();
		this.canvases.clear();
		for (const p of this.markers.values()) p.remove();
		this.markers.clear();
	}
	clearAndPlace(a) {
		this.clear(), this.place(a);
	}
	remove([a, p]) {
		let y = !1;
		const M = this.gm.latLonToPixelsFloor(a, p, this.input.zoom),
			{ key: z, innerPos: T } = this.getCanvasPos(M),
			s = this.canvases.get(z);
		s &&
			((y = s.remove(T.x, T.y)),
			s.annotationsCount() === 0 &&
				(this.canvases.delete(z), s.removeFrom(this.input.map), s.removeDOM()));
		const B = this.getMarkerId(M),
			O = this.markers.get(B);
		return O == null || O.remove(), this.markers.delete(B), y;
	}
	setCanvasOpacity(a) {
		this.canvasOpacity = a;
		for (const p of this.canvases.values()) p.setOpacity(a);
	}
	getMarkerId([a, p]) {
		return `${this.input.id}:${a},${p}`;
	}
	getCanvasPos([a, p]) {
		const y = {
				x: Math.floor(a / this.canvasSize),
				y: Math.floor(p / this.canvasSize),
			},
			M = { x: a % this.canvasSize, y: p % this.canvasSize },
			z = `${y.x},${y.y}`;
		return { pos: y, innerPos: M, key: z };
	}
}
class _4 {
	constructor(a) {
		xr(this, "annotations", new Set());
		xr(this, "canvas");
		xr(this, "imgSize");
		xr(this, "maps", new Set());
		(this.input = a),
			(this.imgSize = n0(a.img)),
			(this.canvas = document.createElement("canvas")),
			(this.canvas.width = this.input.canvasSize * this.imgSize),
			(this.canvas.height = this.input.canvasSize * this.imgSize);
	}
	place(a, p) {
		const y = this.getPixelKey(a, p);
		if (this.annotations.has(y)) return !1;
		const M = this.canvas.getContext("2d");
		if (M) {
			const z = a * this.imgSize,
				T = p * this.imgSize;
			M.drawImage(this.input.img, z, T);
		}
		return this.annotations.add(y), !0;
	}
	remove(a, p) {
		const y = this.getPixelKey(a, p);
		if (!this.annotations.has(y)) return !1;
		const M = this.canvas.getContext("2d");
		if (M) {
			const z = a * this.imgSize,
				T = p * this.imgSize;
			M.clearRect(z, T, this.imgSize, this.imgSize);
		}
		return this.annotations.delete(y), !0;
	}
	addTo(a) {
		const p = this.input.id;
		a.getSource(p) ||
			a.addSource(p, {
				type: "canvas",
				canvas: this.canvas,
				coordinates: this.input.coordinates,
			}),
			a.getLayer(p) ||
				a.addLayer({
					id: p,
					type: "raster",
					source: p,
					paint: this.input.layerPaint,
				}),
			this.maps.add(a);
	}
	removeFrom(a) {
		const { id: p } = this.input;
		a.getLayer(p) && a.removeLayer(p),
			a.getSource(p) && a.removeSource(p),
			this.maps.delete(a);
	}
	removeDOM() {
		this.canvas.remove();
	}
	annotationsCount() {
		return this.annotations.size;
	}
	setOpacity(a) {
		for (const p of this.maps.values())
			p.setPaintProperty(this.input.id, "raster-opacity", a);
	}
	getPixelKey(a, p) {
		return `${a},${p}`;
	}
}
function n0(m) {
	return Math.max(m.naturalWidth, m.naturalHeight);
}
function g4() {
	return (
		window.matchMedia("(display-mode: standalone)").matches ||
		("standalone" in window.navigator && window.navigator.standalone === !0)
	);
}
function xc(m, a) {
	return a.includes(m);
}
function v4(m) {
	const a = { opaque: !0 },
		p = m.searchParams.get("lat"),
		y = m.searchParams.get("lng");
	p && y && (a.pos = { lat: parseFloat(p), lng: parseFloat(y) });
	const M = m.searchParams.get("zoom");
	M && (a.zoom = parseFloat(M));
	const z = m.searchParams.get("season");
	z && (a.season = parseInt(z));
	const T = m.searchParams.get("opaque");
	return (
		T && (a.opaque = T !== "0"),
		m.searchParams.get("select") && (a.select = !0),
		(a.newUser = !!m.searchParams.get("new-user")),
		(a.discordLinked = !!m.searchParams.get("discord-linked")),
		(a.alliance = !!m.searchParams.get("alliance")),
		a
	);
}
function y4(m, a) {
	return (
		(m = new URL(m)),
		a.pos !== void 0 &&
			(m.searchParams.set("lat", a.pos.lat.toString()),
			m.searchParams.set("lng", a.pos.lng.toString())),
		a.zoom !== void 0 && m.searchParams.set("zoom", a.zoom.toString()),
		a.season !== void 0 && m.searchParams.set("season", a.season.toString()),
		a.opaque !== void 0 && m.searchParams.set("opaque", a.opaque ? "1" : "0"),
		a.newUser !== void 0 &&
			m.searchParams.set("new-user", a.newUser ? "1" : "0"),
		a.alliance !== void 0 &&
			m.searchParams.set("alliance", a.alliance ? "1" : "0"),
		a.select && m.searchParams.set("alliance", "1"),
		m
	);
}
const Yd = bi({ shouldReload: !0 });
var x4 = (m, a) => {
		var p;
		(p = a()) == null || p.close();
	},
	b4 = Te(
		'<dialog class="modal"><div class="modal-box max-w-2xl"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="mb-4 mt-2"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function w4(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15),
		y = st(!1),
		M = st(bi(a.description)),
		z = st(void 0);
	Fn(() => {
		const De = (Ee) => {
			var Fe;
			Ee.key === "Escape" && ((Fe = p()) == null || Fe.close());
		};
		return (
			document.addEventListener("keydown", De),
			() => document.removeEventListener("keydown", De)
		);
	});
	var T = b4(),
		s = A(T),
		B = A(s),
		O = A(B, !0);
	k(B);
	var X = j(B, 2),
		K = A(X),
		ne = A(K);
	{
		let De = ft(() => Hv());
		yx(ne, {
			class: "h-24 rounded-lg",
			get placeholder() {
				return x(De);
			},
			max: 512,
			get value() {
				return x(M);
			},
			set value(Ee) {
				se(M, Ee, !0);
			},
			get validate() {
				return x(z);
			},
			set validate(Ee) {
				se(z, Ee, !0);
			},
		});
	}
	k(K);
	var H = j(K, 2),
		fe = A(H);
	fe.__click = [x4, p];
	var ge = A(fe, !0);
	k(fe);
	var Ie = j(fe, 2),
		Ae = A(Ie, !0);
	k(Ie),
		k(H),
		k(X),
		k(s),
		yn(2),
		k(T),
		Ko(
			T,
			(De) => p(De),
			() => p()
		),
		We(
			(De, Ee, Fe) => {
				de(O, De),
					(fe.disabled = x(y)),
					de(ge, Ee),
					(Ie.disabled = x(y)),
					de(Ae, Fe);
			},
			[() => bx(), () => Ah(), () => FT()]
		),
		di("submit", X, async () => {
			var De, Ee, Fe;
			try {
				if (!((De = x(z)) != null && De())) return;
				se(y, !0),
					a.description !== x(M) && (await Qr.updateAllianceDescription(x(M))),
					await ((Ee = a.onsuccess) == null ? void 0 : Ee.call(a, x(M))),
					(Fe = p()) == null || Fe.close();
			} catch ($e) {
				Fr.error($e.message);
			} finally {
				se(y, !1);
			}
		}),
		$(m, T),
		Dr();
}
$n(["click"]);
var T4 = (m, a, p) => {
		navigator.clipboard.writeText(x(a).toString()),
			se(p, !0),
			setTimeout(() => {
				se(p, !1);
			}, 1e3);
	},
	C4 = Te(
		'<span class="loading loading-spinner loading-md center-absolute absolute"></span>'
	),
	S4 = Te(
		'<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <span class="text-base-content/80 text-sm"> </span> <div class="relative mt-4"><div><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function P4(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(""),
		M = st(!1);
	const z = ft(() => yi.url.origin + `/join?id=${x(y)}`);
	Wr(() => {
		p() &&
			Qr.getAllianceInvites()
				.then((Je) => {
					se(y, Je[0], !0);
				})
				.catch((Je) => {
					Fr.error(Je.message);
				});
	}),
		Fn(() => {
			const Je = (qe) => {
				qe.key === "Escape" && p(!1);
			};
			return (
				document.addEventListener("keydown", Je),
				() => document.removeEventListener("keydown", Je)
			);
		});
	var T = S4(),
		s = A(T),
		B = j(A(s), 2),
		O = A(B, !0);
	k(B);
	var X = j(B, 2),
		K = A(X, !0);
	k(X);
	var ne = j(X, 2),
		H = A(ne);
	let fe;
	var ge = A(H);
	Ka(ge);
	var Ie = j(ge, 2),
		Ae = A(Ie);
	let De;
	Ae.__click = [T4, z, M];
	var Ee = A(Ae, !0);
	k(Ae), k(Ie), k(H);
	var Fe = j(H, 2);
	{
		var $e = (Je) => {
			var qe = C4();
			$(Je, qe);
		};
		Oe(Fe, (Je) => {
			x(y) || Je($e);
		});
	}
	k(ne),
		k(s),
		yn(2),
		k(T),
		Ni(T, () => (Je) => {
			Wr(() => {
				p() ? Je.show() : Je.close();
			});
		}),
		We(
			(Je, qe, Ze, Qe, Le, et) => {
				de(O, Je),
					de(K, qe),
					(fe = zr(
						H,
						1,
						"border-base-content/20 rounded-field relative flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5",
						null,
						fe,
						Ze
					)),
					Av(ge, Qe),
					(De = zr(Ae, 1, "btn btn-primary", null, De, Le)),
					de(Ee, et);
			},
			[
				() => O3(),
				() => V3(),
				() => ({ invisible: !x(y) }),
				() => x(z).toString(),
				() => ({ "btn-success": x(M) }),
				() => (x(M) ? Fm() : Wf()),
			]
		),
		di("close", T, () => p(!1)),
		$(m, T),
		Dr();
}
$n(["click"]);
var I4 = Pr(
	'<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z" fill="#5865F2"></path></svg>'
);
function Qf(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = I4();
	ar(y, () => ({
		viewBox: "0 0 256 199",
		width: "256",
		height: "199",
		xmlns: "http://www.w3.org/2000/svg",
		preserveAspectRatio: "xMidYMid",
		...p,
	})),
		$(m, y);
}
var M4 = Te('<span class="text-success">(Verified)</span>'),
	k4 = Te('<a target="_blank" rel="noreferer" aria-label="Discord"><!></a>'),
	A4 = async (m, a) => {
		await navigator.clipboard.writeText(a.username), Fr.info(UC());
	},
	E4 = Te("<button><!></button>"),
	z4 = Te(
		'<span class="tooltip h-4"><div class="tooltip-content"><span> </span> <!></div> <!></span>'
	);
function Eh(m, a) {
	Lr(a, !0);
	const p = !!a.id;
	var y = z4(),
		M = A(y),
		z = A(M),
		T = A(z);
	k(z);
	var s = j(z, 2);
	{
		var B = (ne) => {
			var H = M4();
			$(ne, H);
		};
		Oe(s, (ne) => {
			p && ne(B);
		});
	}
	k(M);
	var O = j(M, 2);
	{
		var X = (ne) => {
				var H = k4(),
					fe = A(H);
				Qf(fe, { class: "size-4 opacity-70" }),
					k(H),
					We(
						(ge) => Tr(H, "href", ge),
						[() => `https://discord.com/users/${encodeURIComponent(a.id)}`]
					),
					$(ne, H);
			},
			K = (ne) => {
				var H = E4();
				H.__click = [A4, a];
				var fe = A(H);
				Qf(fe, { class: "size-4 opacity-70" }), k(H), $(ne, H);
			};
		Oe(O, (ne) => {
			p ? ne(X) : ne(K, !1);
		});
	}
	k(y), We(() => de(T, `Discord: ${a.username ?? ""}`)), $(m, y), Dr();
}
$n(["click"]);
var L4 = Te('<input type="radio" class="tab max-[380px]:px-3"/>'),
	D4 = Te('<div class="tabs tabs-border w-max font-medium"></div>');
function Um(m, a) {
	Lr(a, !0);
	const p = [];
	let y = zt(a, "value", 15, "today"),
		M = [
			{ value: "today", label: vp() },
			{ value: "week", label: tT() },
			{ value: "month", label: iT() },
			{ value: "all-time", label: sT() },
		];
	var z = D4();
	hi(
		z,
		21,
		() => M,
		(T) => T.value,
		(T, s) => {
			var B = L4();
			Ka(B);
			var O;
			We(() => {
				Tr(B, "aria-label", x(s).label),
					O !== (O = x(s).value) && (B.value = (B.__value = x(s).value) ?? "");
			}),
				Lm(p, [], B, () => (x(s).value, y()), y),
				$(T, B);
		}
	),
		k(z),
		$(m, z),
		Dr();
}
const R4 = typeof window < "u" ? window : void 0;
function B4(m) {
	let a = m.activeElement;
	for (; a != null && a.shadowRoot; ) {
		const p = a.shadowRoot.activeElement;
		if (p === a) break;
		a = p;
	}
	return a;
}
var bc, Xu, Pv;
let F4 =
	((Pv = class {
		constructor(a = {}) {
			Ar(this, bc);
			Ar(this, Xu);
			const { window: p = R4, document: y = p == null ? void 0 : p.document } =
				a;
			p !== void 0 &&
				(na(this, bc, y),
				na(
					this,
					Xu,
					Ev((M) => {
						const z = Nu(p, "focusin", M),
							T = Nu(p, "focusout", M);
						return () => {
							z(), T();
						};
					})
				));
		}
		get current() {
			var a;
			return (
				(a = ot(this, Xu)) == null || a.call(this),
				ot(this, bc) ? B4(ot(this, bc)) : null
			);
		}
	}),
	(bc = new WeakMap()),
	(Xu = new WeakMap()),
	Pv);
new F4();
function O4(m, a) {
	switch (m) {
		case "post":
			Wr(a);
			break;
		case "pre":
			Mm(a);
			break;
	}
}
function i0(m, a, p, y = {}) {
	const { lazy: M = !1 } = y;
	let z = !M,
		T = Array.isArray(m) ? [] : void 0;
	O4(a, () => {
		const s = Array.isArray(m) ? m.map((O) => O()) : m();
		if (!z) {
			(z = !0), (T = s);
			return;
		}
		const B = ul(() => p(s, T));
		return (T = s), B;
	});
}
function dl(m, a, p) {
	i0(m, "post", a, p);
}
function N4(m, a, p) {
	i0(m, "pre", a, p);
}
dl.pre = N4;
var j4 = Te(
		'<span class="loading loading-spinner loading-lg mt-18 mx-auto flex items-center"></span>'
	),
	V4 = Te(
		'<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
	),
	q4 = Te('<span class="font-flag tooltip ml-0.5"> </span>'),
	Z4 = (m, a, p) => {
		a.onlastpixelclick({
			lat: x(p).lastLatitude ?? 0,
			lng: x(p).lastLongitude ?? 0,
		});
	},
	U4 = Te("<button><!></button>"),
	$4 = Te(
		'<tr><td class="text-base-content/80 font-medium max-[400px]:hidden"> </td><td><div class="flex items-center gap-2"><!> <span> <span class="ml-0.5"> </span></span> <!> <!></div></td><td class="text-base-content/80 relative text-center font-medium"> <!></td></tr>'
	),
	G4 = Te(
		'<table class="table"><thead class="text-base-content/80"><tr><th class="max-[400px]:hidden"></th><th> </th><th class="text-center max-sm:px-1"> </th></tr></thead><tbody></tbody></table>'
	),
	H4 = Te('<div><!> <div class="mt-4"><!></div></div>');
function W4(m, a) {
	Lr(a, !0);
	let p = zt(a, "reload", 15),
		y = st(!0),
		M = st([]),
		z = st(0),
		T = st("today"),
		s = {};
	p(B);
	function B() {
		const ge = x(T);
		Qr.allianceLeaderboard(ge)
			.then((Ie) => {
				se(M, Ie), (s = { [ge]: Ie }), se(y, !1);
			})
			.catch((Ie) => {
				Fr.error(Ie.message);
			});
	}
	dl(
		() => [x(T)],
		() => {
			const ge = x(T),
				Ie = s[ge];
			if (Ie) {
				se(M, Ie), se(y, !1);
				return;
			}
			se(y, !0),
				Qr.allianceLeaderboard(ge)
					.then((Ae) => {
						se(M, Ae), (s[ge] = Ae), se(y, !1);
					})
					.catch((Ae) => {
						Fr.error(Ae.message);
					});
		}
	);
	var O = H4(),
		X = A(O);
	Um(X, {
		get value() {
			return x(T);
		},
		set value(ge) {
			se(T, ge, !0);
		},
	});
	var K = j(X, 2),
		ne = A(K);
	{
		var H = (ge) => {
				var Ie = j4();
				$(ge, Ie);
			},
			fe = (ge) => {
				var Ie = er(),
					Ae = Ct(Ie);
				{
					var De = (Fe) => {
							var $e = V4(),
								Je = A($e),
								qe = j(Je);
							{
								var Ze = (Le) => {
										var et = wi();
										We((nt) => de(et, nt), [() => vp().toLowerCase()]),
											$(Le, et);
									},
									Qe = (Le) => {
										var et = er(),
											nt = Ct(et);
										{
											var Ue = (vt) => {
													var ee = wi();
													We((re) => de(ee, re), [() => Nm()]), $(vt, ee);
												},
												ke = (vt) => {
													var ee = er(),
														re = Ct(ee);
													{
														var he = (oe) => {
															var ze = wi();
															We((je) => de(ze, je), [() => jm()]), $(oe, ze);
														};
														Oe(
															re,
															(oe) => {
																x(T) === "month" && oe(he);
															},
															!0
														);
													}
													$(vt, ee);
												};
											Oe(
												nt,
												(vt) => {
													x(T) === "week" ? vt(Ue) : vt(ke, !1);
												},
												!0
											);
										}
										$(Le, et);
									};
								Oe(qe, (Le) => {
									x(T) === "today" ? Le(Ze) : Le(Qe, !1);
								});
							}
							k($e),
								We((Le) => de(Je, `${Le ?? ""} `), [() => Om()]),
								$(Fe, $e);
						},
						Ee = (Fe) => {
							var $e = G4(),
								Je = A($e),
								qe = A(Je),
								Ze = j(A(qe)),
								Qe = A(Ze, !0);
							k(Ze);
							var Le = j(Ze),
								et = A(Le, !0);
							k(Le), k(qe), k(Je);
							var nt = j(Je);
							hi(
								nt,
								31,
								() => x(M),
								(Ue) => Ue.userId,
								(Ue, ke, vt) => {
									const ee = ft(() => {
										var $t;
										return (
											(($t = Mt.data) == null ? void 0 : $t.id) === x(ke).userId
										);
									});
									var re = $4();
									let he;
									var oe = A(re),
										ze = A(oe, !0);
									k(oe);
									var je = j(oe),
										pt = A(je),
										it = A(pt);
									co(it, {
										class: "size-10 border",
										get userId() {
											return x(ke).userId;
										},
										get pictureUrl() {
											return x(ke).picture;
										},
									});
									var ct = j(it, 2),
										It = A(ct),
										Dt = j(It),
										at = A(Dt);
									k(Dt), k(ct);
									var dt = j(ct, 2);
									{
										var yt = ($t) => {
											const tr = ft(() => So(x(ke).equippedFlag));
											var Qt = q4(),
												Ot = A(Qt, !0);
											k(Qt),
												We(() => {
													Tr(Qt, "data-tip", x(tr).name), de(Ot, x(tr).flag);
												}),
												$($t, Qt);
										};
										Oe(dt, ($t) => {
											x(ke).equippedFlag && $t(yt);
										});
									}
									var xt = j(dt, 2);
									{
										var St = ($t) => {
											Eh($t, {
												get username() {
													return x(ke).discord;
												},
												get id() {
													return x(ke).discordId;
												},
											});
										};
										Oe(xt, ($t) => {
											x(ke).discord && $t(St);
										});
									}
									k(pt), k(je);
									var wt = j(je),
										_t = A(wt),
										Lt = j(_t);
									{
										var Rt = ($t) => {
											var tr = U4();
											let Qt;
											tr.__click = [Z4, a, ke];
											var Ot = A(tr);
											Em(Ot, { class: "size-4" }),
												k(tr),
												We(
													(Nt, or) => {
														(Qt = zr(
															tr,
															1,
															"btn btn-sm btn-ghost absolute -right-2 top-1/2 !-translate-y-1/2 sm:right-4",
															null,
															Qt,
															Nt
														)),
															Tr(tr, "data-tip", or);
													},
													[() => ({ tooltip: x(z) > 640 }), () => Mx()]
												),
												$($t, tr);
										};
										Oe(Lt, ($t) => {
											x(ke).lastLatitude && x(ke).lastLongitude && $t(Rt);
										});
									}
									k(wt),
										k(re),
										We(
											($t, tr, Qt) => {
												var Ot;
												(he = zr(re, 1, "", null, he, $t)),
													de(ze, x(vt) + 1),
													zr(ct, 1, `font-semibold ${tr ?? ""} flex gap-1`),
													de(
														It,
														`${
															(x(ee)
																? ((Ot = Mt.data) == null ? void 0 : Ot.name) ??
																  x(ke).name
																: x(ke).name) ?? ""
														} `
													),
													de(at, `#${x(ke).userId ?? ""}`),
													de(_t, `${Qt ?? ""} `);
											},
											[
												() => ({ "bg-base-200": x(ee) }),
												() => Oi(x(ke).userId),
												() => x(ke).pixelsPainted.toLocaleString("en-US"),
											]
										),
										ll(
											re,
											() => cl,
											() => ({ duration: 200 })
										),
										$(Ue, re);
								}
							),
								k(nt),
								k($e),
								We(
									(Ue, ke) => {
										de(Qe, Ue), de(et, ke);
									},
									[() => Dm(), () => zm()]
								),
								$(Fe, $e);
						};
					Oe(
						Ae,
						(Fe) => {
							x(M).length === 0 ? Fe(De) : Fe(Ee, !1);
						},
						!0
					);
				}
				$(ge, Ie);
			};
		Oe(ne, (ge) => {
			x(y) ? ge(H) : ge(fe, !1);
		});
	}
	k(K), k(O), mp("innerWidth", (ge) => se(z, ge, !0)), $(m, O), Dr();
}
$n(["click"]);
var X4 = Pr(
	'<svg><path d="M480-160q-33 0-56.5-23.5T400-240q0-33 23.5-56.5T480-320q33 0 56.5 23.5T560-240q0 33-23.5 56.5T480-160Zm0-240q-33 0-56.5-23.5T400-480q0-33 23.5-56.5T480-560q33 0 56.5 23.5T560-480q0 33-23.5 56.5T480-400Zm0-240q-33 0-56.5-23.5T400-720q0-33 23.5-56.5T480-800q33 0 56.5 23.5T560-720q0 33-23.5 56.5T480-640Z"></path></svg>'
);
function $m(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = X4();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var Y4 = (m, a) => a.onclickback(),
	K4 = Te('<div class="badge badge-primary badge-sm badge-soft">ADMIN</div>'),
	J4 = async (m, a) => {
		try {
			(x(a).loading = !0),
				await Qr.giveAllianceAdmin(x(a).id),
				(x(a).role = "admin");
		} catch {
			Fr.error(fS());
		} finally {
			x(a).loading = !1;
		}
	},
	Q4 = async (m, a, p) => {
		try {
			(x(a).loading = !0),
				await Qr.banAllianceUser(x(a).id),
				(p.data = p.data.filter((y) => y.id !== x(a).id));
		} catch {
			Fr.error(jT());
		} finally {
			x(a).loading = !1;
		}
	},
	eM = Te(
		'<li><button class="btn btn-ghost"> </button></li> <li><button class="btn btn-ghost btn-error not-hover:text-error"> </button></li>',
		1
	),
	tM = Te(
		'<li><button class="btn btn-ghost text-base-content/80"> </button></li>'
	),
	rM = Te(
		'<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span> <!></div></td><td class="px-0"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 gap-1 border p-2 shadow-sm"><!></ul></div></td></tr>'
	),
	nM = Te(
		'<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'
	),
	iM = (m, a, p) => {
		Qr.unbanAllianceUser(x(a).id)
			.then(() => {
				p.data = p.data.filter((y) => y.id !== x(a).id);
			})
			.catch((y) => Fr.error(y.message))
			.finally(() => {
				x(a).loading = !1;
			});
	},
	aM = Te(
		'<tr><td class="w-full"><div class="flex items-center gap-2"><!> <span> </span></div></td><td class="px-0"><button class="btn btn-error"> </button></td></tr>'
	),
	oM = Te('<div class="text-base-content/80 mt-4 flex justify-center"> </div>'),
	sM = Te(
		'<div class="mt-2 flex justify-center"><span class="loading loading-dots"></span></div>'
	),
	lM = Te(
		'<div><section class="mt-2 flex items-center gap-1"><button class="btn btn-ghost btn-circle"><!></button> <h2 class="text-xl font-semibold"> </h2></section> <div class="tabs tabs-border mt-2"><input type="radio" name="members_tabs" class="tab" checked/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!></div> <input type="radio" name="members_tabs" class="tab"/> <div class="tab-content py-4"><table class="table"><tbody></tbody></table> <!> <!></div></div></div>'
	);
function cM(m, a) {
	Lr(a, !0);
	let p = bi({ data: [], page: 0, hasNextPage: !0, loading: !1 }),
		y = bi({ data: [], page: 0, hasNextPage: !0, loading: !1 });
	var M = lM(),
		z = A(M),
		T = A(z);
	T.__click = [Y4, a];
	var s = A(T);
	Dx(s, { class: "size-5" }), k(T);
	var B = j(T, 2),
		O = A(B, !0);
	k(B), k(z);
	var X = j(z, 2),
		K = A(X);
	Ka(K);
	var ne = j(K, 2),
		H = A(ne),
		fe = A(H);
	hi(
		fe,
		21,
		() => p.data,
		(Qe) => Qe.id,
		(Qe, Le, et) => {
			const nt = ft(() => {
				var yt;
				return ((yt = Mt.data) == null ? void 0 : yt.id) === x(Le).id;
			});
			var Ue = rM(),
				ke = A(Ue),
				vt = A(ke),
				ee = A(vt);
			co(ee, {
				class: "size-10 border",
				get userId() {
					return x(Le).id;
				},
				get pictureUrl() {
					return x(Le).picture;
				},
			});
			var re = j(ee, 2),
				he = A(re);
			k(re);
			var oe = j(re, 2);
			{
				var ze = (yt) => {
					var xt = K4();
					$(yt, xt);
				};
				Oe(oe, (yt) => {
					x(Le).role === "admin" && yt(ze);
				});
			}
			k(vt), k(ke);
			var je = j(ke),
				pt = A(je),
				it = A(pt),
				ct = A(it);
			$m(ct, { class: "size-4" }), k(it);
			var It = j(it, 2),
				Dt = A(It);
			{
				var at = (yt) => {
						var xt = eM(),
							St = Ct(xt),
							wt = A(St);
						wt.__click = [J4, Le];
						var _t = A(wt, !0);
						k(wt), k(St);
						var Lt = j(St, 2),
							Rt = A(Lt);
						Rt.__click = [Q4, Le, p];
						var $t = A(Rt, !0);
						k(Rt),
							k(Lt),
							We(
								(tr, Qt) => {
									(wt.disabled = x(Le).loading),
										de(_t, tr),
										(Rt.disabled = x(Le).loading),
										de($t, Qt);
								},
								[() => TT(), () => Wv()]
							),
							$(yt, xt);
					},
					dt = (yt) => {
						var xt = tM(),
							St = A(xt);
						St.disabled = !0;
						var wt = A(St, !0);
						k(St), k(xt), We((_t) => de(wt, _t), [() => MT()]), $(yt, xt);
					};
				Oe(Dt, (yt) => {
					x(Le).role === "member" ? yt(at) : yt(dt, !1);
				});
			}
			k(It),
				k(pt),
				k(je),
				k(Ue),
				We(
					(yt) => {
						var xt;
						zr(re, 1, `font-semibold ${yt ?? ""}`),
							de(
								he,
								`${
									(x(nt)
										? ((xt = Mt.data) == null ? void 0 : xt.name) ?? x(Le).name
										: x(Le).name) ?? ""
								} #${x(Le).id ?? ""}`
							);
					},
					[() => Oi(x(Le).id)]
				),
				$(Qe, Ue);
		}
	),
		k(fe),
		k(H);
	var ge = j(H, 2);
	{
		var Ie = (Qe) => {
			var Le = er(),
				et = Ct(Le);
			ju(
				et,
				() => p.page,
				(nt) => {
					var Ue = nM();
					Ni(Ue, () => (ke) => {
						const vt = new IntersectionObserver((ee) => {
							ee[0].isIntersecting &&
								!p.loading &&
								((p.loading = !0),
								Qr.getAllianceMembers(p.page)
									.then((re) => {
										(p.data = [...p.data, ...re.data]),
											(p.hasNextPage = re.hasNext),
											p.page++;
									})
									.catch((re) => {
										Fr.error(re.message);
									})
									.finally(() => {
										p.loading = !1;
									}));
						});
						return (
							vt.observe(ke),
							() => {
								vt.disconnect();
							}
						);
					}),
						$(nt, Ue);
				}
			),
				$(Qe, Le);
		};
		Oe(ge, (Qe) => {
			p.hasNextPage && Qe(Ie);
		});
	}
	k(ne);
	var Ae = j(ne, 2),
		De = j(Ae, 2),
		Ee = A(De),
		Fe = A(Ee);
	hi(
		Fe,
		21,
		() => y.data,
		(Qe) => Qe.id,
		(Qe, Le, et) => {
			var nt = aM(),
				Ue = A(nt),
				ke = A(Ue),
				vt = A(ke);
			co(vt, {
				class: "size-10 border",
				get userId() {
					return x(Le).id;
				},
				get pictureUrl() {
					return x(Le).picture;
				},
			});
			var ee = j(vt, 2),
				re = A(ee);
			k(ee), k(ke), k(Ue);
			var he = j(Ue),
				oe = A(he);
			oe.__click = [iM, Le, y];
			var ze = A(oe, !0);
			k(oe),
				k(he),
				k(nt),
				We(
					(je, pt) => {
						zr(ee, 1, `font-semibold ${je ?? ""}`),
							de(re, `${x(Le).name ?? ""} #${x(Le).id ?? ""}`),
							(oe.disabled = x(Le).loading),
							de(ze, pt);
					},
					[() => Oi(x(Le).id), () => ET()]
				),
				$(Qe, nt);
		}
	),
		k(Fe),
		k(Ee);
	var $e = j(Ee, 2);
	{
		var Je = (Qe) => {
			var Le = oM(),
				et = A(Le, !0);
			k(Le), We((nt) => de(et, nt), [() => DT()]), $(Qe, Le);
		};
		Oe($e, (Qe) => {
			!y.hasNextPage && y.data.length === 0 && Qe(Je);
		});
	}
	var qe = j($e, 2);
	{
		var Ze = (Qe) => {
			var Le = er(),
				et = Ct(Le);
			ju(
				et,
				() => y.page,
				(nt) => {
					var Ue = sM();
					Ni(Ue, () => (ke) => {
						const vt = new IntersectionObserver((ee) => {
							ee[0].isIntersecting &&
								!y.loading &&
								((y.loading = !0),
								Qr.getAllianceBannedMembers(y.page)
									.then((re) => {
										(y.data = [...y.data, ...re.data]),
											(y.hasNextPage = re.hasNext),
											y.page++;
									})
									.catch((re) => {
										Fr.error(re.message);
									})
									.finally(() => {
										y.loading = !1;
									}));
						});
						return (
							vt.observe(ke),
							() => {
								vt.disconnect();
							}
						);
					}),
						$(nt, Ue);
				}
			),
				$(Qe, Le);
		};
		Oe(qe, (Qe) => {
			y.hasNextPage && Qe(Ze);
		});
	}
	k(De),
		k(X),
		k(M),
		We(
			(Qe, Le, et) => {
				de(O, Qe), Tr(K, "aria-label", Le), Tr(Ae, "aria-label", et);
			},
			[() => Dv(), () => ZT(), () => Xv()]
		),
		$(m, M),
		Dr();
}
$n(["click"]);
var uM = Te('<span class="label"> </span>'),
	hM = Te('<span class="hidden px-1 text-[10px] peer-focus:block"> </span>'),
	dM = Te('<p class="text-error ml-3 text-sm"> </p>'),
	pM = Te(
		'<div><label><!> <input class="peer" type="text"/> <!></label> <!></div>'
	);
function em(m, a) {
	Lr(a, !0);
	let p = zt(a, "value", 15),
		y = zt(a, "validate", 15),
		M = st("");
	const z = ft(() => {
		var Ae;
		return ((Ae = p()) == null ? void 0 : Ae.length) ?? 0;
	});
	y(T);
	function T() {
		return a.min !== void 0 && x(z) < a.min
			? (se(M, x(z) === 0 ? "Required" : `Min. characters: ${a.min}`, !0), !1)
			: a.max !== void 0 && x(z) > a.max
			? (se(M, `Max. characters: ${a.max}`), !1)
			: !0;
	}
	Wr(() => {
		var Ae;
		a.max !== void 0 &&
			x(z) > a.max &&
			p((Ae = p()) == null ? void 0 : Ae.substring(0, a.max));
	});
	var s = pM(),
		B = A(s);
	let O;
	var X = A(B);
	{
		var K = (Ae) => {
			var De = uM(),
				Ee = A(De, !0);
			k(De), We(() => de(Ee, a.label)), $(Ae, De);
		};
		Oe(X, (Ae) => {
			a.label && Ae(K);
		});
	}
	var ne = j(X, 2);
	Ka(ne);
	var H = j(ne, 2);
	{
		var fe = (Ae) => {
			var De = hM(),
				Ee = A(De, !0);
			k(De), We(() => de(Ee, a.max - x(z))), $(Ae, De);
		};
		Oe(H, (Ae) => {
			a.max !== void 0 && Ae(fe);
		});
	}
	k(B);
	var ge = j(B, 2);
	{
		var Ie = (Ae) => {
			var De = dM(),
				Ee = A(De, !0);
			k(De), We(() => de(Ee, x(M))), $(Ae, De);
		};
		Oe(ge, (Ae) => {
			x(M) && Ae(Ie);
		});
	}
	k(s),
		We(
			(Ae) => {
				(O = zr(B, 1, "input w-full", null, O, Ae)),
					Tr(ne, "placeholder", a.placeholder),
					Tr(ne, "maxlength", a.max);
			},
			[() => ({ "input-error": !!x(M) })]
		),
		dp(ne, p),
		$(m, s),
		Dr();
}
var fM = (m, a) => {
		var p;
		(p = a()) == null || p.close();
	},
	mM = Te(
		'<dialog class="modal"><div class="modal-box"><h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form><div class="my-4"><!></div> <div class="flex w-full justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-primary"> </button></div></form></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function _M(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15),
		y = st(!1),
		M = st(""),
		z = st(void 0);
	Fn(() => {
		const De = (Ee) => {
			var Fe;
			Ee.key === "Escape" && ((Fe = p()) == null || Fe.close());
		};
		return (
			document.addEventListener("keydown", De),
			() => document.removeEventListener("keydown", De)
		);
	});
	var T = mM(),
		s = A(T),
		B = A(s),
		O = A(B, !0);
	k(B);
	var X = j(B, 2),
		K = A(X),
		ne = A(K);
	{
		let De = ft(() => Kf()),
			Ee = ft(() => gT());
		em(ne, {
			get label() {
				return x(De);
			},
			get placeholder() {
				return x(Ee);
			},
			min: 1,
			max: 16,
			get value() {
				return x(M);
			},
			set value(Fe) {
				se(M, Fe, !0);
			},
			get validate() {
				return x(z);
			},
			set validate(Fe) {
				se(z, Fe, !0);
			},
		});
	}
	k(K);
	var H = j(K, 2),
		fe = A(H);
	fe.__click = [fM, p];
	var ge = A(fe, !0);
	k(fe);
	var Ie = j(fe, 2),
		Ae = A(Ie, !0);
	k(Ie),
		k(H),
		k(X),
		k(s),
		yn(2),
		k(T),
		Ko(
			T,
			(De) => p(De),
			() => p()
		),
		We(
			(De, Ee, Fe) => {
				de(O, De),
					(fe.disabled = x(y)),
					de(ge, Ee),
					(Ie.disabled = x(y)),
					de(Ae, Fe);
			},
			[() => fT(), () => Ah(), () => xT()]
		),
		di("submit", X, async () => {
			var De, Ee;
			try {
				if (!((De = x(z)) != null && De())) return;
				se(y, !0);
				const { id: Fe } = await Qr.createAlliance(x(M));
				await a.onsuccess(Fe), (Ee = p()) == null || Ee.close();
			} catch (Fe) {
				Fr.error(Fe.message);
			} finally {
				se(y, !1);
			}
		}),
		$(m, T),
		Dr();
}
$n(["click"]);
var gM = Pr(
	'<svg><path d="M240-120q-45 0-89-22t-71-58q26 0 53-20.5t27-59.5q0-50 35-85t85-35q50 0 85 35t35 85q0 66-47 113t-113 47Zm230-240L360-470l358-358q11-11 27.5-11.5T774-828l54 54q12 12 12 28t-12 28L470-360Z"></path></svg>'
);
function zh(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = gM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var vM = Pr(
		'<svg><path d="M160-160v-100.77l527.23-527.77q6.15-5.48 13.57-8.47 7.43-2.99 15.49-2.99t15.62 2.54q7.55 2.54 13.94 9.15l42.69 42.93q6.61 6.38 9.04 14 2.42 7.63 2.42 15.25 0 8.13-2.74 15.56-2.74 7.42-8.72 13.57L260.77-160H160Zm540.15-496.46L760-715.54 715.54-760l-59.08 59.85 43.69 43.69Z"></path></svg>'
	),
	yM = Pr(
		'<svg><path d="M200-200h57l391-391-57-57-391 391v57Zm-80 80v-170l528-527q12-11 26.5-17t30.5-6q16 0 31 6t26 18l55 56q12 11 17.5 26t5.5 30q0 16-5.5 30.5T817-647L290-120H120Zm640-584-56-56 56 56Zm-141 85-28-29 57 57-29-28Z"></path></svg>'
	);
function tm(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
	var y = er(),
		M = Ct(y);
	{
		var z = (s) => {
				var B = vM();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			},
			T = (s) => {
				var B = yM();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			};
		Oe(M, (s) => {
			a.filled ? s(z) : s(T, !1);
		});
	}
	$(m, y);
}
var xM = Pr(
	'<svg><path d="M360-440h80v-110h80v110h80v-190l-120-80-120 80v190ZM480-80Q319-217 239.5-334.5T160-552q0-150 96.5-239T480-880q127 0 223.5 89T800-552q0 100-79.5 217.5T480-80Z"></path></svg>'
);
function bM(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = xM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var wM = Pr(
	'<svg><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h640q33 0 56.5 23.5T880-720v480q0 33-23.5 56.5T800-160H160Zm320-280L160-640v400h640v-400L480-440Zm0-80 320-200H160l320 200ZM160-640v-80 480-400Z"></path></svg>'
);
function TM(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = wM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var CM = Pr(
	'<svg><path d="M720-400v-120H600v-80h120v-120h80v120h120v80H800v120h-80Zm-360-80q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM40-160v-112q0-34 17.5-62.5T104-378q62-31 126-46.5T360-440q66 0 130 15.5T616-378q29 15 46.5 43.5T680-272v112H40Z"></path></svg>'
);
function SM(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = CM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var PM = Pr(
	'<svg><path d="M480-480q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47ZM160-160v-112q0-34 17.5-62.5T224-378q62-31 126-46.5T480-440q66 0 130 15.5T736-378q29 15 46.5 43.5T800-272v112H160Z"></path></svg>'
);
function yp(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = PM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
function IM(m, a = "_blank") {
	return m.replaceAll(
		/https?:\/\/[^\s]+/g,
		(p) => `<a href="${p}"${a ? ` target="${a}"` : ""}>${p}</a>`
	);
}
var MM = Te(
		'<div class="flex h-full items-center justify-center"><span class="loading loading-spinner loading-xl"></span></div>'
	),
	kM = async (m, a, p, y) => {
		try {
			se(a, !0), await Qr.leaveAlliance(), se(p, !0), await y();
		} catch (M) {
			Fr.error(M.message);
		} finally {
			se(a, !1);
		}
	},
	AM = (m, a) => {
		se(a, !0);
	},
	EM = Te('<div class="tooltip"><button class="btn"><!></button></div>'),
	zM = (m, a) => {
		var p;
		(p = x(a)) == null || p.show();
	},
	LM = Te(
		'<button class="text-base-content/50 translate-y-0.5 p-1"><!></button>'
	),
	DM = Te(
		'<section class="text-base-content/80 highlight-link"><!> <!></section>'
	),
	RM = Te('<span class="font-semibold"> </span>'),
	BM = (m, a) => se(a, !0),
	FM = Te('<button class="text-primary font-semibold underline"> </button>'),
	OM = (m, a, p) => {
		var y;
		(y = x(a)) != null && y.hq
			? p.onhqclick({ lat: x(a).hq.latitude, lng: x(a).hq.longitude })
			: p.onhqchange();
	},
	NM = Te('<span class="text-primary underline"> </span>'),
	jM = Te('<span class="text-primary underline"> </span>'),
	VM = Te('<button class="text-base-content/80 p-1"><!></button>'),
	qM = Te(
		'<div class="flex items-center gap-1"><!> <span> <button class="font-semibold"><!></button></span> <!></div>'
	),
	ZM = Te(
		'<section class="flex items-center justify-between"><h2 class="text-xl font-semibold sm:text-3xl"> </h2> <div class="flex items-center gap-1"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-ghost"><!></div> <ul class="dropdown-content menu bg-base-100 rounded-box z-1 border-base-200 right-0 w-44 translate-y-1 border p-2 shadow-sm"><li><button class="btn btn-soft btn-error"> </button></li></ul></div> <!></div></section> <!> <section class="mt-3"><div class="flex items-center gap-1"><!> <span> <span class="font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span> <!></span></div> <!></section> <section class="mt-6"><h3 class="text-lg font-semibold"> </h3> <div class="mt-1 pb-2"><!></div></section> <!> <!>',
		1
	),
	UM = (m, a) => {
		var p;
		(p = x(a)) == null || p.show();
	},
	$M = Te(
		'<div class="flex h-[90%] flex-col items-center justify-center gap-3"><span class="text-base-content/80"> </span> <span class="mt-8 flex items-center gap-2 text-xl font-semibold"><!> </span> <div class="flex w-full justify-center"><div class="divider w-full max-w-sm"> </div></div> <button class="btn btn-xl btn-soft mb-6"><!> </button></div> <!>',
		1
	),
	GM = Te('<div class="h-full"><!></div>');
function HM(m, a) {
	Lr(a, !0);
	let p = st(void 0),
		y = st(!0),
		M = st(void 0),
		z = st(!1),
		T = st(void 0),
		s = st(!1),
		B = st(!1),
		O = st(() => {});
	dl(
		() => a.open,
		() => {
			a.open && Yd.shouldReload && X();
		}
	),
		Fn(() => {
			const ge = setInterval(() => {
				Yd.shouldReload = !0;
			}, 1e4);
			return () => {
				clearTimeout(ge);
			};
		});
	async function X() {
		try {
			se(p, await Qr.getAlliance(), !0),
				x(p) && x(O)(),
				se(y, !1),
				(Yd.shouldReload = !1);
		} catch (ge) {
			Fr.error(ge.message);
		}
	}
	var K = GM(),
		ne = A(K);
	{
		var H = (ge) => {
				var Ie = MM();
				$(ge, Ie);
			},
			fe = (ge) => {
				var Ie = er(),
					Ae = Ct(Ie);
				{
					var De = (Fe) => {
							cM(Fe, { onclickback: () => se(B, !1) });
						},
						Ee = (Fe) => {
							var $e = er(),
								Je = Ct($e);
							{
								var qe = (Qe) => {
										var Le = ZM(),
											et = Ct(Le),
											nt = A(et),
											Ue = A(nt, !0);
										k(nt);
										var ke = j(nt, 2),
											vt = A(ke),
											ee = A(vt),
											re = A(ee);
										$m(re, { class: "size-4" }), k(ee);
										var he = j(ee, 2),
											oe = A(he),
											ze = A(oe);
										ze.__click = [kM, z, y, X];
										var je = A(ze, !0);
										k(ze), k(oe), k(he), k(vt);
										var pt = j(vt, 2);
										{
											var it = (ue) => {
												var V = EM(),
													U = A(V);
												U.__click = [AM, s];
												var Y = A(U);
												SM(Y, { class: "size-4" }),
													k(U),
													k(V),
													We((ie) => Tr(V, "data-tip", ie), [() => W3()]),
													$(ue, V);
											};
											Oe(pt, (ue) => {
												x(p).role == "admin" && ue(it);
											});
										}
										k(ke), k(et);
										var ct = j(et, 2);
										{
											var It = (ue) => {
												var V = DM(),
													U = A(V);
												Am(U, () => IM(x(p).description || Hv()));
												var Y = j(U, 2);
												{
													var ie = (pe) => {
														var Se = LM();
														Se.__click = [zM, T];
														var Me = A(Se);
														tm(Me, { class: "size-4" }), k(Se), $(pe, Se);
													};
													Oe(Y, (pe) => {
														x(p).role === "admin" && pe(ie);
													});
												}
												k(V), $(ue, V);
											};
											Oe(ct, (ue) => {
												(x(p).description || x(p).role === "admin") && ue(It);
											});
										}
										var Dt = j(ct, 2),
											at = A(Dt),
											dt = A(at);
										zh(dt, { class: "inline size-4" });
										var yt = j(dt, 2),
											xt = A(yt),
											St = j(xt),
											wt = A(St, !0);
										k(St), k(yt), k(at);
										var _t = j(at, 2),
											Lt = A(_t);
										yp(Lt, { class: "inline size-4" });
										var Rt = j(Lt, 2),
											$t = A(Rt),
											tr = j($t);
										{
											var Qt = (ue) => {
													var V = RM(),
														U = A(V, !0);
													k(V),
														We(
															(Y) => de(U, Y),
															[() => x(p).members.toLocaleString("en-US")]
														),
														$(ue, V);
												},
												Ot = (ue) => {
													var V = FM();
													V.__click = [BM, B];
													var U = A(V, !0);
													k(V),
														We(
															(Y) => de(U, Y),
															[() => x(p).members.toLocaleString("en-US")]
														),
														$(ue, V);
												};
											Oe(tr, (ue) => {
												x(p).role === "member" ? ue(Qt) : ue(Ot, !1);
											});
										}
										k(Rt), k(_t);
										var Nt = j(_t, 2);
										{
											var or = (ue) => {
												var V = qM(),
													U = A(V);
												bM(U, { class: "inline size-4" });
												var Y = j(U, 2),
													ie = A(Y),
													pe = j(ie);
												pe.__click = [OM, p, a];
												var Se = A(pe);
												{
													var Me = (Ke) => {
															var kt = NM(),
																ye = A(kt);
															k(kt),
																We(
																	(Bt, rr) =>
																		de(ye, `${Bt ?? ""}, ${rr ?? ""}`),
																	[
																		() => x(p).hq.latitude.toFixed(3),
																		() => x(p).hq.longitude.toFixed(3),
																	]
																),
																$(Ke, kt);
														},
														we = (Ke) => {
															var kt = jM(),
																ye = A(kt, !0);
															k(kt),
																We((Bt) => de(ye, Bt), [() => T3()]),
																$(Ke, kt);
														};
													Oe(Se, (Ke) => {
														x(p).hq ? Ke(Me) : Ke(we, !1);
													});
												}
												k(pe), k(Y);
												var Ve = j(Y, 2);
												{
													var ut = (Ke) => {
														var kt = VM();
														kt.__click = function (...Bt) {
															var rr;
															(rr = a.onhqchange) == null || rr.apply(this, Bt);
														};
														var ye = A(kt);
														tm(ye, { class: "text-base-content/50 size-4" }),
															k(kt),
															$(Ke, kt);
													};
													Oe(Ve, (Ke) => {
														x(p).role === "admin" && Ke(ut);
													});
												}
												k(V),
													We((Ke) => de(ie, `${Ke ?? ""}: `), [() => x3()]),
													$(ue, V);
											};
											Oe(Nt, (ue) => {
												(x(p).hq || x(p).role === "admin") && ue(or);
											});
										}
										k(Dt);
										var cr = j(Dt, 2),
											Vr = A(cr),
											mr = A(Vr, !0);
										k(Vr);
										var hr = j(Vr, 2),
											_r = A(hr);
										W4(_r, {
											get allianceId() {
												return x(p).id;
											},
											get onlastpixelclick() {
												return a.onlastpixelclick;
											},
											get reload() {
												return x(O);
											},
											set reload(ue) {
												se(O, ue, !0);
											},
										}),
											k(hr),
											k(cr);
										var Ir = j(cr, 2);
										w4(Ir, {
											get description() {
												return x(p).description;
											},
											onsuccess: async (ue) => {
												x(p) && (x(p).description = ue);
											},
											get ref() {
												return x(T);
											},
											set ref(ue) {
												se(T, ue, !0);
											},
										});
										var qr = j(Ir, 2);
										P4(qr, {
											get open() {
												return x(s);
											},
											set open(ue) {
												se(s, ue, !0);
											},
										}),
											We(
												(ue, V, U, Y, ie) => {
													de(Ue, x(p).name),
														(ze.disabled = x(z)),
														de(je, ue),
														de(xt, `${V ?? ""}: `),
														de(wt, U),
														de($t, `${Y ?? ""}: `),
														de(mr, ie);
												},
												[
													() => g3(),
													() => zm(),
													() => x(p).pixelsPainted.toLocaleString("en-US"),
													() => Dv(),
													() => Bm(),
												]
											),
											$(Qe, Le);
									},
									Ze = (Qe) => {
										var Le = $M(),
											et = Ct(Le),
											nt = A(et),
											Ue = A(nt);
										k(nt);
										var ke = j(nt, 2),
											vt = A(ke);
										TM(vt, { class: "size-5" });
										var ee = j(vt, 1, !0);
										k(ke);
										var re = j(ke, 2),
											he = A(re),
											oe = A(he, !0);
										k(he), k(re);
										var ze = j(re, 2);
										ze.__click = [UM, M];
										var je = A(ze);
										Rv(je, { class: "size-6" });
										var pt = j(je);
										k(ze), k(et);
										var it = j(et, 2);
										_M(it, {
											onsuccess: X,
											get ref() {
												return x(M);
											},
											set ref(ct) {
												se(M, ct, !0);
											},
										}),
											We(
												(ct, It, Dt, at) => {
													de(Ue, `${ct ?? ""}:`),
														de(ee, It),
														de(oe, Dt),
														de(pt, ` ${at ?? ""}`);
												},
												[() => P3(), () => k3(), () => z3(), () => R3()]
											),
											$(Qe, Le);
									};
								Oe(
									Je,
									(Qe) => {
										x(p) ? Qe(qe) : Qe(Ze, !1);
									},
									!0
								);
							}
							$(Fe, $e);
						};
					Oe(
						Ae,
						(Fe) => {
							x(B) ? Fe(De) : Fe(Ee, !1);
						},
						!0
					);
				}
				$(ge, Ie);
			};
		Oe(ne, (ge) => {
			x(y) ? ge(H) : ge(fe, !1);
		});
	}
	k(K), $(m, K), Dr();
}
$n(["click"]);
var WM = Pr(
	'<svg><path d="M40-160v-160q0-34 23.5-57t56.5-23h131q20 0 38 10t29 27q29 39 71.5 61t90.5 22q49 0 91.5-22t70.5-61q13-17 30.5-27t36.5-10h131q34 0 57 23t23 57v160H640v-91q-35 25-75.5 38T480-200q-43 0-84-13.5T320-252v92H40Zm440-160q-38 0-72-17.5T351-386q-17-25-42.5-39.5T253-440q22-37 93-58.5T480-520q63 0 134 21.5t93 58.5q-29 0-55 14.5T609-386q-22 32-56 49t-73 17ZM160-440q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T280-560q0 50-34.5 85T160-440Zm640 0q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T920-560q0 50-34.5 85T800-440ZM480-560q-50 0-85-35t-35-85q0-51 35-85.5t85-34.5q51 0 85.5 34.5T600-680q0 50-34.5 85T480-560Z"></path></svg>'
);
function xp(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = WM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var XM = Te(
	'<dialog class="modal"><div class="modal-box sm:h-11/12 flex max-w-3xl flex-col max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1.5"><!> <h3 class="text-lg font-bold max-sm:text-xl"> </h3></div> <div class="mt-1 grow"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function YM(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const K = (ne) => {
			ne.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", K),
			() => document.removeEventListener("keydown", K)
		);
	});
	var y = XM(),
		M = A(y),
		z = j(A(M), 2),
		T = A(z);
	xp(T, { class: "size-5 max-sm:size-6" });
	var s = j(T, 2),
		B = A(s, !0);
	k(s), k(z);
	var O = j(z, 2),
		X = A(O);
	HM(X, {
		get open() {
			return p();
		},
		get onhqchange() {
			return a.onhqchange;
		},
		get onhqclick() {
			return a.onhqclick;
		},
		get onlastpixelclick() {
			return a.onlastpixelclick;
		},
	}),
		k(O),
		k(M),
		yn(2),
		k(y),
		Ni(y, () => (K) => {
			Wr(() => {
				p()
					? (K.show(),
					  yi.url.searchParams.get("alliance") &&
							(yi.url.searchParams.delete("alliance"), km(yi.url.toString())))
					: K.close();
			});
		}),
		We((K) => de(B, K), [() => _p()]),
		di("close", y, () => p(!1)),
		Ai(
			2,
			O,
			() => ia,
			() => ({ duration: 300 })
		),
		$(m, y),
		Dr();
}
function KM(m, a, p) {
	return new Promise((y, M) => {
		m.once("render", () => {
			const z = m.getCanvas().toDataURL(),
				T = document.createElement("img");
			(T.src = z),
				(T.onload = () => {
					const s = document.createElement("canvas");
					(s.width = T.width), (s.height = T.height);
					const B = s.getContext("2d");
					if (B) {
						B.drawImage(T, 0, 0);
						const [O, X, K, ne] = B.getImageData(a, p, 1, 1).data;
						y([O, X, K, ne]);
					} else M(new Error("Could not get 2d context from canvas"));
					T.remove(), s.remove();
				});
		}),
			m.triggerRepaint();
	});
}
function a0(m, a) {
	return new Promise((p, y) => {
		m.once("render", () => {
			const M = m.getCanvas();
			let z = M;
			if ((a != null && a.maxWidth) || (a != null && a.maxHeight)) {
				const T = M.width,
					s = M.height,
					B = (a == null ? void 0 : a.maxWidth) ?? T,
					O = (a == null ? void 0 : a.maxHeight) ?? s;
				z = document.createElement("canvas");
				const X = Math.min(B / T, O / s);
				(z.width = Math.floor(T * X)), (z.height = Math.floor(s * X));
				const K = z.getContext("2d");
				K && K.drawImage(M, 0, 0, z.width, z.height);
			}
			try {
				z.toBlob(
					(T) => {
						T && p(T);
					},
					(a == null ? void 0 : a.type) ?? "image/png",
					(a == null ? void 0 : a.quality) ?? 1
				);
			} catch (T) {
				y(T);
			} finally {
				z !== M && z.remove();
			}
		});
	});
}
var JM = Pr(
	'<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm0-80h560v-560H200v560Zm40-80h480L570-480 450-320l-90-120-120 160Zm-40 80v-560 560Z"></path></svg>'
);
function QM(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = JM();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		height: "24px",
		viewBox: "0 -960 960 960",
		width: "24px",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var e6 = Pr(
	'<svg><path d="M680-80q-50 0-85-35t-35-85q0-6 3-28L282-392q-16 15-37 23.5t-45 8.5q-50 0-85-35t-35-85q0-50 35-85t85-35q24 0 45 8.5t37 23.5l281-164q-2-7-2.5-13.5T560-760q0-50 35-85t85-35q50 0 85 35t35 85q0 50-35 85t-85 35q-24 0-45-8.5T598-672L317-508q2 7 2.5 13.5t.5 14.5q0 8-.5 14.5T317-452l281 164q16-15 37-23.5t45-8.5q50 0 85 35t35 85q0 50-35 85t-85 35Z"></path></svg>'
);
function o0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = e6();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
const gc = { hour: 3600 * 1e3, min: 60 * 1e3, sec: 1e3 };
function rp(m) {
	const a = Math.floor(m / gc.hour);
	m -= a * gc.hour;
	const p = Math.floor(m / gc.min);
	m -= p * gc.min;
	const M = Math.floor(m / gc.sec)
		.toString()
		.padStart(2, "0");
	return a > 0 ? `${a}:${p.toString().padStart(2, "0")}:${M}` : `${p}:${M}`;
}
function t6(m) {
	const a = new Date(),
		p = a.getFullYear(),
		y = String(a.getMonth() + 1).padStart(2, "0"),
		M = String(a.getDate()).padStart(2, "0"),
		z = String(a.getHours()).padStart(2, "0"),
		T = String(a.getMinutes()).padStart(2, "0"),
		s = String(a.getSeconds()).padStart(2, "0");
	return `${p}-${y}-${M} ${z}:${T}:${s}`;
}
var r6 = (m, a, p) => {
		navigator.clipboard.writeText(a.url.toString()),
			se(p, !0),
			setTimeout(() => {
				se(p, !1);
			}, 1e3);
	},
	n6 = Te('<img class="border-base-content/20 border" alt="Screenshot"/>'),
	i6 = Te(
		'<div class="flex w-full items-center justify-center"><span class="loading loading-spinner"></span></div>'
	),
	a6 = async (m, a) => {
		x(a) &&
			(await navigator.clipboard.write([
				new ClipboardItem({ "image/png": x(a) }),
			]),
			Fr.info(xP()));
	},
	o6 = Te(
		'<div><h3 class="mb-1 mt-5 flex items-center gap-1 text-xl font-semibold"><!> </h3> <!> <div class="mt-3 flex items-end justify-end gap-2"><button class="btn"><!> </button> <a class="btn btn-primary"><!> </a></div></div>'
	),
	s6 = Te(
		'<dialog class="modal"><div class="modal-box max-h-11/12"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-xl font-bold"><!> </h3> <div class="border-base-content/20 rounded-field mt-3 flex w-full items-center gap-1 border-2 py-1.5 pl-4 pr-2.5"><input class="text-base-content/80 min-w-10 grow text-sm font-medium" readonly=""/> <div class="h-10"><button> </button></div></div> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function l6(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(!1);
	Fn(() => {
		const Ee = (Fe) => {
			Fe.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", Ee),
			() => document.removeEventListener("keydown", Ee)
		);
	});
	let M = st(null),
		z = st("");
	Wr(() => {
		p()
			? (a.hideHover(),
			  setTimeout(async () => {
					a0(a.map)
						.then((Ee) => {
							se(M, Ee, !0), se(z, URL.createObjectURL(x(M)), !0);
						})
						.finally(() => {
							a.showHover();
						});
			  }, 500))
			: x(z) && (URL.revokeObjectURL(x(z)), se(M, null), se(z, ""));
	});
	var T = s6(),
		s = A(T),
		B = j(A(s), 2),
		O = A(B);
	o0(O, { class: "size-5" });
	var X = j(O);
	k(B);
	var K = j(B, 2),
		ne = A(K);
	Ka(ne);
	var H = j(ne, 2),
		fe = A(H);
	let ge;
	fe.__click = [r6, a, y];
	var Ie = A(fe, !0);
	k(fe), k(H), k(K);
	var Ae = j(K, 2);
	{
		var De = (Ee) => {
			const Fe = ft(() => {
				var oe;
				return (oe = a.map) == null ? void 0 : oe.getCanvas();
			});
			var $e = o6(),
				Je = A($e),
				qe = A(Je);
			QM(qe, { class: "inline size-5" });
			var Ze = j(qe);
			k(Je);
			var Qe = j(Je, 2);
			{
				var Le = (oe) => {
						var ze = n6();
						We(() => {
							Tr(ze, "src", x(z)),
								Tr(ze, "width", x(Fe).width),
								Tr(ze, "height", x(Fe).height);
						}),
							$(oe, ze);
					},
					et = (oe) => {
						var ze = i6();
						We(() => kc(ze, `aspect-ratio: ${x(Fe).width / x(Fe).height}`)),
							$(oe, ze);
					};
				Oe(Qe, (oe) => {
					x(z) ? oe(Le) : oe(et, !1);
				});
			}
			var nt = j(Qe, 2),
				Ue = A(nt);
			Ue.__click = [a6, M];
			var ke = A(Ue);
			Rm(ke, { class: "size-5" });
			var vt = j(ke);
			k(Ue);
			var ee = j(Ue, 2),
				re = A(ee);
			zv(re, { class: "size-5" });
			var he = j(re);
			k(ee),
				k(nt),
				k($e),
				We(
					(oe, ze, je, pt) => {
						de(Ze, ` ${oe ?? ""}`),
							de(vt, ` ${ze ?? ""}`),
							Tr(ee, "href", x(z)),
							Tr(ee, "download", `wplace_${je ?? ""}.png`),
							de(he, ` ${pt ?? ""}`);
					},
					[
						() => fP(),
						() => Wf(),
						() => t6().replaceAll(" ", "_").replaceAll(":", "-"),
						() => gP(),
					]
				),
				Ai(
					2,
					$e,
					() => ia,
					() => ({ duration: 300 })
				),
				$(Ee, $e);
		};
		Oe(Ae, (Ee) => {
			p() && Ee(De);
		});
	}
	k(s),
		yn(2),
		k(T),
		Ni(T, () => (Ee) => {
			Wr(() => {
				p() ? Ee.show() : Ee.close();
			});
		}),
		We(
			(Ee, Fe, $e, Je) => {
				de(X, ` ${Ee ?? ""}`),
					Av(ne, Fe),
					(ge = zr(fe, 1, "btn btn-primary", null, ge, $e)),
					de(Ie, Je);
			},
			[
				() => kC(),
				() => a.url.toString(),
				() => ({ "btn-success": x(y) }),
				() => (x(y) ? Fm() : Wf()),
			]
		),
		di("close", T, () => p(!1)),
		$(m, T),
		Dr();
}
$n(["click"]);
var c6 = Pr(
	'<svg><path d="m576-160-56-56 104-104-104-104 56-56 104 104 104-104 56 56-104 104 104 104-56 56-104-104-104 104Zm79-360L513-662l56-56 85 85 170-170 56 57-225 226ZM80-280v-80h360v80H80Zm0-320v-80h360v80H80Z"></path></svg>'
);
function u6(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = c6();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var h6 = Te(
		'<li class="bg-base-200 border-base-content/10 rounded-xl border-2 p-3"> </li>'
	),
	d6 = Te(
		'<div><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> <span class="badge badge-sm badge-error badge-soft ml-1"> </span></h3></div> <div class="text-sm sm:text-base"><ul class="my-3 flex flex-col gap-2 font-medium"></ul> <p class="text-base-content/80 mt-2 text-sm"> </p></div></div>'
	);
function Gm(m, a) {
	Lr(a, !1);
	const p = [Kw(), Ww(), e5(), n5(), o5(), c5(), d5()];
	Nv();
	var y = d6(),
		M = A(y),
		z = A(M);
	u6(z, { class: "size-5" });
	var T = j(z, 2),
		s = A(T),
		B = j(s),
		O = A(B, !0);
	k(B), k(T), k(M);
	var X = j(M, 2),
		K = A(X);
	hi(
		K,
		5,
		() => p,
		hp,
		(fe, ge) => {
			var Ie = h6(),
				Ae = A(Ie, !0);
			k(Ie), We(() => de(Ae, x(ge))), $(fe, Ie);
		}
	),
		k(K);
	var ne = j(K, 2),
		H = A(ne, !0);
	k(ne),
		k(X),
		k(y),
		We(
			(fe, ge, Ie) => {
				de(s, `${fe ?? ""} `), de(O, ge), de(H, Ie);
			},
			[() => qw(), () => $w(), () => m5()]
		),
		$(m, y),
		Dr();
}
var p6 = (m, a) => {
		a(!1);
	},
	f6 = Te(
		'<dialog class="modal"><div class="modal-box sm:max-h-11/12"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex h-full flex-col gap-6"><h2 class="text-xl font-semibold">📑 Updated rules</h2> <section><!></section> <button class="btn btn-primary">Close</button></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function m6(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const O = (X) => {
			X.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", O),
			() => document.removeEventListener("keydown", O)
		);
	});
	var y = f6(),
		M = A(y),
		z = j(A(M), 2),
		T = j(A(z), 2),
		s = A(T);
	Gm(s, {}), k(T);
	var B = j(T, 2);
	(B.__click = [p6, p]),
		k(z),
		k(M),
		yn(2),
		k(y),
		Ni(y, () => (O) => {
			Wr(() => {
				p() ? O.show() : O.close();
			});
		}),
		di("close", y, () => p(!1)),
		$(m, y),
		Dr();
}
$n(["click"]);
var _6 = () => {
		yi.url.searchParams.delete("new-user"), km(yi.url.toString());
	},
	g6 = Te(
		'<dialog class="modal"><div class="modal-box max-h-11/12"><section class="mb-6 flex justify-center"><h2 class="font-pixel flex flex-col justify-center"><span class="text-center text-2xl"> </span> <!></h2></section> <section class="my-2"><!></section> <form class="mt-6 flex justify-center" method="dialog"><button class="btn btn-primary sm:btn-lg"> </button></form></div></dialog>'
	);
function v6(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const ge = (Ie) => {
			Ie.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", ge),
			() => document.removeEventListener("keydown", ge)
		);
	});
	var y = g6(),
		M = A(y),
		z = A(M),
		T = A(z),
		s = A(T),
		B = A(s, !0);
	k(s);
	var O = j(s, 2);
	jv(O, { hasText: !0, size: "medium" }), k(T), k(z);
	var X = j(z, 2),
		K = A(X);
	Gm(K, {}), k(X);
	var ne = j(X, 2),
		H = A(ne);
	H.__click = [_6];
	var fe = A(H, !0);
	k(H),
		k(ne),
		k(M),
		k(y),
		Ni(y, () => (ge) => {
			Wr(() => {
				p() ? ge.show() : ge.close();
			});
		}),
		We(
			(ge, Ie) => {
				de(B, ge), de(fe, Ie);
			},
			[() => Nw(), () => v5()]
		),
		di("close", y, () => p(!1)),
		$(m, y),
		Dr();
}
$n(["click"]);
function y6() {
	const m = navigator.userAgent,
		a = navigator.vendor;
	return /Chrome/.test(m) && /Google Inc/.test(a)
		? "Chrome"
		: /Safari/.test(m) && /Apple Computer/.test(a)
		? "Safari"
		: /Firefox/.test(m)
		? "Firefox"
		: /Edge/.test(m)
		? "Edge"
		: /Opera|OPR/.test(m)
		? "Opera"
		: "Unknown";
}
var x6 = Pr(
	'<svg><path d="M358.939 44C384.805 44 405.773 64.9683 405.773 90.834C405.773 116.7 384.805 137.668 358.939 137.668C335.282 137.668 315.725 120.127 312.558 97.3418C311.882 97.5076 311.068 97.7132 310.139 97.9658C307.227 98.7577 303.219 99.9781 298.844 101.688C289.898 105.186 280.227 110.425 274.75 117.568C269.021 125.042 265.37 135.158 263.158 143.737C262.067 147.97 261.355 151.71 260.917 154.385C260.789 155.166 260.687 155.855 260.604 156.437C304.314 157.147 344.347 169.064 375.81 188.514C386.896 180.117 400.712 175.135 415.691 175.135C452.208 175.135 481.811 204.738 481.811 241.254C481.81 267.527 466.485 290.221 444.287 300.885C441.861 377.201 358.696 438.508 256.456 438.508C154.451 438.508 71.4321 377.482 68.6426 301.409C45.8419 290.978 30.0001 267.967 30 241.254C30 204.738 59.6021 175.135 96.1182 175.135C111.321 175.135 125.325 180.267 136.494 188.892C167.617 169.488 207.216 157.484 250.507 156.473C250.517 156.392 250.528 156.307 250.539 156.218C250.646 155.398 250.811 154.224 251.049 152.771C251.524 149.867 252.293 145.823 253.475 141.24C255.808 132.188 259.872 120.54 266.814 111.484C274.011 102.098 285.828 96.04 295.202 92.375C299.987 90.5044 304.348 89.1775 307.514 88.3164C309.099 87.8852 310.394 87.568 311.302 87.3574C311.69 87.2673 312.009 87.1968 312.249 87.1445C314.13 63.0035 334.316 44.0001 358.939 44ZM255.905 334.922C234.07 334.922 213.107 336.328 193.621 338.913C190.267 341.144 188.408 343.008 187.698 344.95C187.085 346.63 187.361 348.283 188.093 350.118C200.137 369.374 217.021 383.431 236.377 389.255C237.939 389.694 239.551 390.118 241.216 390.527C246.165 391.641 251.258 392.225 256.456 392.225C283.556 392.224 307.779 376.436 323.849 351.639C325.103 348.78 325.526 346.501 324.943 344.546C324.28 342.322 322.364 340.66 319.327 339.067C299.52 336.385 278.166 334.922 255.905 334.922ZM167.196 240.151C148.634 240.151 133.586 257.42 133.586 278.721C133.586 300.022 148.634 317.29 167.196 317.29C185.759 317.29 200.806 300.022 200.806 278.721C200.806 257.42 185.759 240.152 167.196 240.151ZM343.512 240.151C324.949 240.152 309.901 257.42 309.901 278.721C309.901 300.022 324.949 317.29 343.512 317.29C362.074 317.29 377.122 300.022 377.122 278.721C377.122 257.42 362.074 240.151 343.512 240.151Z"></path></svg>'
);
function b6(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = x6();
	ar(y, () => ({
		viewBox: "0 0 512 512",
		fill: "currentColor",
		xmlns: "http://www.w3.org/2000/svg",
		...p,
	})),
		$(m, y);
}
var w6 = Pr(
	'<svg><path d="M216.856 16.597A208.502 208.502 0 0 0 164.042 0c-2.275 4.113-4.933 9.645-6.766 14.046-19.692-2.961-39.203-2.961-58.533 0-1.832-4.4-4.55-9.933-6.846-14.046a207.809 207.809 0 0 0-52.855 16.638C5.618 67.147-3.443 116.4 1.087 164.956c22.169 16.555 43.653 26.612 64.775 33.193A161.094 161.094 0 0 0 79.735 175.3a136.413 136.413 0 0 1-21.846-10.632 108.636 108.636 0 0 0 5.356-4.237c42.122 19.702 87.89 19.702 129.51 0a131.66 131.66 0 0 0 5.355 4.237 136.07 136.07 0 0 1-21.886 10.653c4.006 8.02 8.638 15.67 13.873 22.848 21.142-6.58 42.646-16.637 64.815-33.213 5.316-56.288-9.08-105.09-38.056-148.36ZM85.474 135.095c-12.645 0-23.015-11.805-23.015-26.18s10.149-26.2 23.015-26.2c12.867 0 23.236 11.804 23.015 26.2.02 14.375-10.148 26.18-23.015 26.18Zm85.051 0c-12.645 0-23.014-11.805-23.014-26.18s10.148-26.2 23.014-26.2c12.867 0 23.236 11.804 23.015 26.2 0 14.375-10.148 26.18-23.015 26.18Z"></path></svg>'
);
function rm(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = w6();
	ar(y, () => ({
		viewBox: "0 0 256 199",
		width: "256",
		height: "199",
		xmlns: "http://www.w3.org/2000/svg",
		preserveAspectRatio: "xMidYMid",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var T6 = Pr(
	'<svg><path fill="#0A0A08" d="M128 23.064c34.177 0 38.225.13 51.722.745 12.48.57 19.258 2.655 23.769 4.408 5.974 2.322 10.238 5.096 14.717 9.575 4.48 4.479 7.253 8.743 9.575 14.717 1.753 4.511 3.838 11.289 4.408 23.768.615 13.498.745 17.546.745 51.723 0 34.178-.13 38.226-.745 51.723-.57 12.48-2.655 19.257-4.408 23.768-2.322 5.974-5.096 10.239-9.575 14.718-4.479 4.479-8.743 7.253-14.717 9.574-4.511 1.753-11.289 3.839-23.769 4.408-13.495.616-17.543.746-51.722.746-34.18 0-38.228-.13-51.723-.746-12.48-.57-19.257-2.655-23.768-4.408-5.974-2.321-10.239-5.095-14.718-9.574-4.479-4.48-7.253-8.744-9.574-14.718-1.753-4.51-3.839-11.288-4.408-23.768-.616-13.497-.746-17.545-.746-51.723 0-34.177.13-38.225.746-51.722.57-12.48 2.655-19.258 4.408-23.769 2.321-5.974 5.095-10.238 9.574-14.717 4.48-4.48 8.744-7.253 14.718-9.575 4.51-1.753 11.288-3.838 23.768-4.408 13.497-.615 17.545-.745 51.723-.745M128 0C93.237 0 88.878.147 75.226.77c-13.625.622-22.93 2.786-31.071 5.95-8.418 3.271-15.556 7.648-22.672 14.764C14.367 28.6 9.991 35.738 6.72 44.155 3.555 52.297 1.392 61.602.77 75.226.147 88.878 0 93.237 0 128c0 34.763.147 39.122.77 52.774.622 13.625 2.785 22.93 5.95 31.071 3.27 8.417 7.647 15.556 14.763 22.672 7.116 7.116 14.254 11.492 22.672 14.763 8.142 3.165 17.446 5.328 31.07 5.95 13.653.623 18.012.77 52.775.77s39.122-.147 52.774-.77c13.624-.622 22.929-2.785 31.07-5.95 8.418-3.27 15.556-7.647 22.672-14.763 7.116-7.116 11.493-14.254 14.764-22.672 3.164-8.142 5.328-17.446 5.95-31.07.623-13.653.77-18.012.77-52.775s-.147-39.122-.77-52.774c-.622-13.624-2.786-22.929-5.95-31.07-3.271-8.418-7.648-15.556-14.764-22.672C227.4 14.368 220.262 9.99 211.845 6.72c-8.142-3.164-17.447-5.328-31.071-5.95C167.122.147 162.763 0 128 0Zm0 62.27C91.698 62.27 62.27 91.7 62.27 128c0 36.302 29.428 65.73 65.73 65.73 36.301 0 65.73-29.428 65.73-65.73 0-36.301-29.429-65.73-65.73-65.73Zm0 108.397c-23.564 0-42.667-19.103-42.667-42.667S104.436 85.333 128 85.333s42.667 19.103 42.667 42.667-19.103 42.667-42.667 42.667Zm83.686-110.994c0 8.484-6.876 15.36-15.36 15.36-8.483 0-15.36-6.876-15.36-15.36 0-8.483 6.877-15.36 15.36-15.36 8.484 0 15.36 6.877 15.36 15.36Z"></path></svg>'
);
function C6(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = T6();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		preserveAspectRatio: "xMidYMid",
		viewBox: "0 0 260 260",
		...p,
	})),
		$(m, y);
}
var S6 = Pr(
	'<svg><path d="M240-640h360v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85h-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640Zm0 480h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Z"></path></svg>'
);
function np(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = S6();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var P6 = Pr(`<svg><path d="M12.75 2c.39 0 .708.316.75.704a5.735 5.735 0 0 0
  4.112 4.751c.257.077.523.127.801.149.394.028.713.35.713.744v2.289a.75.75
  0 0 1-.826.746 8.89 8.89 0 0 1-3.546-1.239v6.43a5.465 5.465 0
  1 1-5.465-5.465c.388 0 .765.042 1.128.122a.75.75 0 0
  1 .593.732v2.289a.75.75 0 0 1-.979.715 1.549 1.549 0 0
  0-.482-.077 1.962 1.962 0 1 0 1.962 1.962V2.75a.75.75 0 0 1
  .75-.75h1.239Z"></path></svg>`);
function I6(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = P6();
	ar(y, () => ({
		viewBox: "0 0 24 24",
		fill: "currentColor",
		xmlns: "http://www.w3.org/2000/svg",
		"aria-label": "Tiktok",
		...p,
	})),
		$(m, y);
}
var M6 = Pr(`<svg><path d="M23.498 6.186a2.986 2.986 0 0 0-2.103-2.115C19.505
    3.5 12 3.5 12 3.5s-7.505 0-9.395.571a2.986 2.986 0 0 0-2.103
    2.115C0 8.082 0 12 0 12s0 3.918.502 5.814a2.986 2.986 0 0 0
    2.103 2.115C4.495 20.5 12 20.5 12 20.5s7.505 0 9.395-.571a2.986
    2.986 0 0 0 2.103-2.115C24 15.918 24 12 24 12s0-3.918-.502-5.814zM9.75
    15.021v-6.042L15.5 12l-5.75 3.021z"></path></svg>`);
function k6(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = M6();
	ar(y, () => ({
		viewBox: "0 0 24 24",
		fill: "currentColor",
		xmlns: "http://www.w3.org/2000/svg",
		"aria-label": "YouTube",
		...p,
	})),
		$(m, y);
}
var A6 = Te(
		' <a class="link" href="https://help.constructiononline.com/en/scheduling-webgl-and-hardware-acceleration">link</a>',
		1
	),
	E6 = Te('<span class="link cursor-auto">chrome://settings/system</span>.', 1),
	z6 = Te(
		'<span class="link cursor-auto">edge://settings/system/manageSystem</span>.',
		1
	),
	L6 = Te(' <kbd class="kbd kbd-sm"> </kbd> <!>', 1),
	D6 = Te(
		'<div class="flex h-full flex-col gap-5"><section class="mb-2 flex flex-col items-center justify-center gap-2"><!> <div class="text-center text-sm max-sm:mt-1"> <a class="link" href="https://maplibre.org/" target="_blank">MapLibre</a> | <a class="link" href="https://openfreemap.org/" target="_blank">OpenFreeMap</a> <a class="link" href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a></div> <div class="w-full text-center text-sm"><p><a href="https://discord.gg/wplacelive" target="_blank" class="text-nowrap"><!> <span class="link">Discord</span></a> <span class="mx-0.5">|</span> <a href="https://www.reddit.com/r/WplaceLive/" target="_blank" class="text-nowrap"><!> <span class="link">Reddit</span></a> <span class="mx-0.5">|</span> <a href="https://www.instagram.com/wplace.live/" target="_blank" class="text-nowrap"><!> <span class="link">Instagram</span></a> <span class="mx-0.5">|</span> <a href="https://www.youtube.com/@WplaceLive" target="_blank" class="text-nowrap"><!> <span class="link">Youtube</span></a> <span class="mx-0.5">|</span> <a href="https://www.tiktok.com/@wplace5" target="_blank" class="text-nowrap"><!> <span class="link">Tiktok</span></a></p></div></section> <section><h3 class="text-lg font-semibold"> </h3> <iframe class="mt-1 aspect-video w-full bg-black" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="not-touchscreen:hidden text-sm"> <button class="btn btn-square shadow-md"><!></button> </p> <p class="touchscreen:hidden text-sm"> <span class="kbd kbd-xs text-base-content rounded-md"> </span> </p></section> <section><h3 class="text-lg font-semibold"> </h3> <p class="text-sm"><!></p></section> <section><!></section> <div class="grow"></div> <section class="text-base-content/80 w-full text-center text-sm max-sm:pb-4"><span>Email: <a class="link" href="mailto:contact@wplace.live">contact@wplace.live</a></span> · <a class="link" target="_blank"> </a> · <a class="link" target="_blank"> </a> · <a class="link" target="_blank"> </a> · <a class="link" href="https://forms.gle/tpDWwewuK5i9C52s8" target="_blank"> </a> · <a class="link" href="https://forms.gle/EVG7A1ZoSyJWAjX96" target="_blank"> </a> · <a class="link" href="https://forms.gle/uinGA5Gj4SpPYa2R6" target="_blank"> </a></section></div>'
	),
	R6 = Te(
		'<dialog class="modal"><div class="modal-box sm:max-h-11/12 max-sm:size-full max-sm:rounded-none max-sm:px-4 sm:max-w-5xl"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>'
	);
function B6(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const K = (ne) => {
			ne.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", K),
			() => document.removeEventListener("keydown", K)
		);
	});
	const y = y6();
	var M = R6(),
		z = A(M),
		T = j(A(z), 2);
	{
		var s = (K) => {
			var ne = D6(),
				H = A(ne),
				fe = A(H);
			jv(fe, { hasText: !0, size: "medium" });
			var ge = j(fe, 2),
				Ie = A(ge),
				Ae = j(Ie, 4);
			yn(), k(ge);
			var De = j(ge, 2),
				Ee = A(De),
				Fe = A(Ee),
				$e = A(Fe);
			rm($e, { class: "text-base-content mr-0.5 inline size-4" }), yn(2), k(Fe);
			var Je = j(Fe, 4),
				qe = A(Je);
			b6(qe, { class: "size-4.5 mr-0.5 inline" }), yn(2), k(Je);
			var Ze = j(Je, 4),
				Qe = A(Ze);
			C6(Qe, { class: "mr-0.5 inline size-3.5" }), yn(2), k(Ze);
			var Le = j(Ze, 4),
				et = A(Le);
			k6(et, { class: "mr-0.5 inline size-3.5" }), yn(2), k(Le);
			var nt = j(Le, 4),
				Ue = A(nt);
			I6(Ue, { class: "mr-0.5 inline size-3.5" }),
				yn(2),
				k(nt),
				k(Ee),
				k(De),
				k(H);
			var ke = j(H, 2),
				vt = A(ke),
				ee = A(vt, !0);
			k(vt);
			var re = j(vt, 2);
			k(ke);
			var he = j(ke, 2),
				oe = A(he),
				ze = A(oe, !0);
			k(oe);
			var je = j(oe, 2),
				pt = A(je),
				it = j(pt),
				ct = A(it);
			np(ct, { class: "size-5" }), k(it);
			var It = j(it);
			k(je);
			var Dt = j(je, 2),
				at = A(Dt),
				dt = j(at),
				yt = A(dt, !0);
			k(dt);
			var xt = j(dt);
			k(Dt), k(he);
			var St = j(he, 2),
				wt = A(St),
				_t = A(wt, !0);
			k(wt);
			var Lt = j(wt, 2),
				Rt = A(Lt);
			{
				var $t = (ie) => {
						var pe = A6(),
							Se = Ct(pe);
						yn(), We((Me) => de(Se, `${Me ?? ""}: `), [() => RP()]), $(ie, pe);
					},
					tr = (ie) => {
						var pe = L6(),
							Se = Ct(pe),
							Me = j(Se),
							we = A(Me, !0);
						k(Me);
						var Ve = j(Me),
							ut = j(Ve);
						{
							var Ke = (ye) => {
									var Bt = E6();
									yn(), $(ye, Bt);
								},
								kt = (ye) => {
									var Bt = er(),
										rr = Ct(Bt);
									{
										var Kt = (gr) => {
											var Ur = z6();
											yn(), $(gr, Ur);
										};
										Oe(
											rr,
											(gr) => {
												y === "Edge" && gr(Kt);
											},
											!0
										);
									}
									$(ye, Bt);
								};
							Oe(ut, (ye) => {
								y === "Chrome" ? ye(Ke) : ye(kt, !1);
							});
						}
						We(
							(ye, Bt, rr) => {
								de(Se, `${ye ?? ""} `), de(we, Bt), de(Ve, ` ${rr ?? ""} `);
							},
							[() => PP(), () => kP(), () => zP()]
						),
							$(ie, pe);
					};
				Oe(Rt, (ie) => {
					y !== "Chrome" && y !== "Edge" ? ie($t) : ie(tr, !1);
				});
			}
			k(Lt), k(St);
			var Qt = j(St, 2),
				Ot = A(Qt);
			Gm(Ot, {}), k(Qt);
			var Nt = j(Qt, 4),
				or = j(A(Nt), 2),
				cr = A(or, !0);
			k(or);
			var Vr = j(or, 2),
				mr = A(Vr, !0);
			k(Vr);
			var hr = j(Vr, 2),
				_r = A(hr, !0);
			k(hr);
			var Ir = j(hr, 2),
				qr = A(Ir, !0);
			k(Ir);
			var ue = j(Ir, 2),
				V = A(ue, !0);
			k(ue);
			var U = j(ue, 2),
				Y = A(U, !0);
			k(U),
				k(Nt),
				k(ne),
				We(
					(
						ie,
						pe,
						Se,
						Me,
						we,
						Ve,
						ut,
						Ke,
						kt,
						ye,
						Bt,
						rr,
						Kt,
						gr,
						Ur,
						nn,
						mn
					) => {
						de(Ie, `${ie ?? ""} `),
							de(
								Ae,
								` ©
						${pe ?? ""} `
							),
							de(ee, Se),
							Tr(
								re,
								"src",
								ai.language === "pt"
									? "https://www.youtube.com/embed/AcE85QM4iPQ?si=wbeZD8vxOzvlB_Z9"
									: "https://www.youtube.com/embed/xOXtd-WzRxA?si=fHz8Z6ecXGYrDhkN"
							),
							de(ze, Me),
							de(pt, `${we ?? ""} `),
							de(It, ` ${Ve ?? ""}`),
							de(at, `${ut ?? ""} `),
							de(yt, Ke),
							de(xt, ` ${kt ?? ""}`),
							de(_t, ye),
							Tr(or, "href", `${yi.url.origin ?? ""}/terms/terms-of-service`),
							de(cr, Bt),
							Tr(Vr, "href", `${yi.url.origin ?? ""}/terms/privacy`),
							de(mr, rr),
							Tr(hr, "href", Kt),
							de(_r, gr),
							de(qr, Ur),
							de(V, nn),
							de(Y, mn);
					},
					[
						() => Nb(),
						() => qb(),
						() => $b(),
						() => Wb(),
						() => Kb(),
						() => e2(),
						() => n2(),
						() => o2(),
						() => c2(),
						() => TP(),
						() => VP(),
						() => UP(),
						() => Bv(yi.url.origin),
						() => Jv(),
						() => QI(),
						() => r4(),
						() => a4(),
					]
				),
				Ai(
					2,
					ne,
					() => ia,
					() => ({ duration: 300 })
				),
				$(K, ne);
		};
		Oe(T, (K) => {
			p() && K(s);
		});
	}
	k(z);
	var B = j(z, 2),
		O = A(B),
		X = A(O, !0);
	k(O),
		k(B),
		k(M),
		Ni(M, () => (K) => {
			Wr(() => {
				p() ? K.show() : K.close();
			});
		}),
		We((K) => de(X, K), [() => Ss()]),
		di("close", M, () => p(!1)),
		$(m, M),
		Dr();
}
function F6(m) {
	return typeof m == "function";
}
function Lh(m) {
	return m !== null && typeof m == "object";
}
const O6 = ["string", "number", "bigint", "boolean"];
function nm(m) {
	return m == null || O6.includes(typeof m)
		? !0
		: Array.isArray(m)
		? m.every((a) => nm(a))
		: typeof m == "object"
		? Object.getPrototypeOf(m) === Object.prototype
		: !1;
}
const Vu = Symbol("box"),
	Hm = Symbol("is-writable");
function N6(m) {
	return Lh(m) && Vu in m;
}
function j6(m) {
	return br.isBox(m) && Hm in m;
}
function br(m) {
	let a = st(bi(m));
	return {
		[Vu]: !0,
		[Hm]: !0,
		get current() {
			return x(a);
		},
		set current(p) {
			se(a, p, !0);
		},
	};
}
function V6(m, a) {
	const p = ft(m);
	return a
		? {
				[Vu]: !0,
				[Hm]: !0,
				get current() {
					return x(p);
				},
				set current(y) {
					a(y);
				},
		  }
		: {
				[Vu]: !0,
				get current() {
					return m();
				},
		  };
}
function q6(m) {
	return br.isBox(m) ? m : F6(m) ? br.with(m) : br(m);
}
function Z6(m) {
	return Object.entries(m).reduce(
		(a, [p, y]) =>
			br.isBox(y)
				? (br.isWritableBox(y)
						? Object.defineProperty(a, p, {
								get() {
									return y.current;
								},
								set(M) {
									y.current = M;
								},
						  })
						: Object.defineProperty(a, p, {
								get() {
									return y.current;
								},
						  }),
				  a)
				: Object.assign(a, { [p]: y }),
		{}
	);
}
function U6(m) {
	return br.isWritableBox(m)
		? {
				[Vu]: !0,
				get current() {
					return m.current;
				},
		  }
		: m;
}
br.from = q6;
br.with = V6;
br.flatten = Z6;
br.readonly = U6;
br.isBox = N6;
br.isWritableBox = j6;
function $6(...m) {
	return function (a) {
		var p;
		for (const y of m)
			if (y) {
				if (a.defaultPrevented) return;
				typeof y == "function"
					? y.call(this, a)
					: (p = y.current) == null || p.call(this, a);
			}
	};
}
var hc = {},
	Rf,
	tv;
function G6() {
	if (tv) return Rf;
	tv = 1;
	var m = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
		a = /\n/g,
		p = /^\s*/,
		y = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
		M = /^:\s*/,
		z = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
		T = /^[;\s]*/,
		s = /^\s+|\s+$/g,
		B = `
`,
		O = "/",
		X = "*",
		K = "",
		ne = "comment",
		H = "declaration";
	Rf = function (ge, Ie) {
		if (typeof ge != "string")
			throw new TypeError("First argument must be a string");
		if (!ge) return [];
		Ie = Ie || {};
		var Ae = 1,
			De = 1;
		function Ee(Ue) {
			var ke = Ue.match(a);
			ke && (Ae += ke.length);
			var vt = Ue.lastIndexOf(B);
			De = ~vt ? Ue.length - vt : De + Ue.length;
		}
		function Fe() {
			var Ue = { line: Ae, column: De };
			return function (ke) {
				return (ke.position = new $e(Ue)), Ze(), ke;
			};
		}
		function $e(Ue) {
			(this.start = Ue),
				(this.end = { line: Ae, column: De }),
				(this.source = Ie.source);
		}
		$e.prototype.content = ge;
		function Je(Ue) {
			var ke = new Error(Ie.source + ":" + Ae + ":" + De + ": " + Ue);
			if (
				((ke.reason = Ue),
				(ke.filename = Ie.source),
				(ke.line = Ae),
				(ke.column = De),
				(ke.source = ge),
				!Ie.silent)
			)
				throw ke;
		}
		function qe(Ue) {
			var ke = Ue.exec(ge);
			if (ke) {
				var vt = ke[0];
				return Ee(vt), (ge = ge.slice(vt.length)), ke;
			}
		}
		function Ze() {
			qe(p);
		}
		function Qe(Ue) {
			var ke;
			for (Ue = Ue || []; (ke = Le()); ) ke !== !1 && Ue.push(ke);
			return Ue;
		}
		function Le() {
			var Ue = Fe();
			if (!(O != ge.charAt(0) || X != ge.charAt(1))) {
				for (
					var ke = 2;
					K != ge.charAt(ke) && (X != ge.charAt(ke) || O != ge.charAt(ke + 1));

				)
					++ke;
				if (((ke += 2), K === ge.charAt(ke - 1)))
					return Je("End of comment missing");
				var vt = ge.slice(2, ke - 2);
				return (
					(De += 2),
					Ee(vt),
					(ge = ge.slice(ke)),
					(De += 2),
					Ue({ type: ne, comment: vt })
				);
			}
		}
		function et() {
			var Ue = Fe(),
				ke = qe(y);
			if (ke) {
				if ((Le(), !qe(M))) return Je("property missing ':'");
				var vt = qe(z),
					ee = Ue({
						type: H,
						property: fe(ke[0].replace(m, K)),
						value: vt ? fe(vt[0].replace(m, K)) : K,
					});
				return qe(T), ee;
			}
		}
		function nt() {
			var Ue = [];
			Qe(Ue);
			for (var ke; (ke = et()); ) ke !== !1 && (Ue.push(ke), Qe(Ue));
			return Ue;
		}
		return Ze(), nt();
	};
	function fe(ge) {
		return ge ? ge.replace(s, K) : K;
	}
	return Rf;
}
var rv;
function H6() {
	if (rv) return hc;
	rv = 1;
	var m =
		(hc && hc.__importDefault) ||
		function (y) {
			return y && y.__esModule ? y : { default: y };
		};
	Object.defineProperty(hc, "__esModule", { value: !0 }), (hc.default = p);
	var a = m(G6());
	function p(y, M) {
		var z = null;
		if (!y || typeof y != "string") return z;
		var T = (0, a.default)(y),
			s = typeof M == "function";
		return (
			T.forEach(function (B) {
				if (B.type === "declaration") {
					var O = B.property,
						X = B.value;
					s ? M(O, X, B) : X && ((z = z || {}), (z[O] = X));
				}
			}),
			z
		);
	}
	return hc;
}
var W6 = H6();
const nv = Zm(W6),
	X6 = nv.default || nv,
	Y6 = /\d/,
	K6 = ["-", "_", "/", "."];
function J6(m = "") {
	if (!Y6.test(m)) return m !== m.toLowerCase();
}
function Q6(m) {
	const a = [];
	let p = "",
		y,
		M;
	for (const z of m) {
		const T = K6.includes(z);
		if (T === !0) {
			a.push(p), (p = ""), (y = void 0);
			continue;
		}
		const s = J6(z);
		if (M === !1) {
			if (y === !1 && s === !0) {
				a.push(p), (p = z), (y = s);
				continue;
			}
			if (y === !0 && s === !1 && p.length > 1) {
				const B = p.at(-1);
				a.push(p.slice(0, Math.max(0, p.length - 1))), (p = B + z), (y = s);
				continue;
			}
		}
		(p += z), (y = s), (M = T);
	}
	return a.push(p), a;
}
function s0(m) {
	return m
		? Q6(m)
				.map((a) => tk(a))
				.join("")
		: "";
}
function ek(m) {
	return rk(s0(m || ""));
}
function tk(m) {
	return m ? m[0].toUpperCase() + m.slice(1) : "";
}
function rk(m) {
	return m ? m[0].toLowerCase() + m.slice(1) : "";
}
function Zd(m) {
	if (!m) return {};
	const a = {};
	function p(y, M) {
		if (
			y.startsWith("-moz-") ||
			y.startsWith("-webkit-") ||
			y.startsWith("-ms-") ||
			y.startsWith("-o-")
		) {
			a[s0(y)] = M;
			return;
		}
		if (y.startsWith("--")) {
			a[y] = M;
			return;
		}
		a[ek(y)] = M;
	}
	return X6(m, p), a;
}
function nk(...m) {
	return (...a) => {
		for (const p of m) typeof p == "function" && p(...a);
	};
}
function ik(m, a) {
	const p = RegExp(m, "g");
	return (y) => {
		if (typeof y != "string")
			throw new TypeError(
				`expected an argument of type string, but got ${typeof y}`
			);
		return y.match(p) ? y.replace(p, a) : y;
	};
}
const ak = ik(/[A-Z]/, (m) => `-${m.toLowerCase()}`);
function ok(m) {
	if (!m || typeof m != "object" || Array.isArray(m))
		throw new TypeError(
			`expected an argument of type object, but got ${typeof m}`
		);
	return Object.keys(m).map((a) => `${ak(a)}: ${m[a]};`).join(`
`);
}
function l0(m = {}) {
	return ok(m).replace(
		`
`,
		" "
	);
}
const c0 = {
	position: "absolute",
	width: "1px",
	height: "1px",
	padding: "0",
	margin: "-1px",
	overflow: "hidden",
	clip: "rect(0, 0, 0, 0)",
	whiteSpace: "nowrap",
	borderWidth: "0",
	transform: "translateX(-100%)",
};
l0(c0);
const sk = [
		"onabort",
		"onanimationcancel",
		"onanimationend",
		"onanimationiteration",
		"onanimationstart",
		"onauxclick",
		"onbeforeinput",
		"onbeforetoggle",
		"onblur",
		"oncancel",
		"oncanplay",
		"oncanplaythrough",
		"onchange",
		"onclick",
		"onclose",
		"oncompositionend",
		"oncompositionstart",
		"oncompositionupdate",
		"oncontextlost",
		"oncontextmenu",
		"oncontextrestored",
		"oncopy",
		"oncuechange",
		"oncut",
		"ondblclick",
		"ondrag",
		"ondragend",
		"ondragenter",
		"ondragleave",
		"ondragover",
		"ondragstart",
		"ondrop",
		"ondurationchange",
		"onemptied",
		"onended",
		"onerror",
		"onfocus",
		"onfocusin",
		"onfocusout",
		"onformdata",
		"ongotpointercapture",
		"oninput",
		"oninvalid",
		"onkeydown",
		"onkeypress",
		"onkeyup",
		"onload",
		"onloadeddata",
		"onloadedmetadata",
		"onloadstart",
		"onlostpointercapture",
		"onmousedown",
		"onmouseenter",
		"onmouseleave",
		"onmousemove",
		"onmouseout",
		"onmouseover",
		"onmouseup",
		"onpaste",
		"onpause",
		"onplay",
		"onplaying",
		"onpointercancel",
		"onpointerdown",
		"onpointerenter",
		"onpointerleave",
		"onpointermove",
		"onpointerout",
		"onpointerover",
		"onpointerup",
		"onprogress",
		"onratechange",
		"onreset",
		"onresize",
		"onscroll",
		"onscrollend",
		"onsecuritypolicyviolation",
		"onseeked",
		"onseeking",
		"onselect",
		"onselectionchange",
		"onselectstart",
		"onslotchange",
		"onstalled",
		"onsubmit",
		"onsuspend",
		"ontimeupdate",
		"ontoggle",
		"ontouchcancel",
		"ontouchend",
		"ontouchmove",
		"ontouchstart",
		"ontransitioncancel",
		"ontransitionend",
		"ontransitionrun",
		"ontransitionstart",
		"onvolumechange",
		"onwaiting",
		"onwebkitanimationend",
		"onwebkitanimationiteration",
		"onwebkitanimationstart",
		"onwebkittransitionend",
		"onwheel",
	],
	lk = new Set(sk);
function ck(m) {
	return lk.has(m);
}
function Va(...m) {
	const a = { ...m[0] };
	for (let p = 1; p < m.length; p++) {
		const y = m[p];
		if (y) {
			for (const M of Object.keys(y)) {
				const z = a[M],
					T = y[M],
					s = typeof z == "function",
					B = typeof T == "function";
				if (s && ck(M)) {
					const O = z,
						X = T;
					a[M] = $6(O, X);
				} else if (s && B) a[M] = nk(z, T);
				else if (M === "class") {
					const O = nm(z),
						X = nm(T);
					O && X ? (a[M] = Ou(z, T)) : O ? (a[M] = Ou(z)) : X && (a[M] = Ou(T));
				} else if (M === "style") {
					const O = typeof z == "object",
						X = typeof T == "object",
						K = typeof z == "string",
						ne = typeof T == "string";
					if (O && X) a[M] = { ...z, ...T };
					else if (O && ne) {
						const H = Zd(T);
						a[M] = { ...z, ...H };
					} else if (K && X) {
						const H = Zd(z);
						a[M] = { ...H, ...T };
					} else if (K && ne) {
						const H = Zd(z),
							fe = Zd(T);
						a[M] = { ...H, ...fe };
					} else
						O ? (a[M] = z) : X ? (a[M] = T) : K ? (a[M] = z) : ne && (a[M] = T);
				} else a[M] = T !== void 0 ? T : z;
			}
			for (const M of Object.getOwnPropertySymbols(y)) {
				const z = a[M],
					T = y[M];
				a[M] = T !== void 0 ? T : z;
			}
		}
	}
	return (
		typeof a.style == "object" &&
			(a.style = l0(a.style).replaceAll(
				`
`,
				" "
			)),
		a.hidden !== !0 && ((a.hidden = void 0), delete a.hidden),
		a.disabled !== !0 && ((a.disabled = void 0), delete a.disabled),
		a
	);
}
const uk = typeof window < "u" ? window : void 0;
function hk(m) {
	let a = m.activeElement;
	for (; a != null && a.shadowRoot; ) {
		const p = a.shadowRoot.activeElement;
		if (p === a) break;
		a = p;
	}
	return a;
}
var wc, Yu;
class dk {
	constructor(a = {}) {
		Ar(this, wc);
		Ar(this, Yu);
		const { window: p = uk, document: y = p == null ? void 0 : p.document } = a;
		p !== void 0 &&
			(na(this, wc, y),
			na(
				this,
				Yu,
				Ev((M) => {
					const z = Nu(p, "focusin", M),
						T = Nu(p, "focusout", M);
					return () => {
						z(), T();
					};
				})
			));
	}
	get current() {
		var a;
		return (
			(a = ot(this, Yu)) == null || a.call(this),
			ot(this, wc) ? hk(ot(this, wc)) : null
		);
	}
}
(wc = new WeakMap()), (Yu = new WeakMap());
new dk();
var Ku, Ho;
class Wm {
	constructor(a) {
		Ar(this, Ku);
		Ar(this, Ho);
		na(this, Ku, a), na(this, Ho, Symbol(a));
	}
	get key() {
		return ot(this, Ho);
	}
	exists() {
		return ex(ot(this, Ho));
	}
	get() {
		const a = Gg(ot(this, Ho));
		if (a === void 0) throw new Error(`Context "${ot(this, Ku)}" not found`);
		return a;
	}
	getOr(a) {
		const p = Gg(ot(this, Ho));
		return p === void 0 ? a : p;
	}
	set(a) {
		return tx(ot(this, Ho), a);
	}
}
(Ku = new WeakMap()), (Ho = new WeakMap());
function pk(m, a) {
	switch (m) {
		case "post":
			Wr(a);
			break;
		case "pre":
			Mm(a);
			break;
	}
}
function u0(m, a, p, y = {}) {
	const { lazy: M = !1 } = y;
	let z = !M,
		T = Array.isArray(m) ? [] : void 0;
	pk(a, () => {
		const s = Array.isArray(m) ? m.map((O) => O()) : m();
		if (!z) {
			(z = !0), (T = s);
			return;
		}
		const B = ul(() => p(s, T));
		return (T = s), B;
	});
}
function Ps(m, a, p) {
	u0(m, "post", a, p);
}
function fk(m, a, p) {
	u0(m, "pre", a, p);
}
Ps.pre = fk;
var Tc;
class mk {
	constructor(a, p) {
		Ar(this, Tc, st(void 0));
		p !== void 0 && se(ot(this, Tc), p, !0),
			Ps(
				() => a(),
				(y, M) => {
					se(ot(this, Tc), M, !0);
				}
			);
	}
	get current() {
		return x(ot(this, Tc));
	}
}
Tc = new WeakMap();
function _k(m, a) {
	return setTimeout(a, m);
}
function dc(m) {
	Iv().then(m);
}
const gk = 1,
	vk = 9,
	yk = 11;
function xk(m) {
	return Lh(m) && m.nodeType === gk && typeof m.nodeName == "string";
}
function h0(m) {
	return Lh(m) && m.nodeType === vk;
}
function bk(m) {
	var a;
	return (
		Lh(m) &&
		((a = m.constructor) == null ? void 0 : a.name) === "VisualViewport"
	);
}
function wk(m) {
	return Lh(m) && m.nodeType !== void 0;
}
function Tk(m) {
	return wk(m) && m.nodeType === yk && "host" in m;
}
function Ck(m) {
	return h0(m)
		? m
		: bk(m)
		? m.document
		: (m == null ? void 0 : m.ownerDocument) ?? document;
}
function d0(m) {
	var a;
	return Tk(m)
		? d0(m.host)
		: h0(m)
		? m.defaultView ?? window
		: xk(m)
		? ((a = m.ownerDocument) == null ? void 0 : a.defaultView) ?? window
		: window;
}
function Sk(m) {
	let a = m.activeElement;
	for (; a != null && a.shadowRoot; ) {
		const p = a.shadowRoot.activeElement;
		if (p === a) break;
		a = p;
	}
	return a;
}
var Ju;
class Pk {
	constructor(a) {
		xr(this, "element");
		Ar(
			this,
			Ju,
			ft(() =>
				this.element.current
					? this.element.current.getRootNode() ?? document
					: document
			)
		);
		xr(this, "getDocument", () => Ck(this.root));
		xr(this, "getWindow", () => this.getDocument().defaultView ?? window);
		xr(this, "getActiveElement", () => Sk(this.root));
		xr(this, "isActiveElement", (a) => a === this.getActiveElement());
		xr(this, "querySelector", (a) =>
			this.root ? this.root.querySelector(a) : null
		);
		xr(this, "querySelectorAll", (a) =>
			this.root ? this.root.querySelectorAll(a) : []
		);
		xr(this, "setTimeout", (a, p) => this.getWindow().setTimeout(a, p));
		xr(this, "clearTimeout", (a) => this.getWindow().clearTimeout(a));
		typeof a == "function" ? (this.element = br.with(a)) : (this.element = a);
	}
	get root() {
		return x(ot(this, Ju));
	}
	set root(a) {
		se(ot(this, Ju), a);
	}
	getElementById(a) {
		return this.root.getElementById(a);
	}
}
Ju = new WeakMap();
function Xa(m, a) {
	return {
		[Wx()]: (p) =>
			br.isBox(m)
				? ((m.current = p),
				  ul(() => (a == null ? void 0 : a(p))),
				  () => {
						("isConnected" in p && p.isConnected) ||
							((m.current = null), a == null || a(null));
				  })
				: (m(p),
				  ul(() => (a == null ? void 0 : a(p))),
				  () => {
						("isConnected" in p && p.isConnected) ||
							(m(null), a == null || a(null));
				  }),
	};
}
function Ik(m) {
	return m ? "true" : "false";
}
function Mk(m) {
	return m ? "true" : "false";
}
function kk(m) {
	return m ? "" : void 0;
}
function Ak(m) {
	return m ? "true" : "false";
}
function Ek(m) {
	return m ? "" : void 0;
}
function zk(m) {
	return m ? !0 : void 0;
}
var Cc, Qu;
class Lk {
	constructor(a) {
		Ar(this, Cc);
		Ar(this, Qu);
		xr(this, "attrs");
		na(this, Cc, a.getVariant ? a.getVariant() : null),
			na(
				this,
				Qu,
				ot(this, Cc) ? `data-${ot(this, Cc)}-` : `data-${a.component}-`
			),
			(this.getAttr = this.getAttr.bind(this)),
			(this.selector = this.selector.bind(this)),
			(this.attrs = Object.fromEntries(
				a.parts.map((p) => [p, this.getAttr(p)])
			));
	}
	getAttr(a, p) {
		return p ? `data-${p}-${a}` : `${ot(this, Qu)}${a}`;
	}
	selector(a, p) {
		return `[${this.getAttr(a, p)}]`;
	}
}
(Cc = new WeakMap()), (Qu = new WeakMap());
function p0(m) {
	const a = new Lk(m);
	return { ...a.attrs, selector: a.selector, getAttr: a.getAttr };
}
const Dk = "ArrowDown",
	Rk = "ArrowLeft",
	Bk = "ArrowRight",
	Fk = "ArrowUp",
	Ok = "End",
	Nk = "Enter",
	jk = "Home",
	Vk = "p",
	qk = "n",
	Zk = "j",
	Uk = "k",
	$k = "h",
	Gk = "l";
function qu() {}
function Ya(m, a) {
	return `bits-${m}`;
}
function Hk(m) {
	if (!m) return null;
	for (const a of m.childNodes) if (a.nodeType !== Node.COMMENT_NODE) return a;
	return null;
}
globalThis.bitsIdCounter ?? (globalThis.bitsIdCounter = { current: 0 });
function Wk(m = "bits") {
	return (
		globalThis.bitsIdCounter.current++,
		`${m}-${globalThis.bitsIdCounter.current}`
	);
}
function Xk(m, a) {
	let p = m.nextElementSibling;
	for (; p; ) {
		if (p.matches(a)) return p;
		p = p.nextElementSibling;
	}
}
function Yk(m, a) {
	let p = m.previousElementSibling;
	for (; p; ) {
		if (p.matches(a)) return p;
		p = p.previousElementSibling;
	}
}
function f0(m) {
	if (typeof CSS < "u" && typeof CSS.escape == "function") return CSS.escape(m);
	const a = m.length;
	let p = -1,
		y,
		M = "";
	const z = m.charCodeAt(0);
	if (a === 1 && z === 45) return "\\" + m;
	for (; ++p < a; ) {
		if (((y = m.charCodeAt(p)), y === 0)) {
			M += "�";
			continue;
		}
		if (
			(y >= 1 && y <= 31) ||
			y === 127 ||
			(p === 0 && y >= 48 && y <= 57) ||
			(p === 1 && y >= 48 && y <= 57 && z === 45)
		) {
			M += "\\" + y.toString(16) + " ";
			continue;
		}
		if (
			y >= 128 ||
			y === 45 ||
			y === 95 ||
			(y >= 48 && y <= 57) ||
			(y >= 65 && y <= 90) ||
			(y >= 97 && y <= 122)
		) {
			M += m.charAt(p);
			continue;
		}
		M += "\\" + m.charAt(p);
	}
	return M;
}
const sl = "data-value",
	wa = p0({
		component: "command",
		parts: [
			"root",
			"list",
			"input",
			"separator",
			"loading",
			"empty",
			"group",
			"group-items",
			"group-heading",
			"item",
			"viewport",
			"input-label",
		],
	}),
	pc = wa.selector("group"),
	Bf = wa.selector("group-items"),
	iv = wa.selector("group-heading"),
	m0 = wa.selector("item"),
	Ff = `${wa.selector("item")}:not([aria-disabled="true"])`,
	ml = new Wm("Command.Root"),
	Kk = new Wm("Command.List"),
	Zu = new Wm("Command.Group"),
	av = {
		search: "",
		value: "",
		filtered: { count: 0, items: new Map(), groups: new Set() },
	};
var Sc,
	eh,
	th,
	rh,
	nh,
	ih,
	ah,
	oh,
	fr,
	_0,
	Kd,
	am,
	Jd,
	Qd,
	ep,
	ws,
	g0,
	v0,
	om,
	Du,
	sm,
	lm,
	y0,
	Ru,
	cm,
	um,
	x0,
	Bu,
	Fu,
	sh;
const e_ = class e_ {
	constructor(a) {
		Ar(this, fr);
		xr(this, "opts");
		xr(this, "attachment");
		Ar(this, Sc, !1);
		Ar(this, eh, !0);
		xr(this, "sortAfterTick", !1);
		xr(this, "sortAndFilterAfterTick", !1);
		xr(this, "allItems", new Set());
		xr(this, "allGroups", new Map());
		xr(this, "allIds", new Map());
		Ar(this, th, st(0));
		Ar(this, rh, st(null));
		Ar(this, nh, st(null));
		Ar(this, ih, st(null));
		Ar(this, ah, st(av));
		Ar(this, oh, st(bi(av)));
		Ar(
			this,
			sh,
			ft(() => ({
				id: this.opts.id.current,
				role: "application",
				[wa.root]: "",
				tabindex: -1,
				onkeydown: this.onkeydown,
				...this.attachment,
			}))
		);
		(this.opts = a), (this.attachment = Xa(this.opts.ref));
		const p = { ...this._commandState, value: this.opts.value.current ?? "" };
		(this._commandState = p),
			(this.commandState = p),
			(this.onkeydown = this.onkeydown.bind(this));
	}
	static create(a) {
		return ml.set(new e_(a));
	}
	get key() {
		return x(ot(this, th));
	}
	set key(a) {
		se(ot(this, th), a, !0);
	}
	get viewportNode() {
		return x(ot(this, rh));
	}
	set viewportNode(a) {
		se(ot(this, rh), a, !0);
	}
	get inputNode() {
		return x(ot(this, nh));
	}
	set inputNode(a) {
		se(ot(this, nh), a, !0);
	}
	get labelNode() {
		return x(ot(this, ih));
	}
	set labelNode(a) {
		se(ot(this, ih), a, !0);
	}
	get commandState() {
		return x(ot(this, ah));
	}
	set commandState(a) {
		se(ot(this, ah), a);
	}
	get _commandState() {
		return x(ot(this, oh));
	}
	set _commandState(a) {
		se(ot(this, oh), a, !0);
	}
	setState(a, p, y) {
		Object.is(this._commandState[a], p) ||
			((this._commandState[a] = p),
			a === "search"
				? (jr(this, fr, ep).call(this), jr(this, fr, Jd).call(this))
				: a === "value" && (y || jr(this, fr, g0).call(this)),
			jr(this, fr, Kd).call(this));
	}
	setValue(a, p) {
		a !== this.opts.value.current &&
			a === "" &&
			dc(() => {
				this.key++;
			}),
			this.setState("value", a, p),
			(this.opts.value.current = a);
	}
	getValidItems() {
		const a = this.opts.ref.current;
		return a ? Array.from(a.querySelectorAll(Ff)).filter((y) => !!y) : [];
	}
	getVisibleItems() {
		const a = this.opts.ref.current;
		return a ? Array.from(a.querySelectorAll(m0)).filter((y) => !!y) : [];
	}
	get itemsGrid() {
		var s, B, O, X;
		if (!this.isGrid) return [];
		const a = this.opts.columns.current ?? 1,
			p = this.getVisibleItems(),
			y = [[]];
		let M = (s = p[0]) == null ? void 0 : s.getAttribute("data-group"),
			z = 0,
			T = 0;
		for (let K = 0; K < p.length; K++) {
			const ne = p[K],
				H = ne == null ? void 0 : ne.getAttribute("data-group");
			M !== H
				? ((M = H),
				  (z = 1),
				  T++,
				  y.push([{ index: K, firstRowOfGroup: !0, ref: ne }]))
				: (z++,
				  z > a && (T++, (z = 1), y.push([])),
				  (X = y[T]) == null ||
						X.push({
							index: K,
							firstRowOfGroup:
								((O = (B = y[T]) == null ? void 0 : B[0]) == null
									? void 0
									: O.firstRowOfGroup) ?? K === 0,
							ref: ne,
						}));
		}
		return y;
	}
	updateSelectedToIndex(a) {
		const p = this.getValidItems()[a];
		p && this.setValue(p.getAttribute(sl) ?? "");
	}
	updateSelectedByItem(a) {
		const p = jr(this, fr, ws).call(this),
			y = this.getValidItems(),
			M = y.findIndex((T) => T === p);
		let z = y[M + a];
		this.opts.loop.current &&
			(z = M + a < 0 ? y[y.length - 1] : M + a === y.length ? y[0] : y[M + a]),
			z && this.setValue(z.getAttribute(sl) ?? "");
	}
	updateSelectedByGroup(a) {
		const p = jr(this, fr, ws).call(this);
		let y = p == null ? void 0 : p.closest(pc),
			M;
		for (; y && !M; )
			(y = a > 0 ? Xk(y, pc) : Yk(y, pc)),
				(M = y == null ? void 0 : y.querySelector(Ff));
		M ? this.setValue(M.getAttribute(sl) ?? "") : this.updateSelectedByItem(a);
	}
	registerValue(a, p) {
		var y;
		return (
			(a && a === ((y = this.allIds.get(a)) == null ? void 0 : y.value)) ||
				this.allIds.set(a, { value: a, keywords: p }),
			this._commandState.filtered.items.set(
				a,
				jr(this, fr, am).call(this, a, p)
			),
			this.sortAfterTick ||
				((this.sortAfterTick = !0),
				dc(() => {
					jr(this, fr, Jd).call(this), (this.sortAfterTick = !1);
				})),
			() => {
				this.allIds.delete(a);
			}
		);
	}
	registerItem(a, p) {
		return (
			this.allItems.add(a),
			p &&
				(this.allGroups.has(p)
					? this.allGroups.get(p).add(a)
					: this.allGroups.set(p, new Set([a]))),
			this.sortAndFilterAfterTick ||
				((this.sortAndFilterAfterTick = !0),
				dc(() => {
					jr(this, fr, ep).call(this),
						jr(this, fr, Jd).call(this),
						(this.sortAndFilterAfterTick = !1);
				})),
			jr(this, fr, Kd).call(this),
			() => {
				const y = jr(this, fr, ws).call(this);
				this.allIds.delete(a),
					this.allItems.delete(a),
					this.commandState.filtered.items.delete(a),
					jr(this, fr, ep).call(this),
					(y == null ? void 0 : y.getAttribute("id")) === a &&
						jr(this, fr, Qd).call(this),
					jr(this, fr, Kd).call(this);
			}
		);
	}
	registerGroup(a) {
		return (
			this.allGroups.has(a) || this.allGroups.set(a, new Set()),
			() => {
				this.allIds.delete(a), this.allGroups.delete(a);
			}
		);
	}
	get isGrid() {
		return this.opts.columns.current !== null;
	}
	onkeydown(a) {
		const p = this.opts.vimBindings.current && a.ctrlKey;
		switch (a.key) {
			case qk:
			case Zk: {
				p &&
					(this.isGrid
						? jr(this, fr, sm).call(this, a)
						: jr(this, fr, Du).call(this, a));
				break;
			}
			case Gk: {
				p && this.isGrid && jr(this, fr, Du).call(this, a);
				break;
			}
			case Dk:
				this.isGrid
					? jr(this, fr, sm).call(this, a)
					: jr(this, fr, Du).call(this, a);
				break;
			case Bk:
				if (!this.isGrid) break;
				jr(this, fr, Du).call(this, a);
				break;
			case Vk:
			case Uk: {
				p &&
					(this.isGrid
						? jr(this, fr, um).call(this, a)
						: jr(this, fr, Fu).call(this, a));
				break;
			}
			case $k: {
				p && this.isGrid && jr(this, fr, Fu).call(this, a);
				break;
			}
			case Fk:
				this.isGrid
					? jr(this, fr, um).call(this, a)
					: jr(this, fr, Fu).call(this, a);
				break;
			case Rk:
				if (!this.isGrid) break;
				jr(this, fr, Fu).call(this, a);
				break;
			case jk:
				a.preventDefault(), this.updateSelectedToIndex(0);
				break;
			case Ok:
				a.preventDefault(), jr(this, fr, om).call(this);
				break;
			case Nk:
				if (!a.isComposing && a.keyCode !== 229) {
					a.preventDefault();
					const y = jr(this, fr, ws).call(this);
					y && (y == null || y.click());
				}
		}
	}
	get props() {
		return x(ot(this, sh));
	}
	set props(a) {
		se(ot(this, sh), a);
	}
};
(Sc = new WeakMap()),
	(eh = new WeakMap()),
	(th = new WeakMap()),
	(rh = new WeakMap()),
	(nh = new WeakMap()),
	(ih = new WeakMap()),
	(ah = new WeakMap()),
	(oh = new WeakMap()),
	(fr = new WeakSet()),
	(_0 = function () {
		return Hx(this._commandState);
	}),
	(Kd = function () {
		ot(this, Sc) ||
			(na(this, Sc, !0),
			dc(() => {
				var y, M;
				na(this, Sc, !1);
				const a = jr(this, fr, _0).call(this);
				!Object.is(this.commandState, a) &&
					((this.commandState = a),
					(M = (y = this.opts.onStateChange) == null ? void 0 : y.current) ==
						null || M.call(y, a));
			}));
	}),
	(am = function (a, p) {
		const y = this.opts.filter.current ?? T0;
		return a ? y(a, this._commandState.search, p) : 0;
	}),
	(Jd = function () {
		var T;
		if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
			jr(this, fr, Qd).call(this);
			return;
		}
		const a = this._commandState.filtered.items,
			p = [];
		for (const s of this._commandState.filtered.groups) {
			const B = this.allGroups.get(s);
			let O = 0;
			if (!B) {
				p.push([s, O]);
				continue;
			}
			for (const X of B) {
				const K = a.get(X);
				O = Math.max(K ?? 0, O);
			}
			p.push([s, O]);
		}
		const y = this.viewportNode,
			M = this.getValidItems().sort((s, B) => {
				const O = s.getAttribute("data-value"),
					X = B.getAttribute("data-value"),
					K = a.get(O) ?? 0;
				return (a.get(X) ?? 0) - K;
			});
		for (const s of M) {
			const B = s.closest(Bf);
			if (B) {
				const O = s.parentElement === B ? s : s.closest(`${Bf} > *`);
				O && B.appendChild(O);
			} else {
				const O = s.parentElement === y ? s : s.closest(`${Bf} > *`);
				O && (y == null || y.appendChild(O));
			}
		}
		const z = p.sort((s, B) => B[1] - s[1]);
		for (const s of z) {
			const B =
				y == null ? void 0 : y.querySelector(`${pc}[${sl}="${f0(s[0])}"]`);
			(T = B == null ? void 0 : B.parentElement) == null || T.appendChild(B);
		}
		jr(this, fr, Qd).call(this);
	}),
	(Qd = function () {
		dc(() => {
			const a = this.getValidItems().find(
					(M) => M.getAttribute("aria-disabled") !== "true"
				),
				p = a == null ? void 0 : a.getAttribute(sl),
				y = ot(this, eh) && this.opts.disableInitialScroll.current;
			this.setValue(p ?? "", y), na(this, eh, !1);
		});
	}),
	(ep = function () {
		var p, y;
		if (!this._commandState.search || this.opts.shouldFilter.current === !1) {
			this._commandState.filtered.count = this.allItems.size;
			return;
		}
		this._commandState.filtered.groups = new Set();
		let a = 0;
		for (const M of this.allItems) {
			const z = ((p = this.allIds.get(M)) == null ? void 0 : p.value) ?? "",
				T = ((y = this.allIds.get(M)) == null ? void 0 : y.keywords) ?? [],
				s = jr(this, fr, am).call(this, z, T);
			this._commandState.filtered.items.set(M, s), s > 0 && a++;
		}
		for (const [M, z] of this.allGroups)
			for (const T of z) {
				const s = this._commandState.filtered.items.get(T);
				if (s && s > 0) {
					this._commandState.filtered.groups.add(M);
					break;
				}
			}
		this._commandState.filtered.count = a;
	}),
	(ws = function () {
		const a = this.opts.ref.current;
		if (!a) return;
		const p = a.querySelector(`${Ff}[data-selected]`);
		if (p) return p;
	}),
	(g0 = function () {
		dc(() => {
			var y, M, z, T, s;
			const a = jr(this, fr, ws).call(this);
			if (!a) return;
			const p = (y = a.parentElement) == null ? void 0 : y.parentElement;
			if (p) {
				if (this.isGrid) {
					const B = jr(this, fr, v0).call(this, a);
					if ((a.scrollIntoView({ block: "nearest" }), B)) {
						const O =
							(M = a == null ? void 0 : a.closest(pc)) == null
								? void 0
								: M.querySelector(iv);
						O == null || O.scrollIntoView({ block: "nearest" });
						return;
					}
				} else {
					const B = Hk(p);
					if (
						B &&
						((z = B.dataset) == null ? void 0 : z.value) ===
							((T = a.dataset) == null ? void 0 : T.value)
					) {
						const O =
							(s = a == null ? void 0 : a.closest(pc)) == null
								? void 0
								: s.querySelector(iv);
						O == null || O.scrollIntoView({ block: "nearest" });
						return;
					}
				}
				a.scrollIntoView({ block: "nearest" });
			}
		});
	}),
	(v0 = function (a) {
		const p = this.itemsGrid;
		if (p.length === 0) return !1;
		for (let y = 0; y < p.length; y++) {
			const M = p[y];
			if (M !== void 0)
				for (let z = 0; z < M.length; z++) {
					const T = M[z];
					if (!(T === void 0 || T.ref !== a)) return T.firstRowOfGroup;
				}
		}
		return !1;
	}),
	(om = function () {
		return this.updateSelectedToIndex(this.getValidItems().length - 1);
	}),
	(Du = function (a) {
		a.preventDefault(),
			a.metaKey
				? jr(this, fr, om).call(this)
				: a.altKey
				? this.updateSelectedByGroup(1)
				: this.updateSelectedByItem(1);
	}),
	(sm = function (a) {
		this.opts.columns.current !== null &&
			(a.preventDefault(),
			a.metaKey
				? this.updateSelectedByGroup(1)
				: this.updateSelectedByItem(jr(this, fr, y0).call(this, a)));
	}),
	(lm = function (a, p) {
		if (p.length === 0) return null;
		for (let y = 0; y < p.length; y++) {
			const M = p[y];
			if (M !== void 0)
				for (let z = 0; z < M.length; z++) {
					const T = M[z];
					if (!(T === void 0 || T.ref !== a))
						return { columnIndex: z, rowIndex: y };
				}
		}
		return null;
	}),
	(y0 = function (a) {
		const p = this.itemsGrid,
			y = jr(this, fr, ws).call(this);
		if (!y) return 0;
		const M = jr(this, fr, lm).call(this, y, p);
		if (!M) return 0;
		let z = null;
		const T = a.altKey ? 1 : 0;
		if (a.altKey && M.rowIndex === p.length - 2 && !this.opts.loop.current)
			z = jr(this, fr, Ru).call(this, {
				start: p.length - 1,
				end: p.length,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			});
		else if (M.rowIndex === p.length - 1) {
			if (!this.opts.loop.current) return 0;
			z = jr(this, fr, Ru).call(this, {
				start: 0 + T,
				end: M.rowIndex,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			});
		} else
			(z = jr(this, fr, Ru).call(this, {
				start: M.rowIndex + 1 + T,
				end: p.length,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			})),
				z === null &&
					this.opts.loop.current &&
					(z = jr(this, fr, Ru).call(this, {
						start: 0,
						end: M.rowIndex,
						expectedColumnIndex: M.columnIndex,
						grid: p,
					}));
		return jr(this, fr, cm).call(this, y, z);
	}),
	(Ru = function ({ start: a, end: p, grid: y, expectedColumnIndex: M }) {
		var T;
		let z = null;
		for (let s = a; s < p; s++) {
			const B = y[s];
			if (
				((z = ((T = B[M]) == null ? void 0 : T.ref) ?? null),
				z !== null && Ud(z))
			) {
				z = null;
				continue;
			}
			if (z === null)
				for (let O = B.length - 1; O >= 0; O--) {
					const X = B[B.length - 1];
					if (!(X === void 0 || Ud(X.ref))) {
						z = X.ref;
						break;
					}
				}
			break;
		}
		return z;
	}),
	(cm = function (a, p) {
		if (p === null) return 0;
		const y = this.getValidItems(),
			M = y.findIndex((T) => T === a);
		return y.findIndex((T) => T === p) - M;
	}),
	(um = function (a) {
		this.opts.columns.current !== null &&
			(a.preventDefault(),
			a.metaKey
				? this.updateSelectedByGroup(-1)
				: this.updateSelectedByItem(jr(this, fr, x0).call(this, a)));
	}),
	(x0 = function (a) {
		const p = this.itemsGrid,
			y = jr(this, fr, ws).call(this);
		if (y === void 0) return 0;
		const M = jr(this, fr, lm).call(this, y, p);
		if (M === null) return 0;
		let z = null;
		const T = a.altKey ? 1 : 0;
		if (a.altKey && M.rowIndex === 1 && this.opts.loop.current === !1)
			z = jr(this, fr, Bu).call(this, {
				start: 0,
				end: 0,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			});
		else if (M.rowIndex === 0) {
			if (this.opts.loop.current === !1) return 0;
			z = jr(this, fr, Bu).call(this, {
				start: p.length - 1 - T,
				end: M.rowIndex + 1,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			});
		} else
			(z = jr(this, fr, Bu).call(this, {
				start: M.rowIndex - 1 - T,
				end: 0,
				expectedColumnIndex: M.columnIndex,
				grid: p,
			})),
				z === null &&
					this.opts.loop.current &&
					(z = jr(this, fr, Bu).call(this, {
						start: p.length - 1,
						end: M.rowIndex + 1,
						expectedColumnIndex: M.columnIndex,
						grid: p,
					}));
		return jr(this, fr, cm).call(this, y, z);
	}),
	(Bu = function ({ start: a, end: p, grid: y, expectedColumnIndex: M }) {
		var T;
		let z = null;
		for (let s = a; s >= p; s--) {
			const B = y[s];
			if (B !== void 0) {
				if (
					((z = ((T = B[M]) == null ? void 0 : T.ref) ?? null),
					z !== null && Ud(z))
				) {
					z = null;
					continue;
				}
				if (z === null)
					for (let O = B.length - 1; O >= 0; O--) {
						const X = B[B.length - 1];
						if (!(X === void 0 || Ud(X.ref))) {
							z = X.ref;
							break;
						}
					}
				break;
			}
		}
		return z;
	}),
	(Fu = function (a) {
		a.preventDefault(),
			a.metaKey
				? this.updateSelectedToIndex(0)
				: a.altKey
				? this.updateSelectedByGroup(-1)
				: this.updateSelectedByItem(-1);
	}),
	(sh = new WeakMap());
let im = e_;
function Ud(m) {
	return m.getAttribute("aria-disabled") === "true";
}
var lh, ch, uh;
const t_ = class t_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(
			this,
			lh,
			ft(
				() =>
					(this.root._commandState.filtered.count === 0 &&
						ot(this, ch) === !1) ||
					this.opts.forceMount.current
			)
		);
		Ar(this, ch, !0);
		Ar(
			this,
			uh,
			ft(() => ({
				id: this.opts.id.current,
				role: "presentation",
				[wa.empty]: "",
				...this.attachment,
			}))
		);
		(this.opts = a),
			(this.root = p),
			(this.attachment = Xa(this.opts.ref)),
			Mm(() => {
				na(this, ch, !1);
			});
	}
	static create(a) {
		return new t_(a, ml.get());
	}
	get shouldRender() {
		return x(ot(this, lh));
	}
	set shouldRender(a) {
		se(ot(this, lh), a);
	}
	get props() {
		return x(ot(this, uh));
	}
	set props(a) {
		se(ot(this, uh), a);
	}
};
(lh = new WeakMap()), (ch = new WeakMap()), (uh = new WeakMap());
let hm = t_;
var hh, dh, ph, fh;
const r_ = class r_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(
			this,
			hh,
			ft(() =>
				this.opts.forceMount.current ||
				this.root.opts.shouldFilter.current === !1 ||
				!this.root.commandState.search
					? !0
					: this.root._commandState.filtered.groups.has(this.trueValue)
			)
		);
		Ar(this, dh, st(null));
		Ar(this, ph, st(""));
		Ar(
			this,
			fh,
			ft(() => ({
				id: this.opts.id.current,
				role: "presentation",
				hidden: this.shouldRender ? void 0 : !0,
				"data-value": this.trueValue,
				[wa.group]: "",
				...this.attachment,
			}))
		);
		(this.opts = a),
			(this.root = p),
			(this.attachment = Xa(this.opts.ref)),
			(this.trueValue = a.value.current ?? a.id.current),
			Ps(
				() => this.trueValue,
				() => this.root.registerGroup(this.trueValue)
			),
			Wr(() =>
				this.opts.value.current
					? ((this.trueValue = this.opts.value.current),
					  this.root.registerValue(this.opts.value.current))
					: this.headingNode && this.headingNode.textContent
					? ((this.trueValue = this.headingNode.textContent
							.trim()
							.toLowerCase()),
					  this.root.registerValue(this.trueValue))
					: ((this.trueValue = `-----${this.opts.id.current}`),
					  this.root.registerValue(this.trueValue))
			);
	}
	static create(a) {
		return Zu.set(new r_(a, ml.get()));
	}
	get shouldRender() {
		return x(ot(this, hh));
	}
	set shouldRender(a) {
		se(ot(this, hh), a);
	}
	get headingNode() {
		return x(ot(this, dh));
	}
	set headingNode(a) {
		se(ot(this, dh), a, !0);
	}
	get trueValue() {
		return x(ot(this, ph));
	}
	set trueValue(a) {
		se(ot(this, ph), a, !0);
	}
	get props() {
		return x(ot(this, fh));
	}
	set props(a) {
		se(ot(this, fh), a);
	}
};
(hh = new WeakMap()),
	(dh = new WeakMap()),
	(ph = new WeakMap()),
	(fh = new WeakMap());
let dm = r_;
var mh;
const n_ = class n_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "group");
		xr(this, "attachment");
		Ar(
			this,
			mh,
			ft(() => ({
				id: this.opts.id.current,
				[wa["group-heading"]]: "",
				...this.attachment,
			}))
		);
		(this.opts = a),
			(this.group = p),
			(this.attachment = Xa(
				this.opts.ref,
				(y) => (this.group.headingNode = y)
			));
	}
	static create(a) {
		return new n_(a, Zu.get());
	}
	get props() {
		return x(ot(this, mh));
	}
	set props(a) {
		se(ot(this, mh), a);
	}
};
mh = new WeakMap();
let pm = n_;
var _h;
const i_ = class i_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "group");
		xr(this, "attachment");
		Ar(
			this,
			_h,
			ft(() => {
				var a;
				return {
					id: this.opts.id.current,
					role: "group",
					[wa["group-items"]]: "",
					"aria-labelledby":
						((a = this.group.headingNode) == null ? void 0 : a.id) ?? void 0,
					...this.attachment,
				};
			})
		);
		(this.opts = a), (this.group = p), (this.attachment = Xa(this.opts.ref));
	}
	static create(a) {
		return new i_(a, Zu.get());
	}
	get props() {
		return x(ot(this, _h));
	}
	set props(a) {
		se(ot(this, _h), a);
	}
};
_h = new WeakMap();
let fm = i_;
var ap, gh;
const a_ = class a_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(
			this,
			ap,
			ft(() => {
				var p;
				const a =
					(p = this.root.viewportNode) == null
						? void 0
						: p.querySelector(
								`${m0}[${sl}="${f0(this.root.opts.value.current)}"]`
						  );
				if (a != null) return a.getAttribute("id") ?? void 0;
			})
		);
		Ar(
			this,
			gh,
			ft(() => {
				var a, p;
				return {
					id: this.opts.id.current,
					type: "text",
					[wa.input]: "",
					autocomplete: "off",
					autocorrect: "off",
					spellcheck: !1,
					"aria-autocomplete": "list",
					role: "combobox",
					"aria-expanded": Mk(!0),
					"aria-controls":
						((a = this.root.viewportNode) == null ? void 0 : a.id) ?? void 0,
					"aria-labelledby":
						((p = this.root.labelNode) == null ? void 0 : p.id) ?? void 0,
					"aria-activedescendant": x(ot(this, ap)),
					...this.attachment,
				};
			})
		);
		(this.opts = a),
			(this.root = p),
			(this.attachment = Xa(this.opts.ref, (y) => (this.root.inputNode = y))),
			Ps(
				() => this.opts.ref.current,
				() => {
					const y = this.opts.ref.current;
					y && this.opts.autofocus.current && _k(10, () => y.focus());
				}
			),
			Ps(
				() => this.opts.value.current,
				() => {
					this.root.commandState.search !== this.opts.value.current &&
						this.root.setState("search", this.opts.value.current);
				}
			);
	}
	static create(a) {
		return new a_(a, ml.get());
	}
	get props() {
		return x(ot(this, gh));
	}
	set props(a) {
		se(ot(this, gh), a);
	}
};
(ap = new WeakMap()), (gh = new WeakMap());
let mm = a_;
var Ts, op, vh, yh, xh, pl, b0, gm, bh;
const o_ = class o_ {
	constructor(a, p) {
		Ar(this, pl);
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(this, Ts, null);
		Ar(
			this,
			op,
			ft(() => {
				var a;
				return (
					this.opts.forceMount.current ||
					((a = ot(this, Ts)) == null ? void 0 : a.opts.forceMount.current) ===
						!0
				);
			})
		);
		Ar(
			this,
			vh,
			ft(() => {
				if (
					(this.opts.ref.current,
					x(ot(this, op)) ||
						this.root.opts.shouldFilter.current === !1 ||
						!this.root.commandState.search)
				)
					return !0;
				const a = this.root.commandState.filtered.items.get(this.trueValue);
				return a === void 0 ? !1 : a > 0;
			})
		);
		Ar(
			this,
			yh,
			ft(
				() =>
					this.root.opts.value.current === this.trueValue &&
					this.trueValue !== ""
			)
		);
		Ar(this, xh, st(""));
		Ar(
			this,
			bh,
			ft(() => {
				var a;
				return {
					id: this.opts.id.current,
					"aria-disabled": Ik(this.opts.disabled.current),
					"aria-selected": Ak(this.isSelected),
					"data-disabled": kk(this.opts.disabled.current),
					"data-selected": Ek(this.isSelected),
					"data-value": this.trueValue,
					"data-group": (a = ot(this, Ts)) == null ? void 0 : a.trueValue,
					[wa.item]: "",
					role: "option",
					onpointermove: this.onpointermove,
					onclick: this.onclick,
					...this.attachment,
				};
			})
		);
		(this.opts = a),
			(this.root = p),
			na(this, Ts, Zu.getOr(null)),
			(this.trueValue = a.value.current),
			(this.attachment = Xa(this.opts.ref)),
			Ps(
				[
					() => this.trueValue,
					() => {
						var y;
						return (y = ot(this, Ts)) == null ? void 0 : y.trueValue;
					},
					() => this.opts.forceMount.current,
				],
				() => {
					var y;
					if (!this.opts.forceMount.current)
						return this.root.registerItem(
							this.trueValue,
							(y = ot(this, Ts)) == null ? void 0 : y.trueValue
						);
				}
			),
			Ps([() => this.opts.value.current, () => this.opts.ref.current], () => {
				var y, M;
				!this.opts.value.current &&
					(y = this.opts.ref.current) != null &&
					y.textContent &&
					(this.trueValue = this.opts.ref.current.textContent.trim()),
					this.root.registerValue(
						this.trueValue,
						a.keywords.current.map((z) => z.trim())
					),
					(M = this.opts.ref.current) == null ||
						M.setAttribute(sl, this.trueValue);
			}),
			(this.onclick = this.onclick.bind(this)),
			(this.onpointermove = this.onpointermove.bind(this));
	}
	static create(a) {
		const p = Zu.getOr(null);
		return new o_({ ...a, group: p }, ml.get());
	}
	get shouldRender() {
		return x(ot(this, vh));
	}
	set shouldRender(a) {
		se(ot(this, vh), a);
	}
	get isSelected() {
		return x(ot(this, yh));
	}
	set isSelected(a) {
		se(ot(this, yh), a);
	}
	get trueValue() {
		return x(ot(this, xh));
	}
	set trueValue(a) {
		se(ot(this, xh), a, !0);
	}
	onpointermove(a) {
		this.opts.disabled.current ||
			this.root.opts.disablePointerSelection.current ||
			jr(this, pl, gm).call(this);
	}
	onclick(a) {
		this.opts.disabled.current || jr(this, pl, b0).call(this);
	}
	get props() {
		return x(ot(this, bh));
	}
	set props(a) {
		se(ot(this, bh), a);
	}
};
(Ts = new WeakMap()),
	(op = new WeakMap()),
	(vh = new WeakMap()),
	(yh = new WeakMap()),
	(xh = new WeakMap()),
	(pl = new WeakSet()),
	(b0 = function () {
		var a;
		this.opts.disabled.current ||
			(jr(this, pl, gm).call(this),
			(a = this.opts.onSelect) == null || a.current());
	}),
	(gm = function () {
		this.opts.disabled.current || this.root.setValue(this.trueValue, !0);
	}),
	(bh = new WeakMap());
let _m = o_;
var wh;
const s_ = class s_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(
			this,
			wh,
			ft(() => ({
				id: this.opts.id.current,
				role: "listbox",
				"aria-label": this.opts.ariaLabel.current,
				[wa.list]: "",
				...this.attachment,
			}))
		);
		(this.opts = a), (this.root = p), (this.attachment = Xa(this.opts.ref));
	}
	static create(a) {
		return Kk.set(new s_(a, ml.get()));
	}
	get props() {
		return x(ot(this, wh));
	}
	set props(a) {
		se(ot(this, wh), a);
	}
};
wh = new WeakMap();
let vm = s_;
var Th;
const l_ = class l_ {
	constructor(a, p) {
		xr(this, "opts");
		xr(this, "root");
		xr(this, "attachment");
		Ar(
			this,
			Th,
			ft(() => {
				var a;
				return {
					id: this.opts.id.current,
					[wa["input-label"]]: "",
					for: (a = this.opts.for) == null ? void 0 : a.current,
					style: c0,
					...this.attachment,
				};
			})
		);
		(this.opts = a),
			(this.root = p),
			(this.attachment = Xa(this.opts.ref, (y) => (this.root.labelNode = y)));
	}
	static create(a) {
		return new l_(a, ml.get());
	}
	get props() {
		return x(ot(this, Th));
	}
	set props(a) {
		se(ot(this, Th), a);
	}
};
Th = new WeakMap();
let ym = l_;
var Jk = Te("<label><!></label>");
function Qk(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = nr(a, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"]);
	const T = ym.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(X) => M(X)
			),
		}),
		s = ft(() => Va(z, T.props));
	var B = Jk();
	ar(B, () => ({ ...x(s) }));
	var O = A(B);
	oi(O, () => a.children ?? pa), k(B), $(m, B), Dr();
}
var eA = Te("<!> <!>", 1),
	tA = Te("<div><!> <!></div>");
function rA(m, a) {
	const p = uo();
	Lr(a, !0);
	const y = (nt) => {
		Qk(nt, {
			children: (Ue, ke) => {
				yn();
				var vt = wi();
				We(() => de(vt, ne())), $(Ue, vt);
			},
			$$slots: { default: !0 },
		});
	};
	let M = zt(a, "id", 19, () => Ya(p)),
		z = zt(a, "ref", 15, null),
		T = zt(a, "value", 15, ""),
		s = zt(a, "onValueChange", 3, qu),
		B = zt(a, "onStateChange", 3, qu),
		O = zt(a, "loop", 3, !1),
		X = zt(a, "shouldFilter", 3, !0),
		K = zt(a, "filter", 3, T0),
		ne = zt(a, "label", 3, ""),
		H = zt(a, "vimBindings", 3, !0),
		fe = zt(a, "disablePointerSelection", 3, !1),
		ge = zt(a, "disableInitialScroll", 3, !1),
		Ie = zt(a, "columns", 3, null),
		Ae = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"value",
			"onValueChange",
			"onStateChange",
			"loop",
			"shouldFilter",
			"filter",
			"label",
			"vimBindings",
			"disablePointerSelection",
			"disableInitialScroll",
			"columns",
			"children",
			"child",
		]);
	const De = im.create({
			id: br.with(() => M()),
			ref: br.with(
				() => z(),
				(nt) => z(nt)
			),
			filter: br.with(() => K()),
			shouldFilter: br.with(() => X()),
			loop: br.with(() => O()),
			value: br.with(
				() => T(),
				(nt) => {
					T() !== nt && (T(nt), s()(nt));
				}
			),
			vimBindings: br.with(() => H()),
			disablePointerSelection: br.with(() => fe()),
			disableInitialScroll: br.with(() => ge()),
			onStateChange: br.with(() => B()),
			columns: br.with(() => Ie()),
		}),
		Ee = (nt) => De.updateSelectedToIndex(nt),
		Fe = (nt) => De.updateSelectedByGroup(nt),
		$e = (nt) => De.updateSelectedByItem(nt),
		Je = () => De.getValidItems(),
		qe = ft(() => Va(Ae, De.props));
	var Ze = er(),
		Qe = Ct(Ze);
	{
		var Le = (nt) => {
				var Ue = eA(),
					ke = Ct(Ue);
				y(ke);
				var vt = j(ke, 2);
				oi(
					vt,
					() => a.child,
					() => ({ props: x(qe) })
				),
					$(nt, Ue);
			},
			et = (nt) => {
				var Ue = tA();
				ar(Ue, () => ({ ...x(qe) }));
				var ke = A(Ue);
				y(ke);
				var vt = j(ke, 2);
				oi(vt, () => a.children ?? pa), k(Ue), $(nt, Ue);
			};
		Oe(Qe, (nt) => {
			a.child ? nt(Le) : nt(et, !1);
		});
	}
	return (
		$(m, Ze),
		Dr({
			updateSelectedToIndex: Ee,
			updateSelectedByGroup: Fe,
			updateSelectedByItem: $e,
			getValidItems: Je,
		})
	);
}
var nA = Te("<div><!></div>");
function iA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = zt(a, "forceMount", 3, !1),
		T = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"children",
			"child",
			"forceMount",
		]);
	const s = hm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(ne) => M(ne)
			),
			forceMount: br.with(() => z()),
		}),
		B = ft(() => Va(s.props, T));
	var O = er(),
		X = Ct(O);
	{
		var K = (ne) => {
			var H = er(),
				fe = Ct(H);
			{
				var ge = (Ae) => {
						var De = er(),
							Ee = Ct(De);
						oi(
							Ee,
							() => a.child,
							() => ({ props: x(B) })
						),
							$(Ae, De);
					},
					Ie = (Ae) => {
						var De = nA();
						ar(De, () => ({ ...x(B) }));
						var Ee = A(De);
						oi(Ee, () => a.children ?? pa), k(De), $(Ae, De);
					};
				Oe(fe, (Ae) => {
					a.child ? Ae(ge) : Ae(Ie, !1);
				});
			}
			$(ne, H);
		};
		Oe(X, (ne) => {
			s.shouldRender && ne(K);
		});
	}
	$(m, O), Dr();
}
var aA = Te("<div><!></div>");
function oA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = zt(a, "value", 3, ""),
		T = zt(a, "forceMount", 3, !1),
		s = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"value",
			"forceMount",
			"children",
			"child",
		]);
	const B = dm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(fe) => M(fe)
			),
			forceMount: br.with(() => T()),
			value: br.with(() => z()),
		}),
		O = ft(() => Va(s, B.props));
	var X = er(),
		K = Ct(X);
	{
		var ne = (fe) => {
				var ge = er(),
					Ie = Ct(ge);
				oi(
					Ie,
					() => a.child,
					() => ({ props: x(O) })
				),
					$(fe, ge);
			},
			H = (fe) => {
				var ge = aA();
				ar(ge, () => ({ ...x(O) }));
				var Ie = A(ge);
				oi(Ie, () => a.children ?? pa), k(ge), $(fe, ge);
			};
		Oe(K, (fe) => {
			a.child ? fe(ne) : fe(H, !1);
		});
	}
	$(m, X), Dr();
}
var sA = Te("<div><!></div>");
function lA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"children",
			"child",
		]);
	const T = pm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(ne) => M(ne)
			),
		}),
		s = ft(() => Va(z, T.props));
	var B = er(),
		O = Ct(B);
	{
		var X = (ne) => {
				var H = er(),
					fe = Ct(H);
				oi(
					fe,
					() => a.child,
					() => ({ props: x(s) })
				),
					$(ne, H);
			},
			K = (ne) => {
				var H = sA();
				ar(H, () => ({ ...x(s) }));
				var fe = A(H);
				oi(fe, () => a.children ?? pa), k(H), $(ne, H);
			};
		Oe(O, (ne) => {
			a.child ? ne(X) : ne(K, !1);
		});
	}
	$(m, B), Dr();
}
var cA = Te("<div><!></div>"),
	uA = Te('<div style="display: contents;"><!></div>');
function hA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"children",
			"child",
		]);
	const T = fm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(ne) => M(ne)
			),
		}),
		s = ft(() => Va(z, T.props));
	var B = uA(),
		O = A(B);
	{
		var X = (ne) => {
				var H = er(),
					fe = Ct(H);
				oi(
					fe,
					() => a.child,
					() => ({ props: x(s) })
				),
					$(ne, H);
			},
			K = (ne) => {
				var H = cA();
				ar(H, () => ({ ...x(s) }));
				var fe = A(H);
				oi(fe, () => a.children ?? pa), k(H), $(ne, H);
			};
		Oe(O, (ne) => {
			a.child ? ne(X) : ne(K, !1);
		});
	}
	k(B), $(m, B), Dr();
}
var dA = Te("<input/>");
function pA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "value", 15, ""),
		M = zt(a, "autofocus", 3, !1),
		z = zt(a, "id", 19, () => Ya(p)),
		T = zt(a, "ref", 15, null),
		s = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"value",
			"autofocus",
			"id",
			"ref",
			"child",
		]);
	const B = mm.create({
			id: br.with(() => z()),
			ref: br.with(
				() => T(),
				(fe) => T(fe)
			),
			value: br.with(
				() => y(),
				(fe) => {
					y(fe);
				}
			),
			autofocus: br.with(() => M() ?? !1),
		}),
		O = ft(() => Va(s, B.props));
	var X = er(),
		K = Ct(X);
	{
		var ne = (fe) => {
				var ge = er(),
					Ie = Ct(ge);
				oi(
					Ie,
					() => a.child,
					() => ({ props: x(O) })
				),
					$(fe, ge);
			},
			H = (fe) => {
				var ge = dA();
				Ka(ge), ar(ge, () => ({ ...x(O) })), dp(ge, y), $(fe, ge);
			};
		Oe(K, (fe) => {
			a.child ? fe(ne) : fe(H, !1);
		});
	}
	$(m, X), Dr();
}
var fA = Te("<div><!></div>"),
	mA = Te('<div style="display: contents;" data-item-wrapper=""><!></div>');
function _A(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = zt(a, "value", 3, ""),
		T = zt(a, "disabled", 3, !1),
		s = zt(a, "onSelect", 3, qu),
		B = zt(a, "forceMount", 3, !1),
		O = zt(a, "keywords", 19, () => []),
		X = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"value",
			"disabled",
			"children",
			"child",
			"onSelect",
			"forceMount",
			"keywords",
		]);
	const K = _m.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(ge) => M(ge)
			),
			value: br.with(() => z()),
			disabled: br.with(() => T()),
			onSelect: br.with(() => s()),
			forceMount: br.with(() => B()),
			keywords: br.with(() => O()),
		}),
		ne = ft(() => Va(X, K.props));
	var H = er(),
		fe = Ct(H);
	ju(
		fe,
		() => K.root.key,
		(ge) => {
			var Ie = mA(),
				Ae = A(Ie);
			{
				var De = (Ee) => {
					var Fe = er(),
						$e = Ct(Fe);
					{
						var Je = (Ze) => {
								var Qe = er(),
									Le = Ct(Qe);
								oi(
									Le,
									() => a.child,
									() => ({ props: x(ne) })
								),
									$(Ze, Qe);
							},
							qe = (Ze) => {
								var Qe = fA();
								ar(Qe, () => ({ ...x(ne) }));
								var Le = A(Qe);
								oi(Le, () => a.children ?? pa), k(Qe), $(Ze, Qe);
							};
						Oe($e, (Ze) => {
							a.child ? Ze(Je) : Ze(qe, !1);
						});
					}
					$(Ee, Fe);
				};
				Oe(Ae, (Ee) => {
					K.shouldRender && Ee(De);
				});
			}
			k(Ie), We(() => Tr(Ie, "data-value", K.trueValue)), $(ge, Ie);
		}
	),
		$(m, H),
		Dr();
}
var gA = Te("<div><!></div>");
function vA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"child",
			"children",
			"aria-label",
		]);
	const T = vm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(X) => M(X)
			),
			ariaLabel: br.with(() => a["aria-label"] ?? "Suggestions..."),
		}),
		s = ft(() => Va(z, T.props));
	var B = er(),
		O = Ct(B);
	ju(
		O,
		() => T.root._commandState.search === "",
		(X) => {
			var K = er(),
				ne = Ct(K);
			{
				var H = (ge) => {
						var Ie = er(),
							Ae = Ct(Ie);
						oi(
							Ae,
							() => a.child,
							() => ({ props: x(s) })
						),
							$(ge, Ie);
					},
					fe = (ge) => {
						var Ie = gA();
						ar(Ie, () => ({ ...x(s) }));
						var Ae = A(Ie);
						oi(Ae, () => a.children ?? pa), k(Ie), $(ge, Ie);
					};
				Oe(ne, (ge) => {
					a.child ? ge(H) : ge(fe, !1);
				});
			}
			$(X, K);
		}
	),
		$(m, B),
		Dr();
}
const ov = 1,
	yA = 0.9,
	xA = 0.8,
	bA = 0.17,
	Of = 0.1,
	Nf = 0.999,
	wA = 0.9999,
	TA = 0.99,
	CA = /[\\/_+.#"@[({&]/,
	SA = /[\\/_+.#"@[({&]/g,
	PA = /[\s-]/,
	w0 = /[\s-]/g;
function xm(m, a, p, y, M, z, T) {
	if (z === a.length) return M === m.length ? ov : TA;
	const s = `${M},${z}`;
	if (T[s] !== void 0) return T[s];
	const B = y.charAt(z);
	let O = p.indexOf(B, M),
		X = 0,
		K,
		ne,
		H,
		fe;
	for (; O >= 0; )
		(K = xm(m, a, p, y, O + 1, z + 1, T)),
			K > X &&
				(O === M
					? (K *= ov)
					: CA.test(m.charAt(O - 1))
					? ((K *= xA),
					  (H = m.slice(M, O - 1).match(SA)),
					  H && M > 0 && (K *= Nf ** H.length))
					: PA.test(m.charAt(O - 1))
					? ((K *= yA),
					  (fe = m.slice(M, O - 1).match(w0)),
					  fe && M > 0 && (K *= Nf ** fe.length))
					: ((K *= bA), M > 0 && (K *= Nf ** (O - M))),
				m.charAt(O) !== a.charAt(z) && (K *= wA)),
			((K < Of && p.charAt(O - 1) === y.charAt(z + 1)) ||
				(y.charAt(z + 1) === y.charAt(z) && p.charAt(O - 1) !== y.charAt(z))) &&
				((ne = xm(m, a, p, y, O + 1, z + 2, T)), ne * Of > K && (K = ne * Of)),
			K > X && (X = K),
			(O = p.indexOf(B, O + 1));
	return (T[s] = X), X;
}
function sv(m) {
	return m.toLowerCase().replace(w0, " ");
}
function T0(m, a, p) {
	return (
		(m =
			p && p.length > 0 ? `${`${m} ${p == null ? void 0 : p.join(" ")}`}` : m),
		xm(m, a, sv(m), sv(a), 0, 0, {})
	);
}
const IA = 18,
	C0 = 40,
	MA = `${C0}px`,
	kA = [
		"[data-lastpass-icon-root]",
		"com-1password-button",
		"[data-dashlanecreated]",
		'[style$="2147483647 !important;"]',
	].join(",");
function AA({
	containerRef: m,
	inputRef: a,
	pushPasswordManagerStrategy: p,
	isFocused: y,
	domContext: M,
}) {
	let z = st(!1),
		T = st(!1),
		s = st(!1);
	function B() {
		const X = p.current;
		return X === "none" ? !1 : X === "increase-width" && x(z) && x(T);
	}
	function O() {
		const X = m.current,
			K = a.current;
		if (!X || !K || x(s) || p.current === "none") return;
		const ne = X,
			H = ne.getBoundingClientRect().left + ne.offsetWidth,
			fe = ne.getBoundingClientRect().top + ne.offsetHeight / 2,
			ge = H - IA,
			Ie = fe;
		(M.querySelectorAll(kA).length === 0 &&
			M.getDocument().elementFromPoint(ge, Ie) === X) ||
			(se(z, !0), se(s, !0));
	}
	return (
		Wr(() => {
			const X = m.current;
			if (!X || p.current === "none") return;
			function K() {
				const fe = d0(X).innerWidth - X.getBoundingClientRect().right;
				se(T, fe >= C0);
			}
			K();
			const ne = setInterval(K, 1e3);
			return () => {
				clearInterval(ne);
			};
		}),
		Wr(() => {
			const X = y.current || M.getActiveElement() === a.current;
			if (p.current === "none" || !X) return;
			const K = setTimeout(O, 0),
				ne = setTimeout(O, 2e3),
				H = setTimeout(O, 5e3),
				fe = setTimeout(() => {
					se(s, !0);
				}, 6e3);
			return () => {
				clearTimeout(K), clearTimeout(ne), clearTimeout(H), clearTimeout(fe);
			};
		}),
		{
			get hasPwmBadge() {
				return x(z);
			},
			get willPushPwmBadge() {
				return B();
			},
			PWM_BADGE_SPACE_WIDTH: MA,
		}
	);
}
const S0 = p0({ component: "pin-input", parts: ["root", "cell"] }),
	EA = [
		"Backspace",
		"Delete",
		"ArrowLeft",
		"ArrowRight",
		"ArrowUp",
		"ArrowDown",
		"Home",
		"End",
		"Escape",
		"Enter",
		"Tab",
		"Shift",
		"Control",
		"Meta",
	];
var Ha,
	Pc,
	Wo,
	ja,
	Wa,
	Ic,
	To,
	Xo,
	Cs,
	Mc,
	sp,
	Ch,
	Sh,
	lp,
	cp,
	P0,
	Ph,
	Ih,
	up,
	Mh;
const c_ = class c_ {
	constructor(a) {
		Ar(this, cp);
		xr(this, "opts");
		xr(this, "attachment");
		Ar(this, Ha, br(null));
		Ar(this, Pc, st(!1));
		xr(this, "inputAttachment", Xa(ot(this, Ha)));
		Ar(this, Wo, br(!1));
		Ar(this, ja, st(null));
		Ar(this, Wa, st(null));
		Ar(this, Ic, new mk(() => this.opts.value.current ?? ""));
		Ar(
			this,
			To,
			ft(() =>
				typeof this.opts.pattern.current == "string"
					? new RegExp(this.opts.pattern.current)
					: this.opts.pattern.current
			)
		);
		Ar(this, Xo, st(bi({ prev: [null, null, "none"], willSyntheticBlur: !1 })));
		Ar(this, Cs);
		Ar(this, Mc);
		xr(this, "domContext");
		xr(this, "onkeydown", (a) => {
			const p = a.key;
			EA.includes(p) ||
				a.ctrlKey ||
				a.metaKey ||
				(p &&
					x(ot(this, To)) &&
					!x(ot(this, To)).test(p) &&
					a.preventDefault());
		});
		Ar(
			this,
			sp,
			ft(() => ({
				position: "relative",
				cursor: this.opts.disabled.current ? "default" : "text",
				userSelect: "none",
				WebkitUserSelect: "none",
				pointerEvents: "none",
			}))
		);
		Ar(
			this,
			Ch,
			ft(() => ({
				id: this.opts.id.current,
				[S0.root]: "",
				style: x(ot(this, sp)),
				...this.attachment,
			}))
		);
		Ar(
			this,
			Sh,
			ft(() => ({
				style: { position: "absolute", inset: 0, pointerEvents: "none" },
			}))
		);
		Ar(
			this,
			lp,
			ft(() => ({
				position: "absolute",
				inset: 0,
				width: ot(this, Cs).willPushPwmBadge
					? `calc(100% + ${ot(this, Cs).PWM_BADGE_SPACE_WIDTH})`
					: "100%",
				clipPath: ot(this, Cs).willPushPwmBadge
					? `inset(0 ${ot(this, Cs).PWM_BADGE_SPACE_WIDTH} 0 0)`
					: void 0,
				height: "100%",
				display: "flex",
				textAlign: this.opts.textAlign.current,
				opacity: "1",
				color: "transparent",
				pointerEvents: "all",
				background: "transparent",
				caretColor: "transparent",
				border: "0 solid transparent",
				outline: "0 solid transparent",
				boxShadow: "none",
				lineHeight: "1",
				letterSpacing: "-.5em",
				fontSize: "var(--bits-pin-input-root-height)",
				fontFamily: "monospace",
				fontVariantNumeric: "tabular-nums",
			}))
		);
		Ar(this, Ph, () => {
			var ge;
			const a = ot(this, Ha).current,
				p = this.opts.ref.current;
			if (!a || !p) return;
			if (this.domContext.getActiveElement() !== a) {
				se(ot(this, ja), null), se(ot(this, Wa), null);
				return;
			}
			const y = a.selectionStart,
				M = a.selectionEnd,
				z = a.selectionDirection ?? "none",
				T = a.maxLength,
				s = a.value,
				B = x(ot(this, Xo)).prev;
			let O = -1,
				X = -1,
				K;
			if (s.length !== 0 && y !== null && M !== null) {
				const Ie = y === M,
					Ae = y === s.length && s.length < T;
				if (Ie && !Ae) {
					const De = y;
					if (De === 0) (O = 0), (X = 1), (K = "forward");
					else if (De === T) (O = De - 1), (X = De), (K = "backward");
					else if (T > 1 && s.length > 1) {
						let Ee = 0;
						if (B[0] !== null && B[1] !== null) {
							K = De < B[0] ? "backward" : "forward";
							const Fe = B[0] === B[1] && B[0] < T;
							K === "backward" && !Fe && (Ee = -1);
						}
						(O = Ee - De), (X = Ee + De + 1);
					}
				}
				O !== -1 &&
					X !== -1 &&
					O !== X &&
					((ge = ot(this, Ha).current) == null ||
						ge.setSelectionRange(O, X, K));
			}
			const ne = O !== -1 ? O : y,
				H = X !== -1 ? X : M,
				fe = K ?? z;
			se(ot(this, ja), ne, !0),
				se(ot(this, Wa), H, !0),
				(x(ot(this, Xo)).prev = [ne, H, fe]);
		});
		xr(this, "oninput", (a) => {
			const p = a.currentTarget.value.slice(0, this.opts.maxLength.current);
			if (p.length > 0 && x(ot(this, To)) && !x(ot(this, To)).test(p)) {
				a.preventDefault();
				return;
			}
			typeof ot(this, Ic).current == "string" &&
				p.length < ot(this, Ic).current.length &&
				this.domContext
					.getDocument()
					.dispatchEvent(new Event("selectionchange")),
				(this.opts.value.current = p);
		});
		xr(this, "onfocus", (a) => {
			const p = ot(this, Ha).current;
			if (p) {
				const y = Math.min(p.value.length, this.opts.maxLength.current - 1),
					M = p.value.length;
				p.setSelectionRange(y, M),
					se(ot(this, ja), y, !0),
					se(ot(this, Wa), M, !0);
			}
			ot(this, Wo).current = !0;
		});
		xr(this, "onpaste", (a) => {
			var X, K, ne, H;
			const p = ot(this, Ha).current;
			if (!p) return;
			const y = (fe) => {
					const ge = p.selectionStart === null ? void 0 : p.selectionStart,
						Ie = p.selectionEnd === null ? void 0 : p.selectionEnd,
						Ae = ge !== Ie,
						De = this.opts.value.current;
					return (
						Ae
							? De.slice(0, ge) + fe + De.slice(Ie)
							: De.slice(0, ge) + fe + De.slice(ge)
					).slice(0, this.opts.maxLength.current);
				},
				M = (fe) =>
					fe.length > 0 && x(ot(this, To)) && !x(ot(this, To)).test(fe);
			if (
				!((X = this.opts.pasteTransformer) != null && X.current) &&
				(!ot(this, Mc).isIOS || !a.clipboardData || !p)
			) {
				const fe = y(
					(K = a.clipboardData) == null ? void 0 : K.getData("text/plain")
				);
				M(fe) && a.preventDefault();
				return;
			}
			const z =
					((ne = a.clipboardData) == null
						? void 0
						: ne.getData("text/plain")) ?? "",
				T =
					(H = this.opts.pasteTransformer) != null && H.current
						? this.opts.pasteTransformer.current(z)
						: z;
			a.preventDefault();
			const s = y(T);
			if (M(s)) return;
			(p.value = s), (this.opts.value.current = s);
			const B = Math.min(s.length, this.opts.maxLength.current - 1),
				O = s.length;
			p.setSelectionRange(B, O),
				se(ot(this, ja), B, !0),
				se(ot(this, Wa), O, !0);
		});
		xr(this, "onmouseover", (a) => {
			se(ot(this, Pc), !0);
		});
		xr(this, "onmouseleave", (a) => {
			se(ot(this, Pc), !1);
		});
		xr(this, "onblur", (a) => {
			if (x(ot(this, Xo)).willSyntheticBlur) {
				x(ot(this, Xo)).willSyntheticBlur = !1;
				return;
			}
			ot(this, Wo).current = !1;
		});
		Ar(
			this,
			Ih,
			ft(() => {
				var a;
				return {
					id: this.opts.inputId.current,
					style: x(ot(this, lp)),
					autocomplete: this.opts.autocomplete.current || "one-time-code",
					"data-pin-input-input": "",
					"data-pin-input-input-mss": x(ot(this, ja)),
					"data-pin-input-input-mse": x(ot(this, Wa)),
					inputmode: this.opts.inputmode.current,
					pattern: (a = x(ot(this, To))) == null ? void 0 : a.source,
					maxlength: this.opts.maxLength.current,
					value: this.opts.value.current,
					disabled: zk(this.opts.disabled.current),
					onpaste: this.onpaste,
					oninput: this.oninput,
					onkeydown: this.onkeydown,
					onmouseover: this.onmouseover,
					onmouseleave: this.onmouseleave,
					onfocus: this.onfocus,
					onblur: this.onblur,
					...this.inputAttachment,
				};
			})
		);
		Ar(
			this,
			up,
			ft(() =>
				Array.from({ length: this.opts.maxLength.current }).map((a, p) => {
					const y =
							ot(this, Wo).current &&
							x(ot(this, ja)) !== null &&
							x(ot(this, Wa)) !== null &&
							((x(ot(this, ja)) === x(ot(this, Wa)) && p === x(ot(this, ja))) ||
								(p >= x(ot(this, ja)) && p < x(ot(this, Wa)))),
						M =
							this.opts.value.current[p] !== void 0
								? this.opts.value.current[p]
								: null;
					return { char: M, isActive: y, hasFakeCaret: y && M === null };
				})
			)
		);
		Ar(
			this,
			Mh,
			ft(() => ({
				cells: x(ot(this, up)),
				isFocused: ot(this, Wo).current,
				isHovering: x(ot(this, Pc)),
			}))
		);
		var p;
		(this.opts = a),
			(this.attachment = Xa(this.opts.ref)),
			(this.domContext = new Pk(a.ref)),
			na(this, Mc, {
				value: this.opts.value,
				isIOS:
					typeof window < "u" &&
					((p = window == null ? void 0 : window.CSS) == null
						? void 0
						: p.supports("-webkit-touch-callout", "none")),
			}),
			na(
				this,
				Cs,
				AA({
					containerRef: this.opts.ref,
					inputRef: ot(this, Ha),
					isFocused: ot(this, Wo),
					pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
					domContext: this.domContext,
				})
			),
			Fn(() => {
				const y = ot(this, Ha).current,
					M = this.opts.ref.current;
				if (!y || !M) return;
				ot(this, Mc).value.current !== y.value &&
					(this.opts.value.current = y.value),
					(x(ot(this, Xo)).prev = [
						y.selectionStart,
						y.selectionEnd,
						y.selectionDirection ?? "none",
					]);
				const z = Nu(
					this.domContext.getDocument(),
					"selectionchange",
					ot(this, Ph),
					{ capture: !0 }
				);
				ot(this, Ph).call(this),
					this.domContext.getActiveElement() === y &&
						(ot(this, Wo).current = !0),
					this.domContext.getElementById("pin-input-style") ||
						jr(this, cp, P0).call(this);
				const T = () => {
					M &&
						M.style.setProperty(
							"--bits-pin-input-root-height",
							`${y.clientHeight}px`
						);
				};
				T();
				const s = new ResizeObserver(T);
				return (
					s.observe(y),
					() => {
						z(), s.disconnect();
					}
				);
			}),
			Ps([() => this.opts.value.current, () => ot(this, Ha).current], () => {
				zA(() => {
					const y = ot(this, Ha).current;
					if (!y) return;
					y.dispatchEvent(new Event("input"));
					const M = y.selectionStart,
						z = y.selectionEnd,
						T = y.selectionDirection ?? "none";
					M !== null &&
						z !== null &&
						(se(ot(this, ja), M, !0),
						se(ot(this, Wa), z, !0),
						(x(ot(this, Xo)).prev = [M, z, T]));
				}, this.domContext);
			}),
			Wr(() => {
				const y = this.opts.value.current,
					M = ot(this, Ic).current,
					z = this.opts.maxLength.current,
					T = this.opts.onComplete.current;
				M !== void 0 && y !== M && M.length < z && y.length === z && T(y);
			});
	}
	static create(a) {
		return new c_(a);
	}
	get rootProps() {
		return x(ot(this, Ch));
	}
	set rootProps(a) {
		se(ot(this, Ch), a);
	}
	get inputWrapperProps() {
		return x(ot(this, Sh));
	}
	set inputWrapperProps(a) {
		se(ot(this, Sh), a);
	}
	get inputProps() {
		return x(ot(this, Ih));
	}
	set inputProps(a) {
		se(ot(this, Ih), a);
	}
	get snippetProps() {
		return x(ot(this, Mh));
	}
	set snippetProps(a) {
		se(ot(this, Mh), a);
	}
};
(Ha = new WeakMap()),
	(Pc = new WeakMap()),
	(Wo = new WeakMap()),
	(ja = new WeakMap()),
	(Wa = new WeakMap()),
	(Ic = new WeakMap()),
	(To = new WeakMap()),
	(Xo = new WeakMap()),
	(Cs = new WeakMap()),
	(Mc = new WeakMap()),
	(sp = new WeakMap()),
	(Ch = new WeakMap()),
	(Sh = new WeakMap()),
	(lp = new WeakMap()),
	(cp = new WeakSet()),
	(P0 = function () {
		const a = this.domContext.getDocument(),
			p = a.createElement("style");
		if (((p.id = "pin-input-style"), a.head.appendChild(p), p.sheet)) {
			const y =
				"background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
			Lu(
				p.sheet,
				"[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }"
			),
				Lu(p.sheet, `[data-pin-input-input]:autofill { ${y} }`),
				Lu(p.sheet, `[data-pin-input-input]:-webkit-autofill { ${y} }`),
				Lu(
					p.sheet,
					"@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"
				),
				Lu(
					p.sheet,
					"[data-pin-input-input] + * { pointer-events: all !important; }"
				);
		}
	}),
	(Ph = new WeakMap()),
	(Ih = new WeakMap()),
	(up = new WeakMap()),
	(Mh = new WeakMap());
let bm = c_;
var kh;
const u_ = class u_ {
	constructor(a) {
		xr(this, "opts");
		xr(this, "attachment");
		Ar(
			this,
			kh,
			ft(() => ({
				id: this.opts.id.current,
				[S0.cell]: "",
				"data-active": this.opts.cell.current.isActive ? "" : void 0,
				"data-inactive": this.opts.cell.current.isActive ? void 0 : "",
				...this.attachment,
			}))
		);
		(this.opts = a), (this.attachment = Xa(this.opts.ref));
	}
	static create(a) {
		return new u_(a);
	}
	get props() {
		return x(ot(this, kh));
	}
	set props(a) {
		se(ot(this, kh), a);
	}
};
kh = new WeakMap();
let wm = u_;
function zA(m, a) {
	const p = a.setTimeout(m, 0),
		y = a.setTimeout(m, 10),
		M = a.setTimeout(m, 50);
	return [p, y, M];
}
function Lu(m, a) {
	try {
		m.insertRule(a);
	} catch {
		console.error("pin input could not insert CSS rule:", a);
	}
}
var LA = Te("<div><!> <div><input/></div></div>");
function DA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "inputId", 19, () => `${Ya(p)}-input`),
		z = zt(a, "ref", 15, null),
		T = zt(a, "maxlength", 3, 6),
		s = zt(a, "textalign", 3, "left"),
		B = zt(a, "inputmode", 3, "numeric"),
		O = zt(a, "onComplete", 3, qu),
		X = zt(a, "pushPasswordManagerStrategy", 3, "increase-width"),
		K = zt(a, "class", 3, ""),
		ne = zt(a, "autocomplete", 3, "one-time-code"),
		H = zt(a, "disabled", 3, !1),
		fe = zt(a, "value", 15, ""),
		ge = zt(a, "onValueChange", 3, qu),
		Ie = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"inputId",
			"ref",
			"maxlength",
			"textalign",
			"pattern",
			"inputmode",
			"onComplete",
			"pushPasswordManagerStrategy",
			"class",
			"children",
			"autocomplete",
			"disabled",
			"value",
			"onValueChange",
			"pasteTransformer",
		]);
	const Ae = bm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => z(),
				(Qe) => z(Qe)
			),
			inputId: br.with(() => M()),
			autocomplete: br.with(() => ne()),
			maxLength: br.with(() => T()),
			textAlign: br.with(() => s()),
			disabled: br.with(() => H()),
			inputmode: br.with(() => B()),
			pattern: br.with(() => a.pattern),
			onComplete: br.with(() => O()),
			value: br.with(
				() => fe(),
				(Qe) => {
					fe(Qe), ge()(Qe);
				}
			),
			pushPasswordManagerStrategy: br.with(() => X()),
			pasteTransformer: br.with(() => a.pasteTransformer),
		}),
		De = ft(() => Va(Ie, Ae.inputProps)),
		Ee = ft(() => Va(Ae.rootProps, { class: K() })),
		Fe = ft(() => Va(Ae.inputWrapperProps, {}));
	var $e = LA();
	ar($e, () => ({ ...x(Ee) }));
	var Je = A($e);
	oi(
		Je,
		() => a.children ?? pa,
		() => Ae.snippetProps
	);
	var qe = j(Je, 2);
	ar(qe, () => ({ ...x(Fe) }));
	var Ze = A(qe);
	Ka(Ze), ar(Ze, () => ({ ...x(De) })), k(qe), k($e), $(m, $e), Dr();
}
var RA = Te("<div><!></div>");
function BA(m, a) {
	const p = uo();
	Lr(a, !0);
	let y = zt(a, "id", 19, () => Ya(p)),
		M = zt(a, "ref", 15, null),
		z = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"id",
			"ref",
			"cell",
			"child",
			"children",
		]);
	const T = wm.create({
			id: br.with(() => y()),
			ref: br.with(
				() => M(),
				(ne) => M(ne)
			),
			cell: br.with(() => a.cell),
		}),
		s = ft(() => Va(z, T.props));
	var B = er(),
		O = Ct(B);
	{
		var X = (ne) => {
				var H = er(),
					fe = Ct(H);
				oi(
					fe,
					() => a.child,
					() => ({ props: x(s) })
				),
					$(ne, H);
			},
			K = (ne) => {
				var H = RA();
				ar(H, () => ({ ...x(s) }));
				var fe = A(H);
				oi(fe, () => a.children ?? pa), k(H), $(ne, H);
			};
		Oe(O, (ne) => {
			a.child ? ne(X) : ne(K, !1);
		});
	}
	$(m, B), Dr();
}
function Ac(...m) {
	return Lv(Ou(m));
}
function FA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = zt(a, "value", 15, ""),
		M = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "value", "class"]);
	var z = er(),
		T = Ct(z);
	{
		let s = ft(() =>
			Ac(
				"bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
				a.class
			)
		);
		xi(
			T,
			() => rA,
			(B, O) => {
				O(
					B,
					Is(
						{
							"data-slot": "command",
							get class() {
								return x(s);
							},
						},
						() => M,
						{
							get value() {
								return y();
							},
							set value(X) {
								y(X);
							},
							get ref() {
								return p();
							},
							set ref(X) {
								p(X);
							},
						}
					)
				);
			}
		);
	}
	$(m, z), Dr();
}
var OA = Pr(
	'<svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"></path></svg>'
);
function _l(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = OA();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
function NA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
	var M = er(),
		z = Ct(M);
	{
		let T = ft(() => Ac("py-6 text-center text-sm", a.class));
		xi(
			z,
			() => iA,
			(s, B) => {
				B(
					s,
					Is(
						{
							"data-slot": "command-empty",
							get class() {
								return x(T);
							},
						},
						() => y,
						{
							get ref() {
								return p();
							},
							set ref(O) {
								p(O);
							},
						}
					)
				);
			}
		);
	}
	$(m, M), Dr();
}
var jA = Te("<!> <!>", 1);
function VA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"ref",
			"class",
			"children",
			"heading",
			"value",
		]);
	var M = er(),
		z = Ct(M);
	{
		let T = ft(() => Ac("text-foreground overflow-hidden p-1", a.class)),
			s = ft(() => a.value ?? a.heading ?? `----${Wk()}`);
		xi(
			z,
			() => oA,
			(B, O) => {
				O(
					B,
					Is(
						{
							"data-slot": "command-group",
							get class() {
								return x(T);
							},
							get value() {
								return x(s);
							},
						},
						() => y,
						{
							get ref() {
								return p();
							},
							set ref(X) {
								p(X);
							},
							children: (X, K) => {
								var ne = jA(),
									H = Ct(ne);
								{
									var fe = (Ie) => {
										var Ae = er(),
											De = Ct(Ae);
										xi(
											De,
											() => lA,
											(Ee, Fe) => {
												Fe(Ee, {
													class:
														"text-muted-foreground px-2 py-1.5 text-xs font-medium",
													children: ($e, Je) => {
														yn();
														var qe = wi();
														We(() => de(qe, a.heading)), $($e, qe);
													},
													$$slots: { default: !0 },
												});
											}
										),
											$(Ie, Ae);
									};
									Oe(H, (Ie) => {
										a.heading && Ie(fe);
									});
								}
								var ge = j(H, 2);
								xi(
									ge,
									() => hA,
									(Ie, Ae) => {
										Ae(Ie, {
											get children() {
												return a.children;
											},
										});
									}
								),
									$(X, ne);
							},
							$$slots: { default: !0 },
						}
					)
				);
			}
		);
	}
	$(m, M), Dr();
}
function qA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
	var M = er(),
		z = Ct(M);
	{
		let T = ft(() =>
			Ac(
				"aria-selected:bg-base-300 aria-selected:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0",
				a.class
			)
		);
		xi(
			z,
			() => _A,
			(s, B) => {
				B(
					s,
					Is(
						{
							"data-slot": "command-item",
							get class() {
								return x(T);
							},
						},
						() => y,
						{
							get ref() {
								return p();
							},
							set ref(O) {
								p(O);
							},
						}
					)
				);
			}
		);
	}
	$(m, M), Dr();
}
var ZA = Pr(
	'<svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"></path></svg>'
);
function UA(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = ZA();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var $A = Te(
	'<div class="border-base-content/10 flex h-9 items-center gap-2 border-b px-3" data-slot="command-input-wrapper"><!> <!></div>'
);
function GA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = zt(a, "value", 15, ""),
		M = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
	var z = $A(),
		T = A(z);
	UA(T, { class: "size-5 opacity-50" });
	var s = j(T, 2);
	{
		let B = ft(() =>
			Ac(
				"placeholder:text-muted-foreground outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm disabled:cursor-not-allowed disabled:opacity-50",
				a.class
			)
		);
		xi(
			s,
			() => pA,
			(O, X) => {
				X(
					O,
					Is(
						{
							"data-slot": "command-input",
							get class() {
								return x(B);
							},
						},
						() => M,
						{
							get ref() {
								return p();
							},
							set ref(K) {
								p(K);
							},
							get value() {
								return y();
							},
							set value(K) {
								y(K);
							},
						}
					)
				);
			}
		);
	}
	k(z), $(m, z), Dr();
}
function HA(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class"]);
	var M = er(),
		z = Ct(M);
	{
		let T = ft(() =>
			Ac("max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden", a.class)
		);
		xi(
			z,
			() => vA,
			(s, B) => {
				B(
					s,
					Is(
						{
							"data-slot": "command-list",
							get class() {
								return x(T);
							},
						},
						() => y,
						{
							get ref() {
								return p();
							},
							set ref(O) {
								p(O);
							},
						}
					)
				);
			}
		);
	}
	$(m, M), Dr();
}
var WA = Pr(
	'<svg><path d="M480-80 240-320l57-57 183 183 183-183 57 57L480-80ZM298-584l-58-56 240-240 240 240-58 56-182-182-182 182Z"></path></svg>'
);
function XA(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = WA();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var YA = Te("<span> </span> <!>", 1),
	KA = Te('<span class="font-flag ml-0.5"> </span> ', 1),
	JA = Te(
		'<span class="flex gap-1.5"><span class="font-flag"> </span> </span>'
	),
	QA = Te("<!> <!>", 1),
	eE = Te("<!> <!>", 1),
	tE = (m, a) => {
		a(0);
	},
	rE = Te('<button class="btn btn-xs btn-circle btn-ghost"><!></button>'),
	nE = Te(
		'<div class="flex items-center"><div class="dropdown"><div tabindex="0" role="button" class="btn btn-sm max-w-74 text-base-content/80 m-1"><!></div> <div><!></div></div> <!></div>'
	);
function lv(m, a) {
	Lr(a, !0);
	let p = zt(a, "countryId", 15, 0),
		y = zt(a, "dropdownDirection", 3, "right"),
		M = st(null),
		z = st(null),
		T = st("");
	function s() {
		Iv().then(() => {
			var Ee;
			(Ee = document.activeElement) == null || Ee.blur(), se(T, "");
		});
	}
	var B = nE(),
		O = A(B),
		X = A(O),
		K = A(X);
	{
		var ne = (Ee) => {
				var Fe = YA(),
					$e = Ct(Fe),
					Je = A($e, !0);
				k($e);
				var qe = j($e, 2);
				XA(qe, { class: "size-3.5" }),
					We((Ze) => de(Je, Ze), [() => Uv()]),
					$(Ee, Fe);
			},
			H = (Ee) => {
				const Fe = ft(() => So(p()));
				var $e = KA(),
					Je = Ct($e),
					qe = A(Je, !0);
				k(Je);
				var Ze = j(Je);
				We(() => {
					de(qe, x(Fe).flag), de(Ze, ` ${x(Fe).name ?? ""}`);
				}),
					$(Ee, $e);
			};
		Oe(K, (Ee) => {
			p() === 0 ? Ee(ne) : Ee(H, !1);
		});
	}
	k(X);
	var fe = j(X, 2);
	let ge;
	var Ie = A(fe);
	xi(
		Ie,
		() => FA,
		(Ee, Fe) => {
			Fe(Ee, {
				children: ($e, Je) => {
					var qe = eE(),
						Ze = Ct(qe);
					xi(
						Ze,
						() => GA,
						(Le, et) => {
							et(Le, {
								placeholder: "Country",
								get ref() {
									return x(M);
								},
								set ref(nt) {
									se(M, nt);
								},
								get value() {
									return x(T);
								},
								set value(nt) {
									se(T, nt, !0);
								},
							});
						}
					);
					var Qe = j(Ze, 2);
					xi(
						Qe,
						() => HA,
						(Le, et) => {
							et(Le, {
								children: (nt, Ue) => {
									var ke = QA(),
										vt = Ct(ke);
									xi(
										vt,
										() => NA,
										(re, he) => {
											he(re, {
												children: (oe, ze) => {
													yn();
													var je = wi();
													We((pt) => de(je, pt), [() => Bw()]), $(oe, je);
												},
												$$slots: { default: !0 },
											});
										}
									);
									var ee = j(vt, 2);
									xi(
										ee,
										() => VA,
										(re, he) => {
											he(re, {
												children: (oe, ze) => {
													var je = er(),
														pt = Ct(je);
													hi(
														pt,
														17,
														() => Wi.countries,
														(it) => it.id,
														(it, ct) => {
															var It = er(),
																Dt = Ct(It);
															xi(
																Dt,
																() => qA,
																(at, dt) => {
																	dt(at, {
																		get value() {
																			return x(ct).name;
																		},
																		onSelect: () => {
																			p(x(ct).id), s();
																		},
																		children: (yt, xt) => {
																			var St = JA(),
																				wt = A(St),
																				_t = A(wt, !0);
																			k(wt);
																			var Lt = j(wt);
																			k(St),
																				We(() => {
																					de(_t, x(ct).flag),
																						de(Lt, ` ${x(ct).name ?? ""}`);
																				}),
																				$(yt, St);
																		},
																		$$slots: { default: !0 },
																	});
																}
															),
																$(it, It);
														}
													),
														$(oe, je);
												},
												$$slots: { default: !0 },
											});
										}
									),
										$(nt, ke);
								},
								$$slots: { default: !0 },
							});
						}
					),
						$($e, qe);
				},
				$$slots: { default: !0 },
			});
		}
	),
		k(fe),
		k(O);
	var Ae = j(O, 2);
	{
		var De = (Ee) => {
			var Fe = rE();
			Fe.__click = [tE, p];
			var $e = A(Fe);
			_l($e, { class: "size-3.5" }), k(Fe), $(Ee, Fe);
		};
		Oe(Ae, (Ee) => {
			p() != 0 && Ee(De);
		});
	}
	k(B),
		Ko(
			B,
			(Ee) => se(z, Ee),
			() => x(z)
		),
		We(
			(Ee) =>
				(ge = zr(
					fe,
					1,
					"dropdown-content menu bg-base-100 rounded-box z-1 border-base-content/10 w-52 rounded-lg border py-1 shadow-sm",
					null,
					ge,
					Ee
				)),
			[() => ({ "right-1": y() === "left" })]
		),
		di("focus", X, () => {
			x(M).focus();
		}),
		$(m, B),
		Dr();
}
$n(["click"]);
var iE = Pr(
	'<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-7-.5-14.5T799-507q-5 29-27 48t-52 19h-80q-33 0-56.5-23.5T560-520v-40H400v-80q0-33 23.5-56.5T480-720h40q0-23 12.5-40.5T563-789q-20-5-40.5-8t-42.5-3q-134 0-227 93t-93 227h200q66 0 113 47t47 113v40H400v110q20 5 39.5 7.5T480-160Z"></path></svg>'
);
function aE(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = iE();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var oE = Pr(
		'<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Z"></path></svg>'
	),
	sE = Pr(
		'<svg><path d="M478-240q21 0 35.5-14.5T528-290q0-21-14.5-35.5T478-340q-21 0-35.5 14.5T428-290q0 21 14.5 35.5T478-240Zm-36-154h74q0-33 7.5-52t42.5-52q26-26 41-49.5t15-56.5q0-56-41-86t-97-30q-57 0-92.5 30T342-618l66 26q5-18 22.5-39t53.5-21q32 0 48 17.5t16 38.5q0 20-12 37.5T506-526q-44 39-54 59t-10 73Zm38 314q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"></path></svg>'
	);
function Uu(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
	var y = er(),
		M = Ct(y);
	{
		var z = (s) => {
				var B = oE();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			},
			T = (s) => {
				var B = sE();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			};
		Oe(M, (s) => {
			a.filled ? s(z) : s(T, !1);
		});
	}
	$(m, y);
}
var lE = Te(
		'<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'
	),
	cE = Te('<div class="mb-2"><!></div>'),
	uE = Te(
		'<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
	),
	hE = (m, a, p) => {
		a.onvisitclick({ lat: x(p).lastLatitude, lng: x(p).lastLongitude });
	},
	dE = Te(
		'<tr><td class="text-base-content/80 text-center font-medium max-sm:hidden"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> <span class="ml-0.5"> </span></span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td><td class="px-1 text-center"><button class="btn btn-sm"> </button></td></tr>'
	),
	pE = Te(
		'<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th class="max-sm:hidden"></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip max-sm:hidden"><!></span></th><th class="px-1"></th></tr></thead><tbody></tbody></table>'
	),
	fE = Te(
		'<tr><td class="text-base-content/80 text-center font-medium"> </td><td><span class="font-flag tooltip mr-1 text-base sm:text-lg"> </span> <span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
	),
	mE = Te(
		'<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th> </th><th class="text-center"> <br class="sm:hidden"/> <span class="tooltip before:-translate-x-1/4 max-sm:hidden"><!></span></th></tr></thead><tbody></tbody></table>'
	),
	_E = Te('<span class="font-flag tooltip ml-0.5"> </span>'),
	gE = Te("<span> </span>"),
	vE = Te(
		'<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
	),
	yE = Te(
		'<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
	),
	xE = Te(
		'<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
	),
	bE = Te(
		'<table class="table max-sm:text-sm"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
	),
	wE = Te(
		'<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'
	),
	TE = Te(
		'<div class="tabs tabs-box max-sm:tabs-xs"></div> <div class="my-4 flex items-center justify-between"><!> <!></div> <!> <!>',
		1
	);
function CE(m, a) {
	Lr(a, !0);
	const p = [];
	let y = st(1e3);
	const M = ft(() => x(y) <= 640);
	let z = st("today"),
		T = {
			regions: { label: WT(), icon: Em },
			countries: { label: KT(), icon: aE },
			players: { label: Yv(), icon: yp },
			alliances: { label: Kv(), icon: xp },
		},
		s = st("regions"),
		B = st(0),
		O = bi({ players: {}, alliances: {}, regions: {}, countries: {} }),
		X = ft(() => {
			var qe, Ze, Qe;
			return x(s) === "regions"
				? (Ze = (qe = O[x(s)][x(B)]) == null ? void 0 : qe[x(z)]) == null
					? void 0
					: Ze.entries
				: (Qe = O[x(s)][x(z)]) == null
				? void 0
				: Qe.entries;
		});
	const K = 5 * 1e3;
	Wr(() => {
		var Le;
		if (!a.open) return;
		const qe = x(z),
			Ze = x(s),
			Qe = x(B);
		Ze === "players" && (!O[Ze][qe] || Date.now() - O[Ze][qe].time > K)
			? Qr.leaderboardPlayers(qe)
					.then((et) => {
						O[Ze][qe] = { time: Date.now(), entries: et };
					})
					.catch((et) => Fr.error(et.message))
			: Ze === "alliances" && (!O[Ze][qe] || Date.now() - O[Ze][qe].time > K)
			? Qr.leaderboardAlliances(qe)
					.then((et) => {
						O[Ze][qe] = { time: Date.now(), entries: et };
					})
					.catch((et) => Fr.error(et.message))
			: Ze === "countries" && (!O[Ze][qe] || Date.now() - O[Ze][qe].time > K)
			? Qr.leaderboardCountries(qe)
					.then((et) => {
						O[Ze][qe] = { time: Date.now(), entries: et };
					})
					.catch((et) => Fr.error(et.message))
			: Ze === "regions" &&
			  (!((Le = O[Ze][Qe]) != null && Le[qe]) ||
					Date.now() - O[Ze][Qe][qe].time > K) &&
			  Qr.leaderboardRegions(qe, Qe)
					.then((et) => {
						O[Ze][Qe] || (O[Ze][Qe] = {}),
							(O[Ze][Qe][qe] = { time: Date.now(), entries: et });
					})
					.catch((et) => Fr.error(et.message));
	});
	var ne = TE(),
		H = Ct(ne);
	hi(
		H,
		21,
		() => Object.entries(T),
		([qe, { label: Ze, icon: Qe }]) => qe,
		(qe, Ze) => {
			var Qe = ft(() => Mv(x(Ze), 2));
			let Le = () => x(Qe)[0],
				et = () => x(Qe)[1].label,
				nt = () => x(Qe)[1].icon;
			const Ue = ft(nt);
			var ke = lE(),
				vt = A(ke);
			Ka(vt);
			var ee,
				re = j(vt, 2);
			xi(
				re,
				() => x(Ue),
				(oe, ze) => {
					ze(oe, {
						get this() {
							return nt();
						},
						class: "mr-1 size-5 max-sm:hidden",
					});
				}
			);
			var he = j(re);
			k(ke),
				We(() => {
					Tr(vt, "aria-label", et()),
						ee !== (ee = Le()) && (vt.value = (vt.__value = Le()) ?? ""),
						de(he, ` ${et() ?? ""}`);
				}),
				Lm(
					p,
					[],
					vt,
					() => (Le(), x(s)),
					(oe) => se(s, oe)
				),
				$(qe, ke);
		}
	),
		k(H);
	var fe = j(H, 2),
		ge = A(fe);
	Um(ge, {
		get value() {
			return x(z);
		},
		set value(qe) {
			se(z, qe, !0);
		},
	});
	var Ie = j(ge, 2);
	{
		var Ae = (qe) => {
			lv(qe, {
				dropdownDirection: "left",
				get countryId() {
					return x(B);
				},
				set countryId(Ze) {
					se(B, Ze, !0);
				},
			});
		};
		Oe(Ie, (qe) => {
			x(s) === "regions" && !x(M) && qe(Ae);
		});
	}
	k(fe);
	var De = j(fe, 2);
	{
		var Ee = (qe) => {
			var Ze = cE(),
				Qe = A(Ze);
			lv(Qe, {
				get countryId() {
					return x(B);
				},
				set countryId(Le) {
					se(B, Le, !0);
				},
			}),
				k(Ze),
				$(qe, Ze);
		};
		Oe(De, (qe) => {
			x(s) === "regions" && x(M) && qe(Ee);
		});
	}
	var Fe = j(De, 2);
	{
		var $e = (qe) => {
				var Ze = uE(),
					Qe = A(Ze),
					Le = j(Qe);
				{
					var et = (Ue) => {
							var ke = wi();
							We((vt) => de(ke, vt), [() => vp().toLowerCase()]), $(Ue, ke);
						},
						nt = (Ue) => {
							var ke = er(),
								vt = Ct(ke);
							{
								var ee = (he) => {
										var oe = wi();
										We((ze) => de(oe, ze), [() => Nm()]), $(he, oe);
									},
									re = (he) => {
										var oe = er(),
											ze = Ct(oe);
										{
											var je = (pt) => {
												var it = wi();
												We((ct) => de(it, ct), [() => jm()]), $(pt, it);
											};
											Oe(
												ze,
												(pt) => {
													x(z) === "month" && pt(je);
												},
												!0
											);
										}
										$(he, oe);
									};
								Oe(
									vt,
									(he) => {
										x(z) === "week" ? he(ee) : he(re, !1);
									},
									!0
								);
							}
							$(Ue, ke);
						};
					Oe(Le, (Ue) => {
						x(z) === "today" ? Ue(et) : Ue(nt, !1);
					});
				}
				k(Ze), We((Ue) => de(Qe, `${Ue ?? ""} `), [() => Om()]), $(qe, Ze);
			},
			Je = (qe) => {
				var Ze = er(),
					Qe = Ct(Ze);
				{
					var Le = (nt) => {
							var Ue = er(),
								ke = Ct(Ue);
							{
								var vt = (re) => {
										const he = ft(() => x(X));
										var oe = pE(),
											ze = A(oe),
											je = A(ze),
											pt = j(A(je)),
											it = A(pt, !0);
										k(pt);
										var ct = j(pt),
											It = A(ct),
											Dt = j(It, 2),
											at = j(Dt),
											dt = A(at);
										Uu(dt, {
											class: "text-base-content/50 mb-0.5 ml-1 inline size-4",
										}),
											k(at),
											k(ct),
											yn(),
											k(je),
											k(ze);
										var yt = j(ze);
										hi(
											yt,
											31,
											() => x(he),
											(xt) => xt.id,
											(xt, St, wt) => {
												const _t = ft(() => So(x(St).countryId));
												var Lt = dE(),
													Rt = A(Lt),
													$t = A(Rt, !0);
												k(Rt);
												var tr = j(Rt),
													Qt = A(tr),
													Ot = A(Qt, !0);
												k(Qt);
												var Nt = j(Qt, 2),
													or = A(Nt),
													cr = j(or),
													Vr = A(cr);
												k(cr), k(Nt), k(tr);
												var mr = j(tr),
													hr = A(mr, !0);
												k(mr);
												var _r = j(mr),
													Ir = A(_r);
												Ir.__click = [hE, a, St];
												var qr = A(Ir, !0);
												k(Ir),
													k(_r),
													k(Lt),
													We(
														(ue, V, U) => {
															de($t, x(wt) + 1),
																Tr(Qt, "data-tip", x(_t).name),
																de(Ot, x(_t).flag),
																zr(Nt, 1, `font-semibold ${ue ?? ""}`),
																de(or, `${x(St).name ?? ""} `),
																de(Vr, `#${x(St).number ?? ""}`),
																de(hr, V),
																de(qr, U);
														},
														[
															() => Oi(x(St).cityId),
															() => x(St).pixelsPainted.toLocaleString("en-US"),
															() => kx(),
														]
													),
													ll(
														Lt,
														() => cl,
														() => ({ duration: 200 })
													),
													$(xt, Lt);
											}
										),
											k(yt),
											k(oe),
											We(
												(xt, St, wt, _t) => {
													de(it, xt),
														de(It, `${St ?? ""} `),
														de(Dt, `${wt ?? ""} `),
														Tr(at, "data-tip", _t);
												},
												[
													() => iC(),
													() => vc(),
													() => yc().toLowerCase(),
													() => hC(),
												]
											),
											$(re, oe);
									},
									ee = (re) => {
										var he = er(),
											oe = Ct(he);
										{
											var ze = (pt) => {
													var it = mE(),
														ct = A(it),
														It = A(ct),
														Dt = j(A(It)),
														at = A(Dt, !0);
													k(Dt);
													var dt = j(Dt),
														yt = A(dt),
														xt = j(yt, 2),
														St = j(xt),
														wt = A(St);
													Uu(wt, {
														class:
															"text-base-content/50 mb-0.5 ml-1 inline size-4",
													}),
														k(St),
														k(dt),
														k(It),
														k(ct);
													var _t = j(ct);
													hi(
														_t,
														31,
														() => x(X),
														(Lt) => Lt.id,
														(Lt, Rt, $t) => {
															const tr = ft(() => So(x(Rt).id));
															var Qt = fE(),
																Ot = A(Qt),
																Nt = A(Ot, !0);
															k(Ot);
															var or = j(Ot),
																cr = A(or),
																Vr = A(cr, !0);
															k(cr);
															var mr = j(cr, 2),
																hr = A(mr, !0);
															k(mr), k(or);
															var _r = j(or),
																Ir = A(_r, !0);
															k(_r),
																k(Qt),
																We(
																	(qr, ue) => {
																		de(Nt, x($t) + 1),
																			Tr(cr, "data-tip", x(tr).name),
																			de(Vr, x(tr).flag),
																			zr(mr, 1, `font-semibold ${qr ?? ""}`),
																			de(hr, x(tr).name),
																			de(Ir, ue);
																	},
																	[
																		() => Oi(x(Rt).id),
																		() =>
																			x(Rt).pixelsPainted.toLocaleString(
																				"en-US"
																			),
																	]
																),
																ll(
																	Qt,
																	() => cl,
																	() => ({ duration: 200 })
																),
																$(Lt, Qt);
														}
													),
														k(_t),
														k(it),
														We(
															(Lt, Rt, $t, tr) => {
																de(at, Lt),
																	de(yt, `${Rt ?? ""} `),
																	de(xt, `${$t ?? ""} `),
																	Tr(St, "data-tip", tr);
															},
															[
																() => Uv(),
																() => vc(),
																() => yc().toLowerCase(),
																() => VC(),
															]
														),
														$(pt, it);
												},
												je = (pt) => {
													var it = er(),
														ct = Ct(it);
													{
														var It = (at) => {
																const dt = ft(() => x(X));
																var yt = yE(),
																	xt = A(yt),
																	St = A(xt),
																	wt = j(A(St)),
																	_t = A(wt, !0);
																k(wt);
																var Lt = j(wt),
																	Rt = A(Lt),
																	$t = j(Rt, 2, !0);
																k(Lt), k(St), k(xt);
																var tr = j(xt);
																hi(
																	tr,
																	31,
																	() => x(dt),
																	(Qt) => Qt.id,
																	(Qt, Ot, Nt) => {
																		const or = ft(() => {
																			var ye;
																			return (
																				((ye = Mt.data) == null
																					? void 0
																					: ye.id) === x(Ot).id
																			);
																		});
																		var cr = vE();
																		let Vr;
																		var mr = A(cr),
																			hr = A(mr, !0);
																		k(mr);
																		var _r = j(mr),
																			Ir = A(_r),
																			qr = A(Ir);
																		co(qr, {
																			class: "size-8 border sm:size-10",
																			get userId() {
																				return x(Ot).id;
																			},
																			get pictureUrl() {
																				return x(Ot).picture;
																			},
																		});
																		var ue = j(qr, 2),
																			V = A(ue),
																			U = A(V),
																			Y = j(U),
																			ie = A(Y);
																		k(Y), k(V);
																		var pe = j(V, 2);
																		{
																			var Se = (ye) => {
																				const Bt = ft(() =>
																					So(x(Ot).equippedFlag)
																				);
																				var rr = _E(),
																					Kt = A(rr, !0);
																				k(rr),
																					We(() => {
																						Tr(rr, "data-tip", x(Bt).name),
																							de(Kt, x(Bt).flag);
																					}),
																					$(ye, rr);
																			};
																			Oe(pe, (ye) => {
																				x(Ot).equippedFlag && ye(Se);
																			});
																		}
																		var Me = j(pe, 2);
																		{
																			var we = (ye) => {
																				Eh(ye, {
																					get username() {
																						return x(Ot).discord;
																					},
																					get id() {
																						return x(Ot).discordId;
																					},
																				});
																			};
																			Oe(Me, (ye) => {
																				x(Ot).discord && ye(we);
																			});
																		}
																		var Ve = j(Me, 2);
																		{
																			var ut = (ye) => {
																				var Bt = gE(),
																					rr = A(Bt, !0);
																				k(Bt),
																					We(
																						(Kt, gr) => {
																							zr(
																								Bt,
																								1,
																								`badge badge-sm ml-0.5 border-0 ${
																									Kt ?? ""
																								} ${gr ?? ""}`
																							),
																								de(rr, x(Ot).allianceName);
																						},
																						[
																							() => pp(x(Ot).allianceId),
																							() => Oi(x(Ot).allianceId),
																						]
																					),
																					$(ye, Bt);
																			};
																			Oe(Ve, (ye) => {
																				"allianceName" in x(Ot) &&
																					x(Ot).allianceName &&
																					ye(ut);
																			});
																		}
																		k(ue), k(Ir), k(_r);
																		var Ke = j(_r),
																			kt = A(Ke, !0);
																		k(Ke),
																			k(cr),
																			We(
																				(ye, Bt, rr) => {
																					(Vr = zr(cr, 1, "", null, Vr, ye)),
																						de(hr, x(Nt) + 1),
																						zr(
																							V,
																							1,
																							`font-semibold max-sm:ml-2 ${
																								Bt ?? ""
																							} flex gap-1`
																						),
																						de(U, `${x(Ot).name ?? ""} `),
																						de(ie, `#${x(Ot).id ?? ""}`),
																						de(kt, rr);
																				},
																				[
																					() => ({ "bg-base-200": x(or) }),
																					() => Oi(x(Ot).id),
																					() =>
																						x(Ot).pixelsPainted.toLocaleString(
																							"en-US"
																						),
																				]
																			),
																			ll(
																				cr,
																				() => cl,
																				() => ({ duration: 200 })
																			),
																			$(Qt, cr);
																	}
																),
																	k(tr),
																	k(yt),
																	We(
																		(Qt, Ot, Nt) => {
																			de(_t, Qt),
																				de(Rt, `${Ot ?? ""} `),
																				de($t, Nt);
																		},
																		[
																			() => Dm(),
																			() => vc(),
																			() => yc().toLowerCase(),
																		]
																	),
																	$(at, yt);
															},
															Dt = (at) => {
																var dt = er(),
																	yt = Ct(dt);
																{
																	var xt = (St) => {
																		var wt = bE(),
																			_t = A(wt),
																			Lt = A(_t),
																			Rt = j(A(Lt)),
																			$t = A(Rt, !0);
																		k(Rt);
																		var tr = j(Rt),
																			Qt = A(tr),
																			Ot = j(Qt, 2, !0);
																		k(tr), k(Lt), k(_t);
																		var Nt = j(_t);
																		hi(
																			Nt,
																			31,
																			() => x(X),
																			(or) => or.id,
																			(or, cr, Vr) => {
																				const mr = ft(() => {
																					var pe;
																					return (
																						((pe = Mt.data) == null
																							? void 0
																							: pe.allianceId) === x(cr).id
																					);
																				});
																				var hr = xE();
																				let _r;
																				var Ir = A(hr),
																					qr = A(Ir, !0);
																				k(Ir);
																				var ue = j(Ir),
																					V = A(ue),
																					U = A(V, !0);
																				k(V), k(ue);
																				var Y = j(ue),
																					ie = A(Y, !0);
																				k(Y),
																					k(hr),
																					We(
																						(pe, Se, Me) => {
																							(_r = zr(
																								hr,
																								1,
																								"",
																								null,
																								_r,
																								pe
																							)),
																								de(qr, x(Vr) + 1),
																								zr(
																									V,
																									1,
																									`font-semibold ${Se ?? ""}`
																								),
																								de(U, x(cr).name),
																								de(ie, Me);
																						},
																						[
																							() => ({ "bg-base-200": x(mr) }),
																							() => Oi(x(cr).id),
																							() =>
																								x(
																									cr
																								).pixelsPainted.toLocaleString(
																									"en-US"
																								),
																						]
																					),
																					ll(
																						hr,
																						() => cl,
																						() => ({ duration: 200 })
																					),
																					$(or, hr);
																			}
																		),
																			k(Nt),
																			k(wt),
																			We(
																				(or, cr, Vr) => {
																					de($t, or),
																						de(Qt, `${cr ?? ""} `),
																						de(Ot, Vr);
																				},
																				[
																					() => _p(),
																					() => vc(),
																					() => yc().toLowerCase(),
																				]
																			),
																			$(St, wt);
																	};
																	Oe(
																		yt,
																		(St) => {
																			x(s) === "alliances" && St(xt);
																		},
																		!0
																	);
																}
																$(at, dt);
															};
														Oe(
															ct,
															(at) => {
																x(s) === "players" ? at(It) : at(Dt, !1);
															},
															!0
														);
													}
													$(pt, it);
												};
											Oe(
												oe,
												(pt) => {
													x(s) === "countries" ? pt(ze) : pt(je, !1);
												},
												!0
											);
										}
										$(re, he);
									};
								Oe(ke, (re) => {
									x(s) === "regions" ? re(vt) : re(ee, !1);
								});
							}
							$(nt, Ue);
						},
						et = (nt) => {
							var Ue = wE();
							$(nt, Ue);
						};
					Oe(
						Qe,
						(nt) => {
							x(X) ? nt(Le) : nt(et, !1);
						},
						!0
					);
				}
				$(qe, Ze);
			};
		Oe(Fe, (qe) => {
			x(X) && x(X).length === 0 ? qe($e) : qe(Je, !1);
		});
	}
	mp("innerWidth", (qe) => se(y, qe, !0)), $(m, ne), Dr();
}
$n(["click"]);
var SE = Pr(
	'<svg><path d="M160-200h160v-320H160v320Zm240 0h160v-560H400v560Zm240 0h160v-240H640v240ZM80-120v-480h240v-240h320v320h240v400H80Z"></path></svg>'
);
function I0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = SE();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var PE = Te(
	'<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl max-sm:size-full max-sm:rounded-none max-sm:px-3 max-sm:py-5 sm:overflow-x-hidden"><form method="dialog"><button class="btn btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold"> </h3></div> <div class="mt-4"><!></div></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
);
function IE(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const K = (ne) => {
			ne.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", K),
			() => document.removeEventListener("keydown", K)
		);
	});
	var y = PE(),
		M = A(y),
		z = j(A(M), 2),
		T = A(z);
	I0(T, { class: "size-6" });
	var s = j(T, 2),
		B = A(s, !0);
	k(s), k(z);
	var O = j(z, 2),
		X = A(O);
	CE(X, {
		get onvisitclick() {
			return a.onvisitclick;
		},
		get open() {
			return p();
		},
	}),
		k(O),
		k(M),
		yn(2),
		k(y),
		Ni(y, () => (K) => {
			Wr(() => {
				p() ? K.show() : K.close();
			});
		}),
		We((K) => de(B, K), [() => Bm()]),
		di("close", y, () => p(!1)),
		$(m, y),
		Dr();
}
var ME = Te("<div><!></div>"),
	kE = Te(
		'<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function AE(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	Fn(() => {
		const s = (B) => {
			B.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", s),
			() => document.removeEventListener("keydown", s)
		);
	});
	var y = kE(),
		M = A(y),
		z = j(A(M), 2);
	{
		var T = (s) => {
			var B = ME(),
				O = A(B);
			jx(O, {}),
				k(B),
				Ai(
					2,
					B,
					() => ia,
					() => ({ duration: 300 })
				),
				$(s, B);
		};
		Oe(z, (s) => {
			p() && s(T);
		});
	}
	k(M),
		yn(2),
		k(y),
		Ni(y, () => (s) => {
			Wr(() => {
				p() ? s.show() : s.close();
			});
		}),
		di("close", y, () => p(!1)),
		$(m, y),
		Dr();
}
var EE = (m, a, p) => {
		localStorage.setItem(x(a), "true"), se(p, !1);
	},
	zE = Te(
		'<span class="indicator-item indicator-bottom indicator-center badge badge-primary badge-xs">new</span>'
	),
	LE = Te("<div><!> <!></div>");
function jf(m, a) {
	Lr(a, !0);
	let p = st(!1);
	const y = ft(() => "showed:" + a.key);
	Fn(() => {
		se(p, !localStorage.getItem(x(y)));
	});
	var M = LE();
	M.__click = [EE, y, p];
	var z = A(M);
	{
		var T = (B) => {
			var O = zE();
			Ai(
				3,
				O,
				() => ia,
				() => ({ duration: 200 })
			),
				$(B, O);
		};
		Oe(z, (B) => {
			x(p) && B(T);
		});
	}
	var s = j(z, 2);
	oi(s, () => a.children),
		k(M),
		We(() => zr(M, 1, `indicator ${a.class ?? ""}`)),
		$(m, M),
		Dr();
}
$n(["click"]);
var DE = Te("<p>You don't have charges to paint. <br/> </p>");
function RE(m, a) {
	Lr(a, !1), Nv();
	var p = DE(),
		y = j(A(p), 2);
	k(p),
		We(
			(M) => de(y, ` Next charge in ${M ?? ""}`),
			[() => rp(Mt.cooldown ?? 0)]
		),
		$(m, p),
		Dr();
}
var BE = Te("<canvas></canvas>");
function M0(m, a) {
	Lr(a, !0);
	let p = zt(a, "width", 15, 0),
		y = nr(a, [
			"$$slots",
			"$$events",
			"$$legacy",
			"value",
			"fontSize",
			"color",
			"weight",
			"mono",
			"width",
		]),
		M = ft(() => Math.ceil(a.fontSize)),
		z = st(null);
	const T = window.devicePixelRatio ?? 1,
		s =
			'"Geist", ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
		B =
			'"Geist Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
	Wr(() => {
		const X = x(z).getContext("2d");
		(X.textBaseline = "top"),
			(X.font = `${a.weight ?? "normal"} ${a.fontSize}px ${a.mono ? B : s}`),
			(X.fillStyle = a.color ?? "#394e6a"),
			X.setTransform(T, 0, 0, T, 0, 0),
			X.clearRect(0, 0, p(), x(M)),
			X.fillText(a.value, 0, 0);
		const K = X.measureText(a.value);
		p(Math.ceil(K.actualBoundingBoxRight)), se(M, K.actualBoundingBoxDescent);
	});
	var O = BE();
	ar(O, () => ({
		width: p() * T,
		height: x(M) * T,
		style: `width: ${p() ?? ""}px; height: ${x(M) ?? ""}px`,
		...y,
	})),
		Ko(
			O,
			(X) => se(z, X),
			() => x(z)
		),
		$(m, O),
		Dr();
}
var FE = Te('<span class="w-7 text-xs"> </span>'),
	OE = Te(
		'<span class="flex items-center gap-1 sm:mt-[1px]"><span><!></span> <!></span>'
	),
	NE = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	jE = Te(
		'<button><!> <div class="flex items-center gap-2"> <!></div> <!></button>'
	);
function k0(m, a) {
	Lr(a, !0);
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "loading", "charges"]),
		y = st(0);
	var M = jE();
	ar(M, () => ({
		...p,
		class: `btn btn-primary btn-lg sm:btn-xl relative ${a.class ?? ""}`,
	}));
	var z = A(M);
	zh(z, { class: "size-6" });
	var T = j(z, 2),
		s = A(T),
		B = j(s);
	{
		var O = (ne) => {
			const H = ft(() => `${Math.floor(a.charges)}/${Mt.data.charges.max}`);
			var fe = OE(),
				ge = A(fe),
				Ie = A(ge);
			{
				let Ee = ft(() => (a.disabled ? "#394e6a33" : "#ffffff"));
				M0(Ie, {
					weight: 600,
					fontSize: 16,
					get value() {
						return x(H);
					},
					get color() {
						return x(Ee);
					},
					get width() {
						return x(y);
					},
					set width(Fe) {
						se(y, Fe, !0);
					},
				});
			}
			k(ge);
			var Ae = j(ge, 2);
			{
				var De = (Ee) => {
					var Fe = FE(),
						$e = A(Fe);
					k(Fe),
						We((Je) => de($e, `(${Je ?? ""})`), [() => rp(Mt.cooldown)]),
						$(Ee, Fe);
				};
				Oe(Ae, (Ee) => {
					a.charges < Mt.data.charges.max && Mt.cooldown !== void 0 && Ee(De);
				});
			}
			k(fe),
				We(
					(Ee) => kc(ge, `width: ${Ee ?? ""}px`),
					[() => (Math.floor(x(y) / 5) + 1) * 5]
				),
				$(ne, fe);
		};
		Oe(B, (ne) => {
			a.charges !== void 0 && Mt.data && ne(O);
		});
	}
	k(T);
	var X = j(T, 2);
	{
		var K = (ne) => {
			var H = NE();
			$(ne, H);
		};
		Oe(X, (ne) => {
			a.loading && ne(K);
		});
	}
	k(M), We((ne) => de(s, `${ne ?? ""} `), [() => Gv()]), $(m, M), Dr();
}
const VE =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAABVQTFRFAAAASkKEenHEta7xWmmLi5y0v8vc+SuCVQAAAAF0Uk5TAEDm2GYAAAA/SURBVHjaXcjBDcAwDMNAUW28/8hF0MCIzN9RV7aVfuxp+IGPe+AdPQRpFaRrgcNrn/Bb4LAE4W5aNb3TXUofoSgBYpzN5I4AAAAASUVORK5CYII=",
	qE =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAFxJREFUeNq107EJACAMRFEHyxSu4jbuZ+0IyhUS4ZDogYEr3++Svp+ZDUzGrRTMIwKmiIApImCKiBgbOXOEcRxQsQcW7rVKeA9gj5gD2D3mgC/GcQSLMEdO+/qtE+/GV5duYCOPAAAAAElFTkSuQmCC",
	ZE =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAAXNSR0IArs4c6QAAAAJ0Uk5TAAB2k804AAAAKklEQVR42mOAAhsbCA3n//9vQ74ApqE2QIAgwIqBykFaICwMAQwt9HEpAIf2Me1Ro5Q9AAAAAElFTkSuQmCC",
	UE =
		"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAABVJREFUeNpjYGA48x8DYwoB1Q0RlQDDCVmniJ241gAAAABJRU5ErkJggg==";
class $E {
	constructor(a) {
		xr(this, "gm");
		xr(this, "opacity", 1);
		xr(this, "id", `paint-preview-${Math.random()}`);
		xr(this, "tiles", new Map());
		(this.input = a), (this.gm = new fl(this.input.tileSize));
	}
	place([a, p], y) {
		const { tile: M, pixel: z } = this.gm.latLonToTileAndPixel(
				a,
				p,
				this.input.tileZoom
			),
			T = this.getTileKey(M[0], M[1]);
		let s = this.tiles.get(T);
		if (!s) {
			const B = this.gm.tileBoundsLatLon(M[0], M[1], this.input.tileZoom),
				O = Vm(B, !0),
				X = new GE({
					coordinates: O,
					id: `${this.id}-${T}`,
					layerPaint: {
						"raster-opacity": this.opacity,
						"raster-resampling": "nearest",
					},
					tileSize: this.input.tileSize,
					beforeLayerId: this.input.beforeLayerId,
				});
			X.addTo(this.input.map), this.tiles.set(T, X), (s = X);
		}
		s.place(z[0], this.input.tileSize - z[1] - 1, y);
	}
	clear() {
		const a = this.input.map;
		for (const p of this.tiles.values()) p.removeFrom(a), p.removeDOM();
		this.tiles.clear();
	}
	clearAndPlace(a, p) {
		this.clear(), this.place(a, p);
	}
	remove([a, p]) {
		const { tile: y, pixel: M } = this.gm.latLonToTileAndPixel(
				a,
				p,
				this.input.tileZoom
			),
			z = this.getTileKey(y[0], y[1]),
			T = this.tiles.get(z);
		T && T.remove(M[0], this.input.tileSize - M[1] - 1);
	}
	setCanvasOpacity(a) {
		this.opacity = a;
		for (const p of this.tiles.values()) p.setOpacity(a);
	}
	getTileKey(a, p) {
		return `${a},${p}`;
	}
}
class GE {
	constructor(a) {
		xr(this, "canvas");
		xr(this, "maps", new Set());
		this.input = a;
		const p = this.input.tileSize;
		(this.canvas = document.createElement("canvas")),
			(this.canvas.width = p),
			(this.canvas.height = p);
	}
	place(a, p, y) {
		var T;
		const M = ((T = Wi.colors) == null ? void 0 : T[y]) ?? Wi.colors[0],
			z = this.canvas.getContext("2d");
		if (z) {
			const s = z.createImageData(1, 1),
				[B, O, X] = M.rgb,
				K = y === 0 ? 0 : 255;
			(s.data[0] = B),
				(s.data[1] = O),
				(s.data[2] = X),
				(s.data[3] = K),
				z.putImageData(s, a, p);
		}
	}
	remove(a, p) {
		const y = this.canvas.getContext("2d");
		y && y.clearRect(a, p, 1, 1);
	}
	addTo(a) {
		const p = this.input.id;
		a.getSource(p) ||
			a.addSource(p, {
				type: "canvas",
				canvas: this.canvas,
				coordinates: this.input.coordinates,
			}),
			a.getLayer(p) ||
				(a.addLayer({
					id: p,
					type: "raster",
					source: p,
					paint: this.input.layerPaint,
				}),
				this.input.beforeLayerId && a.moveLayer(p, this.input.beforeLayerId)),
			this.maps.add(a);
	}
	removeFrom(a) {
		const { id: p } = this.input;
		a.getLayer(p) && a.removeLayer(p),
			a.getSource(p) && a.removeSource(p),
			this.maps.delete(a);
	}
	removeDOM() {
		this.canvas.remove();
	}
	setOpacity(a) {
		for (const p of this.maps.values())
			p.setPaintProperty(this.input.id, "raster-opacity", a);
	}
}
var HE = Pr(
	'<svg><path d="M5 21C4.45 21 3.97917 20.8042 3.5875 20.4125C3.19583 20.0208 3 19.55 3 19V15H5V19H9V21H5ZM15 21V19H19V15H21V19C21 19.55 20.8042 20.0208 20.4125 20.4125C20.0208 20.8042 19.55 21 19 21H15ZM3 9V5C3 4.45 3.19583 3.97917 3.5875 3.5875C3.97917 3.19583 4.45 3 5 3H9V5H5V9H3ZM19 9V5H15V3H19C19.55 3 20.0208 3.19583 20.4125 3.5875C20.8042 3.97917 21 4.45 21 5V9H19Z"></path></svg>'
);
function WE(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = HE();
	ar(y, () => ({
		viewBox: "0 0 24 24",
		fill: "currentColor",
		xmlns: "http://www.w3.org/2000/svg",
		...p,
	})),
		$(m, y);
}
var XE = Pr(
	'<svg><path d="M5 19H9V21H5C4.45 21 3.97956 20.8038 3.58789 20.4121C3.19622 20.0204 3 19.55 3 19V15H5V19ZM20.6768 20.0908C20.6015 20.2031 20.5138 20.3105 20.4121 20.4121C20.0204 20.8038 19.55 21 19 21H15V19H19V18.4141L20.6768 20.0908ZM21 17.5859L19 15.5859V15H21V17.5859ZM5.58594 5H5V9H3V5C3 4.45 3.19622 3.97956 3.58789 3.58789C3.68947 3.48631 3.79597 3.3975 3.9082 3.32227L5.58594 5ZM19 3C19.55 3 20.0204 3.19622 20.4121 3.58789C20.8038 3.97956 21 4.45 21 5V9H19V5H15V3H19ZM9 5H8.41406L6.41406 3H9V5Z"></path><rect x="1" y="2.41422" width="2" height="29" transform="rotate(-45 1 2.41422)"></rect></svg>'
);
function YE(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = XE();
	ar(y, () => ({
		viewBox: "0 0 24 24",
		fill: "currentColor",
		xmlns: "http://www.w3.org/2000/svg",
		...p,
	})),
		$(m, y);
}
var KE = Te("<div><!></div>");
function ol(m, a) {
	Lr(a, !0);
	var p = KE(),
		y = A(p);
	oi(y, () => a.children ?? pa),
		k(p),
		We(() =>
			zr(
				p,
				1,
				`bg-base-100/60 border-base-content/20 -top-15 pointer-events-none absolute left-1/2 line-clamp-1 flex w-max -translate-x-1/2 select-none items-center gap-1 rounded-full border-2 px-3 py-1.5 ${
					a.class ?? ""
				}`
			)
		),
		$(m, p),
		Dr();
}
var JE = Te('<div class="confetti svelte-15ksp55"></div>'),
	QE = Te("<div></div>");
function Xm(m, a) {
	Lr(a, !0);
	const p = zt(a, "size", 3, 10),
		y = zt(a, "x", 19, () => [-0.5, 0.5]),
		M = zt(a, "y", 19, () => [0.25, 1]),
		z = zt(a, "duration", 3, 2e3),
		T = zt(a, "infinite", 3, !1),
		s = zt(a, "delay", 19, () => [0, 50]),
		B = zt(a, "colorRange", 19, () => [0, 360]),
		O = zt(a, "colorArray", 19, () => []),
		X = zt(a, "amount", 3, 50),
		K = zt(a, "iterationCount", 3, 1),
		ne = zt(a, "fallDistance", 3, "100px"),
		H = zt(a, "rounded", 3, !1),
		fe = zt(a, "cone", 3, !1),
		ge = zt(a, "noGravity", 3, !1),
		Ie = zt(a, "xSpread", 3, 0.15),
		Ae = zt(a, "destroyOnComplete", 3, !0),
		De = zt(a, "disableForReducedMotion", 3, !1);
	let Ee = st(!1);
	Fn(() => {
		!Ae() ||
			T() ||
			typeof K() == "string" ||
			setTimeout(() => se(Ee, !0), (z() + s()[1]) * K());
	});
	function Fe(Qe, Le) {
		return Math.random() * (Le - Qe) + Qe;
	}
	function $e() {
		return O().length
			? O()[Math.round(Math.random() * (O().length - 1))]
			: `hsl(${Math.round(Fe(B()[0], B()[1]))}, 75%, 50%)`;
	}
	var Je = er(),
		qe = Ct(Je);
	{
		var Ze = (Qe) => {
			var Le = QE();
			let et;
			hi(
				Le,
				21,
				() => ({ length: X() }),
				hp,
				(nt, Ue) => {
					var ke = JE();
					We(
						(vt, ee, re, he, oe, ze, je, pt, it, ct, It) =>
							kc(
								ke,
								`
        --color: ${vt ?? ""};
        --skew: ${ee ?? ""}deg,${re ?? ""}deg;
        --rotation-xyz: ${he ?? ""}, ${oe ?? ""}, ${ze ?? ""};
        --rotation-deg: ${je ?? ""}deg;
        --translate-y-multiplier: ${pt ?? ""};
        --translate-x-multiplier: ${it ?? ""};
        --scale: ${ct ?? ""};
        --transition-delay: ${It ?? ""}ms;
        --transition-duration: ${
					T() ? `calc(${z()}ms * var(--scale))` : `${z()}ms`
				};`
							),
						[
							$e,
							() => Fe(-45, 45),
							() => Fe(-45, 45),
							() => Fe(-10, 10),
							() => Fe(-10, 10),
							() => Fe(-10, 10),
							() => Fe(0, 360),
							() => Fe(M()[0], M()[1]),
							() => Fe(y()[0], y()[1]),
							() => 0.1 * Fe(2, 10),
							() => Fe(s()[0], s()[1]),
						]
					),
						$(nt, ke);
				}
			),
				k(Le),
				We(
					(nt) => {
						(et = zr(Le, 1, "confetti-holder svelte-15ksp55", null, et, nt)),
							kc(
								Le,
								`
    --fall-distance: ${ne() ?? ""};
    --size: ${p() ?? ""}px;
    --x-spread: ${1 - Ie()};
    --transition-iteration-count: ${(T() ? "infinite" : K()) ?? ""};`
							);
					},
					[
						() => ({
							rounded: H(),
							cone: fe(),
							"no-gravity": ge(),
							"reduced-motion": De(),
						}),
					]
				),
				$(Qe, Le);
		};
		Oe(qe, (Qe) => {
			x(Ee) || Qe(Ze);
		});
	}
	$(m, Je), Dr();
}
var e8 = async (m, a, p, y) => {
		try {
			se(a, !0),
				await Qr.purchase({ id: p, amount: 1, variant: y.colorIdx }),
				await Mt.refresh(),
				aa.notification1.play();
		} catch (M) {
			Fr.error(M.message);
		} finally {
			se(a, !1);
		}
	},
	t8 = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	r8 = Te('<!> <span class="text-sm">Droplets</span>', 1),
	n8 = Te('<!> Unlocked <span class="center-absolute absolute"><!></span>', 1),
	i8 = (m, a) => a(!1),
	a8 = Te(
		'<div class="flex flex-col gap-4"><section><div class="flex items-center gap-1"><!> <h3 class="text-xl font-bold">Unlock</h3> <div class="ml-auto mr-4"><!></div></div> <p class="text-base-content/80 mt-1 text-sm">Permanently unlock the color</p></section> <div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="border-base-content/20 size-32 rounded-2xl border-4"></div></div> <p class="mt-4 text-center text-2xl font-bold"> </p> <div class="flex w-max flex-col"><div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!></button></div> <button class="btn relative mt-3 h-10">Close</button></div></div></div>'
	),
	o8 = Te(
		'<dialog class="modal !bg-black/80"><div class="modal-box max-h-11/12 w-11/12 max-w-md"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function s8(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	const y = ft(() => Wi.colors[a.colorIdx]),
		M = ft(() => {
			var H;
			return ((H = Mt.data) == null ? void 0 : H.droplets) ?? 0;
		});
	let z = st(!1);
	const T = ft(() => (x(z), Mt.hasColor(a.colorIdx)));
	Fn(() => {
		const H = (fe) => {
			fe.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", H),
			() => document.removeEventListener("keydown", H)
		);
	});
	const s = 100,
		B = Wi.products[s];
	var O = o8(),
		X = A(O),
		K = j(A(X), 2);
	{
		var ne = (H) => {
			var fe = a8(),
				ge = A(fe),
				Ie = A(ge),
				Ae = A(Ie);
			np(Ae, { class: "size-6" });
			var De = j(Ae, 4),
				Ee = A(De);
			Fv(Ee, {
				get value() {
					return x(M);
				},
			}),
				k(De),
				k(Ie),
				yn(2),
				k(ge);
			var Fe = j(ge, 2),
				$e = A(Fe),
				Je = A($e);
			k($e);
			var qe = j($e, 2),
				Ze = A(qe, !0);
			k(qe);
			var Qe = j(qe, 2),
				Le = A(Qe);
			let et;
			var nt = A(Le);
			nt.__click = [e8, z, s, a];
			var Ue = A(nt);
			{
				var ke = (oe) => {
					var ze = t8();
					$(oe, ze);
				};
				Oe(Ue, (oe) => {
					x(z) && oe(ke);
				});
			}
			var vt = j(Ue, 2);
			{
				var ee = (oe) => {
						var ze = r8(),
							je = Ct(ze);
						fp(je, { class: "size-5" });
						var pt = j(je);
						yn(),
							We(
								(it) => de(pt, ` ${it ?? ""} `),
								[() => B.price.toLocaleString("en-US")]
							),
							$(oe, ze);
					},
					re = (oe) => {
						var ze = n8(),
							je = Ct(ze);
						np(je, { class: "size-5" });
						var pt = j(je, 2),
							it = A(pt);
						Xm(it, {}), k(pt), $(oe, ze);
					};
				Oe(vt, (oe) => {
					x(T) ? oe(re, !1) : oe(ee);
				});
			}
			k(nt), k(Le);
			var he = j(Le, 2);
			(he.__click = [i8, p]),
				k(Qe),
				k(Fe),
				k(fe),
				We(
					(oe, ze) => {
						kc(
							Je,
							`background: rgb(${x(y).rgb[0]} ${x(y).rgb[1]} ${x(y).rgb[2]})`
						),
							Tr(Je, "aria-label", x(y).name),
							de(Ze, x(y).name),
							Tr(Le, "data-tip", oe),
							(et = zr(Le, 1, "", null, et, ze)),
							(nt.disabled = x(M) < B.price || x(z) || x(T));
					},
					[() => gp(), () => ({ tooltip: !x(T) && x(M) < B.price })]
				),
				$(H, fe);
		};
		Oe(K, (H) => {
			Mt.data && H(ne);
		});
	}
	k(X),
		yn(2),
		k(O),
		Ni(O, () => (H) => {
			Wr(() => {
				p() ? H.show() : H.close();
			});
		}),
		di("close", O, () => p(!1)),
		$(m, O),
		Dr();
}
$n(["click"]);
var Tm = function () {
	return (
		(Tm =
			Object.assign ||
			function (a) {
				for (var p, y = 1, M = arguments.length; y < M; y++) {
					p = arguments[y];
					for (var z in p)
						Object.prototype.hasOwnProperty.call(p, z) && (a[z] = p[z]);
				}
				return a;
			}),
		Tm.apply(this, arguments)
	);
};
function Po(m, a, p, y) {
	function M(z) {
		return z instanceof p
			? z
			: new p(function (T) {
					T(z);
			  });
	}
	return new (p || (p = Promise))(function (z, T) {
		function s(X) {
			try {
				O(y.next(X));
			} catch (K) {
				T(K);
			}
		}
		function B(X) {
			try {
				O(y.throw(X));
			} catch (K) {
				T(K);
			}
		}
		function O(X) {
			X.done ? z(X.value) : M(X.value).then(s, B);
		}
		O((y = y.apply(m, a || [])).next());
	});
}
function Io(m, a) {
	var p = {
			label: 0,
			sent: function () {
				if (z[0] & 1) throw z[1];
				return z[1];
			},
			trys: [],
			ops: [],
		},
		y,
		M,
		z,
		T = Object.create(
			(typeof Iterator == "function" ? Iterator : Object).prototype
		);
	return (
		(T.next = s(0)),
		(T.throw = s(1)),
		(T.return = s(2)),
		typeof Symbol == "function" &&
			(T[Symbol.iterator] = function () {
				return this;
			}),
		T
	);
	function s(O) {
		return function (X) {
			return B([O, X]);
		};
	}
	function B(O) {
		if (y) throw new TypeError("Generator is already executing.");
		for (; T && ((T = 0), O[0] && (p = 0)), p; )
			try {
				if (
					((y = 1),
					M &&
						(z =
							O[0] & 2
								? M.return
								: O[0]
								? M.throw || ((z = M.return) && z.call(M), 0)
								: M.next) &&
						!(z = z.call(M, O[1])).done)
				)
					return z;
				switch (((M = 0), z && (O = [O[0] & 2, z.value]), O[0])) {
					case 0:
					case 1:
						z = O;
						break;
					case 4:
						return p.label++, { value: O[1], done: !1 };
					case 5:
						p.label++, (M = O[1]), (O = [0]);
						continue;
					case 7:
						(O = p.ops.pop()), p.trys.pop();
						continue;
					default:
						if (
							((z = p.trys),
							!(z = z.length > 0 && z[z.length - 1]) &&
								(O[0] === 6 || O[0] === 2))
						) {
							p = 0;
							continue;
						}
						if (O[0] === 3 && (!z || (O[1] > z[0] && O[1] < z[3]))) {
							p.label = O[1];
							break;
						}
						if (O[0] === 6 && p.label < z[1]) {
							(p.label = z[1]), (z = O);
							break;
						}
						if (z && p.label < z[2]) {
							(p.label = z[2]), p.ops.push(O);
							break;
						}
						z[2] && p.ops.pop(), p.trys.pop();
						continue;
				}
				O = a.call(m, p);
			} catch (X) {
				(O = [6, X]), (M = 0);
			} finally {
				y = z = 0;
			}
		if (O[0] & 5) throw O[1];
		return { value: O[0] ? O[1] : void 0, done: !0 };
	}
}
function A0(m, a, p) {
	if (p || arguments.length === 2)
		for (var y = 0, M = a.length, z; y < M; y++)
			(z || !(y in a)) &&
				(z || (z = Array.prototype.slice.call(a, 0, y)), (z[y] = a[y]));
	return m.concat(z || Array.prototype.slice.call(a));
}
var E0 = "4.6.2";
function ip(m, a) {
	return new Promise(function (p) {
		return setTimeout(p, m, a);
	});
}
function l8() {
	return new Promise(function (m) {
		var a = new MessageChannel();
		(a.port1.onmessage = function () {
			return m();
		}),
			a.port2.postMessage(null);
	});
}
function c8(m, a) {
	a === void 0 && (a = 1 / 0);
	var p = window.requestIdleCallback;
	return p
		? new Promise(function (y) {
				return p.call(
					window,
					function () {
						return y();
					},
					{ timeout: a }
				);
		  })
		: ip(Math.min(m, a));
}
function z0(m) {
	return !!m && typeof m.then == "function";
}
function cv(m, a) {
	try {
		var p = m();
		z0(p)
			? p.then(
					function (y) {
						return a(!0, y);
					},
					function (y) {
						return a(!1, y);
					}
			  )
			: a(!0, p);
	} catch (y) {
		a(!1, y);
	}
}
function uv(m, a, p) {
	return (
		p === void 0 && (p = 16),
		Po(this, void 0, void 0, function () {
			var y, M, z, T;
			return Io(this, function (s) {
				switch (s.label) {
					case 0:
						(y = Array(m.length)), (M = Date.now()), (z = 0), (s.label = 1);
					case 1:
						return z < m.length
							? ((y[z] = a(m[z], z)),
							  (T = Date.now()),
							  T >= M + p ? ((M = T), [4, l8()]) : [3, 3])
							: [3, 4];
					case 2:
						s.sent(), (s.label = 3);
					case 3:
						return ++z, [3, 1];
					case 4:
						return [2, y];
				}
			});
		})
	);
}
function $u(m) {
	return m.then(void 0, function () {}), m;
}
function u8(m, a) {
	for (var p = 0, y = m.length; p < y; ++p) if (m[p] === a) return !0;
	return !1;
}
function h8(m, a) {
	return !u8(m, a);
}
function Ym(m) {
	return parseInt(m);
}
function lo(m) {
	return parseFloat(m);
}
function Go(m, a) {
	return typeof m == "number" && isNaN(m) ? a : m;
}
function fa(m) {
	return m.reduce(function (a, p) {
		return a + (p ? 1 : 0);
	}, 0);
}
function L0(m, a) {
	if ((a === void 0 && (a = 1), Math.abs(a) >= 1)) return Math.round(m / a) * a;
	var p = 1 / a;
	return Math.round(m * p) / p;
}
function d8(m) {
	for (
		var a,
			p,
			y = "Unexpected syntax '".concat(m, "'"),
			M = /^\s*([a-z-]*)(.*)$/i.exec(m),
			z = M[1] || void 0,
			T = {},
			s = /([.:#][\w-]+|\[.+?\])/gi,
			B = function (ne, H) {
				(T[ne] = T[ne] || []), T[ne].push(H);
			};
		;

	) {
		var O = s.exec(M[2]);
		if (!O) break;
		var X = O[0];
		switch (X[0]) {
			case ".":
				B("class", X.slice(1));
				break;
			case "#":
				B("id", X.slice(1));
				break;
			case "[": {
				var K = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(
					X
				);
				if (K)
					B(
						K[1],
						(p = (a = K[4]) !== null && a !== void 0 ? a : K[5]) !== null &&
							p !== void 0
							? p
							: ""
					);
				else throw new Error(y);
				break;
			}
			default:
				throw new Error(y);
		}
	}
	return [z, T];
}
function p8(m) {
	for (var a = new Uint8Array(m.length), p = 0; p < m.length; p++) {
		var y = m.charCodeAt(p);
		if (y > 127) return new TextEncoder().encode(m);
		a[p] = y;
	}
	return a;
}
function bs(m, a) {
	var p = m[0] >>> 16,
		y = m[0] & 65535,
		M = m[1] >>> 16,
		z = m[1] & 65535,
		T = a[0] >>> 16,
		s = a[0] & 65535,
		B = a[1] >>> 16,
		O = a[1] & 65535,
		X = 0,
		K = 0,
		ne = 0,
		H = 0;
	(H += z + O),
		(ne += H >>> 16),
		(H &= 65535),
		(ne += M + B),
		(K += ne >>> 16),
		(ne &= 65535),
		(K += y + s),
		(X += K >>> 16),
		(K &= 65535),
		(X += p + T),
		(X &= 65535),
		(m[0] = (X << 16) | K),
		(m[1] = (ne << 16) | H);
}
function Ga(m, a) {
	var p = m[0] >>> 16,
		y = m[0] & 65535,
		M = m[1] >>> 16,
		z = m[1] & 65535,
		T = a[0] >>> 16,
		s = a[0] & 65535,
		B = a[1] >>> 16,
		O = a[1] & 65535,
		X = 0,
		K = 0,
		ne = 0,
		H = 0;
	(H += z * O),
		(ne += H >>> 16),
		(H &= 65535),
		(ne += M * O),
		(K += ne >>> 16),
		(ne &= 65535),
		(ne += z * B),
		(K += ne >>> 16),
		(ne &= 65535),
		(K += y * O),
		(X += K >>> 16),
		(K &= 65535),
		(K += M * B),
		(X += K >>> 16),
		(K &= 65535),
		(K += z * s),
		(X += K >>> 16),
		(K &= 65535),
		(X += p * O + y * B + M * s + z * T),
		(X &= 65535),
		(m[0] = (X << 16) | K),
		(m[1] = (ne << 16) | H);
}
function fc(m, a) {
	var p = m[0];
	(a %= 64),
		a === 32
			? ((m[0] = m[1]), (m[1] = p))
			: a < 32
			? ((m[0] = (p << a) | (m[1] >>> (32 - a))),
			  (m[1] = (m[1] << a) | (p >>> (32 - a))))
			: ((a -= 32),
			  (m[0] = (m[1] << a) | (p >>> (32 - a))),
			  (m[1] = (p << a) | (m[1] >>> (32 - a))));
}
function Na(m, a) {
	(a %= 64),
		a !== 0 &&
			(a < 32
				? ((m[0] = m[1] >>> (32 - a)), (m[1] = m[1] << a))
				: ((m[0] = m[1] << (a - 32)), (m[1] = 0)));
}
function ri(m, a) {
	(m[0] ^= a[0]), (m[1] ^= a[1]);
}
var f8 = [4283543511, 3981806797],
	m8 = [3301882366, 444984403];
function hv(m) {
	var a = [0, m[0] >>> 1];
	ri(m, a),
		Ga(m, f8),
		(a[1] = m[0] >>> 1),
		ri(m, a),
		Ga(m, m8),
		(a[1] = m[0] >>> 1),
		ri(m, a);
}
var $d = [2277735313, 289559509],
	Gd = [1291169091, 658871167],
	dv = [0, 5],
	_8 = [0, 1390208809],
	g8 = [0, 944331445];
function v8(m, a) {
	var p = p8(m);
	a = a || 0;
	var y = [0, p.length],
		M = y[1] % 16,
		z = y[1] - M,
		T = [0, a],
		s = [0, a],
		B = [0, 0],
		O = [0, 0],
		X;
	for (X = 0; X < z; X = X + 16)
		(B[0] = p[X + 4] | (p[X + 5] << 8) | (p[X + 6] << 16) | (p[X + 7] << 24)),
			(B[1] = p[X] | (p[X + 1] << 8) | (p[X + 2] << 16) | (p[X + 3] << 24)),
			(O[0] =
				p[X + 12] | (p[X + 13] << 8) | (p[X + 14] << 16) | (p[X + 15] << 24)),
			(O[1] =
				p[X + 8] | (p[X + 9] << 8) | (p[X + 10] << 16) | (p[X + 11] << 24)),
			Ga(B, $d),
			fc(B, 31),
			Ga(B, Gd),
			ri(T, B),
			fc(T, 27),
			bs(T, s),
			Ga(T, dv),
			bs(T, _8),
			Ga(O, Gd),
			fc(O, 33),
			Ga(O, $d),
			ri(s, O),
			fc(s, 31),
			bs(s, T),
			Ga(s, dv),
			bs(s, g8);
	(B[0] = 0), (B[1] = 0), (O[0] = 0), (O[1] = 0);
	var K = [0, 0];
	switch (M) {
		case 15:
			(K[1] = p[X + 14]), Na(K, 48), ri(O, K);
		case 14:
			(K[1] = p[X + 13]), Na(K, 40), ri(O, K);
		case 13:
			(K[1] = p[X + 12]), Na(K, 32), ri(O, K);
		case 12:
			(K[1] = p[X + 11]), Na(K, 24), ri(O, K);
		case 11:
			(K[1] = p[X + 10]), Na(K, 16), ri(O, K);
		case 10:
			(K[1] = p[X + 9]), Na(K, 8), ri(O, K);
		case 9:
			(K[1] = p[X + 8]), ri(O, K), Ga(O, Gd), fc(O, 33), Ga(O, $d), ri(s, O);
		case 8:
			(K[1] = p[X + 7]), Na(K, 56), ri(B, K);
		case 7:
			(K[1] = p[X + 6]), Na(K, 48), ri(B, K);
		case 6:
			(K[1] = p[X + 5]), Na(K, 40), ri(B, K);
		case 5:
			(K[1] = p[X + 4]), Na(K, 32), ri(B, K);
		case 4:
			(K[1] = p[X + 3]), Na(K, 24), ri(B, K);
		case 3:
			(K[1] = p[X + 2]), Na(K, 16), ri(B, K);
		case 2:
			(K[1] = p[X + 1]), Na(K, 8), ri(B, K);
		case 1:
			(K[1] = p[X]), ri(B, K), Ga(B, $d), fc(B, 31), Ga(B, Gd), ri(T, B);
	}
	return (
		ri(T, y),
		ri(s, y),
		bs(T, s),
		bs(s, T),
		hv(T),
		hv(s),
		bs(T, s),
		bs(s, T),
		("00000000" + (T[0] >>> 0).toString(16)).slice(-8) +
			("00000000" + (T[1] >>> 0).toString(16)).slice(-8) +
			("00000000" + (s[0] >>> 0).toString(16)).slice(-8) +
			("00000000" + (s[1] >>> 0).toString(16)).slice(-8)
	);
}
function y8(m) {
	var a;
	return Tm(
		{
			name: m.name,
			message: m.message,
			stack:
				(a = m.stack) === null || a === void 0
					? void 0
					: a.split(`
`),
		},
		m
	);
}
function x8(m) {
	return /^function\s.*?\{\s*\[native code]\s*}$/.test(String(m));
}
function b8(m) {
	return typeof m != "function";
}
function w8(m, a) {
	var p = $u(
		new Promise(function (y) {
			var M = Date.now();
			cv(m.bind(null, a), function () {
				for (var z = [], T = 0; T < arguments.length; T++) z[T] = arguments[T];
				var s = Date.now() - M;
				if (!z[0])
					return y(function () {
						return { error: z[1], duration: s };
					});
				var B = z[1];
				if (b8(B))
					return y(function () {
						return { value: B, duration: s };
					});
				y(function () {
					return new Promise(function (O) {
						var X = Date.now();
						cv(B, function () {
							for (var K = [], ne = 0; ne < arguments.length; ne++)
								K[ne] = arguments[ne];
							var H = s + Date.now() - X;
							if (!K[0]) return O({ error: K[1], duration: H });
							O({ value: K[1], duration: H });
						});
					});
				});
			});
		})
	);
	return function () {
		return p.then(function (M) {
			return M();
		});
	};
}
function T8(m, a, p, y) {
	var M = Object.keys(m).filter(function (T) {
			return h8(p, T);
		}),
		z = $u(
			uv(
				M,
				function (T) {
					return w8(m[T], a);
				},
				y
			)
		);
	return function () {
		return Po(this, void 0, void 0, function () {
			var s, B, O, X, K;
			return Io(this, function (ne) {
				switch (ne.label) {
					case 0:
						return [4, z];
					case 1:
						return (
							(s = ne.sent()),
							[
								4,
								uv(
									s,
									function (H) {
										return $u(H());
									},
									y
								),
							]
						);
					case 2:
						return (B = ne.sent()), [4, Promise.all(B)];
					case 3:
						for (O = ne.sent(), X = {}, K = 0; K < M.length; ++K)
							X[M[K]] = O[K];
						return [2, X];
				}
			});
		});
	};
}
function D0() {
	var m = window,
		a = navigator;
	return (
		fa([
			"MSCSSMatrix" in m,
			"msSetImmediate" in m,
			"msIndexedDB" in m,
			"msMaxTouchPoints" in a,
			"msPointerEnabled" in a,
		]) >= 4
	);
}
function C8() {
	var m = window,
		a = navigator;
	return (
		fa([
			"msWriteProfilerMark" in m,
			"MSStream" in m,
			"msLaunchUri" in a,
			"msSaveBlob" in a,
		]) >= 3 && !D0()
	);
}
function Dh() {
	var m = window,
		a = navigator;
	return (
		fa([
			"webkitPersistentStorage" in a,
			"webkitTemporaryStorage" in a,
			(a.vendor || "").indexOf("Google") === 0,
			"webkitResolveLocalFileSystemURL" in m,
			"BatteryManager" in m,
			"webkitMediaStream" in m,
			"webkitSpeechGrammar" in m,
		]) >= 5
	);
}
function ho() {
	var m = window,
		a = navigator;
	return (
		fa([
			"ApplePayError" in m,
			"CSSPrimitiveValue" in m,
			"Counter" in m,
			a.vendor.indexOf("Apple") === 0,
			"RGBColor" in m,
			"WebKitMediaKeys" in m,
		]) >= 4
	);
}
function Km() {
	var m = window,
		a = m.HTMLElement,
		p = m.Document;
	return (
		fa([
			"safari" in m,
			!("ongestureend" in m),
			!("TouchEvent" in m),
			!("orientation" in m),
			a && !("autocapitalize" in a.prototype),
			p && "pointerLockElement" in p.prototype,
		]) >= 4
	);
}
function Rh() {
	var m = window;
	return x8(m.print) && String(m.browser) === "[object WebPageNamespace]";
}
function R0() {
	var m,
		a,
		p = window;
	return (
		fa([
			"buildID" in navigator,
			"MozAppearance" in
				((a =
					(m = document.documentElement) === null || m === void 0
						? void 0
						: m.style) !== null && a !== void 0
					? a
					: {}),
			"onmozfullscreenchange" in p,
			"mozInnerScreenX" in p,
			"CSSMozDocumentRule" in p,
			"CanvasCaptureMediaStream" in p,
		]) >= 4
	);
}
function S8() {
	var m = window;
	return (
		fa([
			!("MediaSettingsRange" in m),
			"RTCEncodedAudioFrame" in m,
			"" + m.Intl == "[object Intl]",
			"" + m.Reflect == "[object Reflect]",
		]) >= 3
	);
}
function P8() {
	var m = window,
		a = m.URLPattern;
	return (
		fa([
			"union" in Set.prototype,
			"Iterator" in m,
			a && "hasRegExpGroups" in a.prototype,
			"RGB8" in WebGLRenderingContext.prototype,
		]) >= 3
	);
}
function I8() {
	var m = window;
	return (
		fa([
			"DOMRectList" in m,
			"RTCPeerConnectionIceEvent" in m,
			"SVGGeometryElement" in m,
			"ontransitioncancel" in m,
		]) >= 3
	);
}
function Bh() {
	var m = window,
		a = navigator,
		p = m.CSS,
		y = m.HTMLButtonElement;
	return (
		fa([
			!("getStorageUpdates" in a),
			y && "popover" in y.prototype,
			"CSSCounterStyleRule" in m,
			p.supports("font-size-adjust: ex-height 0.5"),
			p.supports("text-transform: full-width"),
		]) >= 4
	);
}
function M8() {
	if (navigator.platform === "iPad") return !0;
	var m = screen,
		a = m.width / m.height;
	return (
		fa([
			"MediaSource" in window,
			!!Element.prototype.webkitRequestFullscreen,
			a > 0.65 && a < 1.53,
		]) >= 2
	);
}
function k8() {
	var m = document;
	return (
		m.fullscreenElement ||
		m.msFullscreenElement ||
		m.mozFullScreenElement ||
		m.webkitFullscreenElement ||
		null
	);
}
function A8() {
	var m = document;
	return (
		m.exitFullscreen ||
		m.msExitFullscreen ||
		m.mozCancelFullScreen ||
		m.webkitExitFullscreen
	).call(m);
}
function Jm() {
	var m = Dh(),
		a = R0(),
		p = window,
		y = navigator,
		M = "connection";
	return m
		? fa([
				!("SharedWorker" in p),
				y[M] && "ontypechange" in y[M],
				!("sinkId" in new Audio()),
		  ]) >= 2
		: a
		? fa([
				"onorientationchange" in p,
				"orientation" in p,
				/android/i.test(y.appVersion),
		  ]) >= 2
		: !1;
}
function E8() {
	var m = navigator,
		a = window,
		p = Audio.prototype,
		y = a.visualViewport;
	return (
		fa([
			"srLatency" in p,
			"srChannelCount" in p,
			"devicePosture" in m,
			y && "segments" in y,
			"getTextInformation" in Image.prototype,
		]) >= 3
	);
}
function z8() {
	return R8() ? -4 : L8();
}
function L8() {
	var m = window,
		a = m.OfflineAudioContext || m.webkitOfflineAudioContext;
	if (!a) return -2;
	if (D8()) return -1;
	var p = 4500,
		y = 5e3,
		M = new a(1, y, 44100),
		z = M.createOscillator();
	(z.type = "triangle"), (z.frequency.value = 1e4);
	var T = M.createDynamicsCompressor();
	(T.threshold.value = -50),
		(T.knee.value = 40),
		(T.ratio.value = 12),
		(T.attack.value = 0),
		(T.release.value = 0.25),
		z.connect(T),
		T.connect(M.destination),
		z.start(0);
	var s = B8(M),
		B = s[0],
		O = s[1],
		X = $u(
			B.then(
				function (K) {
					return F8(K.getChannelData(0).subarray(p));
				},
				function (K) {
					if (K.name === "timeout" || K.name === "suspended") return -3;
					throw K;
				}
			)
		);
	return function () {
		return O(), X;
	};
}
function D8() {
	return ho() && !Km() && !I8();
}
function R8() {
	return (ho() && Bh() && Rh()) || (Dh() && E8() && P8());
}
function B8(m) {
	var a = 3,
		p = 500,
		y = 500,
		M = 5e3,
		z = function () {},
		T = new Promise(function (s, B) {
			var O = !1,
				X = 0,
				K = 0;
			m.oncomplete = function (fe) {
				return s(fe.renderedBuffer);
			};
			var ne = function () {
					setTimeout(function () {
						return B(pv("timeout"));
					}, Math.min(y, K + M - Date.now()));
				},
				H = function () {
					try {
						var fe = m.startRendering();
						switch ((z0(fe) && $u(fe), m.state)) {
							case "running":
								(K = Date.now()), O && ne();
								break;
							case "suspended":
								document.hidden || X++,
									O && X >= a ? B(pv("suspended")) : setTimeout(H, p);
								break;
						}
					} catch (ge) {
						B(ge);
					}
				};
			H(),
				(z = function () {
					O || ((O = !0), K > 0 && ne());
				});
		});
	return [T, z];
}
function F8(m) {
	for (var a = 0, p = 0; p < m.length; ++p) a += Math.abs(m[p]);
	return a;
}
function pv(m) {
	var a = new Error(m);
	return (a.name = m), a;
}
function B0(m, a, p) {
	var y, M, z;
	return (
		p === void 0 && (p = 50),
		Po(this, void 0, void 0, function () {
			var T, s;
			return Io(this, function (B) {
				switch (B.label) {
					case 0:
						(T = document), (B.label = 1);
					case 1:
						return T.body ? [3, 3] : [4, ip(p)];
					case 2:
						return B.sent(), [3, 1];
					case 3:
						(s = T.createElement("iframe")), (B.label = 4);
					case 4:
						return (
							B.trys.push([4, , 10, 11]),
							[
								4,
								new Promise(function (O, X) {
									var K = !1,
										ne = function () {
											(K = !0), O();
										},
										H = function (Ie) {
											(K = !0), X(Ie);
										};
									(s.onload = ne), (s.onerror = H);
									var fe = s.style;
									fe.setProperty("display", "block", "important"),
										(fe.position = "absolute"),
										(fe.top = "0"),
										(fe.left = "0"),
										(fe.visibility = "hidden"),
										a && "srcdoc" in s
											? (s.srcdoc = a)
											: (s.src = "about:blank"),
										T.body.appendChild(s);
									var ge = function () {
										var Ie, Ae;
										K ||
											(((Ae =
												(Ie = s.contentWindow) === null || Ie === void 0
													? void 0
													: Ie.document) === null || Ae === void 0
												? void 0
												: Ae.readyState) === "complete"
												? ne()
												: setTimeout(ge, 10));
									};
									ge();
								}),
							]
						);
					case 5:
						B.sent(), (B.label = 6);
					case 6:
						return !(
							(M =
								(y = s.contentWindow) === null || y === void 0
									? void 0
									: y.document) === null || M === void 0
						) && M.body
							? [3, 8]
							: [4, ip(p)];
					case 7:
						return B.sent(), [3, 6];
					case 8:
						return [4, m(s, s.contentWindow)];
					case 9:
						return [2, B.sent()];
					case 10:
						return (
							(z = s.parentNode) === null || z === void 0 || z.removeChild(s),
							[7]
						);
					case 11:
						return [2];
				}
			});
		})
	);
}
function O8(m) {
	for (
		var a = d8(m),
			p = a[0],
			y = a[1],
			M = document.createElement(p ?? "div"),
			z = 0,
			T = Object.keys(y);
		z < T.length;
		z++
	) {
		var s = T[z],
			B = y[s].join(" ");
		s === "style" ? N8(M.style, B) : M.setAttribute(s, B);
	}
	return M;
}
function N8(m, a) {
	for (var p = 0, y = a.split(";"); p < y.length; p++) {
		var M = y[p],
			z = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(M);
		if (z) {
			var T = z[1],
				s = z[2],
				B = z[4];
			m.setProperty(T, s, B || "");
		}
	}
}
function j8() {
	for (var m = window; ; ) {
		var a = m.parent;
		if (!a || a === m) return !1;
		try {
			if (a.location.origin !== m.location.origin) return !0;
		} catch (p) {
			if (p instanceof Error && p.name === "SecurityError") return !0;
			throw p;
		}
		m = a;
	}
}
var V8 = "mmMwWLliI0O&1",
	q8 = "48px",
	mc = ["monospace", "sans-serif", "serif"],
	fv = [
		"sans-serif-thin",
		"ARNO PRO",
		"Agency FB",
		"Arabic Typesetting",
		"Arial Unicode MS",
		"AvantGarde Bk BT",
		"BankGothic Md BT",
		"Batang",
		"Bitstream Vera Sans Mono",
		"Calibri",
		"Century",
		"Century Gothic",
		"Clarendon",
		"EUROSTILE",
		"Franklin Gothic",
		"Futura Bk BT",
		"Futura Md BT",
		"GOTHAM",
		"Gill Sans",
		"HELV",
		"Haettenschweiler",
		"Helvetica Neue",
		"Humanst521 BT",
		"Leelawadee",
		"Letter Gothic",
		"Levenim MT",
		"Lucida Bright",
		"Lucida Sans",
		"Menlo",
		"MS Mincho",
		"MS Outlook",
		"MS Reference Specialty",
		"MS UI Gothic",
		"MT Extra",
		"MYRIAD PRO",
		"Marlett",
		"Meiryo UI",
		"Microsoft Uighur",
		"Minion Pro",
		"Monotype Corsiva",
		"PMingLiU",
		"Pristina",
		"SCRIPTINA",
		"Segoe UI Light",
		"Serifa",
		"SimHei",
		"Small Fonts",
		"Staccato222 BT",
		"TRAJAN PRO",
		"Univers CE 55 Medium",
		"Vrinda",
		"ZWAdobeF",
	];
function Z8() {
	var m = this;
	return B0(function (a, p) {
		var y = p.document;
		return Po(m, void 0, void 0, function () {
			var M, z, T, s, B, O, X, K, ne, H, fe, ge;
			return Io(this, function (Ie) {
				for (
					M = y.body,
						M.style.fontSize = q8,
						z = y.createElement("div"),
						z.style.setProperty("visibility", "hidden", "important"),
						T = {},
						s = {},
						B = function (Ae) {
							var De = y.createElement("span"),
								Ee = De.style;
							return (
								(Ee.position = "absolute"),
								(Ee.top = "0"),
								(Ee.left = "0"),
								(Ee.fontFamily = Ae),
								(De.textContent = V8),
								z.appendChild(De),
								De
							);
						},
						O = function (Ae, De) {
							return B("'".concat(Ae, "',").concat(De));
						},
						X = function () {
							return mc.map(B);
						},
						K = function () {
							for (
								var Ae = {},
									De = function (Je) {
										Ae[Je] = mc.map(function (qe) {
											return O(Je, qe);
										});
									},
									Ee = 0,
									Fe = fv;
								Ee < Fe.length;
								Ee++
							) {
								var $e = Fe[Ee];
								De($e);
							}
							return Ae;
						},
						ne = function (Ae) {
							return mc.some(function (De, Ee) {
								return (
									Ae[Ee].offsetWidth !== T[De] || Ae[Ee].offsetHeight !== s[De]
								);
							});
						},
						H = X(),
						fe = K(),
						M.appendChild(z),
						ge = 0;
					ge < mc.length;
					ge++
				)
					(T[mc[ge]] = H[ge].offsetWidth), (s[mc[ge]] = H[ge].offsetHeight);
				return [
					2,
					fv.filter(function (Ae) {
						return ne(fe[Ae]);
					}),
				];
			});
		});
	});
}
function U8() {
	var m = navigator.plugins;
	if (m) {
		for (var a = [], p = 0; p < m.length; ++p) {
			var y = m[p];
			if (y) {
				for (var M = [], z = 0; z < y.length; ++z) {
					var T = y[z];
					M.push({ type: T.type, suffixes: T.suffixes });
				}
				a.push({ name: y.name, description: y.description, mimeTypes: M });
			}
		}
		return a;
	}
}
function $8() {
	return G8(Q8());
}
function G8(m) {
	var a,
		p = !1,
		y,
		M,
		z = H8(),
		T = z[0],
		s = z[1];
	return (
		W8(T, s)
			? ((p = X8(s)),
			  m ? (y = M = "skipped") : ((a = Y8(T, s)), (y = a[0]), (M = a[1])))
			: (y = M = "unsupported"),
		{ winding: p, geometry: y, text: M }
	);
}
function H8() {
	var m = document.createElement("canvas");
	return (m.width = 1), (m.height = 1), [m, m.getContext("2d")];
}
function W8(m, a) {
	return !!(a && m.toDataURL);
}
function X8(m) {
	return (
		m.rect(0, 0, 10, 10), m.rect(2, 2, 6, 6), !m.isPointInPath(5, 5, "evenodd")
	);
}
function Y8(m, a) {
	K8(m, a);
	var p = Vf(m),
		y = Vf(m);
	if (p !== y) return ["unstable", "unstable"];
	J8(m, a);
	var M = Vf(m);
	return [M, p];
}
function K8(m, a) {
	(m.width = 240),
		(m.height = 60),
		(a.textBaseline = "alphabetic"),
		(a.fillStyle = "#f60"),
		a.fillRect(100, 1, 62, 20),
		(a.fillStyle = "#069"),
		(a.font = '11pt "Times New Roman"');
	var p = "Cwm fjordbank gly ".concat("😃");
	a.fillText(p, 2, 15),
		(a.fillStyle = "rgba(102, 204, 0, 0.2)"),
		(a.font = "18pt Arial"),
		a.fillText(p, 4, 45);
}
function J8(m, a) {
	(m.width = 122), (m.height = 110), (a.globalCompositeOperation = "multiply");
	for (
		var p = 0,
			y = [
				["#f2f", 40, 40],
				["#2ff", 80, 40],
				["#ff2", 60, 80],
			];
		p < y.length;
		p++
	) {
		var M = y[p],
			z = M[0],
			T = M[1],
			s = M[2];
		(a.fillStyle = z),
			a.beginPath(),
			a.arc(T, s, 40, 0, Math.PI * 2, !0),
			a.closePath(),
			a.fill();
	}
	(a.fillStyle = "#f9c"),
		a.arc(60, 60, 60, 0, Math.PI * 2, !0),
		a.arc(60, 60, 20, 0, Math.PI * 2, !0),
		a.fill("evenodd");
}
function Vf(m) {
	return m.toDataURL();
}
function Q8() {
	return ho() && Bh() && Rh();
}
function ez() {
	var m = navigator,
		a = 0,
		p;
	m.maxTouchPoints !== void 0
		? (a = Ym(m.maxTouchPoints))
		: m.msMaxTouchPoints !== void 0 && (a = m.msMaxTouchPoints);
	try {
		document.createEvent("TouchEvent"), (p = !0);
	} catch {
		p = !1;
	}
	var y = "ontouchstart" in window;
	return { maxTouchPoints: a, touchEvent: p, touchStart: y };
}
function tz() {
	return navigator.oscpu;
}
function rz() {
	var m = navigator,
		a = [],
		p = m.language || m.userLanguage || m.browserLanguage || m.systemLanguage;
	if ((p !== void 0 && a.push([p]), Array.isArray(m.languages)))
		(Dh() && S8()) || a.push(m.languages);
	else if (typeof m.languages == "string") {
		var y = m.languages;
		y && a.push(y.split(","));
	}
	return a;
}
function nz() {
	return window.screen.colorDepth;
}
function iz() {
	return Go(lo(navigator.deviceMemory), void 0);
}
function az() {
	if (!(ho() && Bh() && Rh())) return oz();
}
function oz() {
	var m = screen,
		a = function (y) {
			return Go(Ym(y), null);
		},
		p = [a(m.width), a(m.height)];
	return p.sort().reverse(), p;
}
var sz = 2500,
	lz = 10,
	tp,
	qf;
function cz() {
	if (qf === void 0) {
		var m = function () {
			var a = Cm();
			Sm(a) ? (qf = setTimeout(m, sz)) : ((tp = a), (qf = void 0));
		};
		m();
	}
}
function uz() {
	var m = this;
	return (
		cz(),
		function () {
			return Po(m, void 0, void 0, function () {
				var a;
				return Io(this, function (p) {
					switch (p.label) {
						case 0:
							return (
								(a = Cm()),
								Sm(a)
									? tp
										? [2, A0([], tp, !0)]
										: k8()
										? [4, A8()]
										: [3, 2]
									: [3, 2]
							);
						case 1:
							p.sent(), (a = Cm()), (p.label = 2);
						case 2:
							return Sm(a) || (tp = a), [2, a];
					}
				});
			});
		}
	);
}
function hz() {
	var m = this;
	if (ho() && Bh() && Rh())
		return function () {
			return Promise.resolve(void 0);
		};
	var a = uz();
	return function () {
		return Po(m, void 0, void 0, function () {
			var p, y;
			return Io(this, function (M) {
				switch (M.label) {
					case 0:
						return [4, a()];
					case 1:
						return (
							(p = M.sent()),
							(y = function (z) {
								return z === null ? null : L0(z, lz);
							}),
							[2, [y(p[0]), y(p[1]), y(p[2]), y(p[3])]]
						);
				}
			});
		});
	};
}
function Cm() {
	var m = screen;
	return [
		Go(lo(m.availTop), null),
		Go(lo(m.width) - lo(m.availWidth) - Go(lo(m.availLeft), 0), null),
		Go(lo(m.height) - lo(m.availHeight) - Go(lo(m.availTop), 0), null),
		Go(lo(m.availLeft), null),
	];
}
function Sm(m) {
	for (var a = 0; a < 4; ++a) if (m[a]) return !1;
	return !0;
}
function dz() {
	return Go(Ym(navigator.hardwareConcurrency), void 0);
}
function pz() {
	var m,
		a = (m = window.Intl) === null || m === void 0 ? void 0 : m.DateTimeFormat;
	if (a) {
		var p = new a().resolvedOptions().timeZone;
		if (p) return p;
	}
	var y = -fz();
	return "UTC".concat(y >= 0 ? "+" : "").concat(y);
}
function fz() {
	var m = new Date().getFullYear();
	return Math.max(
		lo(new Date(m, 0, 1).getTimezoneOffset()),
		lo(new Date(m, 6, 1).getTimezoneOffset())
	);
}
function mz() {
	try {
		return !!window.sessionStorage;
	} catch {
		return !0;
	}
}
function _z() {
	try {
		return !!window.localStorage;
	} catch {
		return !0;
	}
}
function gz() {
	if (!(D0() || C8()))
		try {
			return !!window.indexedDB;
		} catch {
			return !0;
		}
}
function vz() {
	return !!window.openDatabase;
}
function yz() {
	return navigator.cpuClass;
}
function xz() {
	var m = navigator.platform;
	return m === "MacIntel" && ho() && !Km() ? (M8() ? "iPad" : "iPhone") : m;
}
function bz() {
	return navigator.vendor || "";
}
function wz() {
	for (
		var m = [],
			a = 0,
			p = [
				"chrome",
				"safari",
				"__crWeb",
				"__gCrWeb",
				"yandex",
				"__yb",
				"__ybro",
				"__firefox__",
				"__edgeTrackingPreventionStatistics",
				"webkit",
				"oprt",
				"samsungAr",
				"ucweb",
				"UCShellJava",
				"puffinDevice",
			];
		a < p.length;
		a++
	) {
		var y = p[a],
			M = window[y];
		M && typeof M == "object" && m.push(y);
	}
	return m.sort();
}
function Tz() {
	var m = document;
	try {
		m.cookie = "cookietest=1; SameSite=Strict;";
		var a = m.cookie.indexOf("cookietest=") !== -1;
		return (
			(m.cookie =
				"cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT"),
			a
		);
	} catch {
		return !1;
	}
}
function Cz() {
	var m = atob;
	return {
		abpIndo: [
			"#Iklan-Melayang",
			"#Kolom-Iklan-728",
			"#SidebarIklan-wrapper",
			'[title="ALIENBOLA" i]',
			m("I0JveC1CYW5uZXItYWRz"),
		],
		abpvn: [
			".quangcao",
			"#mobileCatfish",
			m("LmNsb3NlLWFkcw=="),
			'[id^="bn_bottom_fixed_"]',
			"#pmadv",
		],
		adBlockFinland: [
			".mainostila",
			m("LnNwb25zb3JpdA=="),
			".ylamainos",
			m("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
			m("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd"),
		],
		adBlockPersian: [
			"#navbar_notice_50",
			".kadr",
			'TABLE[width="140px"]',
			"#divAgahi",
			m("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd"),
		],
		adBlockWarningRemoval: [
			"#adblock-honeypot",
			".adblocker-root",
			".wp_adblock_detect",
			m("LmhlYWRlci1ibG9ja2VkLWFk"),
			m("I2FkX2Jsb2NrZXI="),
		],
		adGuardAnnoyances: [
			".hs-sosyal",
			"#cookieconsentdiv",
			'div[class^="app_gdpr"]',
			".as-oil",
			'[data-cypress="soft-push-notification-modal"]',
		],
		adGuardBase: [
			".BetterJsPopOverlay",
			m("I2FkXzMwMFgyNTA="),
			m("I2Jhbm5lcmZsb2F0MjI="),
			m("I2NhbXBhaWduLWJhbm5lcg=="),
			m("I0FkLUNvbnRlbnQ="),
		],
		adGuardChinese: [
			m("LlppX2FkX2FfSA=="),
			m("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
			"#widget-quan",
			m("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
			m("YVtocmVmKj0iLjE5NTZobC5jb20vIl0="),
		],
		adGuardFrench: [
			"#pavePub",
			m("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
			".mobile_adhesion",
			".widgetadv",
			m("LmFkc19iYW4="),
		],
		adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
		adGuardJapanese: [
			"#kauli_yad_1",
			m("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
			m("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
			m("LmFkZ29vZ2xl"),
			m("Ll9faXNib29zdFJldHVybkFk"),
		],
		adGuardMobile: [
			m("YW1wLWF1dG8tYWRz"),
			m("LmFtcF9hZA=="),
			'amp-embed[type="24smi"]',
			"#mgid_iframe1",
			m("I2FkX2ludmlld19hcmVh"),
		],
		adGuardRussian: [
			m("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
			m("LnJlY2xhbWE="),
			'div[id^="smi2adblock"]',
			m("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
			"#psyduckpockeball",
		],
		adGuardSocial: [
			m("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
			m("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
			".etsy-tweet",
			"#inlineShare",
			".popup-social",
		],
		adGuardSpanishPortuguese: [
			"#barraPublicidade",
			"#Publicidade",
			"#publiEspecial",
			"#queTooltip",
			".cnt-publi",
		],
		adGuardTrackingProtection: [
			"#qoo-counter",
			m("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
			m("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
			m("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
			"#top100counter",
		],
		adGuardTurkish: [
			"#backkapat",
			m("I3Jla2xhbWk="),
			m("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
			m("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
			m("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ=="),
		],
		bulgarian: [
			m("dGQjZnJlZW5ldF90YWJsZV9hZHM="),
			"#ea_intext_div",
			".lapni-pop-over",
			"#xenium_hot_offers",
		],
		easyList: [
			".yb-floorad",
			m("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
			m("LnRyYWZmaWNqdW5reS1hZA=="),
			".textad_headline",
			m("LnNwb25zb3JlZC10ZXh0LWxpbmtz"),
		],
		easyListChina: [
			m("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
			m("LmZyb250cGFnZUFkdk0="),
			"#taotaole",
			"#aafoot.top_box",
			".cfa_popup",
		],
		easyListCookie: [
			".ezmob-footer",
			".cc-CookieWarning",
			"[data-cookie-number]",
			m("LmF3LWNvb2tpZS1iYW5uZXI="),
			".sygnal24-gdpr-modal-wrap",
		],
		easyListCzechSlovak: [
			"#onlajny-stickers",
			m("I3Jla2xhbW5pLWJveA=="),
			m("LnJla2xhbWEtbWVnYWJvYXJk"),
			".sklik",
			m("W2lkXj0ic2tsaWtSZWtsYW1hIl0="),
		],
		easyListDutch: [
			m("I2FkdmVydGVudGll"),
			m("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
			".adstekst",
			m("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
			"#semilo-lrectangle",
		],
		easyListGermany: [
			"#SSpotIMPopSlider",
			m("LnNwb25zb3JsaW5rZ3J1ZW4="),
			m("I3dlcmJ1bmdza3k="),
			m("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
			m("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0="),
		],
		easyListItaly: [
			m("LmJveF9hZHZfYW5udW5jaQ=="),
			".sb-box-pubbliredazionale",
			m("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
			m("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
			m("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ=="),
		],
		easyListLithuania: [
			m("LnJla2xhbW9zX3RhcnBhcw=="),
			m("LnJla2xhbW9zX251b3JvZG9z"),
			m("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
			m("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
			m("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd"),
		],
		estonian: [m("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
		fanboyAnnoyances: [
			"#ac-lre-player",
			".navigate-to-top",
			"#subscribe_popup",
			".newsletter_holder",
			"#back-top",
		],
		fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
		fanboyEnhancedTrackers: [
			".open.pushModal",
			"#issuem-leaky-paywall-articles-zero-remaining-nag",
			"#sovrn_container",
			'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
			".BlockNag__Card",
		],
		fanboySocial: [
			"#FollowUs",
			"#meteored_share",
			"#social_follow",
			".article-sharer",
			".community__social-desc",
		],
		frellwitSwedish: [
			m("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
			m("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
			"article.category-samarbete",
			m("ZGl2LmhvbGlkQWRz"),
			"ul.adsmodern",
		],
		greekAdBlock: [
			m("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
			m("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
			m("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
			"DIV.agores300",
			"TABLE.advright",
		],
		hungarian: [
			"#cemp_doboz",
			".optimonk-iframe-container",
			m("LmFkX19tYWlu"),
			m("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
			"#hirdetesek_box",
		],
		iDontCareAboutCookies: [
			'.alert-info[data-block-track*="CookieNotice"]',
			".ModuleTemplateCookieIndicator",
			".o--cookies--container",
			"#cookies-policy-sticky",
			"#stickyCookieBar",
		],
		icelandicAbp: [
			m("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ=="),
		],
		latvian: [
			m(
				"YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="
			),
			m(
				"YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ=="
			),
		],
		listKr: [
			m("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
			m("I2xpdmVyZUFkV3JhcHBlcg=="),
			m("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
			m("aW5zLmZhc3R2aWV3LWFk"),
			".revenue_unit_item.dable",
		],
		listeAr: [
			m("LmdlbWluaUxCMUFk"),
			".right-and-left-sponsers",
			m("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
			m("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
			m("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd"),
		],
		listeFr: [
			m("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
			m("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
			m("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
			".site-pub-interstitiel",
			'div[id^="crt-"][data-criteo-id]',
		],
		officialPolish: [
			"#ceneo-placeholder-ceneo-12",
			m("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
			m("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
			m("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
			m("ZGl2I3NrYXBpZWNfYWQ="),
		],
		ro: [
			m("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
			m("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
			m(
				"YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="
			),
			m("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
			'a[href^="/url/"]',
		],
		ruAd: [
			m("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
			m("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
			m("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
			"#pgeldiz",
			".yandex-rtb-block",
		],
		thaiAds: [
			"a[href*=macau-uta-popup]",
			m("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
			m("LmFkczMwMHM="),
			".bumq",
			".img-kosana",
		],
		webAnnoyancesUltralist: [
			"#mod-social-share-2",
			"#social-tools",
			m("LmN0cGwtZnVsbGJhbm5lcg=="),
			".zergnet-recommend",
			".yt.btn-link.btn-md.btn",
		],
	};
}
function Sz(m) {
	var a = m === void 0 ? {} : m,
		p = a.debug;
	return Po(this, void 0, void 0, function () {
		var y, M, z, T, s, B;
		return Io(this, function (O) {
			switch (O.label) {
				case 0:
					return Pz()
						? ((y = Cz()),
						  (M = Object.keys(y)),
						  (z = (B = []).concat.apply(
								B,
								M.map(function (X) {
									return y[X];
								})
						  )),
						  [4, Iz(z)])
						: [2, void 0];
				case 1:
					return (
						(T = O.sent()),
						p && Mz(y, T),
						(s = M.filter(function (X) {
							var K = y[X],
								ne = fa(
									K.map(function (H) {
										return T[H];
									})
								);
							return ne > K.length * 0.6;
						})),
						s.sort(),
						[2, s]
					);
			}
		});
	});
}
function Pz() {
	return ho() || Jm();
}
function Iz(m) {
	var a;
	return Po(this, void 0, void 0, function () {
		var p, y, M, z, B, T, s, B;
		return Io(this, function (O) {
			switch (O.label) {
				case 0:
					for (
						p = document,
							y = p.createElement("div"),
							M = new Array(m.length),
							z = {},
							mv(y),
							B = 0;
						B < m.length;
						++B
					)
						(T = O8(m[B])),
							T.tagName === "DIALOG" && T.show(),
							(s = p.createElement("div")),
							mv(s),
							s.appendChild(T),
							y.appendChild(s),
							(M[B] = T);
					O.label = 1;
				case 1:
					return p.body ? [3, 3] : [4, ip(50)];
				case 2:
					return O.sent(), [3, 1];
				case 3:
					p.body.appendChild(y);
					try {
						for (B = 0; B < m.length; ++B) M[B].offsetParent || (z[m[B]] = !0);
					} finally {
						(a = y.parentNode) === null || a === void 0 || a.removeChild(y);
					}
					return [2, z];
			}
		});
	});
}
function mv(m) {
	m.style.setProperty("visibility", "hidden", "important"),
		m.style.setProperty("display", "block", "important");
}
function Mz(m, a) {
	for (
		var p = "DOM blockers debug:\n```", y = 0, M = Object.keys(m);
		y < M.length;
		y++
	) {
		var z = M[y];
		p += `
`.concat(z, ":");
		for (var T = 0, s = m[z]; T < s.length; T++) {
			var B = s[T];
			p += `
  `
				.concat(a[B] ? "🚫" : "➡️", " ")
				.concat(B);
		}
	}
	console.log("".concat(p, "\n```"));
}
function kz() {
	for (var m = 0, a = ["rec2020", "p3", "srgb"]; m < a.length; m++) {
		var p = a[m];
		if (matchMedia("(color-gamut: ".concat(p, ")")).matches) return p;
	}
}
function Az() {
	if (_v("inverted")) return !0;
	if (_v("none")) return !1;
}
function _v(m) {
	return matchMedia("(inverted-colors: ".concat(m, ")")).matches;
}
function Ez() {
	if (gv("active")) return !0;
	if (gv("none")) return !1;
}
function gv(m) {
	return matchMedia("(forced-colors: ".concat(m, ")")).matches;
}
var zz = 100;
function Lz() {
	if (matchMedia("(min-monochrome: 0)").matches) {
		for (var m = 0; m <= zz; ++m)
			if (matchMedia("(max-monochrome: ".concat(m, ")")).matches) return m;
		throw new Error("Too high value");
	}
}
function Dz() {
	if (_c("no-preference")) return 0;
	if (_c("high") || _c("more")) return 1;
	if (_c("low") || _c("less")) return -1;
	if (_c("forced")) return 10;
}
function _c(m) {
	return matchMedia("(prefers-contrast: ".concat(m, ")")).matches;
}
function Rz() {
	if (vv("reduce")) return !0;
	if (vv("no-preference")) return !1;
}
function vv(m) {
	return matchMedia("(prefers-reduced-motion: ".concat(m, ")")).matches;
}
function Bz() {
	if (yv("reduce")) return !0;
	if (yv("no-preference")) return !1;
}
function yv(m) {
	return matchMedia("(prefers-reduced-transparency: ".concat(m, ")")).matches;
}
function Fz() {
	if (xv("high")) return !0;
	if (xv("standard")) return !1;
}
function xv(m) {
	return matchMedia("(dynamic-range: ".concat(m, ")")).matches;
}
var Nn = Math,
	da = function () {
		return 0;
	};
function Oz() {
	var m = Nn.acos || da,
		a = Nn.acosh || da,
		p = Nn.asin || da,
		y = Nn.asinh || da,
		M = Nn.atanh || da,
		z = Nn.atan || da,
		T = Nn.sin || da,
		s = Nn.sinh || da,
		B = Nn.cos || da,
		O = Nn.cosh || da,
		X = Nn.tan || da,
		K = Nn.tanh || da,
		ne = Nn.exp || da,
		H = Nn.expm1 || da,
		fe = Nn.log1p || da,
		ge = function (Ze) {
			return Nn.pow(Nn.PI, Ze);
		},
		Ie = function (Ze) {
			return Nn.log(Ze + Nn.sqrt(Ze * Ze - 1));
		},
		Ae = function (Ze) {
			return Nn.log(Ze + Nn.sqrt(Ze * Ze + 1));
		},
		De = function (Ze) {
			return Nn.log((1 + Ze) / (1 - Ze)) / 2;
		},
		Ee = function (Ze) {
			return Nn.exp(Ze) - 1 / Nn.exp(Ze) / 2;
		},
		Fe = function (Ze) {
			return (Nn.exp(Ze) + 1 / Nn.exp(Ze)) / 2;
		},
		$e = function (Ze) {
			return Nn.exp(Ze) - 1;
		},
		Je = function (Ze) {
			return (Nn.exp(2 * Ze) - 1) / (Nn.exp(2 * Ze) + 1);
		},
		qe = function (Ze) {
			return Nn.log(1 + Ze);
		};
	return {
		acos: m(0.12312423423423424),
		acosh: a(1e308),
		acoshPf: Ie(1e154),
		asin: p(0.12312423423423424),
		asinh: y(1),
		asinhPf: Ae(1),
		atanh: M(0.5),
		atanhPf: De(0.5),
		atan: z(0.5),
		sin: T(-1e300),
		sinh: s(1),
		sinhPf: Ee(1),
		cos: B(10.000000000123),
		cosh: O(1),
		coshPf: Fe(1),
		tan: X(-1e300),
		tanh: K(1),
		tanhPf: Je(1),
		exp: ne(1),
		expm1: H(1),
		expm1Pf: $e(1),
		log1p: fe(10),
		log1pPf: qe(10),
		powPI: ge(-100),
	};
}
var Nz = "mmMwWLliI0fiflO&1",
	Zf = {
		default: [],
		apple: [{ font: "-apple-system-body" }],
		serif: [{ fontFamily: "serif" }],
		sans: [{ fontFamily: "sans-serif" }],
		mono: [{ fontFamily: "monospace" }],
		min: [{ fontSize: "1px" }],
		system: [{ fontFamily: "system-ui" }],
	};
function jz() {
	return Vz(function (m, a) {
		for (var p = {}, y = {}, M = 0, z = Object.keys(Zf); M < z.length; M++) {
			var T = z[M],
				s = Zf[T],
				B = s[0],
				O = B === void 0 ? {} : B,
				X = s[1],
				K = X === void 0 ? Nz : X,
				ne = m.createElement("span");
			(ne.textContent = K), (ne.style.whiteSpace = "nowrap");
			for (var H = 0, fe = Object.keys(O); H < fe.length; H++) {
				var ge = fe[H],
					Ie = O[ge];
				Ie !== void 0 && (ne.style[ge] = Ie);
			}
			(p[T] = ne), a.append(m.createElement("br"), ne);
		}
		for (var Ae = 0, De = Object.keys(Zf); Ae < De.length; Ae++) {
			var T = De[Ae];
			y[T] = p[T].getBoundingClientRect().width;
		}
		return y;
	});
}
function Vz(m, a) {
	return (
		a === void 0 && (a = 4e3),
		B0(function (p, y) {
			var M = y.document,
				z = M.body,
				T = z.style;
			(T.width = "".concat(a, "px")),
				(T.webkitTextSizeAdjust = T.textSizeAdjust = "none"),
				Dh()
					? (z.style.zoom = "".concat(1 / y.devicePixelRatio))
					: ho() && (z.style.zoom = "reset");
			var s = M.createElement("div");
			return (
				(s.textContent = A0([], Array((a / 20) << 0), !0)
					.map(function () {
						return "word";
					})
					.join(" ")),
				z.appendChild(s),
				m(M, z)
			);
		}, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
	);
}
function qz() {
	return navigator.pdfViewerEnabled;
}
function Zz() {
	var m = new Float32Array(1),
		a = new Uint8Array(m.buffer);
	return (m[0] = 1 / 0), (m[0] = m[0] - m[0]), a[3];
}
function Uz() {
	var m = window.ApplePaySession;
	if (typeof (m == null ? void 0 : m.canMakePayments) != "function") return -1;
	if ($z()) return -3;
	try {
		return m.canMakePayments() ? 1 : 0;
	} catch (a) {
		return Gz(a);
	}
}
var $z = j8;
function Gz(m) {
	if (
		m instanceof Error &&
		m.name === "InvalidAccessError" &&
		/\bfrom\b.*\binsecure\b/i.test(m.message)
	)
		return -2;
	throw m;
}
function Hz() {
	var m,
		a = document.createElement("a"),
		p =
			(m = a.attributionSourceId) !== null && m !== void 0
				? m
				: a.attributionsourceid;
	return p === void 0 ? void 0 : String(p);
}
var F0 = -1,
	O0 = -2,
	Wz = new Set([
		10752, 2849, 2884, 2885, 2886, 2928, 2929, 2930, 2931, 2932, 2960, 2961,
		2962, 2963, 2964, 2965, 2966, 2967, 2968, 2978, 3024, 3042, 3088, 3089,
		3106, 3107, 32773, 32777, 32777, 32823, 32824, 32936, 32937, 32938, 32939,
		32968, 32969, 32970, 32971, 3317, 33170, 3333, 3379, 3386, 33901, 33902,
		34016, 34024, 34076, 3408, 3410, 3411, 3412, 3413, 3414, 3415, 34467, 34816,
		34817, 34818, 34819, 34877, 34921, 34930, 35660, 35661, 35724, 35738, 35739,
		36003, 36004, 36005, 36347, 36348, 36349, 37440, 37441, 37443, 7936, 7937,
		7938,
	]),
	Xz = new Set([
		34047, 35723, 36063, 34852, 34853, 34854, 34229, 36392, 36795, 38449,
	]),
	Yz = ["FRAGMENT_SHADER", "VERTEX_SHADER"],
	Kz = [
		"LOW_FLOAT",
		"MEDIUM_FLOAT",
		"HIGH_FLOAT",
		"LOW_INT",
		"MEDIUM_INT",
		"HIGH_INT",
	],
	N0 = "WEBGL_debug_renderer_info",
	Jz = "WEBGL_polygon_mode";
function Qz(m) {
	var a,
		p,
		y,
		M,
		z,
		T,
		s = m.cache,
		B = j0(s);
	if (!B) return F0;
	if (!q0(B)) return O0;
	var O = V0() ? null : B.getExtension(N0);
	return {
		version:
			((a = B.getParameter(B.VERSION)) === null || a === void 0
				? void 0
				: a.toString()) || "",
		vendor:
			((p = B.getParameter(B.VENDOR)) === null || p === void 0
				? void 0
				: p.toString()) || "",
		vendorUnmasked: O
			? (y = B.getParameter(O.UNMASKED_VENDOR_WEBGL)) === null || y === void 0
				? void 0
				: y.toString()
			: "",
		renderer:
			((M = B.getParameter(B.RENDERER)) === null || M === void 0
				? void 0
				: M.toString()) || "",
		rendererUnmasked: O
			? (z = B.getParameter(O.UNMASKED_RENDERER_WEBGL)) === null || z === void 0
				? void 0
				: z.toString()
			: "",
		shadingLanguageVersion:
			((T = B.getParameter(B.SHADING_LANGUAGE_VERSION)) === null || T === void 0
				? void 0
				: T.toString()) || "",
	};
}
function eL(m) {
	var a = m.cache,
		p = j0(a);
	if (!p) return F0;
	if (!q0(p)) return O0;
	var y = p.getSupportedExtensions(),
		M = p.getContextAttributes(),
		z = [],
		T = [],
		s = [],
		B = [],
		O = [];
	if (M)
		for (var X = 0, K = Object.keys(M); X < K.length; X++) {
			var ne = K[X];
			T.push("".concat(ne, "=").concat(M[ne]));
		}
	for (var H = bv(p), fe = 0, ge = H; fe < ge.length; fe++) {
		var Ie = ge[fe],
			Ae = p[Ie];
		s.push(
			""
				.concat(Ie, "=")
				.concat(Ae)
				.concat(Wz.has(Ae) ? "=".concat(p.getParameter(Ae)) : "")
		);
	}
	if (y)
		for (var De = 0, Ee = y; De < Ee.length; De++) {
			var Fe = Ee[De];
			if (!((Fe === N0 && V0()) || (Fe === Jz && nL()))) {
				var $e = p.getExtension(Fe);
				if (!$e) {
					z.push(Fe);
					continue;
				}
				for (var Je = 0, qe = bv($e); Je < qe.length; Je++) {
					var Ie = qe[Je],
						Ae = $e[Ie];
					B.push(
						""
							.concat(Ie, "=")
							.concat(Ae)
							.concat(Xz.has(Ae) ? "=".concat(p.getParameter(Ae)) : "")
					);
				}
			}
		}
	for (var Ze = 0, Qe = Yz; Ze < Qe.length; Ze++)
		for (var Le = Qe[Ze], et = 0, nt = Kz; et < nt.length; et++) {
			var Ue = nt[et],
				ke = tL(p, Le, Ue);
			O.push("".concat(Le, ".").concat(Ue, "=").concat(ke.join(",")));
		}
	return (
		B.sort(),
		s.sort(),
		{
			contextAttributes: T,
			parameters: s,
			shaderPrecisions: O,
			extensions: y,
			extensionParameters: B,
			unsupportedExtensions: z,
		}
	);
}
function j0(m) {
	if (m.webgl) return m.webgl.context;
	var a = document.createElement("canvas"),
		p;
	a.addEventListener("webglCreateContextError", function () {
		return (p = void 0);
	});
	for (var y = 0, M = ["webgl", "experimental-webgl"]; y < M.length; y++) {
		var z = M[y];
		try {
			p = a.getContext(z);
		} catch {}
		if (p) break;
	}
	return (m.webgl = { context: p }), p;
}
function tL(m, a, p) {
	var y = m.getShaderPrecisionFormat(m[a], m[p]);
	return y ? [y.rangeMin, y.rangeMax, y.precision] : [];
}
function bv(m) {
	var a = Object.keys(m.__proto__);
	return a.filter(rL);
}
function rL(m) {
	return typeof m == "string" && !m.match(/[^A-Z0-9_x]/);
}
function V0() {
	return R0();
}
function nL() {
	return Dh() || ho();
}
function q0(m) {
	return typeof m.getParameter == "function";
}
function iL() {
	var m = Jm() || ho();
	if (!m) return -2;
	if (!window.AudioContext) return -1;
	var a = new AudioContext().baseLatency;
	return a == null ? -1 : isFinite(a) ? a : -3;
}
function aL() {
	if (!window.Intl) return -1;
	var m = window.Intl.DateTimeFormat;
	if (!m) return -2;
	var a = m().resolvedOptions().locale;
	return !a && a !== "" ? -3 : a;
}
var oL = {
	fonts: Z8,
	domBlockers: Sz,
	fontPreferences: jz,
	audio: z8,
	screenFrame: hz,
	canvas: $8,
	osCpu: tz,
	languages: rz,
	colorDepth: nz,
	deviceMemory: iz,
	screenResolution: az,
	hardwareConcurrency: dz,
	timezone: pz,
	sessionStorage: mz,
	localStorage: _z,
	indexedDB: gz,
	openDatabase: vz,
	cpuClass: yz,
	platform: xz,
	plugins: U8,
	touchSupport: ez,
	vendor: bz,
	vendorFlavors: wz,
	cookiesEnabled: Tz,
	colorGamut: kz,
	invertedColors: Az,
	forcedColors: Ez,
	monochrome: Lz,
	contrast: Dz,
	reducedMotion: Rz,
	reducedTransparency: Bz,
	hdr: Fz,
	math: Oz,
	pdfViewerEnabled: qz,
	architecture: Zz,
	applePay: Uz,
	privateClickMeasurement: Hz,
	audioBaseLatency: iL,
	dateTimeLocale: aL,
	webGlBasics: Qz,
	webGlExtensions: eL,
};
function sL(m) {
	return T8(oL, m, []);
}
var lL = "$ if upgrade to Pro: https://fpjs.dev/pro";
function cL(m) {
	var a = uL(m),
		p = hL(a);
	return { score: a, comment: lL.replace(/\$/g, "".concat(p)) };
}
function uL(m) {
	if (Jm()) return 0.4;
	if (ho()) return Km() && !(Bh() && Rh()) ? 0.5 : 0.3;
	var a = "value" in m.platform ? m.platform.value : "";
	return /^Win/.test(a) ? 0.6 : /^Mac/.test(a) ? 0.5 : 0.7;
}
function hL(m) {
	return L0(0.99 + 0.01 * m, 1e-4);
}
function dL(m) {
	for (var a = "", p = 0, y = Object.keys(m).sort(); p < y.length; p++) {
		var M = y[p],
			z = m[M],
			T = "error" in z ? "error" : JSON.stringify(z.value);
		a += ""
			.concat(a ? "|" : "")
			.concat(M.replace(/([:|\\])/g, "\\$1"), ":")
			.concat(T);
	}
	return a;
}
function Z0(m) {
	return JSON.stringify(
		m,
		function (a, p) {
			return p instanceof Error ? y8(p) : p;
		},
		2
	);
}
function U0(m) {
	return v8(dL(m));
}
function pL(m) {
	var a,
		p = cL(m);
	return {
		get visitorId() {
			return a === void 0 && (a = U0(this.components)), a;
		},
		set visitorId(y) {
			a = y;
		},
		confidence: p,
		components: m,
		version: E0,
	};
}
function fL(m) {
	return m === void 0 && (m = 50), c8(m, m * 2);
}
function mL(m, a) {
	var p = Date.now();
	return {
		get: function (y) {
			return Po(this, void 0, void 0, function () {
				var M, z, T;
				return Io(this, function (s) {
					switch (s.label) {
						case 0:
							return (M = Date.now()), [4, m()];
						case 1:
							return (
								(z = s.sent()),
								(T = pL(z)),
								(a || (y != null && y.debug)) &&
									console.log(
										"Copy the text below to get the debug data:\n\n```\nversion: "
											.concat(
												T.version,
												`
userAgent: `
											)
											.concat(
												navigator.userAgent,
												`
timeBetweenLoadAndGet: `
											)
											.concat(
												M - p,
												`
visitorId: `
											)
											.concat(
												T.visitorId,
												`
components: `
											)
											.concat(Z0(z), "\n```")
									),
								[2, T]
							);
					}
				});
			});
		},
	};
}
function _L() {
	if (!(window.__fpjs_d_m || Math.random() >= 0.001))
		try {
			var m = new XMLHttpRequest();
			m.open(
				"get",
				"https://m1.openfpcdn.io/fingerprintjs/v".concat(E0, "/npm-monitoring"),
				!0
			),
				m.send();
		} catch (a) {
			console.error(a);
		}
}
function gL(m) {
	var a;
	return (
		m === void 0 && (m = {}),
		Po(this, void 0, void 0, function () {
			var p, y, M;
			return Io(this, function (z) {
				switch (z.label) {
					case 0:
						return (
							(!((a = m.monitoring) !== null && a !== void 0) || a) && _L(),
							(p = m.delayFallback),
							(y = m.debug),
							[4, fL(p)]
						);
					case 1:
						return z.sent(), (M = sL({ cache: {}, debug: y })), [2, mL(M, y)];
				}
			});
		})
	);
}
var vL = { load: gL, hashComponents: U0, componentsToDebugString: Z0 };
let Uf = null;
async function yL() {
	return Uf || (Uf = vL.load()), Uf;
}
async function xL() {
	return (await (await yL()).get()).visitorId;
}
var bL = Pr(
	'<svg><path d="M200-80q-50 0-85-35t-35-85q0-39 22.5-69.5T160-313v-334q-35-13-57.5-43.5T80-760q0-50 35-85t85-35q39 0 69.5 22.5T313-800h334q12-35 42.5-57.5T760-880q50 0 85 35t35 85q0 40-22.5 70.5T800-647v334q35 13 57.5 43.5T880-200q0 50-35 85t-85 35q-39 0-69.5-22.5T647-160H313q-13 35-43.5 57.5T200-80Zm0-640q17 0 28.5-11.5T240-760q0-17-11.5-28.5T200-800q-17 0-28.5 11.5T160-760q0 17 11.5 28.5T200-720Zm560 0q17 0 28.5-11.5T800-760q0-17-11.5-28.5T760-800q-17 0-28.5 11.5T720-760q0 17 11.5 28.5T760-720ZM313-240h334q9-26 28-45t45-28v-334q-26-9-45-28t-28-45H313q-9 26-28 45t-45 28v334q26 9 45 28t28 45Zm447 80q17 0 28.5-11.5T800-200q0-17-11.5-28.5T760-240q-17 0-28.5 11.5T720-200q0 17 11.5 28.5T760-160Zm-560 0q17 0 28.5-11.5T240-200q0-17-11.5-28.5T200-240q-17 0-28.5 11.5T160-200q0 17 11.5 28.5T200-160Zm0-600Zm560 0Zm0 560Zm-560 0Z"></path></svg>'
);
function Gu(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = bL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var wL = Pr(
	'<svg><path d="M120-120v-190l358-358-58-56 58-56 76 76 124-124q5-5 12.5-8t15.5-3q8 0 15 3t13 8l94 94q5 6 8 13t3 15q0 8-3 15.5t-8 12.5L705-555l76 78-57 57-56-58-358 358H120Zm80-80h78l332-334-76-76-334 332v78Zm447-410 96-96-37-37-96 96 37 37Zm0 0-37-37 37 37Z"></path></svg>'
);
function wv(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = wL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var TL = Pr(
	'<svg><path d="m247-904 57-56 343 343q23 23 23 57t-23 57L457-313q-23 23-57 23t-57-23L153-503q-23-23-23-57t23-57l190-191-96-96Zm153 153L209-560h382L400-751Zm360 471q-33 0-56.5-23.5T680-360q0-21 12.5-45t27.5-45q9-12 19-25t21-25q11 12 21 25t19 25q15 21 27.5 45t12.5 45q0 33-23.5 56.5T760-280ZM80 0v-160h800V0H80Z"></path></svg>'
);
function $0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = TL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var CL = Pr(
		'<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm240-400v80h80v-80h-80Zm-160 0v80h80v-80h-80Zm80 80v80h80v-80h-80Zm160 0v80h80v-80h-80Zm-320 0v80h80v-80h-80Zm400-80v80h80v80h80v-80h-80v-80h-80ZM280-360v80h-80v80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h-80v80h-80v-80h-80v80h-80v-80h-80Zm480-160v80-80Zm0 160v80-80Z"></path></svg>'
	),
	SL = Pr(
		'<svg><path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path></svg>'
	);
function G0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
	var y = er(),
		M = Ct(y);
	{
		var z = (s) => {
				var B = CL();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			},
			T = (s) => {
				var B = SL();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			};
		Oe(M, (s) => {
			a.filled ? s(z) : s(T, !1);
		});
	}
	$(m, y);
}
var PL = Pr(
	'<svg><path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"></path></svg>'
);
function Pm(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = PL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var IL = Pr(
	'<svg><path d="M419-80q-28 0-52.5-12T325-126L107-403l19-20q20-21 48-25t52 11l74 45v-328q0-17 11.5-28.5T340-760q17 0 29 11.5t12 28.5v472l-97-60 104 133q6 7 14 11t17 4h221q33 0 56.5-23.5T720-240v-160q0-17-11.5-28.5T680-440H461v-80h219q50 0 85 35t35 85v160q0 66-47 113T640-80H419ZM167-620q-13-22-20-47.5t-7-52.5q0-83 58.5-141.5T340-920q83 0 141.5 58.5T540-720q0 27-7 52.5T513-620l-69-40q8-14 12-28.5t4-31.5q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 17 4 31.5t12 28.5l-69 40Zm335 280Z"></path></svg>'
);
function H0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = IL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var ML = Pr(
	'<svg><path d="m356-160-56-56 180-180 180 180-56 56-124-124-124 124Zm124-404L300-744l56-56 124 124 124-124 56 56-180 180Z"></path></svg>'
);
function kL(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = ML();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var AL = Pr(
	'<svg><path d="M480-120 300-300l58-58 122 122 122-122 58 58-180 180ZM358-598l-58-58 180-180 180 180-58 58-122-122-122 122Z"></path></svg>'
);
function EL(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = AL();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var zL = Te("<!> ", 1),
	LL = Te("<!> ", 1),
	DL = Te("<!> ", 1),
	RL = Te(
		'<!><b> </b> <span class="touchscreen:hidden"> <span class="kbd kbd-xs text-base-content rounded-md"> </span></span> ',
		1
	),
	BL = Te("<!> ", 1),
	FL = Te("<!> <!>", 1),
	OL = (m, a) => se(a, !x(a)),
	NL = (m, a) => {
		se(a, "colorpicker");
	},
	jL = (m, a) => {
		a(!a());
	},
	VL = (m, a) => {
		se(a, "cleararea");
	},
	qL = Te(
		'<div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">C</kbd></div> <button><!></button></div>'
	),
	ZL = (m, a) => {
		aa.smallPlop.play(), a();
	},
	UL = (m, a, p) => {
		a(x(p).idx);
	},
	$L = Te(
		'<!> <span class="bg-base-100 translate-1/2 absolute bottom-0 right-0 flex size-5 items-center justify-center rounded-full max-sm:hidden"><!></span>',
		1
	),
	GL = Te("<div><button><!></button></div>"),
	HL = (m, a) => {
		se(a, !x(a));
	},
	WL = (m, a) => {
		se(a, x(a) === "eraser" ? "pencil" : "eraser", !0);
	},
	XL = Te(
		'<div class="relative px-3"><!> <div class="flex items-center gap-1.5"><button class="btn btn-circle btn-sm btn-soft"><!></button> <div class="flex grow items-center gap-1"><h2 class="select-none text-xl"> <!></h2> <div class="tooltip ml-1"><div class="tooltip-content"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">I</kbd></div> <button><!></button></div> <div class="tooltip"><button title="Toggle art opacity"><!></button></div> <!></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mb-4 mt-3"><div></div></div> <div class="relative h-12 sm:h-14"><button class="btn btn-lg btn-square sm:btn-xl absolute bottom-0 left-0 shadow-md"><!></button> <div class="absolute bottom-0 left-1/2 -translate-x-1/2"><!></div> <div class="absolute bottom-0 right-0"><div class="tooltip ml-auto"><div class="tooltip-content not-touchscreen:-translate-x-[10%]"> <kbd class="kbd kbd-xs text-base-content touchscreen:hidden ml-0.5 rounded-md">E</kbd></div> <button><!></button></div></div></div></div> <!>',
		1
	);
function YL(m, a) {
	Lr(a, !0);
	let p = zt(a, "screenLocked", 15),
		y = zt(a, "opaquePixelArt", 15);
	const M = ft(() => new fl(a.tileSize));
	let z = st(1),
		T = st("pencil");
	const s = new Map(),
		B = new Map();
	let O = st(0),
		X = st(!1),
		K = st(!0),
		ne = ft(() => Mt.charges ?? 0),
		H = ft(() => x(ne) - x(O)),
		fe = st(!1),
		ge = !1,
		Ie = st(!1),
		Ae = st(bi([]));
	const De = ft(() => x(T) === "pencil"),
		Ee = ft(() => x(T) === "eraser"),
		Fe = ft(() => x(T) === "colorpicker"),
		$e = ft(() => x(T) === "cleararea"),
		Je = ft(() => {
			var mt, He;
			return xc(
				(He = (mt = Mt) == null ? void 0 : mt.data) == null ? void 0 : He.role,
				["admin", "global_moderator"]
			);
		});
	let qe = st(!1),
		Ze = st(0),
		Qe = st(void 0),
		Le = st(void 0);
	const et = [
			1, 2, 3, 32, 4, 5, 6, 33, 7, 34, 35, 8, 9, 10, 11, 37, 38, 39, 40, 41, 42,
			12, 13, 14, 15, 16, 17, 43, 20, 44, 18, 19, 45, 46, 21, 22, 47, 48, 49,
			23, 24, 25, 26, 27, 28, 53, 54, 55, 29, 30, 50, 56, 57, 36, 51, 31, 52,
			61, 62, 63, 58, 59, 60, 0,
		].map((mt) => ({ ...Wi.colors[mt], idx: mt })),
		nt = [
			1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
			22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,
		].map((mt) => ({ ...Wi.colors[mt], idx: mt }));
	let Ue = st(!1);
	const ke = ft(() => (x(Ue) ? et : nt)),
		vt = "show-all-colors";
	Fn(() => {
		se(Ue, localStorage.getItem(vt) === "true");
	}),
		Wr(() => {
			localStorage.setItem(vt, x(Ue) ? "true" : "false");
		});
	const ee = "selected-color";
	Fn(() => {
		const mt = Number(localStorage.getItem(ee));
		!isNaN(mt) && mt < Wi.colors.length && mt > 0 && se(z, mt, !0);
	}),
		Wr(() => {
			localStorage.setItem(ee, x(z).toString());
		});
	const re = new $E({
		map: a.map,
		tileSize: a.tileSize,
		tileZoom: a.tileZoom,
		beforeLayerId: a.hoverLayerId,
	});
	Wr(() => {
		const mt = y() ? 1 : 0;
		re.setCanvasOpacity(mt);
	}),
		Wr(() => {
			y() ? Hf() : ct([...s.values()]);
		});
	let he = !1;
	Fn(() => {
		Co(a.map.getCenter(), a.map.getZoom());
		const mt = a.map.on("click", (pr) => {
			var tn;
			a.zoom < a.tileZoom + 2 &&
				((tn = Mt.data) == null ? void 0 : tn.role) === "user" &&
				a.map.easeTo({ center: pr.lngLat, zoom: 17 });
			const In = [pr.lngLat.lat, pr.lngLat.lng];
			if (x(De)) ze([In], x(z));
			else if (x(Ee)) je([In]);
			else if (x(Fe)) pt(In, pr.point);
			else if (x($e) && (x(Ae).push(In), ze([In], 0), x(Ae).length >= 2)) {
				const [en, ma] = x(Ae),
					[pi, Xi] = x(M).latLonToPixelsFloor(en[0], en[1], a.tileZoom),
					[Zn, ni] = x(M).latLonToPixelsFloor(ma[0], ma[1], a.tileZoom),
					Zi = Math.min(pi, Zn),
					Yi = Math.max(pi, Zn),
					Ei = Math.min(Xi, ni),
					zi = Math.max(Xi, ni),
					Ki = [];
				for (let oa = Ei; oa <= zi; oa++) {
					const Ta = x(M).pixelsToLatLon(Zi + 0.5, oa + 0.5, a.tileZoom),
						bt = x(M).pixelsToLatLon(Yi + 0.5, oa + 0.5, a.tileZoom),
						Xt = He(
							{ lat: Ta[0], lng: Ta[1] },
							{ lat: bt[0], lng: bt[1] }
						).slice(0, x(H) - Ki.length);
					if ((Ki.push(...Xt), Ki.length >= x(H))) break;
				}
				ze(Ki, 0), se(Ae, [], !0), se(T, "pencil");
			}
			se(fe, !0);
		});
		function He(pr, In) {
			const tn = x(M).latLonToPixels(pr.lat, pr.lng, a.tileZoom),
				en = In ? x(M).latLonToPixels(In.lat, In.lng, a.tileZoom) : tn;
			return Rx(tn, en).map((pi) =>
				x(M).pixelsToLatLon(pi[0] + 0.5, pi[1] + 0.5, a.tileZoom)
			);
		}
		function At(pr, In) {
			const tn = He(pr, In);
			x(De) ? ze(tn, x(z)) : x(Ee) && je(tn), se(fe, !0);
		}
		let Ft;
		function Jt(pr) {
			const In = a.map.unproject([pr.clientX, pr.clientY]);
			if (x(Ie)) {
				const tn = He(In, Ft);
				je(tn);
			}
			(he || ge) && At(In, Ft), (Ft = In);
		}
		window.addEventListener("mousemove", Jt);
		let Cr = !1;
		const Er = a.map.on("touchstart", (pr) => {
				if (pr.points.length == 2) {
					p(!1), dt(), (Cr = !0), setTimeout(() => (Cr = !1), 150);
					return;
				}
				p() &&
					setTimeout(() => {
						!Cr && At(pr.lngLat);
					}, 150),
					(Ft = pr.lngLat);
			}),
			ur = a.map.on("touchmove", (pr) => {
				p() && At(pr.lngLat, Ft), (Ft = pr.lngLat);
			}),
			rn = (pr) => {
				pr.code === "Space" &&
					(he || (Ft && At(Ft)), (he = !0), pr.preventDefault());
			};
		document.addEventListener("keydown", rn);
		const pn = (pr) => {
			pr.code === "Space" &&
				((he = !1), (oe = !1), x(O) === 0 && x(Ee) && se(T, "pencil"));
		};
		document.addEventListener("keyup", pn);
		function gn(pr) {
			if (pr.button === 2) {
				se(Ie, !0);
				const tn = a.map.unproject([pr.clientX, pr.clientY]);
				je([[tn.lat, tn.lng]]);
			}
		}
		document.addEventListener("mousedown", gn);
		function ln(pr) {
			pr.button === 2 && se(Ie, !1);
		}
		document.addEventListener("mouseup", ln);
		const En = (pr) => {
			switch (pr.code) {
				case "KeyE":
					x(O) > 0 && (x(Ee) ? se(T, "pencil") : se(T, "eraser"));
					return;
				case "KeyI":
					se(T, "colorpicker");
					return;
				case "KeyC":
					x(Je) && se(T, "cleararea");
					return;
			}
		};
		return (
			document.addEventListener("keypress", En),
			() => {
				ur.unsubscribe(),
					Er.unsubscribe(),
					mt.unsubscribe(),
					document.removeEventListener("mousemove", Jt),
					document.removeEventListener("keydown", rn),
					document.removeEventListener("keyup", pn),
					document.removeEventListener("keypress", En),
					document.removeEventListener("mousedown", gn),
					document.removeEventListener("mouseup", ln),
					It();
			}
		);
	});
	let oe = !1;
	function ze(mt, He) {
		let At = !1;
		const Ft = He === 0;
		for (let Jt of mt) {
			const [Cr, Er] = Jt,
				ur = Ex(He),
				{ tile: rn, pixel: pn } = x(M).latLonToTileAndPixel(Cr, Er, a.tileZoom),
				gn = { color: ur, tile: rn, pixel: pn, season: a.season, colorIdx: He },
				ln = Df(gn),
				En = s.get(ln),
				pr = x(ne) - s.size;
			if (!En && pr < 1) {
				if (oe && (he || p())) continue;
				(oe = !0), Fr.info(HC());
				continue;
			}
			(En && En.colorIdx === He) ||
				(aa.plop.play(),
				At || a.hidePixelHover(),
				s.set(ln, gn),
				re.place(Jt, He),
				a.crosshair.place(Jt),
				(At = !0),
				Ft && B.set(ln, gn));
		}
		se(O, s.size, !0),
			At && !y() ? ct([...s.values()]) : At && y() && Ft && ct([...B.values()]);
	}
	function je(mt) {
		let He = !1,
			At = !1;
		for (let Ft of mt) {
			const [Jt, Cr] = Ft,
				{ tile: Er, pixel: ur } = x(M).latLonToTileAndPixel(Jt, Cr, a.tileZoom),
				rn = Df({ tile: Er, pixel: ur, season: a.season }),
				pn = s.get(rn);
			pn &&
				(aa.plop.play(),
				a.hidePixelHover(),
				s.delete(rn),
				B.delete(rn),
				re.remove([Jt, Cr]),
				a.crosshair.remove(Ft),
				(He = !0),
				pn.colorIdx === 0 && (At = !0)),
				s.size === 0 && !(he || ge || p()) && se(T, "pencil");
		}
		se(O, s.size, !0),
			He && !y() ? ct([...s.values()]) : He && y() && At && ct([...B.values()]);
	}
	function pt(mt, He) {
		const { tile: At, pixel: Ft } = x(M).latLonToTileAndPixel(
				mt[0],
				mt[1],
				a.tileZoom
			),
			Jt = Df({ tile: At, pixel: Ft, season: a.season }),
			Cr = s.get(Jt);
		if (Cr) {
			yt(Cr.colorIdx),
				requestAnimationFrame(() => {
					var pn;
					(pn = document.getElementById(`color-${Cr.colorIdx}`)) == null ||
						pn.focus();
				});
			return;
		}
		const Er = window.devicePixelRatio,
			ur = Math.floor(He.x * Er),
			rn = Math.floor(He.y * Er);
		a.hidePixelHover(),
			KM(a.map, ur, rn).then(([pn, gn, ln]) => {
				const En = zx({ r: pn, g: gn, b: ln });
				yt(En),
					requestAnimationFrame(() => {
						var pr;
						(pr = document.getElementById(`color-${En}`)) == null || pr.focus();
					});
			});
	}
	dl(
		() => x(z),
		() => {
			a.clickedLatLon &&
				!x(fe) &&
				(x(z) === void 0 && se(z, 1), ze([a.clickedLatLon], x(z)));
		}
	),
		Wr(() => {
			const mt = x(K) ? 0.8 : 0;
			a.crosshair.setCanvasOpacity(mt);
		});
	let it = st(16.5);
	Wr(() => {
		if (x(Qe) && x(Le) && a.clickedLatLon) {
			const mt = a.map.getZoom();
			if (mt < x(it)) {
				const [He, At] = a.clickedLatLon,
					Ft = x(M).latLonToPixelBoundsLatLon(He, At, a.tileZoom),
					Jt = qm(Ft),
					Cr = x(Qe) - x(Le).clientHeight,
					Er = x(Qe) / 2 - Cr / 2;
				a.map.flyTo({
					center: { lat: Jt[0], lng: Jt[1] },
					zoom: 17.5,
					offset: mt > 11 ? [0, -Er] : [0, 0],
				});
			}
			se(it, a.tileZoom, !0);
		}
	}),
		Fn(() => {
			const mt = () => {
				!document.hidden &&
					(console.log("Tab visible again"),
					y() ? ct([...B.values()]) : ct([...s.values()]));
			};
			return (
				document.addEventListener("visibilitychange", mt),
				() => document.removeEventListener("visibilitychange", mt)
			);
		}),
		Wr(() => {
			switch (x(T)) {
				case "pencil":
					(a.map.getCanvas().style.cursor = `url('${ZE}') 8 8, default`),
						a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0.4);
					return;
				case "colorpicker":
					(a.map.getCanvas().style.cursor = `url('${VE}') 0 16, default`),
						a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0);
					return;
				case "eraser":
					(a.map.getCanvas().style.cursor = `url('${qE}') 2 14, default`),
						a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0.4);
					return;
			}
		}),
		Wr(() => {
			p() ? at() : dt();
		});
	async function ct(mt) {
		await gx(mt), a.refreshPixelArt();
	}
	async function It() {
		await Hf(), re.clear(), a.refreshPixelArt(), a.crosshair.clear();
	}
	async function Dt() {
		await It(),
			dt(),
			(a.map.getCanvas().style.cursor = "default"),
			a.map.setPaintProperty(a.hoverLayerId, "raster-opacity", 0.4),
			a.onclose();
	}
	function at() {
		a.map.dragPan.disable(),
			a.map.touchZoomRotate.disable(),
			(document.body.style.overscrollBehavior = "none");
	}
	function dt() {
		a.map.dragPan.enable(),
			a.map.touchZoomRotate.enable(),
			(document.body.style.overscrollBehavior = "");
	}
	function yt(mt) {
		return (
			mt >= 32 && se(Ue, !0),
			Mt.hasColor(mt)
				? (aa.smallDropplet.play(), se(z, mt, !0), se(T, "pencil"), !0)
				: (aa.smallDropplet.play(), se(qe, !0), se(Ze, mt, !0), !1)
		);
	}
	ix((mt) => {
		mt.type === "leave" && x(O) > 0 && mt.cancel();
	});
	const xt = "show-paint-more-than-one-pixel-msg";
	let St = st(!1);
	Fn(() => {
		var mt;
		se(
			St,
			!localStorage.getItem(xt) &&
				(((mt = Mt.data) == null ? void 0 : mt.pixelsPainted) ?? 0) < 100,
			!0
		);
	}),
		Wr(() => {
			x(O) > 1 && (se(St, !1), localStorage.setItem(xt, "false"));
		});
	const wt = "lp";
	Fn(() => {
		var He;
		const mt = localStorage.getItem(wt);
		if (mt)
			try {
				const At = JSON.parse(atob(mt)),
					Ft = (At == null ? void 0 : At.time) ?? 0,
					Jt = 60 * 1e3;
				(At == null ? void 0 : At.userId) !==
					((He = Mt.data) == null ? void 0 : He.id) &&
					Date.now() - Ft < 30 * Jt &&
					!Xx &&
					(Fr.error(YC()), Dt());
			} catch (At) {
				console.error(At);
			}
	});
	function _t() {
		var He;
		const mt = btoa(
			JSON.stringify({
				userId: (He = Mt.data) == null ? void 0 : He.id,
				time: Date.now(),
			})
		);
		localStorage.setItem(wt, mt);
	}
	var Lt = XL(),
		Rt = Ct(Lt),
		$t = A(Rt);
	{
		var tr = (mt) => {
				ol(mt, {
					children: (He, At) => {
						var Ft = zL(),
							Jt = Ct(Ft);
						$0(Jt, { class: "inline size-5" });
						var Cr = j(Jt);
						We((Er) => de(Cr, ` ${Er ?? ""}`), [() => S5()]), $(He, Ft);
					},
					$$slots: { default: !0 },
				});
			},
			Qt = (mt) => {
				var He = er(),
					At = Ct(He);
				{
					var Ft = (Cr) => {
							ol(Cr, {
								class: "not-touchscreen:hidden",
								children: (Er, ur) => {
									var rn = LL(),
										pn = Ct(rn);
									Wg(pn, { class: "inline size-5" });
									var gn = j(pn);
									We((ln) => de(gn, ` ${ln ?? ""}`), [() => M5()]), $(Er, rn);
								},
								$$slots: { default: !0 },
							});
						},
						Jt = (Cr) => {
							var Er = er(),
								ur = Ct(Er);
							{
								var rn = (gn) => {
										ol(gn, {
											class: "not-touchscreen:hidden",
											children: (ln, En) => {
												var pr = DL(),
													In = Ct(pr);
												wv(In, { class: "inline size-5" });
												var tn = j(In, 1, !0);
												We((en) => de(tn, en), [() => E5()]), $(ln, pr);
											},
											$$slots: { default: !0 },
										});
									},
									pn = (gn) => {
										var ln = er(),
											En = Ct(ln);
										{
											var pr = (tn) => {
													ol(tn, {
														class: "touchscreen:hidden",
														children: (en, ma) => {
															var pi = RL(),
																Xi = Ct(pi);
															H0(Xi, { class: "inline size-5" });
															var Zn = j(Xi),
																ni = A(Zn, !0);
															k(Zn);
															var Zi = j(Zn, 2),
																Yi = A(Zi),
																Ei = j(Yi),
																zi = A(Ei, !0);
															k(Ei), k(Zi);
															var Ki = j(Zi);
															We(
																(oa, Ta, bt, Xt) => {
																	de(ni, oa),
																		de(Yi, `${Ta ?? ""} `),
																		de(zi, bt),
																		de(Ki, ` ${Xt ?? ""}`);
																},
																[() => D5(), () => j5(), () => F5(), () => Z5()]
															),
																$(en, pi);
														},
														$$slots: { default: !0 },
													});
												},
												In = (tn) => {
													var en = er(),
														ma = Ct(en);
													{
														var pi = (Zn) => {
																ol(Zn, {
																	class:
																		"bg-warning text-warning-content animate-bounce",
																	children: (ni, Zi) => {
																		var Yi = BL(),
																			Ei = Ct(Yi);
																		zh(Ei, { class: "inline size-5" });
																		var zi = j(Ei);
																		We(
																			(Ki) => de(zi, ` ${Ki ?? ""}`),
																			[() => G5()]
																		),
																			$(ni, Yi);
																	},
																	$$slots: { default: !0 },
																});
															},
															Xi = (Zn) => {
																var ni = er(),
																	Zi = Ct(ni);
																{
																	var Yi = (Ei) => {
																		ol(Ei, {
																			class:
																				"bg-warning text-warning-content animate-bounce",
																			children: (zi, Ki) => {
																				var oa = FL(),
																					Ta = Ct(oa);
																				Gu(Ta, { class: "inline size-5" });
																				var bt = j(Ta, 2);
																				{
																					var Xt = (xn) => {
																							var On = wi();
																							We(
																								(Yn) => de(On, Yn),
																								[() => Qv()]
																							),
																								$(xn, On);
																						},
																						Br = (xn) => {
																							var On = er(),
																								Yn = Ct(On);
																							{
																								var Vn = (wn) => {
																									var Ji = wi();
																									We(
																										(sr) => de(Ji, sr),
																										[() => e0()]
																									),
																										$(wn, Ji);
																								};
																								Oe(
																									Yn,
																									(wn) => {
																										x(Ae).length === 1 &&
																											wn(Vn);
																									},
																									!0
																								);
																							}
																							$(xn, On);
																						};
																					Oe(bt, (xn) => {
																						x(Ae).length === 0
																							? xn(Xt)
																							: xn(Br, !1);
																					});
																				}
																				$(zi, oa);
																			},
																			$$slots: { default: !0 },
																		});
																	};
																	Oe(
																		Zi,
																		(Ei) => {
																			x($e) && Ei(Yi);
																		},
																		!0
																	);
																}
																$(Zn, ni);
															};
														Oe(
															ma,
															(Zn) => {
																x(St) ? Zn(pi) : Zn(Xi, !1);
															},
															!0
														);
													}
													$(tn, en);
												};
											Oe(
												En,
												(tn) => {
													x(De) && x(O) === 0 ? tn(pr) : tn(In, !1);
												},
												!0
											);
										}
										$(gn, ln);
									};
								Oe(
									ur,
									(gn) => {
										x(Fe) ? gn(rn) : gn(pn, !1);
									},
									!0
								);
							}
							$(Cr, Er);
						};
					Oe(
						At,
						(Cr) => {
							x(Ee) ? Cr(Ft) : Cr(Jt, !1);
						},
						!0
					);
				}
				$(mt, He);
			};
		Oe($t, (mt) => {
			x(Ee) && x(O) === 0 ? mt(tr) : mt(Qt, !1);
		});
	}
	var Ot = j($t, 2),
		Nt = A(Ot);
	Nt.__click = [OL, K];
	var or = A(Nt);
	{
		var cr = (mt) => {
				WE(mt, { class: "size-4" });
			},
			Vr = (mt) => {
				YE(mt, { class: "size-4" });
			};
		Oe(or, (mt) => {
			x(K) ? mt(cr) : mt(Vr, !1);
		});
	}
	k(Nt);
	var mr = j(Nt, 2),
		hr = A(mr),
		_r = A(hr),
		Ir = j(_r);
	M0(Ir, {
		class: "inline",
		fontSize: 14,
		get value() {
			return `(${x(O) ?? ""})`;
		},
		mono: !0,
	}),
		k(hr);
	var qr = j(hr, 2),
		ue = A(qr),
		V = A(ue);
	yn(), k(ue);
	var U = j(ue, 2);
	U.__click = [NL, T];
	var Y = A(U);
	wv(Y, { class: "size-4.5" }), k(U), k(qr);
	var ie = j(qr, 2),
		pe = A(ie);
	let Se;
	pe.__click = [jL, y];
	var Me = A(pe);
	{
		let mt = ft(() => !y());
		G0(Me, {
			class: "size-4.5",
			get filled() {
				return x(mt);
			},
		});
	}
	k(pe), k(ie);
	var we = j(ie, 2);
	{
		var Ve = (mt) => {
			var He = qL(),
				At = A(He),
				Ft = A(At);
			yn(), k(At);
			var Jt = j(At, 2);
			Jt.__click = [VL, T];
			var Cr = A(Jt);
			Gu(Cr, { class: "size-4.5" }),
				k(Jt),
				k(He),
				We(
					(Er) => {
						de(Ft, `${Er ?? ""} `),
							zr(
								Jt,
								1,
								Yo({
									"btn btn-circle btn-sm": !0,
									"btn-ghost": !x($e),
									"btn-primary": x($e),
								})
							);
					},
					[() => XP()]
				),
				$(mt, He);
		};
		Oe(we, (mt) => {
			x(Je) && mt(Ve);
		});
	}
	k(mr);
	var ut = j(mr, 2);
	ut.__click = [ZL, Dt];
	var Ke = A(ut);
	_l(Ke, { class: "size-4" }), k(ut), k(Ot);
	var kt = j(Ot, 2),
		ye = A(kt);
	hi(
		ye,
		23,
		() => x(ke),
		(mt) => mt.idx,
		(mt, He, At) => {
			const Ft = ft(() => {
					const [ln, En, pr] = x(He).rgb;
					return { r: ln, g: En, b: pr };
				}),
				Jt = ft(() => x(z) === x(He).idx && x(De)),
				Cr = ft(() => x(He).idx === 0),
				Er = ft(() => Mt.hasColor(x(He).idx));
			var ur = GL(),
				rn = A(ur);
			rn.__click = [UL, yt, He];
			var pn = A(rn);
			{
				var gn = (ln) => {
					var En = $L(),
						pr = Ct(En);
					Pm(pr, {
						class:
							"center-absolute absolute size-4 opacity-30 sm:hidden sm:size-6",
					});
					var In = j(pr, 2),
						tn = A(In);
					Pm(tn, { class: "text-base-content/80 size-4" }), k(In), $(ln, En);
				};
				Oe(pn, (ln) => {
					x(Er) || ln(gn);
				});
			}
			k(rn),
				k(ur),
				We(() => {
					zr(
						ur,
						1,
						Yo({
							tooltip: !0,
							"max-sm:h-6": x(Ue),
							"max-sm:before:translate-x-1/4":
								x(At) % 8 === 0 && x(He).name.length > 7,
							"max-sm:before:-translate-x-1/4":
								(x(At) - 7) % 8 === 0 && x(He).name.length > 7,
							"max-xl:before:translate-x-1/4":
								x(At) % 16 === 0 && x(He).name.length > 7,
							"max-xl:before:-translate-x-1/4":
								(x(At) - 15) % 16 === 0 && x(He).name.length > 7,
							"xl:before:translate-x-1/4":
								x(Ue) && x(At) % 32 === 0 && x(He).name.length > 7,
							"xl:before:-translate-x-1/4":
								x(Ue) && (x(At) - 31) % 32 === 0 && x(He).name.length > 7,
						})
					),
						Tr(ur, "data-tip", x(He).name),
						zr(
							rn,
							1,
							Yo({
								"btn relative aspect-square w-full rounded-xl": !0,
								"border-primary ring-primary ring-2": x(Jt),
								"border-base-300": !x(Jt) && x(Cr),
								"border-base-content/20": !x(Jt) && !x(Cr),
								"max-sm:h-6 max-sm:rounded-md": x(Ue),
							})
						),
						kc(
							rn,
							x(Cr)
								? `background-image: url(${UE}); background-size: cover; image-rendering: pixelated;`
								: `background: rgb(${x(Ft).r} ${x(Ft).g} ${x(Ft).b})`
						),
						Tr(rn, "aria-label", x(He).name),
						Tr(rn, "id", `color-${x(He).idx ?? ""}`);
				}),
				di("focus", rn, () => {
					x(Er) && (se(z, x(He).idx, !0), se(T, "pencil"));
				}),
				$(mt, ur);
		}
	),
		k(ye),
		k(kt);
	var Bt = j(kt, 2),
		rr = A(Bt);
	rr.__click = [HL, Ue];
	var Kt = A(rr);
	{
		var gr = (mt) => {
				kL(mt, { class: "size-5" });
			},
			Ur = (mt) => {
				EL(mt, { class: "size-5" });
			};
		Oe(Kt, (mt) => {
			x(Ue) ? mt(gr) : mt(Ur, !1);
		});
	}
	k(rr);
	var nn = j(rr, 2),
		mn = A(nn);
	{
		let mt = ft(() => (x(O) > 100 ? "animate-pulse" : "")),
			He = ft(() => x(O) === 0 || x(X) || x(H) < 0 || !ai.captcha),
			At = ft(() => x(X) || !ai.captcha);
		k0(mn, {
			get class() {
				return x(mt);
			},
			get charges() {
				return x(H);
			},
			get disabled() {
				return x(He);
			},
			get loading() {
				return x(At);
			},
			onclick: async () => {
				var Cr;
				const Ft = (Cr = ai.captcha) == null ? void 0 : Cr.token;
				if (!Ft) return;
				aa.droppletAndPlop.play();
				const Jt = [...s.values()];
				se(X, !0);
				try {
					const Er = await xL();
					await Qr.paint(Jt, Ft, Er),
						await vx(Jt),
						_t(),
						Mt.refresh(),
						(Yd.shouldReload = !0),
						await Dt();
				} catch (Er) {
					Fr.error(`${Er.message}`, { duration: 7e3 });
				} finally {
					se(X, !1), (ai.captcha = void 0);
				}
			},
		});
	}
	k(nn);
	var _n = j(nn, 2),
		Vt = A(_n),
		Et = A(Vt),
		dr = A(Et);
	yn(), k(Et);
	var ht = j(Et, 2);
	let Xr;
	ht.__click = [WL, T];
	var Yr = A(ht);
	Wg(Yr, {
		class: "size-5",
		get filled() {
			return x(Ee);
		},
	}),
		k(ht),
		k(Vt),
		k(_n),
		k(Bt),
		k(Rt),
		Ko(
			Rt,
			(mt) => se(Le, mt),
			() => x(Le)
		);
	var Zr = j(Rt, 2);
	s8(Zr, {
		get colorIdx() {
			return x(Ze);
		},
		get open() {
			return x(qe);
		},
		set open(mt) {
			se(qe, mt, !0);
		},
	}),
		We(
			(mt, He, At, Ft, Jt, Cr) => {
				de(_r, `${mt ?? ""} `),
					de(V, `${He ?? ""} `),
					zr(
						U,
						1,
						Yo({
							"btn btn-circle btn-sm": !0,
							"btn-ghost": !x(Fe),
							"btn-primary": x(Fe),
						})
					),
					Tr(ie, "data-tip", At),
					(Se = zr(
						pe,
						1,
						"btn btn-sm btn-circle btn-ghost text-base-content/80",
						null,
						Se,
						Ft
					)),
					zr(
						ye,
						1,
						Yo({
							"md:grid-cols-16 min-[100rem]:grid-cols-32 grid grid-cols-8": !0,
							"xl:grid-cols-32 sm:grid-cols-16 gap-0.5 sm:gap-1": x(Ue),
							"gap-1": !x(Ue),
						})
					),
					de(dr, `${Jt ?? ""} `),
					(Xr = zr(
						ht,
						1,
						"btn btn-lg btn-square sm:btn-xl shadow-md",
						null,
						Xr,
						Cr
					)),
					(ht.disabled = x(O) === 0);
			},
			[
				() => X5(),
				() => J5(),
				() => $v(),
				() => ({ "text-primary": !y() }),
				() => Bx(),
				() => ({ "btn-primary": x(Ee) }),
			]
		),
		mp("innerHeight", (mt) => se(Qe, mt, !0)),
		$(m, Lt),
		Dr();
}
$n(["click"]);
function Qm(...m) {
	return Lv(Ou(m));
}
var KL = Te("<div><!></div>");
function JL(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "children"]);
	var M = KL();
	ar(M, (T) => ({ class: T, ...y }), [() => Qm("flex items-center", a.class)]);
	var z = A(M);
	oi(z, () => a.children ?? pa),
		k(M),
		Ko(
			M,
			(T) => p(T),
			() => p()
		),
		$(m, M),
		Dr();
}
var QL = Te(
		'<div class="pointer-events-none absolute inset-0 flex items-center justify-center"><div class="animate-caret-blink bg-base-content/80 h-4 w-px duration-1000"></div></div>'
	),
	eD = Te(" <!>", 1);
function tD(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "cell", "class"]);
	var M = er(),
		z = Ct(M);
	{
		let T = ft(() =>
			Qm(
				"border-input relative flex size-12 items-center justify-center border-y border-r text-xl transition-all first:rounded-l-md first:border-l last:rounded-r-md",
				a.cell.isActive && "ring-base-content/40 z-10 ring-2",
				a.class
			)
		);
		xi(
			z,
			() => BA,
			(s, B) => {
				B(
					s,
					Is(
						{
							get cell() {
								return a.cell;
							},
							get class() {
								return x(T);
							},
						},
						() => y,
						{
							get ref() {
								return p();
							},
							set ref(O) {
								p(O);
							},
							children: (O, X) => {
								yn();
								var K = eD(),
									ne = Ct(K),
									H = j(ne);
								{
									var fe = (ge) => {
										var Ie = QL();
										$(ge, Ie);
									};
									Oe(H, (ge) => {
										a.cell.hasFakeCaret && ge(fe);
									});
								}
								We(() => de(ne, `${a.cell.char ?? ""} `)), $(O, K);
							},
							$$slots: { default: !0 },
						}
					)
				);
			}
		);
	}
	$(m, M), Dr();
}
function rD(m, a) {
	Lr(a, !0);
	let p = zt(a, "ref", 15, null),
		y = zt(a, "value", 15, ""),
		M = nr(a, ["$$slots", "$$events", "$$legacy", "ref", "class", "value"]);
	var z = er(),
		T = Ct(z);
	{
		let s = ft(() =>
			Qm(
				"flex items-center gap-2 has-[:disabled]:opacity-50 [&_input]:disabled:cursor-not-allowed",
				a.class
			)
		);
		xi(
			T,
			() => DA,
			(B, O) => {
				O(
					B,
					Is(
						{
							get class() {
								return x(s);
							},
						},
						() => M,
						{
							get ref() {
								return p();
							},
							set ref(X) {
								p(X);
							},
							get value() {
								return y();
							},
							set value(X) {
								y(X);
							},
						}
					)
				);
			}
		);
	}
	$(m, z), Dr();
}
var $f = { exports: {} },
	Tv;
function nD() {
	return (
		Tv ||
			((Tv = 1),
			(function (m) {
				(function (a) {
					m.exports ? (m.exports = a()) : (window.intlTelInput = a());
				})(() => {
					var a = (() => {
						var p = Object.defineProperty,
							y = Object.getOwnPropertyDescriptor,
							M = Object.getOwnPropertyNames,
							z = Object.prototype.hasOwnProperty,
							T = (ee, re) => {
								for (var he in re) p(ee, he, { get: re[he], enumerable: !0 });
							},
							s = (ee, re, he, oe) => {
								if ((re && typeof re == "object") || typeof re == "function")
									for (let ze of M(re))
										!z.call(ee, ze) &&
											ze !== he &&
											p(ee, ze, {
												get: () => re[ze],
												enumerable: !(oe = y(re, ze)) || oe.enumerable,
											});
								return ee;
							},
							B = (ee) => s(p({}, "__esModule", { value: !0 }), ee),
							O = {};
						T(O, { Iti: () => nt, default: () => vt });
						var X = [
								["af", "93"],
								["ax", "358", 1],
								["al", "355"],
								["dz", "213"],
								["as", "1", 5, ["684"]],
								["ad", "376"],
								["ao", "244"],
								["ai", "1", 6, ["264"]],
								["ag", "1", 7, ["268"]],
								["ar", "54"],
								["am", "374"],
								["aw", "297"],
								["ac", "247"],
								["au", "61", 0, null, "0"],
								["at", "43"],
								["az", "994"],
								["bs", "1", 8, ["242"]],
								["bh", "973"],
								["bd", "880"],
								["bb", "1", 9, ["246"]],
								["by", "375"],
								["be", "32"],
								["bz", "501"],
								["bj", "229"],
								["bm", "1", 10, ["441"]],
								["bt", "975"],
								["bo", "591"],
								["ba", "387"],
								["bw", "267"],
								["br", "55"],
								["io", "246"],
								["vg", "1", 11, ["284"]],
								["bn", "673"],
								["bg", "359"],
								["bf", "226"],
								["bi", "257"],
								["kh", "855"],
								["cm", "237"],
								[
									"ca",
									"1",
									1,
									[
										"204",
										"226",
										"236",
										"249",
										"250",
										"263",
										"289",
										"306",
										"343",
										"354",
										"365",
										"367",
										"368",
										"382",
										"387",
										"403",
										"416",
										"418",
										"428",
										"431",
										"437",
										"438",
										"450",
										"584",
										"468",
										"474",
										"506",
										"514",
										"519",
										"548",
										"579",
										"581",
										"584",
										"587",
										"604",
										"613",
										"639",
										"647",
										"672",
										"683",
										"705",
										"709",
										"742",
										"753",
										"778",
										"780",
										"782",
										"807",
										"819",
										"825",
										"867",
										"873",
										"879",
										"902",
										"905",
									],
								],
								["cv", "238"],
								["bq", "599", 1, ["3", "4", "7"]],
								["ky", "1", 12, ["345"]],
								["cf", "236"],
								["td", "235"],
								["cl", "56"],
								["cn", "86"],
								["cx", "61", 2, ["89164"], "0"],
								["cc", "61", 1, ["89162"], "0"],
								["co", "57"],
								["km", "269"],
								["cg", "242"],
								["cd", "243"],
								["ck", "682"],
								["cr", "506"],
								["ci", "225"],
								["hr", "385"],
								["cu", "53"],
								["cw", "599", 0],
								["cy", "357"],
								["cz", "420"],
								["dk", "45"],
								["dj", "253"],
								["dm", "1", 13, ["767"]],
								["do", "1", 2, ["809", "829", "849"]],
								["ec", "593"],
								["eg", "20"],
								["sv", "503"],
								["gq", "240"],
								["er", "291"],
								["ee", "372"],
								["sz", "268"],
								["et", "251"],
								["fk", "500"],
								["fo", "298"],
								["fj", "679"],
								["fi", "358", 0],
								["fr", "33"],
								["gf", "594"],
								["pf", "689"],
								["ga", "241"],
								["gm", "220"],
								["ge", "995"],
								["de", "49"],
								["gh", "233"],
								["gi", "350"],
								["gr", "30"],
								["gl", "299"],
								["gd", "1", 14, ["473"]],
								["gp", "590", 0],
								["gu", "1", 15, ["671"]],
								["gt", "502"],
								["gg", "44", 1, ["1481", "7781", "7839", "7911"], "0"],
								["gn", "224"],
								["gw", "245"],
								["gy", "592"],
								["ht", "509"],
								["hn", "504"],
								["hk", "852"],
								["hu", "36"],
								["is", "354"],
								["in", "91"],
								["id", "62"],
								["ir", "98"],
								["iq", "964"],
								["ie", "353"],
								["im", "44", 2, ["1624", "74576", "7524", "7924", "7624"], "0"],
								["il", "972"],
								["it", "39", 0],
								["jm", "1", 4, ["876", "658"]],
								["jp", "81"],
								[
									"je",
									"44",
									3,
									["1534", "7509", "7700", "7797", "7829", "7937"],
									"0",
								],
								["jo", "962"],
								["kz", "7", 1, ["33", "7"], "8"],
								["ke", "254"],
								["ki", "686"],
								["xk", "383"],
								["kw", "965"],
								["kg", "996"],
								["la", "856"],
								["lv", "371"],
								["lb", "961"],
								["ls", "266"],
								["lr", "231"],
								["ly", "218"],
								["li", "423"],
								["lt", "370"],
								["lu", "352"],
								["mo", "853"],
								["mg", "261"],
								["mw", "265"],
								["my", "60"],
								["mv", "960"],
								["ml", "223"],
								["mt", "356"],
								["mh", "692"],
								["mq", "596"],
								["mr", "222"],
								["mu", "230"],
								["yt", "262", 1, ["269", "639"], "0"],
								["mx", "52"],
								["fm", "691"],
								["md", "373"],
								["mc", "377"],
								["mn", "976"],
								["me", "382"],
								["ms", "1", 16, ["664"]],
								["ma", "212", 0, null, "0"],
								["mz", "258"],
								["mm", "95"],
								["na", "264"],
								["nr", "674"],
								["np", "977"],
								["nl", "31"],
								["nc", "687"],
								["nz", "64"],
								["ni", "505"],
								["ne", "227"],
								["ng", "234"],
								["nu", "683"],
								["nf", "672"],
								["kp", "850"],
								["mk", "389"],
								["mp", "1", 17, ["670"]],
								["no", "47", 0],
								["om", "968"],
								["pk", "92"],
								["pw", "680"],
								["ps", "970"],
								["pa", "507"],
								["pg", "675"],
								["py", "595"],
								["pe", "51"],
								["ph", "63"],
								["pl", "48"],
								["pt", "351"],
								["pr", "1", 3, ["787", "939"]],
								["qa", "974"],
								["re", "262", 0, null, "0"],
								["ro", "40"],
								["ru", "7", 0, null, "8"],
								["rw", "250"],
								["ws", "685"],
								["sm", "378"],
								["st", "239"],
								["sa", "966"],
								["sn", "221"],
								["rs", "381"],
								["sc", "248"],
								["sl", "232"],
								["sg", "65"],
								["sx", "1", 21, ["721"]],
								["sk", "421"],
								["si", "386"],
								["sb", "677"],
								["so", "252"],
								["za", "27"],
								["kr", "82"],
								["ss", "211"],
								["es", "34"],
								["lk", "94"],
								["bl", "590", 1],
								["sh", "290"],
								["kn", "1", 18, ["869"]],
								["lc", "1", 19, ["758"]],
								["mf", "590", 2],
								["pm", "508"],
								["vc", "1", 20, ["784"]],
								["sd", "249"],
								["sr", "597"],
								["sj", "47", 1, ["79"]],
								["se", "46"],
								["ch", "41"],
								["sy", "963"],
								["tw", "886"],
								["tj", "992"],
								["tz", "255"],
								["th", "66"],
								["tl", "670"],
								["tg", "228"],
								["tk", "690"],
								["to", "676"],
								["tt", "1", 22, ["868"]],
								["tn", "216"],
								["tr", "90"],
								["tm", "993"],
								["tc", "1", 23, ["649"]],
								["tv", "688"],
								["ug", "256"],
								["ua", "380"],
								["ae", "971"],
								["gb", "44", 0, null, "0"],
								["us", "1", 0],
								["uy", "598"],
								["vi", "1", 24, ["340"]],
								["uz", "998"],
								["vu", "678"],
								["va", "39", 1, ["06698"]],
								["ve", "58"],
								["vn", "84"],
								["wf", "681"],
								["eh", "212", 1, ["5288", "5289"], "0"],
								["ye", "967"],
								["zm", "260"],
								["zw", "263"],
							],
							K = [];
						for (let ee = 0; ee < X.length; ee++) {
							const re = X[ee];
							K[ee] = {
								name: "",
								iso2: re[0],
								dialCode: re[1],
								priority: re[2] || 0,
								areaCodes: re[3] || null,
								nodeById: {},
								nationalPrefix: re[4] || null,
							};
						}
						var ne = K,
							H = {
								ad: "Andorra",
								ae: "United Arab Emirates",
								af: "Afghanistan",
								ag: "Antigua & Barbuda",
								ai: "Anguilla",
								al: "Albania",
								am: "Armenia",
								ao: "Angola",
								ar: "Argentina",
								as: "American Samoa",
								at: "Austria",
								au: "Australia",
								aw: "Aruba",
								ax: "Åland Islands",
								az: "Azerbaijan",
								ba: "Bosnia & Herzegovina",
								bb: "Barbados",
								bd: "Bangladesh",
								be: "Belgium",
								bf: "Burkina Faso",
								bg: "Bulgaria",
								bh: "Bahrain",
								bi: "Burundi",
								bj: "Benin",
								bl: "St. Barthélemy",
								bm: "Bermuda",
								bn: "Brunei",
								bo: "Bolivia",
								bq: "Caribbean Netherlands",
								br: "Brazil",
								bs: "Bahamas",
								bt: "Bhutan",
								bw: "Botswana",
								by: "Belarus",
								bz: "Belize",
								ca: "Canada",
								cc: "Cocos (Keeling) Islands",
								cd: "Congo - Kinshasa",
								cf: "Central African Republic",
								cg: "Congo - Brazzaville",
								ch: "Switzerland",
								ci: "Côte d’Ivoire",
								ck: "Cook Islands",
								cl: "Chile",
								cm: "Cameroon",
								cn: "China",
								co: "Colombia",
								cr: "Costa Rica",
								cu: "Cuba",
								cv: "Cape Verde",
								cw: "Curaçao",
								cx: "Christmas Island",
								cy: "Cyprus",
								cz: "Czechia",
								de: "Germany",
								dj: "Djibouti",
								dk: "Denmark",
								dm: "Dominica",
								do: "Dominican Republic",
								dz: "Algeria",
								ec: "Ecuador",
								ee: "Estonia",
								eg: "Egypt",
								eh: "Western Sahara",
								er: "Eritrea",
								es: "Spain",
								et: "Ethiopia",
								fi: "Finland",
								fj: "Fiji",
								fk: "Falkland Islands",
								fm: "Micronesia",
								fo: "Faroe Islands",
								fr: "France",
								ga: "Gabon",
								gb: "United Kingdom",
								gd: "Grenada",
								ge: "Georgia",
								gf: "French Guiana",
								gg: "Guernsey",
								gh: "Ghana",
								gi: "Gibraltar",
								gl: "Greenland",
								gm: "Gambia",
								gn: "Guinea",
								gp: "Guadeloupe",
								gq: "Equatorial Guinea",
								gr: "Greece",
								gt: "Guatemala",
								gu: "Guam",
								gw: "Guinea-Bissau",
								gy: "Guyana",
								hk: "Hong Kong SAR China",
								hn: "Honduras",
								hr: "Croatia",
								ht: "Haiti",
								hu: "Hungary",
								id: "Indonesia",
								ie: "Ireland",
								il: "Israel",
								im: "Isle of Man",
								in: "India",
								io: "British Indian Ocean Territory",
								iq: "Iraq",
								ir: "Iran",
								is: "Iceland",
								it: "Italy",
								je: "Jersey",
								jm: "Jamaica",
								jo: "Jordan",
								jp: "Japan",
								ke: "Kenya",
								kg: "Kyrgyzstan",
								kh: "Cambodia",
								ki: "Kiribati",
								km: "Comoros",
								kn: "St. Kitts & Nevis",
								kp: "North Korea",
								kr: "South Korea",
								kw: "Kuwait",
								ky: "Cayman Islands",
								kz: "Kazakhstan",
								la: "Laos",
								lb: "Lebanon",
								lc: "St. Lucia",
								li: "Liechtenstein",
								lk: "Sri Lanka",
								lr: "Liberia",
								ls: "Lesotho",
								lt: "Lithuania",
								lu: "Luxembourg",
								lv: "Latvia",
								ly: "Libya",
								ma: "Morocco",
								mc: "Monaco",
								md: "Moldova",
								me: "Montenegro",
								mf: "St. Martin",
								mg: "Madagascar",
								mh: "Marshall Islands",
								mk: "North Macedonia",
								ml: "Mali",
								mm: "Myanmar (Burma)",
								mn: "Mongolia",
								mo: "Macao SAR China",
								mp: "Northern Mariana Islands",
								mq: "Martinique",
								mr: "Mauritania",
								ms: "Montserrat",
								mt: "Malta",
								mu: "Mauritius",
								mv: "Maldives",
								mw: "Malawi",
								mx: "Mexico",
								my: "Malaysia",
								mz: "Mozambique",
								na: "Namibia",
								nc: "New Caledonia",
								ne: "Niger",
								nf: "Norfolk Island",
								ng: "Nigeria",
								ni: "Nicaragua",
								nl: "Netherlands",
								no: "Norway",
								np: "Nepal",
								nr: "Nauru",
								nu: "Niue",
								nz: "New Zealand",
								om: "Oman",
								pa: "Panama",
								pe: "Peru",
								pf: "French Polynesia",
								pg: "Papua New Guinea",
								ph: "Philippines",
								pk: "Pakistan",
								pl: "Poland",
								pm: "St. Pierre & Miquelon",
								pr: "Puerto Rico",
								ps: "Palestinian Territories",
								pt: "Portugal",
								pw: "Palau",
								py: "Paraguay",
								qa: "Qatar",
								re: "Réunion",
								ro: "Romania",
								rs: "Serbia",
								ru: "Russia",
								rw: "Rwanda",
								sa: "Saudi Arabia",
								sb: "Solomon Islands",
								sc: "Seychelles",
								sd: "Sudan",
								se: "Sweden",
								sg: "Singapore",
								sh: "St. Helena",
								si: "Slovenia",
								sj: "Svalbard & Jan Mayen",
								sk: "Slovakia",
								sl: "Sierra Leone",
								sm: "San Marino",
								sn: "Senegal",
								so: "Somalia",
								sr: "Suriname",
								ss: "South Sudan",
								st: "São Tomé & Príncipe",
								sv: "El Salvador",
								sx: "Sint Maarten",
								sy: "Syria",
								sz: "Eswatini",
								tc: "Turks & Caicos Islands",
								td: "Chad",
								tg: "Togo",
								th: "Thailand",
								tj: "Tajikistan",
								tk: "Tokelau",
								tl: "Timor-Leste",
								tm: "Turkmenistan",
								tn: "Tunisia",
								to: "Tonga",
								tr: "Turkey",
								tt: "Trinidad & Tobago",
								tv: "Tuvalu",
								tw: "Taiwan",
								tz: "Tanzania",
								ua: "Ukraine",
								ug: "Uganda",
								us: "United States",
								uy: "Uruguay",
								uz: "Uzbekistan",
								va: "Vatican City",
								vc: "St. Vincent & Grenadines",
								ve: "Venezuela",
								vg: "British Virgin Islands",
								vi: "U.S. Virgin Islands",
								vn: "Vietnam",
								vu: "Vanuatu",
								wf: "Wallis & Futuna",
								ws: "Samoa",
								ye: "Yemen",
								yt: "Mayotte",
								za: "South Africa",
								zm: "Zambia",
								zw: "Zimbabwe",
							},
							fe = H,
							ge = {
								selectedCountryAriaLabel: "Selected country",
								noCountrySelected: "No country selected",
								countryListAriaLabel: "List of countries",
								searchPlaceholder: "Search",
								zeroSearchResults: "No results found",
								oneSearchResult: "1 result found",
								multipleSearchResults: "${count} results found",
								ac: "Ascension Island",
								xk: "Kosovo",
							},
							Ie = ge,
							Ae = { ...fe, ...Ie },
							De = Ae;
						for (let ee = 0; ee < ne.length; ee++)
							ne[ee].name = De[ne[ee].iso2];
						var Ee = 0,
							Fe = {
								allowDropdown: !0,
								autoPlaceholder: "polite",
								containerClass: "",
								countryOrder: null,
								countrySearch: !0,
								customPlaceholder: null,
								dropdownContainer: null,
								excludeCountries: [],
								fixDropdownWidth: !0,
								formatAsYouType: !0,
								formatOnDisplay: !0,
								geoIpLookup: null,
								hiddenInput: null,
								i18n: {},
								initialCountry: "",
								loadUtils: null,
								nationalMode: !0,
								onlyCountries: [],
								placeholderNumberType: "MOBILE",
								showFlags: !0,
								separateDialCode: !1,
								strictMode: !1,
								useFullscreenPopup:
									typeof navigator < "u" && typeof window < "u"
										? /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
												navigator.userAgent
										  ) || window.innerWidth <= 500
										: !1,
								validationNumberTypes: ["MOBILE"],
							},
							$e = [
								"800",
								"822",
								"833",
								"844",
								"855",
								"866",
								"877",
								"880",
								"881",
								"882",
								"883",
								"884",
								"885",
								"886",
								"887",
								"888",
								"889",
							],
							Je = (ee) => ee.replace(/\D/g, ""),
							qe = (ee = "") =>
								ee
									.normalize("NFD")
									.replace(/[\u0300-\u036f]/g, "")
									.toLowerCase(),
							Ze = (ee) => {
								const re = Je(ee);
								if (re.charAt(0) === "1") {
									const he = re.substr(1, 3);
									return $e.includes(he);
								}
								return !1;
							},
							Qe = (ee, re, he, oe) => {
								if (he === 0 && !oe) return 0;
								let ze = 0;
								for (let je = 0; je < re.length; je++) {
									if ((/[+0-9]/.test(re[je]) && ze++, ze === ee && !oe))
										return je + 1;
									if (oe && ze === ee + 1) return je;
								}
								return re.length;
							},
							Le = (ee, re, he) => {
								const oe = document.createElement(ee);
								return (
									re &&
										Object.entries(re).forEach(([ze, je]) =>
											oe.setAttribute(ze, je)
										),
									he && he.appendChild(oe),
									oe
								);
							},
							et = (ee, ...re) => {
								const { instances: he } = ke;
								Object.values(he).forEach((oe) => oe[ee](...re));
							},
							nt = class {
								constructor(ee, re = {}) {
									(this.id = Ee++),
										(this.telInput = ee),
										(this.highlightedItem = null),
										(this.options = Object.assign({}, Fe, re)),
										(this.hadInitialPlaceholder =
											!!ee.getAttribute("placeholder"));
								}
								_init() {
									this.options.useFullscreenPopup &&
										(this.options.fixDropdownWidth = !1),
										this.options.onlyCountries.length === 1 &&
											(this.options.initialCountry =
												this.options.onlyCountries[0]),
										this.options.separateDialCode &&
											(this.options.nationalMode = !1),
										this.options.allowDropdown &&
											!this.options.showFlags &&
											!this.options.separateDialCode &&
											(this.options.nationalMode = !1),
										this.options.useFullscreenPopup &&
											!this.options.dropdownContainer &&
											(this.options.dropdownContainer = document.body),
										(this.isAndroid =
											typeof navigator < "u"
												? /Android/i.test(navigator.userAgent)
												: !1),
										(this.isRTL = !!this.telInput.closest("[dir=rtl]"));
									const ee =
										this.options.allowDropdown || this.options.separateDialCode;
									(this.showSelectedCountryOnLeft = this.isRTL ? !ee : ee),
										this.options.separateDialCode &&
											(this.isRTL
												? (this.originalPaddingRight =
														this.telInput.style.paddingRight)
												: (this.originalPaddingLeft =
														this.telInput.style.paddingLeft)),
										(this.options.i18n = { ...De, ...this.options.i18n });
									const re = new Promise((oe, ze) => {
											(this.resolveAutoCountryPromise = oe),
												(this.rejectAutoCountryPromise = ze);
										}),
										he = new Promise((oe, ze) => {
											(this.resolveUtilsScriptPromise = oe),
												(this.rejectUtilsScriptPromise = ze);
										});
									(this.promise = Promise.all([re, he])),
										(this.selectedCountryData = {}),
										this._processCountryData(),
										this._generateMarkup(),
										this._setInitialState(),
										this._initListeners(),
										this._initRequests();
								}
								_processCountryData() {
									this._processAllCountries(),
										this._processDialCodes(),
										this._translateCountryNames(),
										this._sortCountries();
								}
								_sortCountries() {
									this.options.countryOrder &&
										(this.options.countryOrder = this.options.countryOrder.map(
											(ee) => ee.toLowerCase()
										)),
										this.countries.sort((ee, re) => {
											const { countryOrder: he } = this.options;
											if (he) {
												const oe = he.indexOf(ee.iso2),
													ze = he.indexOf(re.iso2),
													je = oe > -1,
													pt = ze > -1;
												if (je || pt) return je && pt ? oe - ze : je ? -1 : 1;
											}
											return ee.name.localeCompare(re.name);
										});
								}
								_addToDialCodeMap(ee, re, he) {
									re.length > this.dialCodeMaxLen &&
										(this.dialCodeMaxLen = re.length),
										this.dialCodeToIso2Map.hasOwnProperty(re) ||
											(this.dialCodeToIso2Map[re] = []);
									for (let ze = 0; ze < this.dialCodeToIso2Map[re].length; ze++)
										if (this.dialCodeToIso2Map[re][ze] === ee) return;
									const oe =
										he !== void 0 ? he : this.dialCodeToIso2Map[re].length;
									this.dialCodeToIso2Map[re][oe] = ee;
								}
								_processAllCountries() {
									const { onlyCountries: ee, excludeCountries: re } =
										this.options;
									if (ee.length) {
										const he = ee.map((oe) => oe.toLowerCase());
										this.countries = ne.filter((oe) => he.includes(oe.iso2));
									} else if (re.length) {
										const he = re.map((oe) => oe.toLowerCase());
										this.countries = ne.filter((oe) => !he.includes(oe.iso2));
									} else this.countries = ne;
								}
								_translateCountryNames() {
									for (let ee = 0; ee < this.countries.length; ee++) {
										const re = this.countries[ee].iso2.toLowerCase();
										this.options.i18n.hasOwnProperty(re) &&
											(this.countries[ee].name = this.options.i18n[re]);
									}
								}
								_processDialCodes() {
									(this.dialCodes = {}),
										(this.dialCodeMaxLen = 0),
										(this.dialCodeToIso2Map = {});
									for (let ee = 0; ee < this.countries.length; ee++) {
										const re = this.countries[ee];
										this.dialCodes[re.dialCode] ||
											(this.dialCodes[re.dialCode] = !0),
											this._addToDialCodeMap(re.iso2, re.dialCode, re.priority);
									}
									for (let ee = 0; ee < this.countries.length; ee++) {
										const re = this.countries[ee];
										if (re.areaCodes) {
											const he = this.dialCodeToIso2Map[re.dialCode][0];
											for (let oe = 0; oe < re.areaCodes.length; oe++) {
												const ze = re.areaCodes[oe];
												for (let je = 1; je < ze.length; je++) {
													const pt = ze.substr(0, je),
														it = re.dialCode + pt;
													this._addToDialCodeMap(he, it),
														this._addToDialCodeMap(re.iso2, it);
												}
												this._addToDialCodeMap(re.iso2, re.dialCode + ze);
											}
										}
									}
								}
								_generateMarkup() {
									var dt, yt, xt;
									this.telInput.classList.add("iti__tel-input"),
										!this.telInput.hasAttribute("autocomplete") &&
											!(
												this.telInput.form &&
												this.telInput.form.hasAttribute("autocomplete")
											) &&
											this.telInput.setAttribute("autocomplete", "off");
									const {
										allowDropdown: ee,
										separateDialCode: re,
										showFlags: he,
										containerClass: oe,
										hiddenInput: ze,
										dropdownContainer: je,
										fixDropdownWidth: pt,
										useFullscreenPopup: it,
										countrySearch: ct,
										i18n: It,
									} = this.options;
									let Dt = "iti";
									ee && (Dt += " iti--allow-dropdown"),
										he && (Dt += " iti--show-flags"),
										oe && (Dt += ` ${oe}`),
										it || (Dt += " iti--inline-dropdown");
									const at = Le("div", { class: Dt });
									if (
										((dt = this.telInput.parentNode) == null ||
											dt.insertBefore(at, this.telInput),
										ee || he || re)
									) {
										(this.countryContainer = Le(
											"div",
											{ class: "iti__country-container" },
											at
										)),
											this.showSelectedCountryOnLeft
												? (this.countryContainer.style.left = "0px")
												: (this.countryContainer.style.right = "0px"),
											ee
												? ((this.selectedCountry = Le(
														"button",
														{
															type: "button",
															class: "iti__selected-country",
															"aria-expanded": "false",
															"aria-label":
																this.options.i18n.selectedCountryAriaLabel,
															"aria-haspopup": "true",
															"aria-controls": `iti-${this.id}__dropdown-content`,
															role: "combobox",
														},
														this.countryContainer
												  )),
												  this.telInput.disabled &&
														this.selectedCountry.setAttribute(
															"disabled",
															"true"
														))
												: (this.selectedCountry = Le(
														"div",
														{ class: "iti__selected-country" },
														this.countryContainer
												  ));
										const St = Le(
											"div",
											{ class: "iti__selected-country-primary" },
											this.selectedCountry
										);
										if (
											((this.selectedCountryInner = Le(
												"div",
												{ class: "iti__flag" },
												St
											)),
											(this.selectedCountryA11yText = Le(
												"span",
												{ class: "iti__a11y-text" },
												this.selectedCountryInner
											)),
											ee &&
												(this.dropdownArrow = Le(
													"div",
													{ class: "iti__arrow", "aria-hidden": "true" },
													St
												)),
											re &&
												(this.selectedDialCode = Le(
													"div",
													{ class: "iti__selected-dial-code" },
													this.selectedCountry
												)),
											ee)
										) {
											const wt = pt ? "" : "iti--flexible-dropdown-width";
											if (
												((this.dropdownContent = Le("div", {
													id: `iti-${this.id}__dropdown-content`,
													class: `iti__dropdown-content iti__hide ${wt}`,
												})),
												ct &&
													((this.searchInput = Le(
														"input",
														{
															type: "text",
															class: "iti__search-input",
															placeholder: It.searchPlaceholder,
															role: "combobox",
															"aria-expanded": "true",
															"aria-label": It.searchPlaceholder,
															"aria-controls": `iti-${this.id}__country-listbox`,
															"aria-autocomplete": "list",
															autocomplete: "off",
														},
														this.dropdownContent
													)),
													(this.searchResultsA11yText = Le(
														"span",
														{ class: "iti__a11y-text" },
														this.dropdownContent
													))),
												(this.countryList = Le(
													"ul",
													{
														class: "iti__country-list",
														id: `iti-${this.id}__country-listbox`,
														role: "listbox",
														"aria-label": It.countryListAriaLabel,
													},
													this.dropdownContent
												)),
												this._appendListItems(),
												ct && this._updateSearchResultsText(),
												je)
											) {
												let _t = "iti iti--container";
												it
													? (_t += " iti--fullscreen-popup")
													: (_t += " iti--inline-dropdown"),
													(this.dropdown = Le("div", { class: _t })),
													this.dropdown.appendChild(this.dropdownContent);
											} else
												this.countryContainer.appendChild(this.dropdownContent);
										}
									}
									if (
										(at.appendChild(this.telInput),
										this._updateInputPadding(),
										ze)
									) {
										const St = this.telInput.getAttribute("name") || "",
											wt = ze(St);
										if (wt.phone) {
											const _t =
												(yt = this.telInput.form) == null
													? void 0
													: yt.querySelector(`input[name="${wt.phone}"]`);
											_t
												? (this.hiddenInput = _t)
												: ((this.hiddenInput = Le("input", {
														type: "hidden",
														name: wt.phone,
												  })),
												  at.appendChild(this.hiddenInput));
										}
										if (wt.country) {
											const _t =
												(xt = this.telInput.form) == null
													? void 0
													: xt.querySelector(`input[name="${wt.country}"]`);
											_t
												? (this.hiddenInputCountry = _t)
												: ((this.hiddenInputCountry = Le("input", {
														type: "hidden",
														name: wt.country,
												  })),
												  at.appendChild(this.hiddenInputCountry));
										}
									}
								}
								_appendListItems() {
									for (let ee = 0; ee < this.countries.length; ee++) {
										const re = this.countries[ee],
											he = ee === 0 ? "iti__highlight" : "",
											oe = Le(
												"li",
												{
													id: `iti-${this.id}__item-${re.iso2}`,
													class: `iti__country ${he}`,
													tabindex: "-1",
													role: "option",
													"data-dial-code": re.dialCode,
													"data-country-code": re.iso2,
													"aria-selected": "false",
												},
												this.countryList
											);
										re.nodeById[this.id] = oe;
										let ze = "";
										this.options.showFlags &&
											(ze += `<div class='iti__flag iti__${re.iso2}'></div>`),
											(ze += `<span class='iti__country-name'>${re.name}</span>`),
											(ze += `<span class='iti__dial-code'>+${re.dialCode}</span>`),
											oe.insertAdjacentHTML("beforeend", ze);
									}
								}
								_setInitialState(ee = !1) {
									const re = this.telInput.getAttribute("value"),
										he = this.telInput.value,
										ze =
											re &&
											re.charAt(0) === "+" &&
											(!he || he.charAt(0) !== "+")
												? re
												: he,
										je = this._getDialCode(ze),
										pt = Ze(ze),
										{ initialCountry: it, geoIpLookup: ct } = this.options,
										It = it === "auto" && ct;
									if (je && !pt) this._updateCountryFromNumber(ze);
									else if (!It || ee) {
										const Dt = it ? it.toLowerCase() : "";
										Dt && this._getCountryData(Dt, !0)
											? this._setCountry(Dt)
											: je && pt
											? this._setCountry("us")
											: this._setCountry();
									}
									ze && this._updateValFromNumber(ze);
								}
								_initListeners() {
									this._initTelInputListeners(),
										this.options.allowDropdown && this._initDropdownListeners(),
										(this.hiddenInput || this.hiddenInputCountry) &&
											this.telInput.form &&
											this._initHiddenInputListener();
								}
								_initHiddenInputListener() {
									var ee;
									(this._handleHiddenInputSubmit = () => {
										this.hiddenInput &&
											(this.hiddenInput.value = this.getNumber()),
											this.hiddenInputCountry &&
												(this.hiddenInputCountry.value =
													this.getSelectedCountryData().iso2 || "");
									}),
										(ee = this.telInput.form) == null ||
											ee.addEventListener(
												"submit",
												this._handleHiddenInputSubmit
											);
								}
								_initDropdownListeners() {
									this._handleLabelClick = (re) => {
										this.dropdownContent.classList.contains("iti__hide")
											? this.telInput.focus()
											: re.preventDefault();
									};
									const ee = this.telInput.closest("label");
									ee && ee.addEventListener("click", this._handleLabelClick),
										(this._handleClickSelectedCountry = () => {
											this.dropdownContent.classList.contains("iti__hide") &&
												!this.telInput.disabled &&
												!this.telInput.readOnly &&
												this._openDropdown();
										}),
										this.selectedCountry.addEventListener(
											"click",
											this._handleClickSelectedCountry
										),
										(this._handleCountryContainerKeydown = (re) => {
											this.dropdownContent.classList.contains("iti__hide") &&
												["ArrowUp", "ArrowDown", " ", "Enter"].includes(
													re.key
												) &&
												(re.preventDefault(),
												re.stopPropagation(),
												this._openDropdown()),
												re.key === "Tab" && this._closeDropdown();
										}),
										this.countryContainer.addEventListener(
											"keydown",
											this._handleCountryContainerKeydown
										);
								}
								_initRequests() {
									let {
										loadUtils: ee,
										initialCountry: re,
										geoIpLookup: he,
									} = this.options;
									ee && !ke.utils
										? ((this._handlePageLoad = () => {
												var ze;
												window.removeEventListener(
													"load",
													this._handlePageLoad
												),
													(ze = ke.attachUtils(ee)) == null ||
														ze.catch(() => {});
										  }),
										  ke.documentReady()
												? this._handlePageLoad()
												: window.addEventListener("load", this._handlePageLoad))
										: this.resolveUtilsScriptPromise(),
										re === "auto" && he && !this.selectedCountryData.iso2
											? this._loadAutoCountry()
											: this.resolveAutoCountryPromise();
								}
								_loadAutoCountry() {
									ke.autoCountry
										? this.handleAutoCountry()
										: ke.startedLoadingAutoCountry ||
										  ((ke.startedLoadingAutoCountry = !0),
										  typeof this.options.geoIpLookup == "function" &&
												this.options.geoIpLookup(
													(ee = "") => {
														const re = ee.toLowerCase();
														re && this._getCountryData(re, !0)
															? ((ke.autoCountry = re),
															  setTimeout(() => et("handleAutoCountry")))
															: (this._setInitialState(!0),
															  et("rejectAutoCountryPromise"));
													},
													() => {
														this._setInitialState(!0),
															et("rejectAutoCountryPromise");
													}
												));
								}
								_openDropdownWithPlus() {
									this._openDropdown(),
										(this.searchInput.value = "+"),
										this._filterCountries("", !0);
								}
								_initTelInputListeners() {
									const {
										strictMode: ee,
										formatAsYouType: re,
										separateDialCode: he,
										formatOnDisplay: oe,
										allowDropdown: ze,
										countrySearch: je,
									} = this.options;
									let pt = !1;
									new RegExp("\\p{L}", "u").test(this.telInput.value) &&
										(pt = !0),
										(this._handleInputEvent = (it) => {
											if (
												this.isAndroid &&
												(it == null ? void 0 : it.data) === "+" &&
												he &&
												ze &&
												je
											) {
												const at = this.telInput.selectionStart || 0,
													dt = this.telInput.value.substring(0, at - 1),
													yt = this.telInput.value.substring(at);
												(this.telInput.value = dt + yt),
													this._openDropdownWithPlus();
												return;
											}
											this._updateCountryFromNumber(this.telInput.value) &&
												this._triggerCountryChange();
											const ct =
													(it == null ? void 0 : it.data) &&
													/[^+0-9]/.test(it.data),
												It =
													(it == null ? void 0 : it.inputType) ===
														"insertFromPaste" && this.telInput.value;
											ct || (It && !ee)
												? (pt = !0)
												: /[^+0-9]/.test(this.telInput.value) || (pt = !1);
											const Dt =
												(it == null ? void 0 : it.detail) &&
												it.detail.isSetNumber &&
												!oe;
											if (re && !pt && !Dt) {
												const at = this.telInput.selectionStart || 0,
													yt = this.telInput.value
														.substring(0, at)
														.replace(/[^+0-9]/g, "").length,
													xt =
														(it == null ? void 0 : it.inputType) ===
														"deleteContentForward",
													St = this._formatNumberAsYouType(),
													wt = Qe(yt, St, at, xt);
												(this.telInput.value = St),
													this.telInput.setSelectionRange(wt, wt);
											}
										}),
										this.telInput.addEventListener(
											"input",
											this._handleInputEvent
										),
										(ee || he) &&
											((this._handleKeydownEvent = (it) => {
												if (
													it.key &&
													it.key.length === 1 &&
													!it.altKey &&
													!it.ctrlKey &&
													!it.metaKey
												) {
													if (he && ze && je && it.key === "+") {
														it.preventDefault(), this._openDropdownWithPlus();
														return;
													}
													if (ee) {
														const ct = this.telInput.value,
															It = ct.charAt(0) === "+",
															Dt =
																!It &&
																this.telInput.selectionStart === 0 &&
																it.key === "+",
															at = /^[0-9]$/.test(it.key),
															dt = he ? at : Dt || at,
															yt =
																ct.slice(0, this.telInput.selectionStart) +
																it.key +
																ct.slice(this.telInput.selectionEnd),
															xt = this._getFullNumber(yt),
															St = ke.utils.getCoreNumber(
																xt,
																this.selectedCountryData.iso2
															),
															wt =
																this.maxCoreNumberLength &&
																St.length > this.maxCoreNumberLength;
														let _t = !1;
														if (It) {
															const Lt = this.selectedCountryData.iso2;
															_t = this._getCountryFromNumber(xt) !== Lt;
														}
														(!dt || (wt && !_t && !Dt)) && it.preventDefault();
													}
												}
											}),
											this.telInput.addEventListener(
												"keydown",
												this._handleKeydownEvent
											));
								}
								_cap(ee) {
									const re = parseInt(
										this.telInput.getAttribute("maxlength") || "",
										10
									);
									return re && ee.length > re ? ee.substr(0, re) : ee;
								}
								_trigger(ee, re = {}) {
									const he = new CustomEvent(ee, {
										bubbles: !0,
										cancelable: !0,
										detail: re,
									});
									this.telInput.dispatchEvent(he);
								}
								_openDropdown() {
									const { fixDropdownWidth: ee, countrySearch: re } =
										this.options;
									if (
										(ee &&
											(this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`),
										this.dropdownContent.classList.remove("iti__hide"),
										this.selectedCountry.setAttribute("aria-expanded", "true"),
										this._setDropdownPosition(),
										re)
									) {
										const he = this.countryList.firstElementChild;
										he &&
											(this._highlightListItem(he, !1),
											(this.countryList.scrollTop = 0)),
											this.searchInput.focus();
									}
									this._bindDropdownListeners(),
										this.dropdownArrow.classList.add("iti__arrow--up"),
										this._trigger("open:countrydropdown");
								}
								_setDropdownPosition() {
									if (
										(this.options.dropdownContainer &&
											this.options.dropdownContainer.appendChild(this.dropdown),
										!this.options.useFullscreenPopup)
									) {
										const ee = this.telInput.getBoundingClientRect(),
											re = this.telInput.offsetHeight;
										this.options.dropdownContainer &&
											((this.dropdown.style.top = `${ee.top + re}px`),
											(this.dropdown.style.left = `${ee.left}px`),
											(this._handleWindowScroll = () => this._closeDropdown()),
											window.addEventListener(
												"scroll",
												this._handleWindowScroll
											));
									}
								}
								_bindDropdownListeners() {
									(this._handleMouseoverCountryList = (oe) => {
										var je;
										const ze =
											(je = oe.target) == null
												? void 0
												: je.closest(".iti__country");
										ze && this._highlightListItem(ze, !1);
									}),
										this.countryList.addEventListener(
											"mouseover",
											this._handleMouseoverCountryList
										),
										(this._handleClickCountryList = (oe) => {
											var je;
											const ze =
												(je = oe.target) == null
													? void 0
													: je.closest(".iti__country");
											ze && this._selectListItem(ze);
										}),
										this.countryList.addEventListener(
											"click",
											this._handleClickCountryList
										);
									let ee = !0;
									(this._handleClickOffToClose = () => {
										ee || this._closeDropdown(), (ee = !1);
									}),
										document.documentElement.addEventListener(
											"click",
											this._handleClickOffToClose
										);
									let re = "",
										he = null;
									if (
										((this._handleKeydownOnDropdown = (oe) => {
											["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(
												oe.key
											) &&
												(oe.preventDefault(),
												oe.stopPropagation(),
												oe.key === "ArrowUp" || oe.key === "ArrowDown"
													? this._handleUpDownKey(oe.key)
													: oe.key === "Enter"
													? this._handleEnterKey()
													: oe.key === "Escape" && this._closeDropdown()),
												!this.options.countrySearch &&
													/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(oe.key) &&
													(oe.stopPropagation(),
													he && clearTimeout(he),
													(re += oe.key.toLowerCase()),
													this._searchForCountry(re),
													(he = setTimeout(() => {
														re = "";
													}, 1e3)));
										}),
										document.addEventListener(
											"keydown",
											this._handleKeydownOnDropdown
										),
										this.options.countrySearch)
									) {
										const oe = () => {
											const je = this.searchInput.value.trim();
											je
												? this._filterCountries(je)
												: this._filterCountries("", !0);
										};
										let ze = null;
										(this._handleSearchChange = () => {
											ze && clearTimeout(ze),
												(ze = setTimeout(() => {
													oe(), (ze = null);
												}, 100));
										}),
											this.searchInput.addEventListener(
												"input",
												this._handleSearchChange
											),
											this.searchInput.addEventListener("click", (je) =>
												je.stopPropagation()
											);
									}
								}
								_searchForCountry(ee) {
									for (let re = 0; re < this.countries.length; re++) {
										const he = this.countries[re];
										if (he.name.substr(0, ee.length).toLowerCase() === ee) {
											const ze = he.nodeById[this.id];
											this._highlightListItem(ze, !1), this._scrollTo(ze);
											break;
										}
									}
								}
								_filterCountries(ee, re = !1) {
									let he = !0;
									this.countryList.innerHTML = "";
									const oe = qe(ee);
									for (let ze = 0; ze < this.countries.length; ze++) {
										const je = this.countries[ze],
											pt = qe(je.name),
											it = je.name
												.split(/[^a-zA-ZÀ-ÿа-яА-Я]/)
												.map((It) => It[0])
												.join("")
												.toLowerCase(),
											ct = `+${je.dialCode}`;
										if (
											re ||
											pt.includes(oe) ||
											ct.includes(oe) ||
											je.iso2.includes(oe) ||
											it.includes(oe)
										) {
											const It = je.nodeById[this.id];
											It && this.countryList.appendChild(It),
												he && (this._highlightListItem(It, !1), (he = !1));
										}
									}
									he && this._highlightListItem(null, !1),
										(this.countryList.scrollTop = 0),
										this._updateSearchResultsText();
								}
								_updateSearchResultsText() {
									const { i18n: ee } = this.options,
										re = this.countryList.childElementCount;
									let he;
									re === 0
										? (he = ee.zeroSearchResults)
										: re === 1
										? (he = ee.oneSearchResult)
										: (he = ee.multipleSearchResults.replace(
												"${count}",
												re.toString()
										  )),
										(this.searchResultsA11yText.textContent = he);
								}
								_handleUpDownKey(ee) {
									var he, oe;
									let re =
										ee === "ArrowUp"
											? (he = this.highlightedItem) == null
												? void 0
												: he.previousElementSibling
											: (oe = this.highlightedItem) == null
											? void 0
											: oe.nextElementSibling;
									!re &&
										this.countryList.childElementCount > 1 &&
										(re =
											ee === "ArrowUp"
												? this.countryList.lastElementChild
												: this.countryList.firstElementChild),
										re && (this._scrollTo(re), this._highlightListItem(re, !1));
								}
								_handleEnterKey() {
									this.highlightedItem &&
										this._selectListItem(this.highlightedItem);
								}
								_updateValFromNumber(ee) {
									let re = ee;
									if (
										this.options.formatOnDisplay &&
										ke.utils &&
										this.selectedCountryData
									) {
										const he =
												this.options.nationalMode ||
												(re.charAt(0) !== "+" &&
													!this.options.separateDialCode),
											{ NATIONAL: oe, INTERNATIONAL: ze } =
												ke.utils.numberFormat,
											je = he ? oe : ze;
										re = ke.utils.formatNumber(
											re,
											this.selectedCountryData.iso2,
											je
										);
									}
									(re = this._beforeSetNumber(re)), (this.telInput.value = re);
								}
								_updateCountryFromNumber(ee) {
									const re = this._getCountryFromNumber(ee);
									return re !== null ? this._setCountry(re) : !1;
								}
								_ensureHasDialCode(ee) {
									const { dialCode: re, nationalPrefix: he } =
										this.selectedCountryData;
									if (ee.charAt(0) === "+" || !re) return ee;
									const je =
										he && ee.charAt(0) === he && !this.options.separateDialCode
											? ee.substring(1)
											: ee;
									return `+${re}${je}`;
								}
								_getCountryFromNumber(ee) {
									const re = ee.indexOf("+");
									let he = re ? ee.substring(re) : ee;
									const oe = this.selectedCountryData.iso2,
										ze = this.selectedCountryData.dialCode;
									he = this._ensureHasDialCode(he);
									const je = this._getDialCode(he, !0),
										pt = Je(he);
									if (je) {
										const it = Je(je),
											ct = this.dialCodeToIso2Map[it];
										if (
											!oe &&
											this.defaultCountry &&
											ct.includes(this.defaultCountry)
										)
											return this.defaultCountry;
										const It =
											oe &&
											ct.includes(oe) &&
											(pt.length === it.length ||
												!this.selectedCountryData.areaCodes);
										if (!(ze === "1" && Ze(pt)) && !It) {
											for (let at = 0; at < ct.length; at++)
												if (ct[at]) return ct[at];
										}
									} else {
										if (he.charAt(0) === "+" && pt.length) return "";
										if ((!he || he === "+") && !this.selectedCountryData.iso2)
											return this.defaultCountry;
									}
									return null;
								}
								_highlightListItem(ee, re) {
									const he = this.highlightedItem;
									if (
										(he &&
											(he.classList.remove("iti__highlight"),
											he.setAttribute("aria-selected", "false")),
										(this.highlightedItem = ee),
										this.highlightedItem)
									) {
										this.highlightedItem.classList.add("iti__highlight"),
											this.highlightedItem.setAttribute(
												"aria-selected",
												"true"
											);
										const oe = this.highlightedItem.getAttribute("id") || "";
										this.selectedCountry.setAttribute(
											"aria-activedescendant",
											oe
										),
											this.options.countrySearch &&
												this.searchInput.setAttribute(
													"aria-activedescendant",
													oe
												);
									}
									re && this.highlightedItem.focus();
								}
								_getCountryData(ee, re) {
									for (let he = 0; he < this.countries.length; he++)
										if (this.countries[he].iso2 === ee)
											return this.countries[he];
									if (re) return null;
									throw new Error(`No country data for '${ee}'`);
								}
								_setCountry(ee) {
									const {
											separateDialCode: re,
											showFlags: he,
											i18n: oe,
										} = this.options,
										ze = this.selectedCountryData.iso2
											? this.selectedCountryData
											: {};
									if (
										((this.selectedCountryData = ee
											? this._getCountryData(ee, !1) || {}
											: {}),
										this.selectedCountryData.iso2 &&
											(this.defaultCountry = this.selectedCountryData.iso2),
										this.selectedCountryInner)
									) {
										let je = "",
											pt = "";
										ee && he
											? ((je = `iti__flag iti__${ee}`),
											  (pt = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`))
											: ((je = "iti__flag iti__globe"),
											  (pt = oe.noCountrySelected)),
											(this.selectedCountryInner.className = je),
											(this.selectedCountryA11yText.textContent = pt);
									}
									if ((this._setSelectedCountryTitleAttribute(ee, re), re)) {
										const je = this.selectedCountryData.dialCode
											? `+${this.selectedCountryData.dialCode}`
											: "";
										(this.selectedDialCode.innerHTML = je),
											this._updateInputPadding();
									}
									return (
										this._updatePlaceholder(),
										this._updateMaxLength(),
										ze.iso2 !== ee
									);
								}
								_updateInputPadding() {
									if (this.selectedCountry) {
										const re =
											(this.selectedCountry.offsetWidth ||
												this._getHiddenSelectedCountryWidth()) + 6;
										this.showSelectedCountryOnLeft
											? (this.telInput.style.paddingLeft = `${re}px`)
											: (this.telInput.style.paddingRight = `${re}px`);
									}
								}
								_updateMaxLength() {
									const {
											strictMode: ee,
											placeholderNumberType: re,
											validationNumberTypes: he,
										} = this.options,
										{ iso2: oe } = this.selectedCountryData;
									if (ee && ke.utils)
										if (oe) {
											const ze = ke.utils.numberType[re];
											let je = ke.utils.getExampleNumber(oe, !1, ze, !0),
												pt = je;
											for (; ke.utils.isPossibleNumber(je, oe, he); )
												(pt = je), (je += "0");
											const it = ke.utils.getCoreNumber(pt, oe);
											(this.maxCoreNumberLength = it.length),
												oe === "by" &&
													(this.maxCoreNumberLength = it.length + 1);
										} else this.maxCoreNumberLength = null;
								}
								_setSelectedCountryTitleAttribute(ee = null, re) {
									if (!this.selectedCountry) return;
									let he;
									ee && !re
										? (he = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}`)
										: ee
										? (he = this.selectedCountryData.name)
										: (he = "Unknown"),
										this.selectedCountry.setAttribute("title", he);
								}
								_getHiddenSelectedCountryWidth() {
									if (this.telInput.parentNode) {
										const ee = this.telInput.parentNode.cloneNode(!1);
										(ee.style.visibility = "hidden"),
											document.body.appendChild(ee);
										const re = this.countryContainer.cloneNode();
										ee.appendChild(re);
										const he = this.selectedCountry.cloneNode(!0);
										re.appendChild(he);
										const oe = he.offsetWidth;
										return document.body.removeChild(ee), oe;
									}
									return 0;
								}
								_updatePlaceholder() {
									const {
											autoPlaceholder: ee,
											placeholderNumberType: re,
											nationalMode: he,
											customPlaceholder: oe,
										} = this.options,
										ze =
											ee === "aggressive" ||
											(!this.hadInitialPlaceholder && ee === "polite");
									if (ke.utils && ze) {
										const je = ke.utils.numberType[re];
										let pt = this.selectedCountryData.iso2
											? ke.utils.getExampleNumber(
													this.selectedCountryData.iso2,
													he,
													je
											  )
											: "";
										(pt = this._beforeSetNumber(pt)),
											typeof oe == "function" &&
												(pt = oe(pt, this.selectedCountryData)),
											this.telInput.setAttribute("placeholder", pt);
									}
								}
								_selectListItem(ee) {
									const re = this._setCountry(
										ee.getAttribute("data-country-code")
									);
									this._closeDropdown(),
										this._updateDialCode(ee.getAttribute("data-dial-code")),
										this.telInput.focus(),
										re && this._triggerCountryChange();
								}
								_closeDropdown() {
									this.dropdownContent.classList.add("iti__hide"),
										this.selectedCountry.setAttribute("aria-expanded", "false"),
										this.selectedCountry.removeAttribute(
											"aria-activedescendant"
										),
										this.highlightedItem &&
											this.highlightedItem.setAttribute(
												"aria-selected",
												"false"
											),
										this.options.countrySearch &&
											this.searchInput.removeAttribute("aria-activedescendant"),
										this.dropdownArrow.classList.remove("iti__arrow--up"),
										document.removeEventListener(
											"keydown",
											this._handleKeydownOnDropdown
										),
										this.options.countrySearch &&
											this.searchInput.removeEventListener(
												"input",
												this._handleSearchChange
											),
										document.documentElement.removeEventListener(
											"click",
											this._handleClickOffToClose
										),
										this.countryList.removeEventListener(
											"mouseover",
											this._handleMouseoverCountryList
										),
										this.countryList.removeEventListener(
											"click",
											this._handleClickCountryList
										),
										this.options.dropdownContainer &&
											(this.options.useFullscreenPopup ||
												window.removeEventListener(
													"scroll",
													this._handleWindowScroll
												),
											this.dropdown.parentNode &&
												this.dropdown.parentNode.removeChild(this.dropdown)),
										this._handlePageLoad &&
											window.removeEventListener("load", this._handlePageLoad),
										this._trigger("close:countrydropdown");
								}
								_scrollTo(ee) {
									const re = this.countryList,
										he = document.documentElement.scrollTop,
										oe = re.offsetHeight,
										ze = re.getBoundingClientRect().top + he,
										je = ze + oe,
										pt = ee.offsetHeight,
										it = ee.getBoundingClientRect().top + he,
										ct = it + pt,
										It = it - ze + re.scrollTop;
									if (it < ze) re.scrollTop = It;
									else if (ct > je) {
										const Dt = oe - pt;
										re.scrollTop = It - Dt;
									}
								}
								_updateDialCode(ee) {
									const re = this.telInput.value,
										he = `+${ee}`;
									let oe;
									if (re.charAt(0) === "+") {
										const ze = this._getDialCode(re);
										ze ? (oe = re.replace(ze, he)) : (oe = he),
											(this.telInput.value = oe);
									}
								}
								_getDialCode(ee, re) {
									let he = "";
									if (ee.charAt(0) === "+") {
										let oe = "";
										for (let ze = 0; ze < ee.length; ze++) {
											const je = ee.charAt(ze);
											if (!isNaN(parseInt(je, 10))) {
												if (((oe += je), re))
													this.dialCodeToIso2Map[oe] &&
														(he = ee.substr(0, ze + 1));
												else if (this.dialCodes[oe]) {
													he = ee.substr(0, ze + 1);
													break;
												}
												if (oe.length === this.dialCodeMaxLen) break;
											}
										}
									}
									return he;
								}
								_getFullNumber(ee) {
									const re = ee || this.telInput.value.trim(),
										{ dialCode: he } = this.selectedCountryData;
									let oe;
									const ze = Je(re);
									return (
										this.options.separateDialCode &&
										re.charAt(0) !== "+" &&
										he &&
										ze
											? (oe = `+${he}`)
											: (oe = ""),
										oe + re
									);
								}
								_beforeSetNumber(ee) {
									let re = ee;
									if (this.options.separateDialCode) {
										let he = this._getDialCode(re);
										if (he) {
											he = `+${this.selectedCountryData.dialCode}`;
											const oe =
												re[he.length] === " " || re[he.length] === "-"
													? he.length + 1
													: he.length;
											re = re.substr(oe);
										}
									}
									return this._cap(re);
								}
								_triggerCountryChange() {
									this._trigger("countrychange");
								}
								_formatNumberAsYouType() {
									const ee = this._getFullNumber(),
										re = ke.utils
											? ke.utils.formatNumberAsYouType(
													ee,
													this.selectedCountryData.iso2
											  )
											: ee,
										{ dialCode: he } = this.selectedCountryData;
									return this.options.separateDialCode &&
										this.telInput.value.charAt(0) !== "+" &&
										re.includes(`+${he}`)
										? (re.split(`+${he}`)[1] || "").trim()
										: re;
								}
								handleAutoCountry() {
									this.options.initialCountry === "auto" &&
										ke.autoCountry &&
										((this.defaultCountry = ke.autoCountry),
										this.selectedCountryData.iso2 ||
											this.selectedCountryInner.classList.contains(
												"iti__globe"
											) ||
											this.setCountry(this.defaultCountry),
										this.resolveAutoCountryPromise());
								}
								handleUtils() {
									ke.utils &&
										(this.telInput.value &&
											this._updateValFromNumber(this.telInput.value),
										this.selectedCountryData.iso2 &&
											(this._updatePlaceholder(), this._updateMaxLength())),
										this.resolveUtilsScriptPromise();
								}
								destroy() {
									var ze, je;
									const { allowDropdown: ee, separateDialCode: re } =
										this.options;
									if (ee) {
										this._closeDropdown(),
											this.selectedCountry.removeEventListener(
												"click",
												this._handleClickSelectedCountry
											),
											this.countryContainer.removeEventListener(
												"keydown",
												this._handleCountryContainerKeydown
											);
										const pt = this.telInput.closest("label");
										pt &&
											pt.removeEventListener("click", this._handleLabelClick);
									}
									const { form: he } = this.telInput;
									this._handleHiddenInputSubmit &&
										he &&
										he.removeEventListener(
											"submit",
											this._handleHiddenInputSubmit
										),
										this.telInput.removeEventListener(
											"input",
											this._handleInputEvent
										),
										this._handleKeydownEvent &&
											this.telInput.removeEventListener(
												"keydown",
												this._handleKeydownEvent
											),
										this.telInput.removeAttribute("data-intl-tel-input-id"),
										re &&
											(this.isRTL
												? (this.telInput.style.paddingRight =
														this.originalPaddingRight)
												: (this.telInput.style.paddingLeft =
														this.originalPaddingLeft));
									const oe = this.telInput.parentNode;
									(ze = oe == null ? void 0 : oe.parentNode) == null ||
										ze.insertBefore(this.telInput, oe),
										(je = oe == null ? void 0 : oe.parentNode) == null ||
											je.removeChild(oe),
										delete ke.instances[this.id];
								}
								getExtension() {
									return ke.utils
										? ke.utils.getExtension(
												this._getFullNumber(),
												this.selectedCountryData.iso2
										  )
										: "";
								}
								getNumber(ee) {
									if (ke.utils) {
										const { iso2: re } = this.selectedCountryData;
										return ke.utils.formatNumber(this._getFullNumber(), re, ee);
									}
									return "";
								}
								getNumberType() {
									return ke.utils
										? ke.utils.getNumberType(
												this._getFullNumber(),
												this.selectedCountryData.iso2
										  )
										: -99;
								}
								getSelectedCountryData() {
									return this.selectedCountryData;
								}
								getValidationError() {
									if (ke.utils) {
										const { iso2: ee } = this.selectedCountryData;
										return ke.utils.getValidationError(
											this._getFullNumber(),
											ee
										);
									}
									return -99;
								}
								isValidNumber() {
									if (!this.selectedCountryData.iso2) return !1;
									const ee = this._getFullNumber(),
										re = ee.search(new RegExp("\\p{L}", "u"));
									if (re > -1) {
										const he = ee.substring(0, re),
											oe = this._utilsIsPossibleNumber(he),
											ze = this._utilsIsPossibleNumber(ee);
										return oe && ze;
									}
									return this._utilsIsPossibleNumber(ee);
								}
								_utilsIsPossibleNumber(ee) {
									return ke.utils
										? ke.utils.isPossibleNumber(
												ee,
												this.selectedCountryData.iso2,
												this.options.validationNumberTypes
										  )
										: null;
								}
								isValidNumberPrecise() {
									if (!this.selectedCountryData.iso2) return !1;
									const ee = this._getFullNumber(),
										re = ee.search(new RegExp("\\p{L}", "u"));
									if (re > -1) {
										const he = ee.substring(0, re),
											oe = this._utilsIsValidNumber(he),
											ze = this._utilsIsValidNumber(ee);
										return oe && ze;
									}
									return this._utilsIsValidNumber(ee);
								}
								_utilsIsValidNumber(ee) {
									return ke.utils
										? ke.utils.isValidNumber(
												ee,
												this.selectedCountryData.iso2,
												this.options.validationNumberTypes
										  )
										: null;
								}
								setCountry(ee) {
									const re = ee == null ? void 0 : ee.toLowerCase(),
										he = this.selectedCountryData.iso2;
									((ee && re !== he) || (!ee && he)) &&
										(this._setCountry(re),
										this._updateDialCode(this.selectedCountryData.dialCode),
										this._triggerCountryChange());
								}
								setNumber(ee) {
									const re = this._updateCountryFromNumber(ee);
									this._updateValFromNumber(ee),
										re && this._triggerCountryChange(),
										this._trigger("input", { isSetNumber: !0 });
								}
								setPlaceholderNumberType(ee) {
									(this.options.placeholderNumberType = ee),
										this._updatePlaceholder();
								}
								setDisabled(ee) {
									(this.telInput.disabled = ee),
										ee
											? this.selectedCountry.setAttribute("disabled", "true")
											: this.selectedCountry.removeAttribute("disabled");
								}
							},
							Ue = (ee) => {
								if (!ke.utils && !ke.startedLoadingUtilsScript) {
									let re;
									if (typeof ee == "function")
										try {
											re = Promise.resolve(ee());
										} catch (he) {
											return Promise.reject(he);
										}
									else
										return Promise.reject(
											new TypeError(
												`The argument passed to attachUtils must be a function that returns a promise for the utilities module, not ${typeof ee}`
											)
										);
									return (
										(ke.startedLoadingUtilsScript = !0),
										re
											.then((he) => {
												const oe = he == null ? void 0 : he.default;
												if (!oe || typeof oe != "object")
													throw new TypeError(
														"The loader function passed to attachUtils did not resolve to a module object with utils as its default export."
													);
												return (ke.utils = oe), et("handleUtils"), !0;
											})
											.catch((he) => {
												throw (et("rejectUtilsScriptPromise", he), he);
											})
									);
								}
								return null;
							},
							ke = Object.assign(
								(ee, re) => {
									const he = new nt(ee, re);
									return (
										he._init(),
										ee.setAttribute("data-intl-tel-input-id", he.id.toString()),
										(ke.instances[he.id] = he),
										he
									);
								},
								{
									defaults: Fe,
									documentReady: () => document.readyState === "complete",
									getCountryData: () => ne,
									getInstance: (ee) => {
										const re = ee.getAttribute("data-intl-tel-input-id");
										return re ? ke.instances[re] : null;
									},
									instances: {},
									attachUtils: Ue,
									startedLoadingUtilsScript: !1,
									startedLoadingAutoCountry: !1,
									version: "25.3.2",
								}
							),
							vt = ke;
						return B(O);
					})();
					return a.default;
				});
			})($f)),
		$f.exports
	);
}
var iD = nD();
const aD = Zm(iD);
var oD = Te(
		'<div><span class="loading loading-spinner loading-xl"></span></div>'
	),
	sD = Te('<span class="w-8"> </span>'),
	lD = Te(
		'<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="text-base-content/80 mt-0.5 text-sm"> </p></div> <form class="mt-8 flex w-full flex-col gap-3"><input class="input pl-12! w-full" type="tel" id="phone"/> <button class="btn btn-primary w-full"> <!></button></form>',
		1
	),
	cD = async (m, a, p) => {
		await a(x(p));
	},
	uD = Te('<span class="w-8"> </span>'),
	hD = (m, a) => {
		se(a, "");
	},
	dD = Te(
		'<div class="text-center"><h2 class="text-2xl font-bold"> </h2> <p class="mt-0.5 text-sm"> </p></div> <div class="mt-4"><!></div> <div class="mt-3 flex flex-col items-center gap-1"><button class="btn btn-ghost w-max"> <!></button> <button class="text-primary cursor-pointer text-xs"> </button></div>',
		1
	),
	pD = Te(
		'<div class="flex h-full w-full flex-col items-center justify-center"><!></div>'
	);
function fD(m, a) {
	Lr(a, !0);
	let p = st(!0),
		y = st(""),
		M = st(0),
		z = st(!1);
	const T = ft(() => x(M) > 0 || x(z));
	let s = st(!1),
		B = st(""),
		O = st(void 0);
	const X = ft(() => {
		var Ie;
		return `phone:${(Ie = Mt.data) == null ? void 0 : Ie.id}`;
	});
	Wr(() => {
		const Ie = localStorage.getItem(x(X));
		Ie && se(y, Ie, !0);
	}),
		Fn(() => {
			Qr.getOtpCooldown()
				.then((De) => {
					se(M, De.cooldownMs, !0);
				})
				.catch((De) => {
					Fr.error(De.message);
				})
				.finally(() => {
					se(p, !1);
				});
			const Ie = 1e3,
				Ae = setInterval(() => {
					se(M, Math.max(0, x(M) - Ie), !0);
				}, Ie);
			return () => {
				clearInterval(Ae);
			};
		});
	async function K(Ie) {
		try {
			se(z, !0);
			const Ae = await Qr.sendOtp(Ie);
			Fr.info(`${QC()} ${Ae.phone}`),
				se(y, Ae.phone, !0),
				se(M, Ae.cooldownMs, !0),
				localStorage.setItem(x(X), x(y));
		} catch (Ae) {
			Fr.error(Ae.message);
		} finally {
			se(z, !1);
		}
	}
	Wr(() => {
		x(B).length === 6 &&
			(se(s, !0),
			(async () => {
				try {
					await Qr.verifyOtp(x(B)),
						await Mt.refresh(),
						Fr.success(rS()),
						localStorage.removeItem(x(X)),
						a.onsuccess(x(y));
				} catch (Ie) {
					Fr.error(Ie.message);
				} finally {
					se(B, ""), se(s, !1);
				}
			})());
	});
	var ne = pD(),
		H = A(ne);
	{
		var fe = (Ie) => {
				var Ae = oD();
				$(Ie, Ae);
			},
			ge = (Ie) => {
				var Ae = er(),
					De = Ct(Ae);
				{
					var Ee = ($e) => {
							var Je = lD(),
								qe = Ct(Je),
								Ze = A(qe),
								Qe = A(Ze, !0);
							k(Ze);
							var Le = j(Ze, 2),
								et = A(Le, !0);
							k(Le), k(qe);
							var nt = j(qe, 2),
								Ue = A(nt);
							Ni(
								Ue,
								() => (he) => (
									se(
										O,
										aD(he, {
											strictMode: !0,
											initialCountry: "br",
											loadUtils: () =>
												qx(
													() => import("../chunks/yW7U80iv.js"),
													[],
													import.meta.url
												),
											containerClass: "w-full",
											dropdownContainer: document.body,
										})
									),
									() => {
										var oe;
										(oe = x(O)) == null || oe.destroy();
									}
								)
							);
							var ke = j(Ue, 2),
								vt = A(ke),
								ee = j(vt);
							{
								var re = (he) => {
									var oe = sD(),
										ze = A(oe);
									k(oe),
										We((je) => de(ze, `(${je ?? ""})`), [() => rp(x(M))]),
										$(he, oe);
								};
								Oe(ee, (he) => {
									x(M) > 0 && he(re);
								});
							}
							k(ke),
								k(nt),
								We(
									(he, oe, ze) => {
										de(Qe, he),
											de(et, oe),
											(ke.disabled = x(T)),
											de(vt, `${ze ?? ""} `);
									},
									[() => US(), () => HS(), () => YS()]
								),
								di("submit", nt, async () => {
									var oe;
									if (x(T)) return;
									if (!((oe = x(O)) != null && oe.isValidNumber())) {
										Fr.error(aS());
										return;
									}
									const he = x(O).getNumber();
									await K(he);
								}),
								$($e, Je);
						},
						Fe = ($e) => {
							var Je = dD(),
								qe = Ct(Je),
								Ze = A(qe),
								Qe = A(Ze, !0);
							k(Ze);
							var Le = j(Ze, 2),
								et = A(Le);
							k(Le), k(qe);
							var nt = j(qe, 2),
								Ue = A(nt);
							{
								const je = (pt, it) => {
									let ct = () => (it == null ? void 0 : it().cells);
									var It = er(),
										Dt = Ct(It);
									xi(
										Dt,
										() => JL,
										(at, dt) => {
											dt(at, {
												class: "border-primary",
												children: (yt, xt) => {
													var St = er(),
														wt = Ct(St);
													hi(
														wt,
														16,
														ct,
														(_t) => _t,
														(_t, Lt) => {
															var Rt = er(),
																$t = Ct(Rt);
															xi(
																$t,
																() => tD,
																(tr, Qt) => {
																	Qt(tr, {
																		get cell() {
																			return Lt;
																		},
																		class:
																			"border-base-content/20 size-11 sm:size-12",
																	});
																}
															),
																$(_t, Rt);
														}
													),
														$(yt, St);
												},
												$$slots: { default: !0 },
											});
										}
									),
										$(pt, It);
								};
								xi(
									Ue,
									() => rD,
									(pt, it) => {
										it(pt, {
											maxlength: 6,
											class: "mx-auto w-max",
											get disabled() {
												return x(s);
											},
											get value() {
												return x(B);
											},
											set value(ct) {
												se(B, ct, !0);
											},
											children: je,
											$$slots: { default: !0 },
										});
									}
								);
							}
							k(nt);
							var ke = j(nt, 2),
								vt = A(ke);
							vt.__click = [cD, K, y];
							var ee = A(vt),
								re = j(ee);
							{
								var he = (je) => {
									var pt = uD(),
										it = A(pt);
									k(pt),
										We((ct) => de(it, `(${ct ?? ""})`), [() => rp(x(M))]),
										$(je, pt);
								};
								Oe(re, (je) => {
									x(M) > 0 && je(he);
								});
							}
							k(vt);
							var oe = j(vt, 2);
							oe.__click = [hD, y];
							var ze = A(oe, !0);
							k(oe),
								k(ke),
								We(
									(je, pt, it, ct) => {
										de(Qe, je),
											de(et, `${pt ?? ""} ${x(y) ?? ""}`),
											(vt.disabled = x(T)),
											de(ee, `${it ?? ""} `),
											de(ze, ct);
									},
									[() => QS(), () => rP(), () => aP(), () => lP()]
								),
								$($e, Je);
						};
					Oe(
						De,
						($e) => {
							x(y) ? $e(Fe, !1) : $e(Ee);
						},
						!0
					);
				}
				$(Ie, Ae);
			};
		Oe(H, (Ie) => {
			x(p) ? Ie(fe) : Ie(ge, !1);
		});
	}
	k(ne), $(m, ne), Dr();
}
$n(["click"]);
var mD = Te(
	'<dialog class="modal"><div class="modal-box h-72 max-w-sm"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <!></div></dialog>'
);
function _D(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	var y = mD(),
		M = A(y),
		z = j(A(M), 2);
	{
		var T = (s) => {
			fD(s, { onsuccess: () => p(!1) });
		};
		Oe(z, (s) => {
			p() && s(T);
		});
	}
	k(M),
		k(y),
		Ni(y, () => (s) => {
			Wr(() => {
				p() ? s.show() : s.close();
			});
		}),
		di("close", y, () => p(!1)),
		$(m, y),
		Dr();
}
var gD = Pr(
	'<svg><path d="m40-120 440-760 440 760H40Zm138-80h604L480-720 178-200Zm302-40q17 0 28.5-11.5T520-280q0-17-11.5-28.5T480-320q-17 0-28.5 11.5T440-280q0 17 11.5 28.5T480-240Zm-40-120h80v-200h-80v200Zm40-100Z"></path></svg>'
);
function vD(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = gD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var yD = Te('<p class="text-error mt-1 text-sm"> </p>'),
	xD = (m, a) => {
		a(!1);
	},
	bD = async (m, a, p, y, M, z) => {
		if (x(a) !== x(p)) {
			se(y, ax(), !0);
			return;
		}
		try {
			se(M, !0),
				await Qr.deleteMe(x(p)),
				Fr.warning(zS()),
				await Mt.logout(),
				z(!1);
		} catch (T) {
			Fr.error(T.message);
		} finally {
			se(M, !1);
		}
	},
	wD = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	TD = Te(
		'<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <div class="flex items-center gap-2"><!> <h3 class="text-lg font-bold"> </h3></div> <p class="mt-4"><b> </b> </p> <p class="mt-2"> </p> <div class="rounded-box border-base-content/20 border-1 mt-6 w-full py-1.5 text-center"> </div> <input class="input input-bordered mt-2 w-full" type="text"/> <!> <div class="mt-6 flex justify-end gap-2"><button type="button" class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>'
	);
function CD(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(""),
		M = st(null),
		z = st(!1),
		T = ft(() => {
			var he;
			return ((he = Mt.data) == null ? void 0 : he.name) ?? "";
		});
	Wr(() => {
		p() || (se(y, ""), se(M, null));
	});
	var s = TD(),
		B = A(s),
		O = j(A(B), 2),
		X = A(O);
	vD(X, { class: "text-error size-5" });
	var K = j(X, 2),
		ne = A(K, !0);
	k(K), k(O);
	var H = j(O, 2),
		fe = A(H),
		ge = A(fe, !0);
	k(fe);
	var Ie = j(fe);
	k(H);
	var Ae = j(H, 2),
		De = A(Ae);
	k(Ae);
	var Ee = j(Ae, 2),
		Fe = A(Ee, !0);
	k(Ee);
	var $e = j(Ee, 2);
	Ka($e);
	var Je = j($e, 2);
	{
		var qe = (he) => {
			var oe = yD(),
				ze = A(oe, !0);
			k(oe), We(() => de(ze, x(M))), $(he, oe);
		};
		Oe(Je, (he) => {
			x(M) && he(qe);
		});
	}
	var Ze = j(Je, 2),
		Qe = A(Ze);
	Qe.__click = [xD, p];
	var Le = A(Qe, !0);
	k(Qe);
	var et = j(Qe, 2);
	et.__click = [bD, y, T, M, z, p];
	var nt = A(et),
		Ue = j(nt);
	{
		var ke = (he) => {
			var oe = wD();
			$(he, oe);
		};
		Oe(Ue, (he) => {
			x(z) && he(ke);
		});
	}
	k(et), k(Ze), k(B);
	var vt = j(B, 2),
		ee = A(vt),
		re = A(ee, !0);
	k(ee),
		k(vt),
		k(s),
		Ni(s, () => (he) => {
			Wr(() => {
				p() ? he.show() : he.close();
			});
		}),
		We(
			(he, oe, ze, je, pt, it, ct, It, Dt) => {
				de(ne, he),
					de(ge, oe),
					de(Ie, ` ${ze ?? ""}`),
					de(De, `${je ?? ""} ${pt ?? ""}`),
					de(Fe, x(T)),
					Tr($e, "placeholder", it),
					de(Le, ct),
					(et.disabled = x(z)),
					de(nt, `${It ?? ""} `),
					de(re, Dt);
			},
			[
				() => Yf(),
				() => pw(),
				() => _w(),
				() => VI(),
				() => UI(),
				() => HI(),
				() => Ah(),
				() => Yf(),
				() => Ss(),
			]
		),
		di("close", s, () => p(!1)),
		dp(
			$e,
			() => x(y),
			(he) => se(y, he)
		),
		$(m, s),
		Dr();
}
$n(["click"]);
var SD = async (m, a, p) => {
		try {
			se(a, !0),
				await Qr.deleteSessions(),
				Fr.success(zI()),
				await Mt.logout(),
				p(!1);
		} catch {
			Fr.error(RI());
		} finally {
			se(a, !1);
		}
	},
	PD = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	ID = Te(
		'<dialog class="modal !bg-black/80"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <p class="mt-4"> </p> <p class="text-base-content/80 text-sm"> </p> <div class="mt-4 flex justify-end gap-2"><button class="btn btn-soft"> </button> <button class="btn btn-error relative"> <!></button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>'
	);
function MD(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(!1);
	var M = ID(),
		z = A(M),
		T = j(A(z), 2),
		s = A(T, !0);
	k(T);
	var B = j(T, 2),
		O = A(B, !0);
	k(B);
	var X = j(B, 2),
		K = A(X, !0);
	k(X);
	var ne = j(X, 2),
		H = A(ne),
		fe = A(H, !0);
	k(H);
	var ge = j(H, 2);
	ge.__click = [SD, y, p];
	var Ie = A(ge),
		Ae = j(Ie);
	{
		var De = (Je) => {
			var qe = PD();
			$(Je, qe);
		};
		Oe(Ae, (Je) => {
			x(y) && Je(De);
		});
	}
	k(ge), k(ne), k(z);
	var Ee = j(z, 2),
		Fe = A(Ee),
		$e = A(Fe, !0);
	k(Fe),
		k(Ee),
		k(M),
		Ni(M, () => (Je) => {
			Wr(() => {
				p() ? Je.show() : Je.close();
			});
		}),
		We(
			(Je, qe, Ze, Qe, Le, et) => {
				de(s, Je),
					de(O, qe),
					de(K, Ze),
					de(fe, Qe),
					(ge.disabled = x(y)),
					de(Ie, `${Le ?? ""} `),
					de($e, et);
			},
			[() => PI(), () => kI(), () => YI(), () => Ah(), () => qv(), () => Ss()]
		),
		di("close", M, () => p(!1)),
		$(m, M),
		Dr();
}
$n(["click"]);
var kD = (m, a) => {
		a();
	},
	AD = Te(
		'<span class="center-absolute loading loading-spinner absolute"></span>'
	),
	ED = Te(
		'<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'
	),
	zD = (m, a, p) => {
		a(x(p).id);
	},
	LD = Te(
		'<span class="center-absolute loading loading-spinner absolute"></span>'
	),
	DD = Te(
		'<button type="button" class="relative hover:brightness-95 disabled:opacity-50"><!> <!></button>'
	),
	RD = Te(
		'<div><div class="text-base-content/80 text-sm"> </div> <div class="mt-2 grid grid-cols-3 gap-2"><!> <!></div></div>'
	),
	BD = Te('<a class="btn border-0 bg-[#5865F2] text-white"><!> </a>'),
	FD = async (m, a, p) => {
		try {
			se(a, !0),
				await Qr.unlinkDiscord(),
				Mt.refresh(),
				Fr.success(TS()),
				se(p, !1);
		} catch (y) {
			Fr.error(y.message, { duration: 5e3 });
		} finally {
			se(a, !1);
		}
	},
	OD = Te('<button class="btn btn-error btn-soft"><!> </button>'),
	ND = (m, a) => {
		se(a, !0);
	},
	jD = (m, a) => {
		se(a, !0);
	},
	VD = (m, a) => {
		a(!1);
	},
	qD = Te(
		'<dialog class="modal"><div class="modal-box"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h3 class="flex items-center gap-1.5 text-lg font-bold"> </h3> <form class="mt-3 w-full"><div class="flex flex-col gap-6 sm:flex-row"><div class="sm:min-w-34 flex items-center justify-center gap-6 sm:flex-col sm:gap-3"><div class="relative w-max"><!> <a class="tooltip btn btn-circle tooltip-right absolute -bottom-1 -right-1 max-sm:overflow-x-hidden" href="/profile-picture"><!></a></div> <!></div> <div class="flex w-full flex-col gap-3"><!> <!> <label class="label text-sm"><input class="checkbox checkbox-xs" type="checkbox"/> </label></div></div> <div class="col mt-4 flex flex-wrap justify-between gap-2"><div class="dropdown dropdown-top max-sm:dropdown-top col ml-1 mt-4 flex gap-2"><button tabindex="0" class="btn btn-sm btn-soft"> </button> <ul class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 font-medium shadow-sm"><li><button type="button" class="text-error py-2"> </button></li> <li><button type="button" class="text-error py-2"> </button></li></ul></div> <div class="col mt-4 flex gap-2"><button class="btn btn-soft" type="button"> </button> <button class="btn btn-primary" type="submit"> </button></div></div></form></div></dialog> <!> <!>',
		1
	);
function ZD(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(bi(a.userData.name)),
		M = st(bi(a.userData.discord)),
		z = st(bi(a.userData.showLastPixel)),
		T = st(!1),
		s = st(void 0),
		B = st(!1),
		O = st(!1);
	const X = ox("2025-09_discord_linking");
	let K = st(!!a.userData.discordId),
		ne = st(void 0),
		H = st(void 0);
	Wr(() => {
		se(y, a.userData.name, !0), se(z, a.userData.showLastPixel, !0);
	}),
		Wr(() => {
			p() &&
				!x(s) &&
				Qr.getMyProfilePictures()
					.then((Nt) => {
						se(s, Nt, !0);
					})
					.catch((Nt) => {
						Fr.error(Nt.message);
					});
		});
	let fe = st(!1);
	async function ge(Nt) {
		try {
			se(fe, !0), await Qr.changeProfilePicture(Nt), await Mt.refresh();
		} finally {
			se(fe, !1);
		}
	}
	var Ie = qD(),
		Ae = Ct(Ie),
		De = A(Ae),
		Ee = j(A(De), 2),
		Fe = A(Ee, !0);
	k(Ee);
	var $e = j(Ee, 2),
		Je = A($e),
		qe = A(Je),
		Ze = A(qe),
		Qe = A(Ze);
	co(Qe, {
		class: "size-30",
		get userId() {
			return a.userData.id;
		},
		get pictureUrl() {
			return a.userData.picture;
		},
	});
	var Le = j(Qe, 2),
		et = A(Le);
	Rv(et, { class: "size-5" }), k(Le), k(Ze);
	var nt = j(Ze, 2);
	{
		var Ue = (Nt) => {
			var or = RD(),
				cr = A(or),
				Vr = A(cr, !0);
			k(cr);
			var mr = j(cr, 2),
				hr = A(mr);
			{
				var _r = (qr) => {
					var ue = ED();
					ue.__click = [kD, ge];
					var V = A(ue);
					co(V, {
						class: "size-10 border",
						get userId() {
							return a.userData.id;
						},
					});
					var U = j(V, 2);
					{
						var Y = (ie) => {
							var pe = AD();
							$(ie, pe);
						};
						Oe(U, (ie) => {
							x(fe) && ie(Y);
						});
					}
					k(ue), We(() => (ue.disabled = x(fe))), $(qr, ue);
				};
				Oe(hr, (qr) => {
					a.userData.picture && qr(_r);
				});
			}
			var Ir = j(hr, 2);
			hi(
				Ir,
				17,
				() => x(s),
				(qr) => qr.id,
				(qr, ue) => {
					var V = er(),
						U = Ct(V);
					{
						var Y = (ie) => {
							var pe = DD();
							pe.__click = [zD, ge, ue];
							var Se = A(pe);
							co(Se, {
								class: "size-10 border",
								get userId() {
									return a.userData.id;
								},
								get pictureUrl() {
									return x(ue).url;
								},
							});
							var Me = j(Se, 2);
							{
								var we = (Ve) => {
									var ut = LD();
									$(Ve, ut);
								};
								Oe(Me, (Ve) => {
									x(fe) && Ve(we);
								});
							}
							k(pe), We(() => (pe.disabled = x(fe))), $(ie, pe);
						};
						Oe(U, (ie) => {
							a.userData.picture !== x(ue).url && ie(Y);
						});
					}
					$(qr, V);
				}
			),
				k(mr),
				k(or),
				We((qr) => de(Vr, qr), [() => aw()]),
				$(Nt, or);
		};
		Oe(nt, (Nt) => {
			var or;
			(or = x(s)) != null && or.length && Nt(Ue);
		});
	}
	k(qe);
	var ke = j(qe, 2),
		vt = A(ke);
	{
		let Nt = ft(() => Kf()),
			or = ft(() => Kf());
		em(vt, {
			get label() {
				return x(Nt);
			},
			get placeholder() {
				return x(or);
			},
			min: 1,
			max: 16,
			get value() {
				return x(y);
			},
			set value(cr) {
				se(y, cr, !0);
			},
			get validate() {
				return x(ne);
			},
			set validate(cr) {
				se(ne, cr, !0);
			},
		});
	}
	var ee = j(vt, 2);
	{
		var re = (Nt) => {
				var or = er(),
					cr = Ct(or);
				{
					var Vr = (hr) => {
							var _r = BD(),
								Ir = A(_r);
							rm(Ir, { class: "size-4.5" });
							var qr = j(Ir);
							k(_r),
								We(
									(ue, V) => {
										Tr(_r, "href", ue), de(qr, ` ${V ?? ""}`);
									},
									[() => sx("/discord/authorize"), () => PS()]
								),
								$(hr, _r);
						},
						mr = (hr) => {
							var _r = OD();
							_r.__click = [FD, T, K];
							var Ir = A(_r);
							rm(Ir, { class: "size-4.5" });
							var qr = j(Ir);
							k(_r),
								We(
									(ue) => {
										(_r.disabled = x(T)), de(qr, ` ${ue ?? ""}`);
									},
									[
										() => {
											var ue;
											return kS({
												username:
													((ue = a.userData) == null ? void 0 : ue.discord) ??
													"",
											});
										},
									]
								),
								$(hr, _r);
						};
					Oe(cr, (hr) => {
						x(K) ? hr(mr, !1) : hr(Vr);
					});
				}
				$(Nt, or);
			},
			he = (Nt) => {
				{
					let or = ft(() => o3());
					em(Nt, {
						label: "Discord",
						get placeholder() {
							return x(or);
						},
						max: 32,
						get value() {
							return x(M);
						},
						set value(cr) {
							se(M, cr, !0);
						},
						get validate() {
							return x(H);
						},
						set validate(cr) {
							se(H, cr, !0);
						},
					});
				}
			};
		Oe(ee, (Nt) => {
			X ? Nt(re) : Nt(he, !1);
		});
	}
	var oe = j(ee, 2),
		ze = A(oe);
	Ka(ze);
	var je = j(ze);
	k(oe), k(ke), k(Je);
	var pt = j(Je, 2),
		it = A(pt),
		ct = A(it),
		It = A(ct, !0);
	k(ct);
	var Dt = j(ct, 2),
		at = A(Dt),
		dt = A(at);
	dt.__click = [ND, O];
	var yt = A(dt, !0);
	k(dt), k(at);
	var xt = j(at, 2),
		St = A(xt);
	St.__click = [jD, B];
	var wt = A(St, !0);
	k(St), k(xt), k(Dt), k(it);
	var _t = j(it, 2),
		Lt = A(_t);
	Lt.__click = [VD, p];
	var Rt = A(Lt, !0);
	k(Lt);
	var $t = j(Lt, 2),
		tr = A($t, !0);
	k($t),
		k(_t),
		k(pt),
		k($e),
		k(De),
		k(Ae),
		Ni(Ae, () => (Nt) => {
			Wr(() => {
				p() ? Nt.show() : Nt.close();
			});
		});
	var Qt = j(Ae, 2);
	CD(Qt, {
		get open() {
			return x(B);
		},
		set open(Nt) {
			se(B, Nt, !0);
		},
	});
	var Ot = j(Qt, 2);
	MD(Ot, {
		get open() {
			return x(O);
		},
		set open(Nt) {
			se(O, Nt, !0);
		},
	}),
		We(
			(Nt, or, cr, Vr, mr, hr, _r, Ir) => {
				de(Fe, Nt),
					Tr(Le, "data-tip", or),
					de(je, ` ${cr ?? ""}`),
					de(It, Vr),
					de(yt, mr),
					de(wt, hr),
					(Lt.disabled = x(T)),
					de(Rt, _r),
					($t.disabled = x(T)),
					de(tr, Ir);
			},
			[
				() => hP(),
				() => Fx(),
				() => lw(),
				() => OI(),
				() => TI(),
				() => Yf(),
				() => Ss(),
				() => Ax(),
			]
		),
		di("close", Ae, () => p(!1)),
		di("submit", $e, async () => {
			var Nt, or;
			try {
				if (!((Nt = x(ne)) != null && Nt()) || !((or = x(H)) != null && or()))
					return;
				se(T, !0),
					await Qr.updateMe({ name: x(y), showLastPixel: x(z), discord: x(M) }),
					Mt.refresh(),
					Fr.success(gS()),
					p(!1);
			} catch (cr) {
				Fr.error(cr.message, { duration: 5e3 });
			} finally {
				se(T, !1);
			}
		}),
		Ix(
			ze,
			() => x(z),
			(Nt) => se(z, Nt)
		),
		$(m, Ie),
		Dr();
}
$n(["click"]);
var UD = Pr(
	'<svg><path d="M440-160v-487L216-423l-56-57 320-320 320 320-56 57-224-224v487h-80Z"></path></svg>'
);
function $D(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = UD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var GD = Pr(
	'<svg><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Zm-10-270Z"></path></svg>'
);
function HD(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = GD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var WD = Pr(
	'<svg><path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 80q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Zm326-268Z"></path></svg>'
);
function XD(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = WD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var YD = Pr(
	'<svg><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"></path></svg>'
);
function W0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = YD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var KD = Pr(
	'<svg><path d="M240-80q-50 0-85-35t-35-85v-120h120v-560l60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60 60 60 60-60v680q0 50-35 85t-85 35H240Zm480-80q17 0 28.5-11.5T760-200v-560H320v440h360v120q0 17 11.5 28.5T720-160ZM360-600v-80h240v80H360Zm0 120v-80h240v80H360Zm320-120q-17 0-28.5-11.5T640-640q0-17 11.5-28.5T680-680q17 0 28.5 11.5T720-640q0 17-11.5 28.5T680-600Zm0 120q-17 0-28.5-11.5T640-520q0-17 11.5-28.5T680-560q17 0 28.5 11.5T720-520q0 17-11.5 28.5T680-480ZM240-160h360v-80H200v40q0 17 11.5 28.5T240-160Zm-40 0v-80 80Z"></path></svg>'
);
function JD(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = KD();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var QD = Pr(
	'<svg><defs><radialGradient id="snoo-radial-gragient" cx="169.75" cy="92.19" r="50.98" fx="169.75" fy="92.19" gradientTransform="matrix(1 0 0 .87 0 11.64)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#feffff"></stop><stop offset=".4" stop-color="#feffff"></stop><stop offset=".51" stop-color="#f9fcfc"></stop><stop offset=".62" stop-color="#edf3f5"></stop><stop offset=".7" stop-color="#dee9ec"></stop><stop offset=".72" stop-color="#d8e4e8"></stop><stop offset=".76" stop-color="#ccd8df"></stop><stop offset=".8" stop-color="#c8d5dd"></stop><stop offset=".83" stop-color="#ccd6de"></stop><stop offset=".85" stop-color="#d8dbe2"></stop><stop offset=".88" stop-color="#ede3e9"></stop><stop offset=".9" stop-color="#ffebef"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-2" cx="47.31" r="50.98" fx="47.31"></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-3" cx="109.61" cy="85.59" r="153.78" fx="109.61" fy="85.59" gradientTransform="matrix(1 0 0 .7 0 25.56)"></radialGradient><radialGradient id="snoo-radial-gragient-4" cx="-6.01" cy="64.68" r="12.85" fx="-6.01" fy="64.68" gradientTransform="matrix(1.07 0 0 1.55 81.08 27.26)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#f60"></stop><stop offset=".5" stop-color="#ff4500"></stop><stop offset=".7" stop-color="#fc4301"></stop><stop offset=".82" stop-color="#f43f07"></stop><stop offset=".92" stop-color="#e53812"></stop><stop offset="1" stop-color="#d4301f"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient-4" id="snoo-radial-gragient-5" cx="-73.55" cy="64.68" r="12.85" fx="-73.55" fy="64.68" gradientTransform="matrix(-1.07 0 0 1.55 62.87 27.26)"></radialGradient><radialGradient id="snoo-radial-gragient-6" cx="107.93" cy="166.96" r="45.3" fx="107.93" fy="166.96" gradientTransform="matrix(1 0 0 .66 0 57.4)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#172e35"></stop><stop offset=".29" stop-color="#0e1c21"></stop><stop offset=".73" stop-color="#030708"></stop><stop offset="1"></stop></radialGradient><radialGradient xlink:href="#snoo-radial-gragient" id="snoo-radial-gragient-7" cx="147.88" cy="32.94" r="39.77" fx="147.88" fy="32.94" gradientTransform="matrix(1 0 0 .98 0 .54)"></radialGradient><radialGradient id="snoo-radial-gragient-8" cx="131.31" cy="73.08" r="32.6" fx="131.31" fy="73.08" gradientUnits="userSpaceOnUse"><stop offset=".48" stop-color="#7a9299"></stop><stop offset=".67" stop-color="#172e35"></stop><stop offset=".75"></stop><stop offset=".82" stop-color="#172e35"></stop></radialGradient></defs><path fill="#ff4500" stroke-width="0" d="M108 0C48.35 0 0 48.35 0 108c0 29.82 12.09 56.82 31.63 76.37l-20.57 20.57C6.98 209.02 9.87 216 15.64 216H108c59.65 0 108-48.35 108-108S167.65 0 108 0Z"></path><circle cx="169.22" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient)" stroke-width="0"></circle><circle cx="46.78" cy="106.98" r="25.22" fill="url(#snoo-radial-gragient-2)" stroke-width="0"></circle><ellipse cx="108.06" cy="128.64" fill="url(#snoo-radial-gragient-3)" stroke-width="0" rx="72" ry="54"></ellipse><path fill="url(#snoo-radial-gragient-4)" stroke-width="0" d="M86.78 123.48c-.42 9.08-6.49 12.38-13.56 12.38s-12.46-4.93-12.04-14.01c.42-9.08 6.49-15.02 13.56-15.02s12.46 7.58 12.04 16.66Z"></path><path fill="url(#snoo-radial-gragient-5)" stroke-width="0" d="M129.35 123.48c.42 9.08 6.49 12.38 13.56 12.38s12.46-4.93 12.04-14.01c-.42-9.08-6.49-15.02-13.56-15.02s-12.46 7.58-12.04 16.66Z"></path><ellipse cx="79.63" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><ellipse cx="146.21" cy="116.37" class="snoo-cls-11 svelte-1977t4s" rx="2.8" ry="3.05"></ellipse><path fill="url(#snoo-radial-gragient-6)" stroke-width="0" d="M108.06 142.92c-8.76 0-17.16.43-24.92 1.22-1.33.13-2.17 1.51-1.65 2.74 4.35 10.39 14.61 17.69 26.57 17.69s22.23-7.3 26.57-17.69c.52-1.23-.33-2.61-1.65-2.74-7.77-.79-16.16-1.22-24.92-1.22Z"></path><circle cx="147.49" cy="49.43" r="17.87" fill="url(#snoo-radial-gragient-7)" stroke-width="0"></circle><path fill="url(#snoo-radial-gragient-8)" stroke-width="0" d="M107.8 76.92c-2.14 0-3.87-.89-3.87-2.27 0-16.01 13.03-29.04 29.04-29.04 2.14 0 3.87 1.73 3.87 3.87s-1.73 3.87-3.87 3.87c-11.74 0-21.29 9.55-21.29 21.29 0 1.38-1.73 2.27-3.87 2.27Z"></path><path fill="#842123" stroke-width="0" d="M62.82 122.65c.39-8.56 6.08-14.16 12.69-14.16 6.26 0 11.1 6.39 11.28 14.33.17-8.88-5.13-15.99-12.05-15.99s-13.14 6.05-13.56 15.2c-.42 9.15 4.97 13.83 12.04 13.83h.52c-6.44-.16-11.3-4.79-10.91-13.2Zm90.48 0c-.39-8.56-6.08-14.16-12.69-14.16-6.26 0-11.1 6.39-11.28 14.33-.17-8.88 5.13-15.99 12.05-15.99 7.07 0 13.14 6.05 13.56 15.2.42 9.15-4.97 13.83-12.04 13.83h-.52c6.44-.16 11.3-4.79 10.91-13.2Z"></path></svg>'
);
function eR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = QD();
	ar(
		y,
		() => ({
			xmlns: "http://www.w3.org/2000/svg",
			"xmlns:xlink": "http://www.w3.org/1999/xlink",
			viewBox: "0 0 216 216",
			...p,
		}),
		void 0,
		void 0,
		"svelte-1977t4s"
	),
		$(m, y);
}
var tR = Pr(
	'<svg><path d="M480-280q17 0 28.5-11.5T520-320q0-17-11.5-28.5T480-360q-17 0-28.5 11.5T440-320q0 17 11.5 28.5T480-280Zm-40-160h80v-240h-80v240ZM330-120 120-330v-300l210-210h300l210 210v300L630-120H330Zm34-80h232l164-164v-232L596-760H364L200-596v232l164 164Zm116-280Z"></path></svg>'
);
function X0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = tR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var rR = Pr(
	'<svg><path d="M480-440q-59 0-99.5-40.5T340-580q0-59 40.5-99.5T480-720q59 0 99.5 40.5T620-580q0 59-40.5 99.5T480-440Zm0-80q26 0 43-17t17-43q0-26-17-43t-43-17q-26 0-43 17t-17 43q0 26 17 43t43 17Zm0 440q-139-35-229.5-159.5T160-516v-244l320-120 320 120v244q0 152-90.5 276.5T480-80Zm0-400Zm0-315-240 90v189q0 54 15 105t41 96q42-21 88-33t96-12q50 0 96 12t88 33q26-45 41-96t15-105v-189l-240-90Zm0 515q-36 0-70 8t-65 22q29 30 63 52t72 34q38-12 72-34t63-52q-31-14-65-22t-70-8Z"></path></svg>'
);
function Cv(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = rR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var nR = Pr(
	'<svg><path d="m476-80 182-480h84L924-80h-84l-43-122H603L560-80h-84ZM160-200l-56-56 202-202q-35-35-63.5-80T190-640h84q20 39 40 68t48 58q33-33 68.5-92.5T484-720H40v-80h280v-80h80v80h280v80H564q-21 72-63 148t-83 116l96 98-30 82-122-125-202 201Zm468-72h144l-72-204-72 204Z"></path></svg>'
);
function iR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = nR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		height: "24px",
		viewBox: "0 -960 960 960",
		width: "24px",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var aR = Pr(
	'<svg><path d="M792-56 671-177q-25 16-53 27.5T560-131v-82q14-5 27.5-10t25.5-12L480-368v208L280-360H120v-240h128L56-792l56-56 736 736-56 56Zm-8-232-58-58q17-31 25.5-65t8.5-70q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 53-14.5 102T784-288ZM650-422l-90-90v-130q47 22 73.5 66t26.5 96q0 15-2.5 29.5T650-422ZM480-592 376-696l104-104v208Zm-80 238v-94l-72-72H200v80h114l86 86Zm-36-130Z"></path></svg>'
);
function oR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = aR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var sR = Pr(
	'<svg><path d="M560-131v-82q90-26 145-100t55-168q0-94-55-168T560-749v-82q124 28 202 125.5T840-481q0 127-78 224.5T560-131ZM120-360v-240h160l200-200v640L280-360H120Zm440 40v-322q47 22 73.5 66t26.5 96q0 51-26.5 94.5T560-320ZM400-606l-86 86H200v80h114l86 86v-252ZM300-480Z"></path></svg>'
);
function lR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = sR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var cR = (m, a) => {
		se(a, !0);
	},
	uR = Te('<span class="tooltip font-flag ml-0.5"> </span>'),
	hR = Te('<div class="mt-1"><!></div>'),
	dR = Te('<p class="w-full text-black"> <!></p>'),
	pR = Te('<p class="w-full text-black"><!></p>'),
	fR = Te('<div class=" flex items-center gap-[8px]"><!> <!></div>'),
	mR = (m, a, p) => {
		localStorage.setItem(xx, x(a).key), se(p, x(a).key, !0), location.reload();
	},
	_R = Te(
		'<span class="center-absolute loading loading-spinner loading-xs absolute"></span>'
	),
	gR = Te("<li><button><!> </button></li>"),
	vR = Te(
		'<div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div>'
	),
	yR = async (m, a) => {
		var p;
		try {
			const y = await ((p = x(a)) == null ? void 0 : p.prompt());
			(y == null ? void 0 : y.outcome) === "accepted" && se(a, void 0);
		} catch (y) {
			Fr.error(U2({ error: y.message }));
		}
	},
	xR = Te('<button class="btn pwa:hidden w-full sm:hidden"><!> </button>'),
	bR = Te('<a class="btn w-full" target="_blank"><!> </a>'),
	wR = Te('<a class="btn w-full" target="_blank"><!> </a>'),
	TR = Te(
		'<form class="w-full" method="POST"><button class="btn w-full"><!> </button></form> <a class="btn w-full" target="_blank"><!> </a>',
		1
	),
	CR = async (m, a, p, y) => {
		var M;
		try {
			se(a, !0),
				await p.user.logout(),
				y(),
				Fr.warning(RS(), { icon: W0 }),
				(M = p.onlogout) == null || M.call(p);
		} catch {
			Fr.error(OS());
		} finally {
			se(a, !1);
		}
	},
	SR = Te(
		'<div class="dropdown"><div tabindex="0" role="button"><!></div> <div class="dropdown-content menu bg-base-100 rounded-box border-base-300 z-1 relative right-1 w-[min(100vw-24px,400px)] translate-y-2 border p-4 shadow-md" tabindex="0"><button class="btn btn-ghost btn-circle absolute right-2 top-2"><!></button> <section class="flex gap-2"><div class="relative"><!> <button class="btn btn-circle btn-sm absolute -bottom-1 -right-1"><!></button></div> <div><div class="flex items-center gap-1.5 pr-8 text-lg font-medium"><h3 class="line-clamp-1 text-ellipsis text-lg"> </h3> <span> </span> <!> <!></div> <div class="flex items-center gap-1"><!> <span> <span class="text-primary font-semibold"> </span></span></div> <div class="flex items-center gap-1"><!> <span class="text-secondary"><span class="font-semibold"> </span> <button class="tooltip"><!></button></span></div></div></section> <section class="mt-3 flex flex-col gap-2"><!> <div class="mb-1 flex items-center justify-between"><h3 class="text-lg font-semibold"> </h3> <div class="flex items-center gap-2"><div class="dropdown dropdown-end"><div tabindex="0" role="button" class="btn btn-sm btn-circle"><!></div> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 w-max rounded-xl p-2 shadow-sm"></ul></div> <div class="tooltip"><button class="btn btn-sm btn-circle"><!></button></div> <!></div></div>  <!> <!> <!> <a class="btn w-full" href="https://www.twitch.tv/directory/category/wplace" target="_blank"><!> </a> <a class="btn w-full" href="http://discord.gg/wplacelive" target="_blank"><!> Discord</a> <a class="btn w-full" href="https://www.reddit.com/r/WplaceLive/" target="_blank"><!> Reddit</a> <!> <button class="btn"><!> </button></section></div></div> <!>',
		1
	);
function PR(m, a) {
	Lr(a, !0);
	let p = st(!1),
		y = st(!1);
	function M() {
		var ne;
		(ne = document.activeElement) == null || ne.blur();
	}
	const z = [
		{ label: "🇺🇸 English", key: "en" },
		{ label: "🇧🇷 Português", key: "pt" },
	];
	let T = st(""),
		s = st(void 0);
	const B = ft(() => {
		var ne;
		return !!((ne = a.user.data) != null && ne.banned) || !!a.user.timeoutUntil;
	});
	var O = er(),
		X = Ct(O);
	{
		var K = (ne) => {
			var H = SR(),
				fe = Ct(H),
				ge = A(fe);
			let Ie;
			var Ae = A(ge);
			Ov(Ae, {
				get userId() {
					return a.user.data.id;
				},
				get level() {
					return a.user.data.level;
				},
				get pictureUrl() {
					return a.user.data.picture;
				},
			}),
				k(ge);
			var De = j(ge, 2),
				Ee = A(De);
			Ee.__click = M;
			var Fe = A(Ee);
			_l(Fe, { class: "size-5" }), k(Ee);
			var $e = j(Ee, 2),
				Je = A($e),
				qe = A(Je);
			co(qe, {
				get userId() {
					return a.user.data.id;
				},
				get pictureUrl() {
					return a.user.data.picture;
				},
				get isSuspended() {
					return x(B);
				},
			});
			var Ze = j(qe, 2);
			Ze.__click = [cR, p];
			var Qe = A(Ze);
			tm(Qe, { class: "size-4" }), k(Ze), k(Je);
			var Le = j(Je, 2),
				et = A(Le),
				nt = A(et),
				Ue = A(nt, !0);
			k(nt);
			var ke = j(nt, 2),
				vt = A(ke);
			k(ke);
			var ee = j(ke, 2);
			{
				var re = (Vt) => {
					const Et = ft(() => So(a.user.data.equippedFlag));
					var dr = uR(),
						ht = A(dr, !0);
					k(dr),
						We(() => {
							Tr(dr, "data-tip", x(Et).name), de(ht, x(Et).flag);
						}),
						$(Vt, dr);
				};
				Oe(ee, (Vt) => {
					a.user.data.equippedFlag && Vt(re);
				});
			}
			var he = j(ee, 2);
			{
				var oe = (Vt) => {
					var Et = hR(),
						dr = A(Et);
					Eh(dr, {
						get username() {
							return a.user.data.discord;
						},
						get id() {
							return a.user.data.discordId;
						},
					}),
						k(Et),
						$(Vt, Et);
				};
				Oe(he, (Vt) => {
					a.user.data.discord && Vt(oe);
				});
			}
			k(et);
			var ze = j(et, 2),
				je = A(ze);
			zh(je, { class: "inline size-4" });
			var pt = j(je, 2),
				it = A(pt),
				ct = j(it),
				It = A(ct, !0);
			k(ct), k(pt), k(ze);
			var Dt = j(ze, 2),
				at = A(Dt);
			$D(at, { class: "inline size-4" });
			var dt = j(at, 2),
				yt = A(dt),
				xt = A(yt);
			k(yt);
			var St = j(yt),
				wt = j(St),
				_t = A(wt);
			Uu(_t, { class: "mb-0.5 inline size-4 opacity-50" }),
				k(wt),
				k(dt),
				k(Dt),
				k(Le),
				k($e);
			var Lt = j($e, 2),
				Rt = A(Lt);
			{
				var $t = (Vt) => {
					var Et = fR(),
						dr = A(Et);
					X0(dr, { class: "size-6 text-red-500" });
					var ht = j(dr, 2);
					{
						var Xr = (Zr) => {
								var mt = dR(),
									He = A(mt),
									At = j(He);
								{
									var Ft = (Jt) => {
										var Cr = wi();
										We(
											(Er) => de(Cr, `(${Er ?? ""})`),
											[() => aI({ reason: hx() })]
										),
											$(Jt, Cr);
									};
									Oe(At, (Jt) => {
										a.user.data.suspensionReason === "bot" && Jt(Ft);
									});
								}
								k(mt),
									We((Jt) => de(He, `${Jt ?? ""} `), [() => cx()]),
									$(Zr, mt);
							},
							Yr = (Zr) => {
								var mt = er(),
									He = Ct(mt);
								{
									var At = (Ft) => {
										var Jt = pR(),
											Cr = A(Jt);
										Am(Cr, () =>
											ux({
												until: `<span class="text-secondary font-medium text-nowrap">${a.user.timeoutUntil.toLocaleString()}</span>`,
											})
										),
											k(Jt),
											$(Ft, Jt);
									};
									Oe(
										He,
										(Ft) => {
											a.user.timeoutUntil && Ft(At);
										},
										!0
									);
								}
								$(Zr, mt);
							};
						Oe(ht, (Zr) => {
							var mt;
							(mt = a.user.data) != null && mt.banned ? Zr(Xr) : Zr(Yr, !1);
						});
					}
					k(Et), $(Vt, Et);
				};
				Oe(Rt, (Vt) => {
					x(B) && Vt($t);
				});
			}
			var tr = j(Rt, 2),
				Qt = A(tr),
				Ot = A(Qt, !0);
			k(Qt);
			var Nt = j(Qt, 2),
				or = A(Nt),
				cr = A(or),
				Vr = A(cr);
			iR(Vr, { class: "size-4" }), k(cr);
			var mr = j(cr, 2);
			hi(
				mr,
				21,
				() => z,
				hp,
				(Vt, Et) => {
					const dr = ft(() => x(T) === x(Et).key);
					var ht = gR(),
						Xr = A(ht);
					let Yr;
					Xr.__click = [mR, Et, T];
					var Zr = A(Xr);
					{
						var mt = (At) => {
							var Ft = _R();
							$(At, Ft);
						};
						Oe(Zr, (At) => {
							x(dr) && At(mt);
						});
					}
					var He = j(Zr);
					k(Xr),
						k(ht),
						We(
							(At) => {
								(Yr = zr(
									Xr,
									1,
									"font-flag relative font-medium",
									null,
									Yr,
									At
								)),
									de(He, ` ${x(Et).label ?? ""}`);
							},
							[() => ({ "bg-base-200": x(dr) })]
						),
						$(Vt, ht);
				}
			),
				k(mr),
				k(or);
			var hr = j(or, 2),
				_r = A(hr);
			_r.__click = () => {
				ai.muted = !ai.muted;
			};
			var Ir = A(_r);
			{
				var qr = (Vt) => {
						oR(Vt, { class: "size-4" });
					},
					ue = (Vt) => {
						lR(Vt, { class: "size-4" });
					};
				Oe(Ir, (Vt) => {
					ai.muted ? Vt(qr) : Vt(ue, !1);
				});
			}
			k(_r), k(hr);
			var V = j(hr, 2);
			{
				var U = (Vt) => {
					var Et = vR(),
						dr = A(Et);
					dr.__click = () => {
						ai.theme = ai.theme === "dark" ? "custom-winter" : "dark";
					};
					var ht = A(dr);
					{
						var Xr = (Zr) => {
								XD(Zr, { class: "size-4" });
							},
							Yr = (Zr) => {
								HD(Zr, { class: "size-4" });
							};
						Oe(ht, (Zr) => {
							ai.theme === "dark" ? Zr(Xr) : Zr(Yr, !1);
						});
					}
					k(dr),
						k(Et),
						We(
							(Zr) => Tr(Et, "data-tip", Zr),
							[() => (ai.theme === "dark" ? xI() : gI())]
						),
						$(Vt, Et);
				};
				Oe(V, (Vt) => {
					var Et, dr;
					xc(
						(dr = (Et = a.user) == null ? void 0 : Et.data) == null
							? void 0
							: dr.role,
						["admin", "moderator", "global_moderator"]
					) && Vt(U);
				});
			}
			k(Nt), k(tr);
			var Y = j(tr, 2);
			{
				var ie = (Vt) => {
					var Et = xR();
					Et.__click = [yR, s];
					var dr = A(Et);
					zv(dr, { class: "size-5" });
					var ht = j(dr);
					k(Et), We((Xr) => de(ht, ` ${Xr ?? ""}`), [() => H2()]), $(Vt, Et);
				};
				Oe(Y, (Vt) => {
					x(s) && Vt(ie);
				});
			}
			var pe = j(Y, 2);
			{
				var Se = (Vt) => {
					var Et = bR(),
						dr = A(Et);
					Cv(dr, { class: "size-5" });
					var ht = j(dr);
					k(Et),
						We(
							(Xr) => {
								Tr(Et, "href", `${yi.url.origin ?? ""}/admin/dashboard`),
									de(ht, ` ${Xr ?? ""}`);
							},
							[() => rI()]
						),
						$(Vt, Et);
				};
				Oe(pe, (Vt) => {
					var Et;
					((Et = a.user.data) == null ? void 0 : Et.role) === "admin" && Vt(Se);
				});
			}
			var Me = j(pe, 2);
			{
				var we = (Vt) => {
					var Et = wR(),
						dr = A(Et);
					Cv(dr, { class: "size-5" });
					var ht = j(dr);
					k(Et),
						We(
							(Xr) => {
								Tr(Et, "href", `${yi.url.origin ?? ""}/moderation`),
									de(ht, ` ${Xr ?? ""}`);
							},
							[() => OP()]
						),
						$(Vt, Et);
				};
				Oe(Me, (Vt) => {
					var Et;
					(Et = a.user.data) != null &&
						Et.role &&
						a.user.data.role !== "user" &&
						Vt(we);
				});
			}
			var Ve = j(Me, 2),
				ut = A(Ve);
			Vv(ut, { class: "size-5" });
			var Ke = j(ut);
			k(Ve);
			var kt = j(Ve, 2),
				ye = A(kt);
			Qf(ye, { class: "size-5" }), yn(), k(kt);
			var Bt = j(kt, 2),
				rr = A(Bt);
			eR(rr, { class: "size-5" }), yn(), k(Bt);
			var Kt = j(Bt, 2);
			{
				var gr = (Vt) => {
					var Et = TR(),
						dr = Ct(Et),
						ht = A(dr),
						Xr = A(ht);
					JD(Xr, { class: "size-5" });
					var Yr = j(Xr);
					k(ht), k(dr);
					var Zr = j(dr, 2),
						mt = A(Zr);
					Uu(mt, { class: "size-5" });
					var He = j(mt);
					k(Zr),
						We(
							(At, Ft, Jt) => {
								Tr(dr, "action", `${lx}/payment/create-portal-session`),
									de(Yr, ` ${At ?? ""}`),
									Tr(Zr, "href", Ft),
									de(He, ` ${Jt ?? ""}`);
							},
							[() => wx(), () => Bv(yi.url.origin), () => Jv()]
						),
						$(Vt, Et);
				};
				Oe(Kt, (Vt) => {
					var Et;
					(Et = a.user.data) != null && Et.isCustomer && Vt(gr);
				});
			}
			var Ur = j(Kt, 2);
			Ur.__click = [CR, y, a, M];
			var nn = A(Ur);
			W0(nn, { class: "size-5" });
			var mn = j(nn);
			k(Ur), k(Lt), k(De), k(fe);
			var _n = j(fe, 2);
			ZD(_n, {
				get userData() {
					return a.user.data;
				},
				get open() {
					return x(p);
				},
				set open(Vt) {
					se(p, Vt, !0);
				},
			}),
				We(
					(Vt, Et, dr, ht, Xr, Yr, Zr, mt, He, At, Ft, Jt) => {
						(Ie = zr(ge, 1, "btn size-12 p-0 shadow-md", null, Ie, Vt)),
							Tr(ge, "title", Et),
							Tr(nt, "title", a.user.data.name),
							de(Ue, a.user.data.name),
							zr(ke, 1, dr),
							de(vt, `#${a.user.data.id ?? ""}`),
							de(it, `${ht ?? ""}: `),
							de(It, Xr),
							de(xt, `Level ${Yr ?? ""}`),
							de(St, ` (${Zr ?? ""}%) `),
							Tr(wt, "data-tip", mt),
							de(Ot, He),
							Tr(hr, "data-tip", At),
							de(Ke, ` ${Ft ?? ""}`),
							(Ur.disabled = x(y)),
							de(mn, ` ${Jt ?? ""}`);
					},
					[
						() => ({ "bg-red-500": x(B) }),
						() => O2(),
						() => Yo(Oi(a.user.data.id)),
						() => zm(),
						() => a.user.data.pixelsPainted.toLocaleString("en-US"),
						() => Math.floor(a.user.data.level),
						() => Math.floor((a.user.data.level % 1) * 100),
						() => t3(),
						() => V2(),
						() => (ai.muted ? RC() : zC()),
						() => Y2(),
						() => Q2(),
					]
				),
				di("focus", ge, () => {
					se(s, window.pwaInstallPrompt, !0);
				}),
				$(ne, H);
		};
		Oe(X, (ne) => {
			a.user.data && a.user.charges !== void 0 && ne(K);
		});
	}
	$(m, O), Dr();
}
$n(["click"]);
var IR = Pr(
	'<svg><path d="M100-240v-480l360 240-360 240Zm400 0v-480l360 240-360 240ZM180-480Zm400 0Zm-400 90 136-90-136-90v180Zm400 0 136-90-136-90v180Z"></path></svg>'
);
function MR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = IR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		height: "24px",
		viewBox: "0 -960 960 960",
		width: "24px",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var kR = Pr(
	'<svg><path d="M480-80q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q146 0 255.5 91.5T872-559h-82q-19-73-68.5-130.5T600-776v16q0 33-23.5 56.5T520-680h-80v80q0 17-11.5 28.5T400-560h-80v80h80v120h-40L168-552q-3 18-5.5 36t-2.5 36q0 131 92 225t228 95v80Zm364-20L716-228q-21 12-45 20t-51 8q-75 0-127.5-52.5T440-380q0-75 52.5-127.5T620-560q75 0 127.5 52.5T800-380q0 27-8 51t-20 45l128 128-56 56ZM620-280q42 0 71-29t29-71q0-42-29-71t-71-29q-42 0-71 29t-29 71q0 42 29 71t71 29Z"></path></svg>'
);
function AR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = kR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var ER = async (m, a, p, y, M, z) => {
		if (x(a)) {
			p.map.easeTo(x(a)), se(a, void 0);
			return;
		}
		se(y, !0);
		try {
			Co(p.map.getCenter(), p.map.getZoom());
			const T = new fl(x(M)),
				{ tile: s, pixel: B } = await Qr.getRandomTile(p.season),
				O = s.x * x(M) + B.x,
				X = s.y * x(M) + B.y,
				[K, ne] = T.pixelsToLatLon(O, X, x(z)),
				H = { lat: K, lng: ne },
				fe = x(z) + 2;
			se(a, { zoom: fe, center: H }, !0),
				p.map.flyTo(x(a)),
				hl.isEmpty() &&
					hl.push({ pos: p.map.getCenter(), zoom: p.map.getZoom() }),
				setTimeout(() => {
					se(a, void 0);
				}, 2500),
				hl.push({ pos: H, zoom: fe });
		} catch (T) {
			Fr.error(T.message);
		} finally {
			se(y, !1);
		}
	},
	zR = Te('<button class="btn btn-square shadow-md"><!></button>');
function LR(m, a) {
	Lr(a, !0);
	const p = ft(() => Wi.seasons[a.season].tileSize),
		y = ft(() => Wi.seasons[a.season].zoom);
	let M = st(!1),
		z = st(void 0);
	var T = zR();
	T.__click = [ER, z, a, M, p, y];
	var s = A(T);
	{
		var B = (X) => {
				AR(X, { class: "size-5" });
			},
			O = (X) => {
				MR(X, { class: "size-5" });
			};
		Oe(s, (X) => {
			x(z) ? X(O, !1) : X(B);
		});
	}
	k(T),
		We(
			(X) => {
				Tr(T, "title", X), (T.disabled = x(M));
			},
			[() => d2()]
		),
		$(m, T),
		Dr();
}
$n(["click"]);
var DR = Te(
		'<label class="tab grow font-semibold max-sm:h-10"><input type="radio" class="tab grow"/> <!> </label>'
	),
	RR = Te(
		'<div class="text-base-content/80 mt-20 text-center text-sm"> <!></div>'
	),
	BR = Te('<span class="font-flag tooltip ml-0.5"> </span>'),
	FR = Te("<span> </span>"),
	OR = Te(
		'<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="max-sm:px-1"><div class="flex items-center gap-2"><!> <div class="items-center gap-2 sm:flex"><span> <span class="ml-0.5"> </span></span> <!> <!> <!></div></div></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
	),
	NR = Te(
		'<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
	),
	jR = Te(
		'<tr><td class="text-base-content/80 text-center font-medium"> </td><td class="h-14 max-sm:px-1"><span> </span></td><td class="text-base-content/80 text-center font-medium max-sm:px-1"> </td></tr>'
	),
	VR = Te(
		'<table class="table"><thead class="text-base-content/80"><tr><th></th><th class="max-sm:px-1"> </th><th class="text-center"> <br class="sm:hidden"/> </th></tr></thead><tbody></tbody></table>'
	),
	qR = Te(
		'<div class="h-screen pt-20"><div class="flex justify-center"><span class="loading loading-spinner"></span></div></div>'
	),
	ZR = Te(
		'<div class="tabs tabs-box"></div> <div class="my-4 flex items-center justify-between"><!></div> <!>',
		1
	);
function UR(m, a) {
	Lr(a, !0);
	const p = [];
	let y = st("today"),
		M = {
			players: { label: Yv(), icon: yp },
			alliances: { label: Kv(), icon: xp },
		},
		z = st("players"),
		T = bi({ players: {}, alliances: {} });
	const s = ft(() => T[x(z)][x(y)]);
	Wr(() => {
		if (x(s)) return;
		const ge = x(y),
			Ie = x(z);
		Ie === "players"
			? Qr.leaderboardRegionPlayers(a.regionId, ge)
					.then((Ae) => {
						T[Ie][ge] = Ae;
					})
					.catch((Ae) => {
						Fr.error(Ae.message);
					})
			: Ie === "alliances" &&
			  Qr.leaderboardRegionAlliances(a.regionId, ge)
					.then((Ae) => {
						T[Ie][ge] = Ae;
					})
					.catch((Ae) => {
						Fr.error(Ae.message);
					});
	});
	var B = ZR(),
		O = Ct(B);
	hi(
		O,
		21,
		() => Object.entries(M),
		([ge, { label: Ie, icon: Ae }]) => ge,
		(ge, Ie) => {
			var Ae = ft(() => Mv(x(Ie), 2));
			let De = () => x(Ae)[0],
				Ee = () => x(Ae)[1].label,
				Fe = () => x(Ae)[1].icon;
			const $e = ft(Fe);
			var Je = DR(),
				qe = A(Je);
			Ka(qe);
			var Ze,
				Qe = j(qe, 2);
			xi(
				Qe,
				() => x($e),
				(et, nt) => {
					nt(et, {
						get this() {
							return Fe();
						},
						class: "mr-1 size-5 max-sm:hidden",
					});
				}
			);
			var Le = j(Qe);
			k(Je),
				We(() => {
					Tr(qe, "aria-label", Ee()),
						Ze !== (Ze = De()) && (qe.value = (qe.__value = De()) ?? ""),
						de(Le, ` ${Ee() ?? ""}`);
				}),
				Lm(
					p,
					[],
					qe,
					() => (De(), x(z)),
					(et) => se(z, et)
				),
				$(ge, Je);
		}
	),
		k(O);
	var X = j(O, 2),
		K = A(X);
	Um(K, {
		get value() {
			return x(y);
		},
		set value(ge) {
			se(y, ge, !0);
		},
	}),
		k(X);
	var ne = j(X, 2);
	{
		var H = (ge) => {
				var Ie = RR(),
					Ae = A(Ie),
					De = j(Ae);
				{
					var Ee = ($e) => {
							var Je = wi();
							We((qe) => de(Je, qe), [() => vp().toLowerCase()]), $($e, Je);
						},
						Fe = ($e) => {
							var Je = er(),
								qe = Ct(Je);
							{
								var Ze = (Le) => {
										var et = wi();
										We((nt) => de(et, nt), [() => Nm()]), $(Le, et);
									},
									Qe = (Le) => {
										var et = er(),
											nt = Ct(et);
										{
											var Ue = (ke) => {
												var vt = wi();
												We((ee) => de(vt, ee), [() => jm()]), $(ke, vt);
											};
											Oe(
												nt,
												(ke) => {
													x(y) === "month" && ke(Ue);
												},
												!0
											);
										}
										$(Le, et);
									};
								Oe(
									qe,
									(Le) => {
										x(y) === "week" ? Le(Ze) : Le(Qe, !1);
									},
									!0
								);
							}
							$($e, Je);
						};
					Oe(De, ($e) => {
						x(y) === "today" ? $e(Ee) : $e(Fe, !1);
					});
				}
				k(Ie), We(($e) => de(Ae, `${$e ?? ""} `), [() => Om()]), $(ge, Ie);
			},
			fe = (ge) => {
				var Ie = er(),
					Ae = Ct(Ie);
				{
					var De = (Fe) => {
							var $e = er(),
								Je = Ct($e);
							{
								var qe = (Qe) => {
										const Le = ft(() => x(s));
										var et = NR(),
											nt = A(et),
											Ue = A(nt),
											ke = j(A(Ue)),
											vt = A(ke, !0);
										k(ke);
										var ee = j(ke),
											re = A(ee),
											he = j(re, 2, !0);
										k(ee), k(Ue), k(nt);
										var oe = j(nt);
										hi(
											oe,
											31,
											() => x(Le),
											(ze) => ze.id,
											(ze, je, pt) => {
												const it = ft(() => {
													var mr;
													return (
														((mr = Mt.data) == null ? void 0 : mr.id) ===
														x(je).id
													);
												});
												var ct = OR();
												let It;
												var Dt = A(ct),
													at = A(Dt, !0);
												k(Dt);
												var dt = j(Dt),
													yt = A(dt),
													xt = A(yt);
												co(xt, {
													class: "size-10 border",
													get userId() {
														return x(je).id;
													},
													get pictureUrl() {
														return x(je).picture;
													},
												});
												var St = j(xt, 2),
													wt = A(St),
													_t = A(wt),
													Lt = j(_t),
													Rt = A(Lt);
												k(Lt), k(wt);
												var $t = j(wt, 2);
												{
													var tr = (mr) => {
														const hr = ft(() => So(x(je).equippedFlag));
														var _r = BR(),
															Ir = A(_r, !0);
														k(_r),
															We(() => {
																Tr(_r, "data-tip", x(hr).name),
																	de(Ir, x(hr).flag);
															}),
															$(mr, _r);
													};
													Oe($t, (mr) => {
														"equippedFlag" in x(je) &&
															x(je).equippedFlag &&
															mr(tr);
													});
												}
												var Qt = j($t, 2);
												{
													var Ot = (mr) => {
														Eh(mr, {
															get username() {
																return x(je).discord;
															},
															get id() {
																return x(je).discordId;
															},
														});
													};
													Oe(Qt, (mr) => {
														x(je).discord && mr(Ot);
													});
												}
												var Nt = j(Qt, 2);
												{
													var or = (mr) => {
														var hr = FR(),
															_r = A(hr, !0);
														k(hr),
															We(
																(Ir, qr) => {
																	zr(
																		hr,
																		1,
																		`badge badge-sm ml-0.5 border-0 ${
																			Ir ?? ""
																		} ${qr ?? ""}`
																	),
																		de(_r, x(je).allianceName);
																},
																[
																	() => pp(x(je).allianceId),
																	() => Oi(x(je).allianceId),
																]
															),
															$(mr, hr);
													};
													Oe(Nt, (mr) => {
														"allianceName" in x(je) &&
															x(je).allianceName &&
															mr(or);
													});
												}
												k(St), k(yt), k(dt);
												var cr = j(dt),
													Vr = A(cr, !0);
												k(cr),
													k(ct),
													We(
														(mr, hr, _r) => {
															(It = zr(ct, 1, "", null, It, mr)),
																de(at, x(pt) + 1),
																zr(
																	wt,
																	1,
																	`font-semibold max-sm:ml-2 ${
																		hr ?? ""
																	} flex gap-1`
																),
																de(_t, `${x(je).name ?? ""} `),
																de(Rt, `#${x(je).id ?? ""}`),
																de(Vr, _r);
														},
														[
															() => ({ "bg-base-200": x(it) }),
															() => Oi(x(je).id),
															() => x(je).pixelsPainted.toLocaleString("en-US"),
														]
													),
													ll(
														ct,
														() => cl,
														() => ({ duration: 200 })
													),
													$(ze, ct);
											}
										),
											k(oe),
											k(et),
											We(
												(ze, je, pt) => {
													de(vt, ze), de(re, `${je ?? ""} `), de(he, pt);
												},
												[() => Dm(), () => vc(), () => yc().toLowerCase()]
											),
											$(Qe, et);
									},
									Ze = (Qe) => {
										var Le = er(),
											et = Ct(Le);
										{
											var nt = (Ue) => {
												var ke = VR(),
													vt = A(ke),
													ee = A(vt),
													re = j(A(ee)),
													he = A(re, !0);
												k(re);
												var oe = j(re),
													ze = A(oe),
													je = j(ze, 2, !0);
												k(oe), k(ee), k(vt);
												var pt = j(vt);
												hi(
													pt,
													31,
													() => x(s),
													(it) => it.id,
													(it, ct, It) => {
														const Dt = ft(() => {
															var $t;
															return (
																(($t = Mt.data) == null
																	? void 0
																	: $t.allianceId) === x(ct).id
															);
														});
														var at = jR();
														let dt;
														var yt = A(at),
															xt = A(yt, !0);
														k(yt);
														var St = j(yt),
															wt = A(St),
															_t = A(wt, !0);
														k(wt), k(St);
														var Lt = j(St),
															Rt = A(Lt, !0);
														k(Lt),
															k(at),
															We(
																($t, tr, Qt) => {
																	(dt = zr(at, 1, "", null, dt, $t)),
																		de(xt, x(It) + 1),
																		zr(wt, 1, `font-semibold ${tr ?? ""}`),
																		de(_t, x(ct).name),
																		de(Rt, Qt);
																},
																[
																	() => ({ "bg-base-200": x(Dt) }),
																	() => Oi(x(ct).id),
																	() =>
																		x(ct).pixelsPainted.toLocaleString("en-US"),
																]
															),
															ll(
																at,
																() => cl,
																() => ({ duration: 200 })
															),
															$(it, at);
													}
												),
													k(pt),
													k(ke),
													We(
														(it, ct, It) => {
															de(he, it), de(ze, `${ct ?? ""} `), de(je, It);
														},
														[() => _p(), () => vc(), () => yc().toLowerCase()]
													),
													$(Ue, ke);
											};
											Oe(
												et,
												(Ue) => {
													x(z) === "alliances" && Ue(nt);
												},
												!0
											);
										}
										$(Qe, Le);
									};
								Oe(Je, (Qe) => {
									x(z) === "players" ? Qe(qe) : Qe(Ze, !1);
								});
							}
							$(Fe, $e);
						},
						Ee = (Fe) => {
							var $e = qR();
							$(Fe, $e);
						};
					Oe(
						Ae,
						(Fe) => {
							x(s) ? Fe(De) : Fe(Ee, !1);
						},
						!0
					);
				}
				$(ge, Ie);
			};
		Oe(ne, (ge) => {
			x(s) && x(s).length === 0 ? ge(H) : ge(fe, !1);
		});
	}
	$(m, B), Dr();
}
var $R = Te('<div class="mt-5"><!></div>'),
	GR = Te(
		'<dialog class="modal"><div class="modal-box h-11/12 max-w-3xl"><form method="dialog"><button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2">✕</button></form> <h2><span class="font-flag tooltip"> </span> <span> </span> <span> </span></h2> <!></div> <form method="dialog" class="modal-backdrop"><button>close</button></form></dialog>'
	);
function HR(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15);
	const y = ft(() => So(a.region.countryId));
	Fn(() => {
		const ge = (Ie) => {
			Ie.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", ge),
			() => document.removeEventListener("keydown", ge)
		);
	});
	var M = GR(),
		z = A(M),
		T = j(A(z), 2),
		s = A(T),
		B = A(s, !0);
	k(s);
	var O = j(s, 2),
		X = A(O, !0);
	k(O);
	var K = j(O, 2),
		ne = A(K);
	k(K), k(T);
	var H = j(T, 2);
	{
		var fe = (ge) => {
			var Ie = $R(),
				Ae = A(Ie);
			UR(Ae, {
				get regionId() {
					return a.region.id;
				},
			}),
				k(Ie),
				Ai(
					2,
					Ie,
					() => ia,
					() => ({ duration: 300 })
				),
				$(ge, Ie);
		};
		Oe(H, (ge) => {
			p() && ge(fe);
		});
	}
	k(z),
		yn(2),
		k(M),
		Ni(M, () => (ge) => {
			Wr(() => {
				p() ? ge.show() : ge.close();
			});
		}),
		We(
			(ge) => {
				zr(T, 1, `flex gap-2 text-xl font-bold sm:text-2xl ${ge ?? ""}`),
					Tr(s, "data-tip", x(y).name),
					de(B, x(y).flag),
					de(X, a.region.name),
					de(ne, `#${a.region.number ?? ""}`);
			},
			[() => Oi(a.region.cityId)]
		),
		di("close", M, () => p(!1)),
		$(m, M),
		Dr();
}
var WR = Pr(
	'<svg><path d="M791-55 686-160H160v-112q0-34 17.5-62.5T224-378q45-23 91.5-37t94.5-21L55-791l57-57 736 736-57 57ZM240-240h366L486-360h-6q-56 0-111 13.5T260-306q-9 5-14.5 14t-5.5 20v32Zm496-138q29 14 46 42.5t18 61.5L666-408q18 7 35.5 14t34.5 16ZM568-506l-59-59q23-9 37-29.5t14-45.5q0-33-23.5-56.5T480-720q-25 0-45.5 14T405-669l-59-59q23-34 58-53t76-19q66 0 113 47t47 113q0 41-19 76t-53 58Zm38 266H240h366ZM457-617Z"></path></svg>'
);
function XR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = WR();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		height: "24px",
		viewBox: "0 -960 960 960",
		width: "24px",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var YR = Pr(
		'<svg><path d="m233-120 65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Z"></path></svg>'
	),
	KR = Pr(
		'<svg><path d="m354-287 126-76 126 77-33-144 111-96-146-13-58-136-58 135-146 13 111 97-33 143ZM233-120l65-281L80-590l288-25 112-265 112 265 288 25-218 189 65 281-247-149-247 149Zm247-350Z"></path></svg>'
	);
function JR(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
	var y = er(),
		M = Ct(y);
	{
		var z = (s) => {
				var B = YR();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			},
			T = (s) => {
				var B = KR();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			};
		Oe(M, (s) => {
			a.filled ? s(z) : s(T, !1);
		});
	}
	$(m, y);
}
var QR = (m, a, p, y, M) => {
		if (x(a) && x(p)) {
			const z = x(a) - x(p).clientHeight,
				T = x(a) / 2 - z / 2;
			y.map.flyTo({
				center: { lat: x(M).center[0], lng: x(M).center[1] },
				zoom: 17.5,
				offset: [0, -T],
			});
		}
	},
	e7 = (m, a, p) => a.onclickregion(x(p)),
	t7 = Te(
		'<button><span class="font-flag tooltip"> </span> <span class="line-clamp-1 text-ellipsis"> </span> <span> </span></button>'
	),
	r7 = Te('<div class="skeleton h-5 w-16"></div>'),
	n7 = Te('<div class="skeleton mt-1 h-5 w-32"></div>'),
	i7 = Te('<span class="font-flag tooltip ml-0.5"> </span>'),
	a7 = (m, a) => {
		navigator.clipboard.writeText(x(a).allianceId.toString()), Fr.success(Fm());
	},
	o7 = Te("<button><!></button>"),
	s7 = Te("<span> </span> <!>", 1),
	l7 = Te('<span class="tooltip"><!></span>'),
	c7 = Te('<span class="tooltip"><!></span>'),
	u7 = (m, a) => {
		a("report-user");
	},
	h7 = Te("<li><button><!> </button></li>"),
	d7 = (m, a) => {
		a("timeout");
	},
	p7 = Te("<li><button><!> </button></li>"),
	f7 = (m, a) => {
		a("ban");
	},
	m7 = Te("<li><button><!> </button></li>"),
	_7 = async (m, a, p, y, M, z) => {
		se(a, !0);
		try {
			await Qr.banAllianceUser(x(p).id), await y({ ...x(M), season: z.season });
		} catch (T) {
			Fr.error(T.message);
		} finally {
			se(a, !1);
		}
	},
	g7 = Te('<li><button class="text-error font-medium"><!> </button></li>'),
	v7 = Te(
		'<div class="dropdown dropdown-top max-sm:dropdown-top max-sm:dropdown-left ml-1"><button tabindex="0" class="btn btn-xs btn-circle"><!></button> <ul tabindex="0" class="dropdown-content menu bg-base-100 z-1 mb-1 w-max gap-0.5 rounded-xl p-2.5 shadow-sm"></ul></div>'
	),
	y7 = Te(
		'<div class="flex items-center gap-1"><span> </span> <div class="ml-0.5"><!></div> <div class="flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!> <!> <!> <!></div> <!></div>'
	),
	x7 = (m, a) => a.onclickpaint(a.latLon),
	b7 = async (m, a, p, y) => {
		try {
			se(a, !0),
				x(p)
					? (await Qr.deleteFavoriteLocation(x(p).id), Fr.warning(lS()))
					: (await Qr.favoriteLocation(x(y).center), Fr.success(hS())),
				aa.smallPlop.play(),
				Mt.refresh();
		} catch (M) {
			Fr.error(M.message);
		} finally {
			se(a, !1);
		}
	},
	w7 = Te("<button><!> </button>"),
	T7 = (m, a, p) =>
		a.onclickshare(
			y4(yi.url, {
				pos: { lat: x(p).center[0], lng: x(p).center[1] },
				zoom: a.zoom,
			})
		),
	C7 = Te(
		'<div><div class="flex gap-2 px-3"><div class="flex grow gap-1"><button class="btn btn-sm btn-circle btn-soft"><!></button> <h2 class="mt-0.5 flex items-center gap-2 text-lg"><span class="whitespace-nowrap"> </span> <!></h2></div> <button class="btn btn-circle btn-sm"><!></button></div> <div class="text-base-content/80 mt-1 px-3 text-sm"><!></div> <div class="hide-scrollbar flex max-w-full gap-1.5 overflow-x-auto px-3 pb-2 pt-3 sm:pb-3"><button class="btn btn-primary"><!> </button> <!> <button class="btn btn-primary btn-soft"><!> </button></div></div>'
	);
function S7(m, a) {
	Lr(a, !0);
	let p = st(void 0);
	const y = ft(() => new fl(a.tileSize));
	let M = st(void 0),
		z = st(void 0),
		T = st(!1),
		s = st(!1);
	const B = ft(() => {
			var at, dt, yt;
			return (
				!!(
					(dt = (at = x(p)) == null ? void 0 : at.paintedBy) != null && dt.id
				) && ((yt = Mt.data) == null ? void 0 : yt.id) === x(p).paintedBy.id
			);
		}),
		O = ft(() => {
			const [at, dt] = a.latLon ?? [0, 0],
				yt = x(y).latLonToPixelBoundsLatLon(at, dt, a.pixelArtZoom),
				xt = qm(yt),
				{ tile: St, pixel: wt } = x(y).latLonToTileAndPixel(
					at,
					dt,
					a.pixelArtZoom
				),
				_t = x(y).latLonToRegionAndPixel(at, dt, a.pixelArtZoom);
			return {
				bounds: yt,
				center: xt,
				tile: St,
				pixel: wt,
				regionPixel: _t.pixel,
			};
		});
	Wr(() => {
		aa.plop.play(), a.crosshair.clearAndPlace(a.latLon);
	});
	let X = 0;
	const K = ({ pixel: at, tile: dt, season: yt }) =>
		`s${yt}:p(${at[0]},${at[1]}):t(${dt[0]},${dt[1]})`;
	let ne;
	dl(
		() => [x(O), a.season],
		() => {
			const at = { ...x(O), season: a.season },
				dt = K(at);
			if ((se(p, a.pixelInfoCache.get(dt), !0), x(p) !== void 0)) return;
			a.pixelInfoCache.size === 0 && (X = 0),
				X++,
				X > 6
					? (clearTimeout(ne), (ne = setTimeout(async () => H(at), 500)))
					: H(at);
		}
	);
	async function H(at) {
		var xt;
		const dt = await Qr.getPixelInfo({
			...at,
			isModerator: xc((xt = Mt.data) == null ? void 0 : xt.role, [
				"admin",
				"global_moderator",
				"moderator",
			]),
		});
		if (dt.paintedBy !== void 0) {
			const St = K(at);
			a.pixelInfoCache.set(St, dt);
		}
		const yt = K({ ...x(O), season: a.season });
		return se(p, a.pixelInfoCache.get(yt), !0), dt;
	}
	function fe() {
		a.crosshair.clear(), aa.smallPlop.play(), a.onclose();
	}
	Fn(() => {
		const at = (dt) => {
			dt.key === "Escape" && fe();
		};
		return (
			document.addEventListener("keydown", at),
			() => document.removeEventListener("keydown", at)
		);
	});
	const ge = ft(() => {
		var xt, St, wt, _t, Lt;
		const at = [],
			dt =
				(St = (xt = Mt) == null ? void 0 : xt.data) == null ? void 0 : St.role;
		xc(dt, ["admin"]) && !x(B) && at.push("ban-user"),
			xc(dt, ["admin", "global_moderator", "moderator"]) &&
				!x(B) &&
				at.push("timeout-user"),
			!x(B) && Mt.data && at.push("report-user");
		const yt = (wt = x(p)) == null ? void 0 : wt.paintedBy;
		return (
			(yt == null ? void 0 : yt.allianceId) ===
				((_t = Mt.data) == null ? void 0 : _t.allianceId) &&
				((Lt = Mt.data) == null ? void 0 : Lt.allianceRole) === "admin" &&
				Mt.data.id !== (yt == null ? void 0 : yt.id) &&
				!x(B) &&
				at.push("ban-alliance"),
			at
		);
	});
	function Ie(at) {
		const dt = (async () =>
			await a0(a.map, {
				maxHeight: 1080,
				maxWidth: 1080,
				quality: 0.8,
				type: "image/jpeg",
			}))();
		a.onclickmodaction(x(p), dt, a.latLon, at);
	}
	var Ae = C7(),
		De = A(Ae),
		Ee = A(De),
		Fe = A(Ee);
	Fe.__click = [QR, M, z, a, O];
	var $e = A(Fe);
	Em($e, { class: "fill-primary size-5" }), k(Fe);
	var Je = j(Fe, 2),
		qe = A(Je),
		Ze = A(qe);
	k(qe);
	var Qe = j(qe, 2);
	{
		var Le = (at) => {
				const dt = ft(() => x(p).region),
					yt = ft(() => So(x(dt).countryId));
				var xt = t7();
				xt.__click = [e7, a, dt];
				var St = A(xt),
					wt = A(St, !0);
				k(St);
				var _t = j(St, 2),
					Lt = A(_t, !0);
				k(_t);
				var Rt = j(_t, 2),
					$t = A(Rt);
				k(Rt),
					k(xt),
					We(
						(tr) => {
							zr(
								xt,
								1,
								`btn btn-xs flex gap-1 py-3 text-sm max-sm:max-w-32 ${tr ?? ""}`
							),
								Tr(St, "data-tip", x(yt).name),
								de(wt, x(yt).flag),
								de(Lt, x(dt).name),
								de($t, `#${x(dt).number ?? ""}`);
						},
						[() => Oi(x(dt).cityId)]
					),
					$(at, xt);
			},
			et = (at) => {
				var dt = r7();
				$(at, dt);
			};
		Oe(Qe, (at) => {
			var dt;
			(dt = x(p)) != null && dt.region ? at(Le) : at(et, !1);
		});
	}
	k(Je), k(Ee);
	var nt = j(Ee, 2);
	nt.__click = fe;
	var Ue = A(nt);
	_l(Ue, { class: "size-4" }), k(nt), k(De);
	var ke = j(De, 2),
		vt = A(ke);
	{
		var ee = (at) => {
				var dt = n7();
				$(at, dt);
			},
			re = (at) => {
				var dt = er(),
					yt = Ct(dt);
				{
					var xt = (wt) => {
							var _t = wi();
							We((Lt) => de(_t, Lt), [() => fC()]), $(wt, _t);
						},
						St = (wt) => {
							const _t = ft(() => x(p).paintedBy);
							var Lt = y7(),
								Rt = A(Lt),
								$t = A(Rt);
							k(Rt);
							var tr = j(Rt, 2),
								Qt = A(tr);
							co(Qt, {
								class: "size-5 border-0",
								get userId() {
									return x(_t).id;
								},
								get pictureUrl() {
									return x(_t).picture;
								},
							}),
								k(tr);
							var Ot = j(tr, 2),
								Nt = A(Ot),
								or = A(Nt),
								cr = A(or, !0);
							k(or);
							var Vr = j(or, 2),
								mr = A(Vr);
							k(Vr), k(Nt);
							var hr = j(Nt, 2);
							{
								var _r = (Me) => {
									const we = ft(() => So(x(_t).equippedFlag));
									var Ve = i7(),
										ut = A(Ve, !0);
									k(Ve),
										We(() => {
											Tr(Ve, "data-tip", x(we).name), de(ut, x(we).flag);
										}),
										$(Me, Ve);
								};
								Oe(hr, (Me) => {
									x(_t).equippedFlag && Me(_r);
								});
							}
							var Ir = j(hr, 2);
							{
								var qr = (Me) => {
									Eh(Me, {
										get username() {
											return x(_t).discord;
										},
										get id() {
											return x(_t).discordId;
										},
									});
								};
								Oe(Ir, (Me) => {
									x(_t).discord && Me(qr);
								});
							}
							var ue = j(Ir, 2);
							{
								var V = (Me) => {
									var we = s7(),
										Ve = Ct(we),
										ut = A(Ve, !0);
									k(Ve);
									var Ke = j(Ve, 2);
									{
										var kt = (ye) => {
											var Bt = o7();
											Bt.__click = [a7, _t];
											var rr = A(Bt);
											Rm(rr, { class: "size-3" }),
												k(Bt),
												We(
													(Kt, gr) => {
														zr(Bt, 1, Kt), Tr(Bt, "title", gr);
													},
													[
														() => Yo(Oi(x(_t).allianceId)),
														() => Nx({ allianceId: x(_t).allianceId }),
													]
												),
												$(ye, Bt);
										};
										Oe(Ke, (ye) => {
											var Bt, rr, Kt;
											(((Bt = Mt.data) == null ? void 0 : Bt.role) ===
												"admin" ||
												((rr = Mt.data) == null ? void 0 : rr.role) ===
													"moderator" ||
												((Kt = Mt.data) == null ? void 0 : Kt.role) ===
													"global_moderator") &&
												ye(kt);
										});
									}
									We(
										(ye, Bt) => {
											zr(
												Ve,
												1,
												`badge badge-sm ml-0.5 border-0 ${ye ?? ""} ${Bt ?? ""}`
											),
												de(ut, x(_t).allianceName);
										},
										[() => pp(x(_t).allianceId), () => Oi(x(_t).allianceId)]
									),
										$(Me, we);
								};
								Oe(ue, (Me) => {
									x(_t).allianceId && Me(V);
								});
							}
							var U = j(ue, 2);
							{
								var Y = (Me) => {
										var we = l7(),
											Ve = A(we);
										Xg(Ve, { class: "text-error size-4" }),
											k(we),
											We((ut) => Tr(we, "data-tip", ut), [() => Xv()]),
											$(Me, we);
									},
									ie = (Me) => {
										var we = er(),
											Ve = Ct(we);
										{
											var ut = (Ke) => {
												var kt = c7(),
													ye = A(kt);
												Xf(ye, { class: "text-error size-4" }),
													k(kt),
													We((Bt) => Tr(kt, "data-tip", Bt), [() => Lx()]),
													$(Ke, kt);
											};
											Oe(
												Ve,
												(Ke) => {
													x(p).paintedBy.timedOut && Ke(ut);
												},
												!0
											);
										}
										$(Me, we);
									};
								Oe(U, (Me) => {
									x(p).paintedBy.banned ? Me(Y) : Me(ie, !1);
								});
							}
							k(Ot);
							var pe = j(Ot, 2);
							{
								var Se = (Me) => {
									var we = v7(),
										Ve = A(we),
										ut = A(Ve);
									$m(ut, { class: "size-4" }), k(Ve);
									var Ke = j(Ve, 2);
									hi(
										Ke,
										21,
										() => x(ge),
										hp,
										(kt, ye) => {
											var Bt = er(),
												rr = Ct(Bt);
											{
												var Kt = (Ur) => {
														var nn = h7(),
															mn = A(nn);
														let _n;
														mn.__click = [u7, Ie];
														var Vt = A(mn);
														X0(Vt, { class: "size-5" });
														var Et = j(Vt);
														k(mn),
															k(nn),
															We(
																(dr, ht) => {
																	(_n = zr(
																		mn,
																		1,
																		"text-error py-2 font-medium",
																		null,
																		_n,
																		dr
																	)),
																		de(Et, ` ${ht ?? ""}`);
																},
																[
																	() => ({ "cursor-not-allowed": x(B) }),
																	() => Tx(),
																]
															),
															$(Ur, nn);
													},
													gr = (Ur) => {
														var nn = er(),
															mn = Ct(nn);
														{
															var _n = (Et) => {
																	var dr = p7(),
																		ht = A(dr);
																	let Xr;
																	ht.__click = [d7, Ie];
																	var Yr = A(ht);
																	Xf(Yr, { class: "size-5" });
																	var Zr = j(Yr);
																	k(ht),
																		k(dr),
																		We(
																			(mt, He) => {
																				(Xr = zr(
																					ht,
																					1,
																					"text-error font-medium",
																					null,
																					Xr,
																					mt
																				)),
																					de(Zr, ` ${He ?? ""}`);
																			},
																			[
																				() => ({ "cursor-not-allowed": x(B) }),
																				() => Cx(),
																			]
																		),
																		$(Et, dr);
																},
																Vt = (Et) => {
																	var dr = er(),
																		ht = Ct(dr);
																	{
																		var Xr = (Zr) => {
																				var mt = m7(),
																					He = A(mt);
																				let At;
																				He.__click = [f7, Ie];
																				var Ft = A(He);
																				Xg(Ft, { class: "size-5" });
																				var Jt = j(Ft);
																				k(He),
																					k(mt),
																					We(
																						(Cr, Er) => {
																							(At = zr(
																								He,
																								1,
																								"text-error font-medium",
																								null,
																								At,
																								Cr
																							)),
																								de(Jt, ` ${Er ?? ""}`);
																						},
																						[
																							() => ({
																								"cursor-not-allowed": x(B),
																							}),
																							() => Sx(),
																						]
																					),
																					$(Zr, mt);
																			},
																			Yr = (Zr) => {
																				var mt = er(),
																					He = Ct(mt);
																				{
																					var At = (Ft) => {
																						var Jt = g7(),
																							Cr = A(Jt);
																						Cr.__click = [_7, s, _t, H, O, a];
																						var Er = A(Cr);
																						XR(Er, { class: "size-5" });
																						var ur = j(Er);
																						k(Cr),
																							k(Jt),
																							We(
																								(rn) => de(ur, ` ${rn ?? ""}`),
																								[() => Wv()]
																							),
																							$(Ft, Jt);
																					};
																					Oe(
																						He,
																						(Ft) => {
																							x(ye) === "ban-alliance" &&
																								Ft(At);
																						},
																						!0
																					);
																				}
																				$(Zr, mt);
																			};
																		Oe(
																			ht,
																			(Zr) => {
																				x(ye) === "ban-user"
																					? Zr(Xr)
																					: Zr(Yr, !1);
																			},
																			!0
																		);
																	}
																	$(Et, dr);
																};
															Oe(
																mn,
																(Et) => {
																	x(ye) === "timeout-user"
																		? Et(_n)
																		: Et(Vt, !1);
																},
																!0
															);
														}
														$(Ur, nn);
													};
												Oe(rr, (Ur) => {
													x(ye) === "report-user" ? Ur(Kt) : Ur(gr, !1);
												});
											}
											$(kt, Bt);
										}
									),
										k(Ke),
										k(we),
										$(Me, we);
								};
								Oe(pe, (Me) => {
									x(ge).length > 0 && Me(Se);
								});
							}
							k(Lt),
								We(
									(Me, we) => {
										var Ve;
										de($t, `${Me ?? ""}:`),
											zr(Nt, 1, `font-medium ${we ?? ""} flex gap-1.5`),
											de(
												cr,
												((Ve = Mt.data) == null ? void 0 : Ve.id) === x(_t).id
													? Mt.data.name
													: x(_t).name
											),
											de(mr, `#${x(_t).id ?? ""}`);
									},
									[() => gC(), () => Oi(x(_t).id)]
								),
								$(wt, Lt);
						};
					Oe(
						yt,
						(wt) => {
							x(p).paintedBy.id === 0 ? wt(xt) : wt(St, !1);
						},
						!0
					);
				}
				$(at, dt);
			};
		Oe(vt, (at) => {
			x(p) === void 0 ? at(ee) : at(re, !1);
		});
	}
	k(ke);
	var he = j(ke, 2),
		oe = A(he);
	oe.__click = [x7, a];
	var ze = A(oe);
	zh(ze, { class: "size-4.5" });
	var je = j(ze);
	k(oe);
	var pt = j(oe, 2);
	{
		var it = (at) => {
			const dt = ft(() =>
					Mt.data.favoriteLocations.find(
						(Lt) =>
							Math.abs(Lt.latitude - x(O).center[0]) < 5e-5 &&
							Math.abs(Lt.longitude - x(O).center[1]) < 5e-5
					)
				),
				yt = ft(
					() =>
						!x(dt) &&
						Mt.data.favoriteLocations.length >= Mt.data.maxFavoriteLocations
				);
			var xt = w7();
			let St;
			xt.__click = [b7, T, dt, O];
			var wt = A(xt);
			{
				let Lt = ft(() => !!x(dt));
				JR(wt, {
					class: "size-4.5",
					get filled() {
						return x(Lt);
					},
				});
			}
			var _t = j(wt);
			k(xt),
				We(
					(Lt, Rt) => {
						(St = zr(xt, 1, "btn btn-primary btn-soft", null, St, Lt)),
							(xt.disabled = x(T) || x(yt)),
							de(_t, ` ${Rt ?? ""}`);
					},
					[() => ({ "text-yellow-400": !!x(dt) }), () => (x(yt) ? xC() : TC())]
				),
				$(at, xt);
		};
		Oe(pt, (at) => {
			Mt.data && at(it);
		});
	}
	var ct = j(pt, 2);
	ct.__click = [T7, a, O];
	var It = A(ct);
	o0(It, { class: "size-4.5" });
	var Dt = j(It);
	k(ct),
		k(he),
		k(Ae),
		Ko(
			Ae,
			(at) => se(z, at),
			() => x(z)
		),
		We(
			(at, dt) => {
				de(
					Ze,
					`Pixel: ${x(O).regionPixel[0] ?? ""}, ${x(O).regionPixel[1] ?? ""}`
				),
					(oe.disabled = Mt.loading),
					de(je, ` ${at ?? ""}`),
					de(Dt, ` ${dt ?? ""}`);
			},
			[() => Gv(), () => PC()]
		),
		mp("innerHeight", (at) => se(M, at, !0)),
		$(m, Ae),
		Dr();
}
$n(["click"]);
var P7 = Te("<!> <!>", 1),
	I7 = (m, a, p) => {
		a(x(p));
	},
	M7 = Te(
		'<div class="mt-3 flex justify-center"><span class="loading loading-spinner"></span></div>'
	),
	k7 = Te(
		'<div class="mt-3 flex justify-center"><p class="text-base-content/80 text-sm">No one has painted in this area yet.</p></div>'
	),
	A7 = (m, a) => {
		navigator.clipboard.writeText(
			x(a)
				.map((p) => p.id)
				.join(", ")
		),
			Fr.success("Player IDs copied to clipboard");
	},
	E7 = (m, a, p, y, M) => {
		a.crosshair.clear(), p(x(y).painted), se(M, x(y).id, !0);
	},
	z7 = Te("<span> </span>"),
	L7 = Te(
		'<tr><th> </th><td class="flex items-center gap-1"><!> <div class="ml-0.5 flex flex-wrap items-center gap-1"><span><span> </span> <span> </span></span> <!></div></td><td class="text-center"> </td></tr>'
	),
	D7 = Te(
		'<div class="max-h-[25vh] overflow-y-auto"><table class="table"><thead><tr><th></th><th>Player <button class="btn btn-xs btn-circle btn-ghost ml-0.5" title="Copy player IDs to clipboard"><!></button></th><th class="text-center">Pixels Painted</th></tr></thead><tbody></tbody></table></div>'
	),
	R7 = Te(
		'<div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t sm:mb-3 sm:shadow-xl"><div class="p-3"><div class="flex justify-between gap-1"><h2 class="flex items-center gap-1 pl-1 text-lg"><button class="btn btn-circle btn-soft size-7"><!></button> <span>Selected area</span> <span class="text-base-content/80 ml-0.5 text-sm"> </span></h2> <button class="btn btn-circle btn-sm"><!></button></div> <div class="pb-3"><!></div></div></div>'
	);
function B7(m, a) {
	Lr(a, !0);
	let p = bi([]),
		y = st(bi([])),
		M = st(!1),
		z = st(void 0);
	Fn(() => {
		const H = a.map.on("click", async (fe) => {
			if (p.length >= 2) {
				a.onclose();
				return;
			}
			if (
				(p.push(fe.lngLat),
				a.crosshair.place([fe.lngLat.lat, fe.lngLat.lng]),
				aa.plop.play(),
				p.length === 2)
			)
				try {
					se(M, !0), se(y, await T(p[0], p[1]), !0), s(x(y));
				} finally {
					se(M, !1);
				}
		});
		return () => {
			H.unsubscribe(), a.crosshair.clear();
		};
	});
	async function T(H, fe) {
		const ge = new fl(a.tileSize),
			[Ie, Ae] = ge.latLonToPixelsFloor(H.lat, H.lng, a.pixelArtZoom),
			[De, Ee] = ge.latLonToPixelsFloor(fe.lat, fe.lng, a.pixelArtZoom),
			[Fe, $e] = [Math.min(Ie, De), Math.min(Ae, Ee)],
			[Je, qe] = [Math.max(Ie, De), Math.max(Ae, Ee)],
			Ze = Je - Fe,
			Qe = qe - $e;
		if (Ze * Qe > 1e6)
			return (
				Fr.error(
					"The selected area is too big. Please select an area smaller than 1,000,000 pixels."
				),
				[]
			);
		const et = Math.floor(Fe / a.tileSize),
			nt = Math.floor($e / a.tileSize),
			Ue = Math.floor(Je / a.tileSize),
			ke = Math.floor(qe / a.tileSize),
			vt = Ue - et + 1,
			ee = ke - nt + 1,
			re = new Array(ee).fill(0).flatMap((it, ct) =>
				new Array(vt).fill(0).map(async (It, Dt) => {
					const at = et + Dt,
						dt = nt + ct;
					let yt = 0,
						xt = 0,
						St = a.tileSize - 1,
						wt = a.tileSize - 1;
					dt === nt && (xt = $e % a.tileSize),
						at === et && (yt = Fe % a.tileSize),
						dt === ke && (wt = qe % a.tileSize),
						at === Ue && (St = Je % a.tileSize);
					const tr = [at, dt],
						Qt = [yt, xt],
						Ot = [St, wt];
					return {
						response: await Qr.getPixelAreaInfo({
							season: a.season,
							tile: tr,
							p0: Qt,
							p1: Ot,
						}),
						tile: tr,
						p0: Qt,
						p1: Ot,
					};
				})
			),
			he = await Promise.all(re),
			oe = new Map();
		for (const { response: it, p0: ct, p1: It, tile: Dt } of he) {
			const [at, dt] = Dt,
				[yt, xt] = ct,
				[St, wt] = It,
				_t = St - yt + 1,
				Lt = wt - xt + 1;
			for (let Rt = 0; Rt < Lt; Rt++)
				for (let $t = 0; $t < _t; $t++) {
					const tr = Rt * _t + $t,
						Qt = it.paintedBy[tr];
					let Ot = oe.get(Qt);
					Ot || ((Ot = { latitudes: [], longitudes: [] }), oe.set(Qt, Ot));
					const [Nt, or] = ge.pixelsToLatLon(
						at * a.tileSize + (yt + $t + 0.5),
						dt * a.tileSize + (xt + Rt + 0.5),
						a.pixelArtZoom
					);
					Ot.latitudes.push(Nt), Ot.longitudes.push(or);
				}
		}
		const { users: ze } = await Qr.getMultipleUsersInfoById([...oe.keys()]),
			je = dx(ze, (it) => it.id),
			pt = [...oe.entries()].map(([it, ct]) => ({
				...(je[it] ?? { id: it, name: "Player" }),
				painted: ct,
			}));
		return (
			pt.sort(
				(it, ct) => ct.painted.latitudes.length - it.painted.latitudes.length
			),
			pt
		);
	}
	function s(H) {
		for (const fe of H) B(fe.painted);
		se(z, void 0);
	}
	function B(H) {
		for (let fe = 0; fe < H.latitudes.length; fe++)
			a.crosshair.place([H.latitudes[fe], H.longitudes[fe]]);
		aa.plop.play();
	}
	var O = er(),
		X = Ct(O);
	{
		var K = (H) => {
				ol(H, {
					class: "bg-warning",
					children: (fe, ge) => {
						var Ie = P7(),
							Ae = Ct(Ie);
						Gu(Ae, { class: "inline size-5" });
						var De = j(Ae, 2);
						{
							var Ee = ($e) => {
									var Je = wi();
									We((qe) => de(Je, qe), [() => Qv()]), $($e, Je);
								},
								Fe = ($e) => {
									var Je = er(),
										qe = Ct(Je);
									{
										var Ze = (Qe) => {
											var Le = wi();
											We((et) => de(Le, et), [() => e0()]), $(Qe, Le);
										};
										Oe(
											qe,
											(Qe) => {
												p.length === 1 && Qe(Ze);
											},
											!0
										);
									}
									$($e, Je);
								};
							Oe(De, ($e) => {
								p.length === 0 ? $e(Ee) : $e(Fe, !1);
							});
						}
						$(fe, Ie);
					},
					$$slots: { default: !0 },
				});
			},
			ne = (H) => {
				const fe = ft(() => x(y).filter((Ue) => Ue.id !== 0));
				var ge = R7(),
					Ie = A(ge),
					Ae = A(Ie),
					De = A(Ae),
					Ee = A(De);
				Ee.__click = [I7, s, y];
				var Fe = A(Ee);
				Gu(Fe, { class: "size-4" }), k(Ee);
				var $e = j(Ee, 4),
					Je = A($e);
				k($e), k(De);
				var qe = j(De, 2);
				qe.__click = function (...Ue) {
					var ke;
					(ke = a.onclose) == null || ke.apply(this, Ue);
				};
				var Ze = A(qe);
				_l(Ze, { class: "size-4" }), k(qe), k(Ae);
				var Qe = j(Ae, 2),
					Le = A(Qe);
				{
					var et = (Ue) => {
							var ke = M7();
							$(Ue, ke);
						},
						nt = (Ue) => {
							var ke = er(),
								vt = Ct(ke);
							{
								var ee = (he) => {
										var oe = k7();
										$(he, oe);
									},
									re = (he) => {
										var oe = D7(),
											ze = A(oe),
											je = A(ze),
											pt = A(je),
											it = j(A(pt)),
											ct = j(A(it));
										ct.__click = [A7, fe];
										var It = A(ct);
										Rm(It, { class: "size-3" }),
											k(ct),
											k(it),
											yn(),
											k(pt),
											k(je);
										var Dt = j(je);
										hi(
											Dt,
											23,
											() => x(fe),
											(at) => at.id,
											(at, dt, yt) => {
												var xt = L7();
												let St;
												xt.__click = [E7, a, B, dt, z];
												var wt = A(xt),
													_t = A(wt, !0);
												k(wt);
												var Lt = j(wt),
													Rt = A(Lt);
												co(Rt, {
													class: "size-5 border-0",
													get userId() {
														return x(dt).id;
													},
													get pictureUrl() {
														return x(dt).picture;
													},
												});
												var $t = j(Rt, 2),
													tr = A($t),
													Qt = A(tr),
													Ot = A(Qt, !0);
												k(Qt);
												var Nt = j(Qt, 2),
													or = A(Nt);
												k(Nt), k(tr);
												var cr = j(tr, 2);
												{
													var Vr = (_r) => {
														var Ir = z7(),
															qr = A(Ir, !0);
														k(Ir),
															We(
																(ue, V) => {
																	zr(
																		Ir,
																		1,
																		`badge badge-sm ml-0.5 border-0 ${
																			ue ?? ""
																		} ${V ?? ""}`
																	),
																		de(qr, x(dt).allianceName);
																},
																[
																	() => pp(x(dt).allianceId),
																	() => Oi(x(dt).allianceId),
																]
															),
															$(_r, Ir);
													};
													Oe(cr, (_r) => {
														x(dt).allianceId && _r(Vr);
													});
												}
												k($t), k(Lt);
												var mr = j(Lt),
													hr = A(mr, !0);
												k(mr),
													k(xt),
													We(
														(_r, Ir, qr) => {
															(St = zr(
																xt,
																1,
																"hover:bg-base-200 cursor-pointer",
																null,
																St,
																_r
															)),
																de(_t, x(yt) + 1),
																zr(
																	tr,
																	1,
																	`font-medium ${Ir ?? ""} flex gap-1.5`
																),
																de(Ot, x(dt).name),
																de(or, `#${x(dt).id ?? ""}`),
																de(hr, qr);
														},
														[
															() => ({ "!bg-base-300": x(dt).id === x(z) }),
															() => Oi(x(dt).id),
															() =>
																x(dt).painted.latitudes.length.toLocaleString(),
														]
													),
													$(at, xt);
											}
										),
											k(Dt),
											k(ze),
											k(oe),
											$(he, oe);
									};
								Oe(
									vt,
									(he) => {
										x(fe).length === 0 ? he(ee) : he(re, !1);
									},
									!0
								);
							}
							$(Ue, ke);
						};
					Oe(Le, (Ue) => {
						x(M) ? Ue(et) : Ue(nt, !1);
					});
				}
				k(Qe),
					k(Ie),
					k(ge),
					We(
						(Ue) => de(Je, `(Pixels: ${Ue ?? ""})`),
						[() => x(y).reduce((Ue, ke) => Ue + ke.painted.latitudes.length, 0)]
					),
					Ai(
						3,
						ge,
						() => Hd,
						() => ({ duration: 100 })
					),
					$(H, ge);
			};
		Oe(X, (H) => {
			p.length < 2 ? H(K) : H(ne, !1);
		});
	}
	$(m, O), Dr();
}
$n(["click"]);
function F7(m) {
	var y;
	const a = document.createElement("div");
	(y = m.parentElement) == null || y.insertBefore(a, m.nextSibling);
	const p = new IntersectionObserver(
		(M) => {
			M[0].isIntersecting
				? m.classList.remove("stuck")
				: m.classList.add("stuck");
		},
		{ threshold: 0, rootMargin: "0px" }
	);
	return (
		p.observe(a),
		() => {
			a.remove(), p.disconnect();
		}
	);
}
var Im;
((m) => {
	function a() {
		let p, y;
		return {
			promise: new Promise((z, T) => {
				(p = z), (y = T);
			}),
			resolve: p,
			reject: y,
		};
	}
	m.withResolvers = a;
})(Im || (Im = {}));
var O7 = Pr(
		'<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Z"></path></svg>'
	),
	N7 = Pr(
		'<svg><path d="M200-120v-680h360l16 80h224v400H520l-16-80H280v280h-80Zm300-440Zm86 160h134v-240H510l-16-80H280v240h290l16 80Z"></path></svg>'
	);
function j7(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy", "filled"]);
	var y = er(),
		M = Ct(y);
	{
		var z = (s) => {
				var B = O7();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			},
			T = (s) => {
				var B = N7();
				ar(B, () => ({
					xmlns: "http://www.w3.org/2000/svg",
					viewBox: "0 -960 960 960",
					fill: "currentColor",
					...p,
				})),
					$(s, B);
			};
		Oe(M, (s) => {
			a.filled ? s(z) : s(T, !1);
		});
	}
	$(m, y);
}
var V7 = Te("<p><!></p>"),
	q7 = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	Z7 = Te(
		'<button class="btn btn-lg sm:btn-md btn-primary relative h-10"><!> <!> <span class="text-sm">Droplets</span></button>'
	),
	U7 = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	$7 = Te('<!> <span class="text-sm"> </span>', 1),
	G7 = Te('<span class="text-sm"> </span>'),
	H7 = Te(
		'<button><div class="tooltip-content max-w-54 p-2"> </div> <!> <!></button>'
	),
	W7 = Te(
		'<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="font-flag flex grow items-center justify-center p-1 text-7xl"> </div> <h3 class="mt-2 text-center text-xl font-bold"> <!></h3> <!> <div><!></div></div>'
	),
	X7 = (m, a) => {
		se(a, !x(a));
	},
	Y7 = Te(
		'<div><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium">Flags</h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="grid-cols mt-3 grid gap-3 sm:grid-cols-2 lg:grid-cols-4"></div> <div class="mt-4 flex justify-center"><button class="btn btn-lg"> </button></div></div>'
	);
function K7(m, a) {
	Lr(a, !0);
	const p = (Fe, $e = pa, Je = pa) => {
			const qe = ft(() => {
					var ct;
					return (
						(((ct = Mt.data) == null ? void 0 : ct.droplets) ?? 0) >= s.price
					);
				}),
				Ze = ft(() => x(O) === $e().id),
				Qe = ft(() => y.has($e().id));
			var Le = W7(),
				et = A(Le),
				nt = A(et, !0);
			k(et);
			var Ue = j(et, 2),
				ke = A(Ue),
				vt = j(ke);
			{
				var ee = (ct) => {
					var It = V7(),
						Dt = A(It);
					Uu(Dt, { class: "text-base-content/60 size-4.5 inline pb-0.5" }),
						k(It),
						We(
							(at) => {
								zr(
									It,
									1,
									Yo({
										"tooltip inline": !0,
										"lg:before:-translate-x-1/3": (Je() + 1) % 4 === 0,
										"lg:before:translate-x-1/3": Je() % 4 === 0,
										"before:-translate-x-1/3": (Je() + 1) % 2 === 0,
										"before:translate-x-1/3": Je() % 2 === 0,
									})
								),
									Tr(It, "data-tip", at);
							},
							[() => lI()]
						),
						$(ct, It);
				};
				Oe(vt, (ct) => {
					x(Qe) && ct(ee);
				});
			}
			k(Ue);
			var re = j(Ue, 2);
			{
				var he = (ct) => {
					Xm(ct, {});
				};
				Oe(re, (ct) => {
					$e().id === x(X) && ct(he);
				});
			}
			var oe = j(re, 2);
			let ze;
			var je = A(oe);
			{
				var pt = (ct) => {
						var It = Z7();
						It.__click = async () => {
							if (!(x(Qe) && !(await a.promptUserConfirmation($e().name))))
								try {
									const xt = $e().id;
									se(O, xt, !0),
										await Qr.purchase({ id: T, amount: 1, variant: xt }),
										Mt.refresh(),
										aa.notification1.play();
									const St = z.find((wt) => wt.id === xt);
									St && (St.owned = !0), se(X, xt, !0);
								} catch (xt) {
									Fr.error(xt.message);
								} finally {
									se(O, void 0);
								}
						};
						var Dt = A(It);
						{
							var at = (xt) => {
								var St = q7();
								$(xt, St);
							};
							Oe(Dt, (xt) => {
								x(Ze) && xt(at);
							});
						}
						var dt = j(Dt, 2);
						fp(dt, { class: "size-4" });
						var yt = j(dt);
						yn(),
							k(It),
							We(
								(xt) => {
									(It.disabled = !x(qe) || x(Ze)), de(yt, ` ${xt ?? ""} `);
								},
								[() => s.price.toLocaleString("en-US")]
							),
							$(ct, It);
					},
					it = (ct) => {
						const It = ft(() => {
							var Rt;
							return (
								((Rt = Mt.data) == null ? void 0 : Rt.equippedFlag) === $e().id
							);
						});
						var Dt = H7();
						let at;
						Dt.__click = async () => {
							try {
								se(O, $e().id, !0);
								const Rt = x(It) ? 0 : $e().id;
								await Qr.equipFlag(Rt),
									Mt.data && (Mt.data.equippedFlag = Rt),
									Mt.refresh();
							} catch (Rt) {
								Fr.error(Rt.message);
							} finally {
								se(O, void 0);
							}
						};
						var dt = A(Dt),
							yt = A(dt, !0);
						k(dt);
						var xt = j(dt, 2);
						{
							var St = (Rt) => {
								var $t = U7();
								$(Rt, $t);
							};
							Oe(xt, (Rt) => {
								x(Ze) && Rt(St);
							});
						}
						var wt = j(xt, 2);
						{
							var _t = (Rt) => {
									var $t = $7(),
										tr = Ct($t);
									_l(tr, { class: "size-4" });
									var Qt = j(tr, 2),
										Ot = A(Qt, !0);
									k(Qt), We((Nt) => de(Ot, Nt), [() => Mw()]), $(Rt, $t);
								},
								Lt = (Rt) => {
									var $t = G7(),
										tr = A($t, !0);
									k($t), We((Qt) => de(tr, Qt), [() => Ew()]), $(Rt, $t);
								};
							Oe(wt, (Rt) => {
								x(It) ? Rt(_t) : Rt(Lt, !1);
							});
						}
						k(Dt),
							We(
								(Rt, $t) => {
									(at = zr(
										Dt,
										1,
										"btn btn-lg sm:btn-md tooltip tooltip-bottom relative h-10",
										null,
										at,
										Rt
									)),
										(Dt.disabled = x(Ze)),
										de(yt, $t);
								},
								[() => ({ "btn-warning": x(It) }), () => Sw()]
							),
							$(ct, Dt);
					};
				Oe(je, (ct) => {
					$e().owned ? ct(it, !1) : ct(pt);
				});
			}
			k(oe),
				k(Le),
				We(
					(ct, It) => {
						de(nt, $e().flag),
							de(ke, `${$e().name ?? ""} `),
							(ze = zr(oe, 1, "mt-3", null, ze, ct)),
							Tr(oe, "data-tip", It);
					},
					[() => ({ tooltip: !x(qe) }), () => gp()]
				),
				$(Fe, Le);
		},
		y = new Set([
			8, 30, 32, 84, 96, 125, 143, 146, 150, 192, 200, 236, 240, 251,
		]),
		M = Wi.countries.map((Fe) => ({ ...Fe, owned: Mt.flagsBitmap.get(Fe.id) }));
	M.sort((Fe, $e) => Number($e.owned) - Number(Fe.owned));
	const z = bi(M),
		T = 110,
		s = Wi.products[T];
	let B = st(!1),
		O = st(void 0),
		X = st(void 0);
	var K = Y7(),
		ne = A(K),
		H = A(ne);
	j7(H, { class: "size-5.5", filled: !0 }), yn(2), k(ne);
	var fe = j(ne, 2),
		ge = A(fe, !0);
	k(fe);
	var Ie = j(fe, 2);
	hi(
		Ie,
		23,
		() => z,
		(Fe) => Fe.id,
		(Fe, $e, Je) => {
			var qe = er(),
				Ze = Ct(qe);
			{
				var Qe = (Le) => {
					p(
						Le,
						() => x($e),
						() => x(Je)
					);
				};
				Oe(Ze, (Le) => {
					(x(Je) < 8 || x(B)) && Le(Qe);
				});
			}
			$(Fe, qe);
		}
	),
		k(Ie);
	var Ae = j(Ie, 2),
		De = A(Ae);
	De.__click = [X7, B];
	var Ee = A(De, !0);
	k(De),
		k(Ae),
		k(K),
		We(
			(Fe) => {
				de(ge, Fe), de(Ee, x(B) ? "Show less" : "Show more");
			},
			[() => ww()]
		),
		$(m, K),
		Dr();
}
$n(["click"]);
var J7 = Te('<p class="mt-1 text-center text-sm"> </p>'),
	Q7 = (m, a) => {
		kv(a, -1);
	},
	e9 = (m, a) => {
		kv(a);
	},
	t9 = (m, a, p) => {
		a(x(p));
	},
	r9 = Te(
		'<button class="text-base-content/80 absolute left-full top-1/2 ml-2 size-10 -translate-y-1/2 rounded-full text-[10px] font-bold">MAX</button>'
	),
	n9 = async (m, a, p, y) => {
		try {
			se(a, !0),
				await Qr.purchase({ id: p.productId, amount: y() }),
				aa.notification1.play(),
				p.onpurchasecompleted(y());
		} catch (M) {
			Fr.error(M.message);
		} finally {
			se(a, !1);
		}
	},
	i9 = Te(
		'<span class="loading loading-spinner center-absolute absolute"></span>'
	),
	a9 = Te(
		'<div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><!></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <!> <div class="relative mt-4 flex justify-center gap-3"><button class="btn btn-circle">-</button> <input class="input number-input max-w-16 text-center font-bold opacity-80" type="number" min="1"/> <button class="btn btn-circle">+</button> <!></div> <div><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <!> <span class="text-sm">Droplets</span></button></div></div>'
	);
function Sv(m, a) {
	Lr(a, !0);
	let p = zt(a, "amount", 15, 1);
	const y = ft(() => p() * a.unitPrice),
		M = ft(() => Math.floor(a.userDroplets / a.unitPrice));
	let z = st(!1);
	Wr(() => {
		p() < 0 && p(0);
	});
	var T = a9(),
		s = A(T),
		B = A(s);
	oi(B, () => a.icon ?? pa), k(s);
	var O = j(s, 2),
		X = A(O, !0);
	k(O);
	var K = j(O, 2);
	{
		var ne = (Le) => {
			var et = J7(),
				nt = A(et, !0);
			k(et), We(() => de(nt, a.subtitle)), $(Le, et);
		};
		Oe(K, (Le) => {
			a.subtitle && Le(ne);
		});
	}
	var H = j(K, 2),
		fe = A(H);
	fe.__click = [Q7, p];
	var ge = j(fe, 2);
	Ka(ge);
	var Ie = j(ge, 2);
	Ie.__click = [e9, p];
	var Ae = j(Ie, 2);
	{
		var De = (Le) => {
			var et = r9();
			(et.__click = [t9, p, M]), $(Le, et);
		};
		Oe(Ae, (Le) => {
			p() < x(M) && Le(De);
		});
	}
	k(H);
	var Ee = j(H, 2);
	let Fe;
	var $e = A(Ee);
	$e.__click = [n9, z, a, p];
	var Je = A($e);
	{
		var qe = (Le) => {
			var et = i9();
			$(Le, et);
		};
		Oe(Je, (Le) => {
			x(z) && Le(qe);
		});
	}
	var Ze = j(Je, 2);
	fp(Ze, { class: "size-4" });
	var Qe = j(Ze);
	yn(),
		k($e),
		k(Ee),
		k(T),
		We(
			(Le, et, nt, Ue) => {
				de(X, Le),
					(Ie.disabled = p() >= x(M)),
					Tr(Ee, "data-tip", et),
					(Fe = zr(Ee, 1, "", null, Fe, nt)),
					($e.disabled = a.userDroplets < x(y) || x(z) || !p()),
					de(Qe, ` ${Ue ?? ""} `);
			},
			[
				() => a.title(p()),
				() => gp(),
				() => ({ tooltip: a.userDroplets < x(y) }),
				() => x(y).toLocaleString("en-US"),
			]
		),
		dp(ge, p),
		$(m, T),
		Dr();
}
$n(["click"]);
var o9 = Pr(
	'<svg><path d="M346-140 100-386q-10-10-15-22t-5-25q0-13 5-25t15-22l230-229-106-106 62-65 400 400q10 10 14.5 22t4.5 25q0 13-4.5 25T686-386L440-140q-10 10-22 15t-25 5q-13 0-25-5t-22-15Zm47-506L179-432h428L393-646Zm399 526q-36 0-61-25.5T706-208q0-27 13.5-51t30.5-47l42-54 44 54q16 23 30 47t14 51q0 37-26 62.5T792-120Z"></path></svg>'
);
function s9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = o9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var l9 = Pr(
	'<svg><path d="M280-80q-33 0-56.5-23.5T200-160q0-33 23.5-56.5T280-240q33 0 56.5 23.5T360-160q0 33-23.5 56.5T280-80Zm400 0q-33 0-56.5-23.5T600-160q0-33 23.5-56.5T680-240q33 0 56.5 23.5T760-160q0 33-23.5 56.5T680-80ZM246-720l96 200h280l110-200H246Zm-38-80h590q23 0 35 20.5t1 41.5L692-482q-11 20-29.5 31T622-440H324l-44 80h480v80H280q-45 0-68-39.5t-2-78.5l54-98-144-304H40v-80h130l38 80Zm134 280h280-280Z"></path></svg>'
);
function Y0(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = l9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var c9 = Pr(
	'<svg><path d="m700-300-57-56 84-84H120v-80h607l-83-84 57-56 179 180-180 180Z"></path></svg>'
);
function u9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = c9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var h9 = Pr(
	'<svg><path d="M280-160v-80h400v80H280Zm160-160v-327L336-544l-56-56 200-200 200 200-56 56-104-103v327h-80Z"></path></svg>'
);
function d9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = h9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var p9 = Te(
		'<div><section class="not-stuck:border-transparent stuck:border-base-content/10 bg-base-100/70 sticky top-0 z-10 border-b px-6 pb-4 pt-6 backdrop-blur-sm"><div class="relative flex items-center gap-1"><!> <h3 class="text-3xl font-bold"> </h3> <div class="ml-auto mr-4"><!></div> <form method="dialog" class="absolute -right-4 -top-4"><button class="btn btn-sm btn-circle btn-ghost">✕</button></form></div></section> <div class="flex flex-col gap-6 px-6 pb-6"><section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <p class="text-base-content/80 text-sm"> </p> <div class="mt-3 grid gap-3 sm:grid-cols-2"><!> <!></div></section> <section><div class="text-primary flex items-center gap-1"><!> <h3 class="text-xl font-medium"> </h3></div> <div class="mt-3"><div class="bg-base-300 flex flex-col items-center justify-center rounded-xl p-6"><div class="flex grow items-center justify-center"><div class="relative flex size-52 items-center justify-center"><div class="scale-[3]"><!></div></div></div> <p class="mt-2 text-center text-2xl font-bold sm:text-3xl"> </p> <p class="mt-1 text-center text-sm"> </p> <div><a href="/profile-picture"><button class="btn btn-xl btn-primary relative mt-3 h-10"><!> <span class="text-sm">Droplets</span></button></a></div></div></div></section> <section><!></section></div></div>'
	),
	f9 = Te('<span class="center-absolute absolute"><!></span>'),
	m9 = (m, a, p) => {
		var y;
		(y = x(a)) == null || y.resolve(!1), x(p).close();
	},
	_9 = (m, a, p) => {
		var y;
		(y = x(a)) == null || y.resolve(!0), x(p).close();
	},
	g9 = Te(
		'<dialog class="modal"><div class="modal-box max-h-11/12 w-11/12 max-w-4xl p-0"><!></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><div class="flex flex-col items-center gap-6 px-4"><h2 class="text-lg font-semibold"> </h2> <div class="flex items-center gap-2 text-3xl sm:text-5xl"><span class="text-base-content/80 flex items-center gap-2"> <span class="text-primary text-3xl font-semibold max-sm:hidden"> </span></span> <span><!></span> <span class="text-primary flex font-bold"> </span></div> <form method="dialog"><button class="btn btn-primary btn-lg relative"> <!></button></form></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog> <dialog class="modal"><div class="modal-box w-max overflow-hidden"><h3 class="mb-2 text-lg font-bold"> </h3> <p class="text-sm opacity-80"><!></p> <div class="mt-5 flex justify-end gap-2"><button class="btn btn-ghost"> </button> <button class="btn btn-primary"> </button></div></div> <form method="dialog" class="modal-backdrop"><button> </button></form></dialog>',
		1
	);
function v9(m, a) {
	Lr(a, !0);
	let p = zt(a, "open", 15),
		y = st(null),
		M = st(bi({ name: Kg(), prev: 1e3, new: 1e5 }));
	Fn(() => {
		const Ot = (Nt) => {
			Nt.key === "Escape" && p(!1);
		};
		return (
			document.addEventListener("keydown", Ot),
			() => document.removeEventListener("keydown", Ot)
		);
	});
	const z = { id: 70, product: Wi.products[70] },
		T = { id: 80, product: Wi.products[80] },
		s = { product: Wi.products[120] };
	let B = st(null),
		O = st(null),
		X = st("");
	async function K(Ot) {
		return (
			x(B).showModal(),
			se(O, Im.withResolvers(), !0),
			se(X, Ot, !0),
			x(O).promise
		);
	}
	var ne = g9(),
		H = Ct(ne),
		fe = A(H),
		ge = A(fe);
	{
		var Ie = (Ot) => {
			var Nt = p9(),
				or = A(Nt),
				cr = A(or),
				Vr = A(cr);
			Y0(Vr, { class: "size-8" });
			var mr = j(Vr, 2),
				hr = A(mr, !0);
			k(mr);
			var _r = j(mr, 2),
				Ir = A(_r);
			{
				let Jt = ft(() => {
					var Cr;
					return ((Cr = Mt.data) == null ? void 0 : Cr.droplets) ?? 0;
				});
				Fv(Ir, {
					get value() {
						return x(Jt);
					},
				});
			}
			k(_r), yn(2), k(cr), k(or), Ni(or, () => F7);
			var qr = j(or, 2),
				ue = A(qr),
				V = A(ue),
				U = A(V);
			s9(U, { class: "size-5.5", filled: !0 });
			var Y = j(U, 2),
				ie = A(Y, !0);
			k(Y), k(V);
			var pe = j(V, 2),
				Se = A(pe, !0);
			k(pe);
			var Me = j(pe, 2),
				we = A(Me);
			{
				const Jt = (Er) => {
					d9(Er, { class: "text-primary size-26" });
				};
				let Cr = ft(() => I2());
				Sv(we, {
					get productId() {
						return z.id;
					},
					title: (Er) => C2({ amount: z.product.items[0].amount * Er }),
					get subtitle() {
						return x(Cr);
					},
					get unitPrice() {
						return z.product.price;
					},
					get userDroplets() {
						return Mt.data.droplets;
					},
					onpurchasecompleted: async (Er) => {
						var pn, gn, ln, En;
						const ur =
							(gn = (pn = Mt.data) == null ? void 0 : pn.charges) == null
								? void 0
								: gn.max;
						await Mt.refresh();
						const rn =
							(En = (ln = Mt.data) == null ? void 0 : ln.charges) == null
								? void 0
								: En.max;
						ur !== void 0 &&
							rn !== void 0 &&
							(se(M, { name: Kg(), prev: ur, new: rn }, !0), x(y).show());
					},
					icon: Jt,
					$$slots: { icon: !0 },
				});
			}
			var Ve = j(we, 2);
			{
				const Jt = (Er) => {
					$0(Er, { class: "text-primary my-3 size-20" });
				};
				let Cr = ft(() => m2());
				Sv(Ve, {
					get productId() {
						return T.id;
					},
					title: (Er) => f3({ amount: T.product.items[0].amount * Er }),
					get subtitle() {
						return x(Cr);
					},
					get unitPrice() {
						return T.product.price;
					},
					get userDroplets() {
						return Mt.data.droplets;
					},
					onpurchasecompleted: async (Er) => {
						var rn, pn, gn;
						const ur =
							(pn = (rn = Mt.data) == null ? void 0 : rn.charges) == null
								? void 0
								: pn.count;
						await Mt.refresh(),
							ur !== void 0 &&
								(se(
									M,
									{
										name: h3(),
										prev: Math.floor(ur),
										new: Math.floor(ur + T.product.items[0].amount * Er),
									},
									!0
								),
								(gn = x(y)) == null || gn.show());
					},
					icon: Jt,
					$$slots: { icon: !0 },
				});
			}
			k(Me), k(ue);
			var ut = j(ue, 2),
				Ke = A(ut),
				kt = A(Ke);
			yp(kt, { class: "size-5.5", filled: !0 });
			var ye = j(kt, 2),
				Bt = A(ye, !0);
			k(ye), k(Ke);
			var rr = j(Ke, 2),
				Kt = A(rr),
				gr = A(Kt),
				Ur = A(gr),
				nn = A(Ur),
				mn = A(nn);
			Ov(mn, {
				get userId() {
					return Mt.data.id;
				},
				get level() {
					return Mt.data.level;
				},
				get pictureUrl() {
					return Mt.data.picture;
				},
			}),
				k(nn),
				k(Ur),
				k(gr);
			var _n = j(gr, 2),
				Vt = A(_n, !0);
			k(_n);
			var Et = j(_n, 2),
				dr = A(Et, !0);
			k(Et);
			var ht = j(Et, 2);
			let Xr;
			var Yr = A(ht),
				Zr = A(Yr),
				mt = A(Zr);
			fp(mt, { class: "size-4" });
			var He = j(mt);
			yn(), k(Zr), k(Yr), k(ht), k(Kt), k(rr), k(ut);
			var At = j(ut, 2),
				Ft = A(At);
			K7(Ft, { promptUserConfirmation: K }),
				k(At),
				k(qr),
				k(Nt),
				We(
					(Jt, Cr, Er, ur, rn, pn, gn, ln, En) => {
						de(hr, Jt),
							de(ie, Cr),
							de(Se, Er),
							de(Bt, ur),
							de(Vt, rn),
							de(dr, pn),
							Tr(ht, "data-tip", gn),
							(Xr = zr(ht, 1, "", null, Xr, ln)),
							(Zr.disabled = Mt.data.droplets < s.product.price),
							de(He, ` ${En ?? ""} `);
					},
					[
						() => Zv(),
						() => v2(),
						() => b2(),
						() => yw(),
						() => A2(),
						() => L2(),
						() => gp(),
						() => ({ tooltip: Mt.data.droplets < s.product.price }),
						() => s.product.price.toLocaleString("en-US"),
					]
				),
				Ai(2, Nt, () => ia),
				$(Ot, Nt);
		};
		Oe(ge, (Ot) => {
			Mt.data && p() && Ot(Ie);
		});
	}
	k(fe);
	var Ae = j(fe, 2),
		De = A(Ae),
		Ee = A(De, !0);
	k(De),
		k(Ae),
		k(H),
		Ni(H, () => (Ot) => {
			Wr(() => {
				p() ? Ot.show() : Ot.close();
			});
		});
	var Fe = j(H, 2),
		$e = A(Fe),
		Je = A($e),
		qe = A(Je),
		Ze = A(qe, !0);
	k(qe);
	var Qe = j(qe, 2),
		Le = A(Qe),
		et = A(Le),
		nt = j(et),
		Ue = A(nt);
	k(nt), k(Le);
	var ke = j(Le, 2),
		vt = A(ke);
	u9(vt, { class: "size-5" }), k(ke);
	var ee = j(ke, 2),
		re = A(ee, !0);
	k(ee), k(Qe);
	var he = j(Qe, 2),
		oe = A(he),
		ze = A(oe),
		je = j(ze);
	ju(
		je,
		() => x(M).new,
		(Ot) => {
			var Nt = f9(),
				or = A(Nt);
			Xm(or, {}), k(Nt), $(Ot, Nt);
		}
	),
		k(oe),
		k(he),
		k(Je),
		k($e);
	var pt = j($e, 2),
		it = A(pt),
		ct = A(it, !0);
	k(it),
		k(pt),
		k(Fe),
		Ko(
			Fe,
			(Ot) => se(y, Ot),
			() => x(y)
		);
	var It = j(Fe, 2),
		Dt = A(It),
		at = A(Dt),
		dt = A(at, !0);
	k(at);
	var yt = j(at, 2),
		xt = A(yt);
	Am(xt, () => fI({ country: x(X) })), k(yt);
	var St = j(yt, 2),
		wt = A(St);
	wt.__click = [m9, O, B];
	var _t = A(wt, !0);
	k(wt);
	var Lt = j(wt, 2);
	Lt.__click = [_9, O, B];
	var Rt = A(Lt, !0);
	k(Lt), k(St), k(Dt);
	var $t = j(Dt, 2),
		tr = A($t),
		Qt = A(tr, !0);
	k(tr),
		k($t),
		k(It),
		Ko(
			It,
			(Ot) => se(B, Ot),
			() => x(B)
		),
		We(
			(Ot, Nt, or, cr, Vr, mr, hr) => {
				de(Ee, Ot),
					de(Ze, x(M).name),
					de(et, `${x(M).prev ?? ""} `),
					de(Ue, `(+${x(M).new - x(M).prev})`),
					de(re, x(M).new),
					de(ze, `${Nt ?? ""} `),
					de(ct, or),
					de(dt, cr),
					de(_t, Vr),
					de(Rt, mr),
					de(Qt, hr);
			},
			[
				() => Ss(),
				() => Ss(),
				() => Ss(),
				() => hI(),
				() => Ah(),
				() => qv(),
				() => Ss(),
			]
		),
		di("close", H, () => p(!1)),
		$(m, ne),
		Dr();
}
$n(["click"]);
var y9 = Pr(
	'<svg><path d="M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z"></path></svg>'
);
function x9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = y9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var b9 = Pr(
	'<svg><path d="M480-680q-33 0-56.5-23.5T400-760q0-33 23.5-56.5T480-840q33 0 56.5 23.5T560-760q0 33-23.5 56.5T480-680Zm-60 560v-480h120v480H420Z"></path></svg>'
);
function w9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = b9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var T9 = Pr(
	'<svg><path d="M440-40v-80q-125-14-214.5-103.5T122-438H42v-80h80q14-125 103.5-214.5T440-836v-80h80v80q125 14 214.5 103.5T838-518h80v80h-80q-14 125-103.5 214.5T520-120v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"></path></svg>'
);
function C9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = T9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var S9 = Pr(
	'<svg><path d="M440-42v-80q-125-14-214.5-103.5T122-440H42v-80h80q14-125 103.5-214.5T440-838v-80h80v80q125 14 214.5 103.5T838-520h80v80h-80q-14 125-103.5 214.5T520-122v80h-80Zm40-158q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Zm0-120q-66 0-113-47t-47-113q0-66 47-113t113-47q66 0 113 47t47 113q0 66-47 113t-113 47Z"></path></svg>'
);
function P9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = S9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var I9 = Pr(
	'<svg><path d="M380-720v-98L142-580h98v60H40v-200h60v98l238-238h-98v-60h200v200h-60ZM593-40q-24 0-46-9t-39-26L304-280l30-31q16-16 37.5-21.5t42.5.5l66 19v-327q0-17 11.5-28.5T520-680q17 0 28.5 11.5T560-640v433l-97-27 102 102q5 5 12.5 8.5T593-120h167q33 0 56.5-23.5T840-200v-160q0-17 11.5-28.5T880-400q17 0 28.5 11.5T920-360v160q0 66-47 113T760-40H593Zm7-280v-160q0-17 11.5-28.5T640-520q17 0 28.5 11.5T680-480v160h-80Zm120 0v-120q0-17 11.5-28.5T760-480q17 0 28.5 11.5T800-440v120h-80Zm-20 80Z"></path></svg>'
);
function M9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = I9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var k9 = Pr(
	'<svg><path d="M280-200v-80h284q63 0 109.5-40T720-420q0-60-46.5-100T564-560H312l104 104-56 56-200-200 200-200 56 56-104 104h252q97 0 166.5 63T800-420q0 94-69.5 157T564-200H280Z"></path></svg>'
);
function A9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = k9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
var E9 = Pr(
	'<svg><path d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"></path></svg>'
);
function z9(m, a) {
	let p = nr(a, ["$$slots", "$$events", "$$legacy"]);
	var y = E9();
	ar(y, () => ({
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 -960 960 960",
		fill: "currentColor",
		...p,
	})),
		$(m, y);
}
function Gf(m) {
	const a = document.createElement("img");
	return (
		(a.src = m),
		new Promise((p, y) => {
			a.addEventListener("load", () => {
				p(a);
			}),
				a.addEventListener("error", (M) => {
					y(M);
				});
		})
	);
}
function L9(m) {
	const a = document.createElement("canvas");
	(a.width = m.naturalWidth), (a.height = m.naturalHeight);
	const p = a.getContext("2d");
	return p == null || p.drawImage(m, 0, 0), a;
}
function D9(m, a, p) {
	return m < a ? a : m > p ? p : m;
}
function R9(m, a) {
	const p = 10 ** a;
	return Math.round(m * p) / p;
}
var B9 = Te(
		'<meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/>',
		1
	),
	F9 = (m, a) => {
		se(a, !x(a));
	},
	O9 = Te("<button><!></button>"),
	N9 = async (m, a, p, y) => {
		var M;
		x(a) ||
			se(
				a,
				await new Promise((z, T) => {
					navigator.geolocation.getCurrentPosition(
						(s) => {
							z(s);
						},
						(s) => {
							T(s);
						}
					);
				})
			),
			x(a) &&
				(Co({ lat: x(a).coords.latitude, lng: x(a).coords.longitude }, x(p)),
				(M = x(y)) == null ||
					M.flyTo({
						center: { lat: x(a).coords.latitude, lng: x(a).coords.longitude },
						zoom: 16.5,
					}));
	},
	j9 = Te(
		'<div class="relative"><!> <span class="center-absolute absolute text-[10px] text-red-400">?</span></div>'
	),
	V9 = Te(
		'<button class="btn btn-lg btn-square sm:btn-xl z-30 shadow-md"><!></button>'
	),
	q9 = (m, a, p, y) => {
		var M;
		se(a, !0), x(p) && Co((M = x(p)) == null ? void 0 : M.getCenter(), x(y));
	},
	Z9 = Te('<button class="btn btn-primary shadow-xl"> </button>'),
	U9 = Te(
		'<a class="badge badge-secondary absolute -left-2 top-0 -translate-x-full translate-y-1/2 font-semibold" target="_blank"><!></a>'
	),
	$9 = Te('<div class="relative"><!> <!></div>'),
	G9 = (m, a, p, y) => {
		var z;
		se(a, !0);
		const M = (z = x(p)) == null ? void 0 : z.getCenter();
		M && Co(M, x(y));
	},
	H9 = Te('<button class="btn btn-square shadow-md"><!></button>'),
	W9 = (m, a) => {
		se(a, !0);
	},
	X9 = Te('<button class="btn btn-square relative shadow-md"><!></button>'),
	Y9 = (m, a) => {
		se(a, !0);
	},
	K9 = Te('<button class="btn btn-square relative shadow-md"><!></button>'),
	J9 = Te(
		'<div class="flex flex-col items-center gap-3"><!> <!> <!> <!></div>'
	),
	Q9 = (m, a) => {
		se(a, !x(a));
	},
	eB = Te('<div class="flex flex-col gap-3"><button><!></button></div>'),
	tB = Te(
		'<div class="z-100 absolute bottom-1 left-1/2 -translate-x-1/2"><!></div>'
	),
	rB = (m, a) => {
		se(a, !0);
	},
	nB = Te('<button class="btn btn-sm btn-circle"><!></button>'),
	iB = (m, a) => {
		var p;
		(p = x(a)) == null || p.zoomIn();
	},
	aB = (m, a) => {
		var p;
		(p = x(a)) == null || p.zoomOut();
	},
	oB = (m, a) => {
		se(a, { name: "getPixelAreaInfo" }, !0);
	},
	sB = Te(
		'<button class="btn btn-sm btn-circle" title="Select area"><!></button>'
	),
	lB = Te('<button class="btn btn-sm btn-circle"><!></button>'),
	cB = () => {
		window.location.replace(yi.url.origin);
	},
	uB = Te('<button class="btn btn-sm btn-circle not-pwa:hidden"><!></button>'),
	hB = (m, a) => {
		x(a) && hl.goToPrev(x(a));
	},
	dB = Te('<button class="btn btn-sm btn-circle"><!></button>'),
	pB = Te(
		'<div class="btn btn-sm btn-error w-max cursor-auto text-nowrap text-xs sm:text-base"><!> </div>'
	),
	fB = (m, a, p) => {
		var y;
		(y = x(a)) == null || y.flyTo({ center: x(a).getCenter(), zoom: p });
	},
	mB = Te(
		'<button class="btn sm:btn-lg duration text-nowrap text-xs transition-opacity sm:text-base"><!> </button>'
	),
	_B = Te("<span></span>"),
	gB = Te(
		'<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-lg"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><!></div></div>'
	),
	vB = Te(
		'<div class="absolute bottom-0 left-0 z-50 w-full"><div class="rounded-t-box bg-base-100 border-base-300 w-full border-t py-3"><!></div></div>'
	),
	yB = Te(
		'<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2 md:max-w-xl"><!></div>'
	),
	xB = (m, a) => {
		se(a, { name: "mainMenu" }, !0);
	},
	bB = Te(
		'<div class="absolute bottom-0 left-0 z-50 w-full sm:left-1/2 sm:max-w-md sm:-translate-x-1/2"><div class="rounded-t-box bg-base-100 border-base-300 sm:rounded-b-box w-full border-t pt-2 sm:mb-3 sm:shadow-xl"><div class="px-3 pb-2 pt-1"><div class="flex items-center justify-between"><span><!> </span> <button class="btn btn-circle btn-sm"><!></button></div> <div class="mt-1 flex items-center justify-center gap-4"><button class="btn btn-primary w-46"><!></button></div></div></div></div>'
	),
	wB = Te(
		'<div class="disable-pinch-zoom relative h-full overflow-hidden svelte-6wmtgk"><div id="map" class="h-screen w-screen cursor-default"></div> <div><div><!> <!></div></div> <!> <div><!> <div class="flex flex-col gap-1 max-sm:hidden"><button class="btn btn-sm btn-circle">+</button> <button class="btn btn-sm btn-circle">-</button></div> <div class="max-sm:hidden"><a href="https://www.twitch.tv/directory/category/wplace" class="btn btn-sm btn-circle" target="_blank" title="Livestreams"><!></a></div> <!> <!> <!> <!></div> <div><!> <!></div> <div><!></div> <div><!></div> <div><!></div>  <!></div> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>',
		1
	);
function uF(m, a) {
	Lr(a, !0);
	const p = Lf,
		y = px,
		M = new fl(y),
		z = p - 0.4,
		T = v4(yi.url),
		s = T.season ?? Hg,
		B = new Map();
	let O = st(void 0),
		X = st(14.5),
		K = st(!1);
	const ne = ft(() => {
		var bt;
		return ((bt = Mt.data) == null ? void 0 : bt.id) === 401;
	});
	let H = st(!1),
		fe = st(
			bi(
				T.select && T.pos
					? { name: "pixelSelected", latLon: [T.pos.lat, T.pos.lng] }
					: { name: "mainMenu" }
			)
		);
	Fn(() => {
		De().then((Br) => se(O, Br));
		let bt = [0, 0];
		function Xt(Br) {
			var xn;
			if (x(O) && x(X) > p + 1) {
				const { lat: On, lng: Yn } = x(O).unproject([Br.clientX, Br.clientY]),
					Vn = M.latLonToPixels(On, Yn, p),
					wn = Math.floor(Vn[0]),
					Ji = Math.floor(Vn[1]);
				if (bt[0] !== wn || bt[1] !== Ji) {
					const sr = M.latLonToPixelBoundsLatLon(On, Yn, p),
						Ut = Vm(sr, !0);
					(xn = x(O).getSource($e)) == null || xn.setCoordinates(Ut),
						(bt = [wn, Ji]);
				}
			}
		}
		return (
			window.addEventListener("mousemove", Xt),
			() => {
				var Br;
				(Br = x(O)) == null || Br.remove(),
					window.removeEventListener("mousemove", Xt),
					Ae && clearInterval(Ae),
					Hf();
			}
		);
	}),
		dl(
			() => [ai.theme],
			() => {
				if (x(O)) {
					Ie = !1;
					const bt = ge(ai.theme);
					x(O).setStyle(bt);
				}
			}
		);
	function ge(bt) {
		return `/maps/styles/${
			bt === "custom-winter" ? "liberty" : "fiord"
		}`;
	}
	let Ie = !1,
		Ae;
	async function De() {
		const bt = T.pos ? { ...T.pos, zoom: x(X) } : await l4();
		T.zoom !== void 0 && (bt.zoom = T.zoom);
		const Xt = await new Promise((Vn) => {
				const wn = new qd.Map({
					style: ge(ai.theme),
					center: bt,
					zoom: bt.zoom,
					container: "map",
					dragRotate: !1,
					doubleClickZoom: !1,
					pitch: 0,
					maxPitch: 0,
					attributionControl: !1,
				});
				wn.touchZoomRotate.disableRotation(),
					wn.on("styledata", (Ji) => {
						Ie ||
							(ai.theme === "custom-winter" &&
								(wn.setLayoutProperty("poi_transit", "visibility", "none"),
								wn.setLayoutProperty("poi_r20", "visibility", "none"),
								wn.setLayoutProperty("poi_r7", "visibility", "none"),
								wn.setLayoutProperty("poi_r1", "visibility", "none"),
								wn.setLayoutProperty("building", "visibility", "none"),
								wn.setLayoutProperty("building-3d", "visibility", "none"),
								wn.setLayoutProperty("landuse_pitch", "visibility", "none"),
								wn.setLayoutProperty("landuse_hospital", "visibility", "none"),
								wn.setLayoutProperty("landuse_school", "visibility", "none"),
								wn.setLayoutProperty(
									"landuse_residential",
									"visibility",
									"none"
								),
								wn.setLayoutProperty("waterway_tunnel", "visibility", "none"),
								wn.setFilter("water", [
									"all",
									["!=", "brunnel", "tunnel"],
									["!=", "class", "swimming_pool"],
								])),
							Fe(wn),
							Qe(),
							(Ie = !0));
					}),
					wn.on("style.load", () => {
						Vn(wn);
					});
			}),
			Br = Wi.refreshIntervalMs;
		function xn() {
			let Vn = x(X) > p + 1.5 ? Br : 2.5 * Br;
			try {
				document.visibilityState === "visible" && Fe(Xt);
			} finally {
				setTimeout(xn, Vn);
			}
		}
		(Ae = setTimeout(xn, Br)),
			Xt.on("load", () => {
				T.discordLinked &&
					(Fr.success(xS()),
					yi.url.searchParams.delete("discord-linked"),
					km(yi.url.toString()));
			});
		let On = x(X);
		Xt.on("zoom", () => {
			se(X, Xt.getZoom(), !0);
			const Vn = R9(x(X), 1);
			Vn != On && (x(ee) && x(ee).setOpacity(re(On)), (On = Vn));
		});
		let Yn = "default";
		return (
			Xt.on("dragstart", () => {
				const Vn = Xt.getCanvas();
				(Yn = Vn.style.cursor), (Vn.style.cursor = "move");
			}),
			Xt.on("dragend", () => {
				Xt.getCanvas().style.cursor = Yn;
			}),
			Xt.on("mouseout", () => {
				Le();
			}),
			Xt.on("click", async (Vn) => {
				var $r;
				const wn = Vn.lngLat.lat,
					Ji = Vn.lngLat.lng,
					sr = [wn, Ji];
				if (x(fe).name === "paintingPixel" || x(fe).name === "getPixelAreaInfo")
					return;
				if (x(fe).name === "selectHq") {
					(x(fe).hq = sr), ($r = x(he)) == null || $r.clearAndPlace(sr);
					return;
				}
				const Ut = Xt.getZoom();
				if (Ut < z) {
					Fr.info(VS());
					return;
				}
				Co({ lat: wn, lng: Ji }, Ut),
					se(fe, { name: "pixelSelected", latLon: sr }, !0);
			}),
			Xt
		);
	}
	const Ee = "pixel-art-layer";
	function Fe(bt) {
		const Xt = window.innerWidth,
			Br = `${fx}/s${Hg}/tiles/{x}/{y}.png`;
		if ((B.clear(), !bt.style)) return;
		bt.getSource(Ee)
			? bt.refreshTiles(Ee)
			: bt.addSource(Ee, {
					type: "raster",
					tiles: [Br],
					minzoom: p,
					maxzoom: p,
					tileSize: Xt > 640 ? 550 : 400,
			  }),
			bt.getLayer(Ee) ||
				bt.addLayer({
					id: Ee,
					type: "raster",
					source: Ee,
					paint: { "raster-resampling": "nearest", "raster-opacity": x(nt) },
				});
	}
	const $e = "pixel-hover",
		Je = 1e-5,
		qe = [
			[0, 0],
			[Je, 0],
			[Je, -Je],
			[0, -Je],
		],
		Ze = 0.4;
	async function Qe() {
		var bt, Xt, Br, xn;
		if (!((bt = x(O)) != null && bt.getSource($e))) {
			const On = L9(await Gf(o4));
			(Xt = x(O)) == null ||
				Xt.addSource($e, { type: "canvas", canvas: On, coordinates: qe });
		}
		((Br = x(O)) != null && Br.getLayer($e)) ||
			(xn = x(O)) == null ||
			xn.addLayer({
				id: $e,
				type: "raster",
				source: $e,
				paint: { "raster-resampling": "nearest", "raster-opacity": Ze },
			});
	}
	function Le() {
		var bt, Xt;
		(Xt = (bt = x(O)) == null ? void 0 : bt.getSource($e)) == null ||
			Xt.setCoordinates(qe);
	}
	let et = st(bi(T.opaque ?? !0)),
		nt = ft(() => (x(et) ? 1 : 0.1));
	Wr(() => {
		var bt;
		(bt = x(O)) != null &&
			bt.getLayer(Ee) &&
			x(O).setPaintProperty(Ee, "raster-opacity", x(nt));
	});
	let Ue = st(void 0),
		ke = st(void 0),
		vt = st(void 0);
	Fn(
		() => (
			navigator.permissions.query({ name: "geolocation" }).then((bt) => {
				bt.state === "granted" &&
					se(
						vt,
						navigator.geolocation.watchPosition(
							(Xt) => {
								se(Ue, Xt);
							},
							(Xt) => {
								se(ke, Xt);
							},
							{ enableHighAccuracy: !1, maximumAge: 1e3, timeout: 6e3 }
						),
						!0
					);
			}),
			() => {
				x(vt) && navigator.geolocation.clearWatch(x(vt));
			}
		)
	);
	let ee = st(void 0);
	dl(
		() => [x(Ue), x(O)],
		() => {
			var bt, Xt;
			if (x(Ue) && x(O)) {
				const Br = { lat: x(Ue).coords.latitude, lng: x(Ue).coords.longitude },
					xn = re(x(X));
				if (!x(ee)) {
					const On = document.createElement("div");
					On.classList.add("maplibregl-user-location-dot"),
						On.classList.add("cursor-auto"),
						se(
							ee,
							new qd.Marker({ element: On, opacity: xn })
								.setLngLat(Br)
								.addTo(x(O))
						);
				}
				(Xt = (bt = x(ee)) == null ? void 0 : bt.setLngLat(Br)) == null ||
					Xt.setOpacity(xn);
			}
		}
	);
	function re(bt) {
		return bt < p ? "1.0" : D9((bt - p) * 0.2, 0.5, 1).toFixed(2);
	}
	let he = st(void 0);
	Wr(() => {
		var bt;
		x(O) &&
			((bt = ul(() => x(he))) == null || bt.clear(),
			Gf(Jg).then((Xt) => {
				se(
					he,
					new ev({
						id: "select-crosshair",
						map: x(O),
						tileSize: y,
						zoom: p,
						img: Xt,
						markerFn: () => {
							const Br = new qd.Marker({ color: "#0069ff" });
							return Br.addClassName("z-20"), Br;
						},
					})
				);
			}));
	});
	let oe = st(void 0);
	Wr(() => {
		var bt;
		x(O) &&
			((bt = ul(() => x(he))) == null || bt.clear(),
			Gf(Jg).then((Xt) => {
				se(
					oe,
					new ev({
						id: "paint-crosshair",
						map: x(O),
						tileSize: y,
						zoom: p,
						img: Xt,
					})
				);
			}));
	});
	let ze = st(!1),
		je = st(!1),
		pt = st(!1),
		it = st(!!T.newUser),
		ct = st(!1),
		It = st(!!T.alliance),
		Dt = st(!1);
	const at = "void-message-2";
	let dt = st(!1);
	Wr(() => {
		const bt = localStorage.getItem(at);
		Mt.data && !bt && (se(dt, !0), localStorage.setItem(at, "true"));
	});
	let yt = st(!1),
		xt = st(bi(yi.url)),
		St = st(bi({ cityId: 0, countryId: 1, id: 0, name: "None", number: 1 })),
		wt = st(!1);
	const _t = "view-rules";
	let Lt = !1;
	Wr(() => {
		Mt.data &&
			(!Lt &&
				Mt.data.pixelsPainted > 1 &&
				(localStorage.getItem(_t) ||
					(se(wt, !0), localStorage.setItem(_t, "true"))),
			(Lt = !0));
	});
	let Rt = st(!1);
	Wr(() => {
		var bt;
		se(Rt, !!((bt = Mt.data) != null && bt.needsPhoneVerification));
	});
	let $t = st([]),
		tr = ft(() => (x(X) < z ? "1.0" : x(X) < z + 2 ? "0.5" : "0.3"));
	Wr(() => {
		var Xt;
		const bt = (Xt = Mt.data) == null ? void 0 : Xt.favoriteLocations;
		if (bt && x(O)) {
			for (const Br of ul(() => x($t))) Br.remove();
			se(
				$t,
				bt.map((Br) => {
					const xn = document.createElement("div");
					xn.classList.add("text-yellow-400"),
						xn.classList.add("cursor-pointer"),
						xn.classList.add("z-10"),
						(xn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
					<path fill="#000a" d="m183-51 79-338L-1-617l346-29 135-319 135 319 346 29-263 228 79 338-297-180L183-51Z"/>
					<path d="m293-203.08 49.62-212.54-164.93-142.84 217.23-18.85L480-777.69l85.08 200.38 217.23 18.85-164.93 142.84L667-203.08 480-315.92 293-203.08Z"/>
				</svg>`);
					const On = { lat: Br.latitude, lng: Br.longitude };
					return (
						xn.addEventListener("click", (Vn) => {
							Vn.stopPropagation(), Qt([Br.latitude, Br.longitude]);
						}),
						new qd.Marker({ element: xn, opacity: x(tr) })
							.setLngLat(On)
							.addTo(x(O))
					);
				})
			);
		}
	});
	function Qt(bt) {
		var Br;
		const Xt = { lat: bt[0], lng: bt[1] };
		(Br = x(O)) == null || Br.flyTo({ center: Xt, zoom: Math.max(x(X), 15) }),
			Co(Xt, x(X)),
			se(fe, { name: "pixelSelected", latLon: [Xt.lat, Xt.lng] }, !0);
	}
	Wr(() => {
		if (x(fe).name === "paintingPixel")
			for (const bt of x($t)) bt.addClassName("hidden");
		else
			for (const bt of x($t))
				bt.removeClassName("hidden"), bt.setOpacity(x(tr));
	});
	let Ot = Number.MAX_VALUE;
	Wr(() => {
		if (Mt.charges !== void 0 && Mt.data) {
			const bt = Mt.data.charges.max,
				Xt = Mt.charges;
			Ot < bt && Xt >= bt && aa.notification1.play(), (Ot = Mt.charges);
		}
	});
	let Nt = st(!1),
		or = Date.now();
	Fn(() => {
		const bt = g4(),
			Xt = () => {
				var xn;
				if (!document.hidden && Date.now() - or > 30 * gc.min) {
					if (bt) {
						const Yn = (xn = x(O)) == null ? void 0 : xn.getCenter();
						Yn && Co(Yn, x(X)), window.location.replace(yi.url.origin);
					} else Mt.refresh();
					or = Date.now();
				}
			};
		return (
			document.addEventListener("visibilitychange", Xt),
			() => document.removeEventListener("visibilitychange", Xt)
		);
	}),
		Fn(() => {
			function bt() {
				Qr.online = !0;
			}
			window.addEventListener("online", bt);
			function Xt() {
				Qr.online = !1;
			}
			return (
				window.addEventListener("offline", Xt),
				() => {
					window.removeEventListener("online", bt),
						window.removeEventListener("offline", Xt);
				}
			);
		}),
		Wr(() => {
			if (!Qr.online) {
				const bt = setInterval(() => {
					Qr.health().then(() => {
						(Qr.online = !0), !Mt.data && !Mt.loading && Mt.refresh();
					});
				}, 5e3);
				return () => {
					clearInterval(bt);
				};
			}
		}),
		Fn(() => {
			function bt(Xt) {
				Xt.data.type && x(O) && Fe(x(O));
			}
			return (
				navigator.serviceWorker.addEventListener("message", bt),
				() => {
					navigator.serviceWorker.removeEventListener("message", bt);
				}
			);
		});
	let cr = st(!1),
		Vr = st("report-user"),
		mr = st(void 0),
		hr = st(void 0),
		_r = st(void 0),
		Ir = st(0);
	var qr = wB();
	nx((bt) => {
		var Xt = B9();
		(rx.title = "Wplace - Paint the world"), yn(6), $(bt, Xt);
	});
	var ue = Ct(qr);
	{
		const bt = (sr) => {
				var Ut = O9();
				Ut.__click = [F9, et];
				var $r = A(Ut);
				{
					let lr = ft(() => !x(et));
					G0($r, {
						class: "size-5",
						get filled() {
							return x(lr);
						},
					});
				}
				k(Ut),
					We(
						(lr) => {
							Tr(Ut, "title", lr),
								zr(
									Ut,
									1,
									Yo({
										"btn btn-lg btn-square sm:btn-xl z-30 shadow-md": !0,
										"text-base-content/80": x(et),
										"btn-primary btn-soft": !x(et),
									})
								);
						},
						[() => $v()]
					),
					$(sr, Ut);
			},
			Xt = (sr) => {
				var Ut = V9();
				Ut.__click = [N9, Ue, X, O];
				var $r = A(Ut);
				{
					var lr = (an) => {
							P9(an, { class: "size-5.5 fill-blue-800" });
						},
						Tn = (an) => {
							var Cn = j9(),
								Gn = A(Cn);
							C9(Gn, { class: "size-5.5 fill-red-400" }),
								yn(2),
								k(Cn),
								$(an, Cn);
						};
					Oe($r, (an) => {
						x(Ue) ? an(lr) : an(Tn, !1);
					});
				}
				k(Ut), We((an) => Tr(Ut, "title", an), [() => Lb()]), $(sr, Ut);
			};
		var V = j(A(ue), 2);
		let Br;
		var U = A(V);
		let xn;
		var Y = A(U);
		{
			var ie = (sr) => {
					var Ut = Z9();
					Ut.__click = [q9, ze, O, X];
					var $r = A(Ut, !0);
					k(Ut), We((lr) => de($r, lr), [() => Jx()]), $(sr, Ut);
				},
				pe = (sr) => {
					var Ut = er(),
						$r = Ct(Ut);
					{
						var lr = (Tn) => {
							var an = $9(),
								Cn = A(an);
							{
								var Gn = (Mn) => {
									var bn = U9(),
										cn = A(bn);
									{
										var Sn = (vn) => {
												var fn = wi("MOD");
												$(vn, fn);
											},
											kn = (vn) => {
												var fn = er(),
													on = Ct(fn);
												{
													var po = (Hn) => {
															var jn = wi("GM");
															$(Hn, jn);
														},
														fi = (Hn) => {
															var jn = wi("ADMIN");
															$(Hn, jn);
														};
													Oe(
														on,
														(Hn) => {
															var jn;
															((jn = Mt.data) == null ? void 0 : jn.role) ===
															"global_moderator"
																? Hn(po)
																: Hn(fi, !1);
														},
														!0
													);
												}
												$(vn, fn);
											};
										Oe(cn, (vn) => {
											var fn;
											((fn = Mt.data) == null ? void 0 : fn.role) ===
											"moderator"
												? vn(Sn)
												: vn(kn, !1);
										});
									}
									k(bn),
										We(() => {
											var vn;
											return Tr(
												bn,
												"href",
												((vn = Mt.data) == null ? void 0 : vn.role) === "admin"
													? `${yi.url.origin}/admin/dashboard`
													: `${yi.url.origin}/moderation`
											);
										}),
										$(Mn, bn);
								};
								Oe(Cn, (Mn) => {
									var bn;
									xc((bn = Mt.data) == null ? void 0 : bn.role, [
										"admin",
										"moderator",
										"global_moderator",
									]) && Mn(Gn);
								});
							}
							var Mr = j(Cn, 2);
							PR(Mr, {
								get user() {
									return Mt;
								},
								onlogout: () => {
									se(fe, { name: "mainMenu" }, !0);
								},
							}),
								k(an),
								Ai(
									3,
									an,
									() => ia,
									() => ({ duration: 150 })
								),
								$(Tn, an);
						};
						Oe(
							$r,
							(Tn) => {
								Mt.data && x(O) && x(fe).name !== "paintingPixel" && Tn(lr);
							},
							!0
						);
					}
					$(sr, Ut);
				};
			Oe(Y, (sr) => {
				!Mt.loading && !Mt.data ? sr(ie) : sr(pe, !1);
			});
		}
		var Se = j(Y, 2);
		{
			var Me = (sr) => {
					var Ut = J9(),
						$r = A(Ut);
					{
						var lr = (Mr) => {
							jf(Mr, {
								key: "shop-profile-picture",
								children: (Mn, bn) => {
									var cn = H9();
									cn.__click = [G9, je, O, X];
									var Sn = A(cn);
									Y0(Sn, { class: "size-5" }),
										k(cn),
										We((kn) => Tr(cn, "title", kn), [() => Zv()]),
										$(Mn, cn);
								},
								$$slots: { default: !0 },
							});
						};
						Oe($r, (Mr) => {
							Mt.data && Mr(lr);
						});
					}
					var Tn = j($r, 2);
					{
						var an = (Mr) => {
							var Mn = X9();
							Mn.__click = [W9, It];
							var bn = A(Mn);
							xp(bn, { class: "size-5" }),
								k(Mn),
								We((cn) => Tr(Mn, "title", cn), [() => _p()]),
								$(Mr, Mn);
						};
						Oe(Tn, (Mr) => {
							Mt.data && Mr(an);
						});
					}
					var Cn = j(Tn, 2);
					LR(Cn, {
						get map() {
							return x(O);
						},
						get season() {
							return s;
						},
					});
					var Gn = j(Cn, 2);
					jf(Gn, {
						key: "region-leaderboard",
						children: (Mr, Mn) => {
							var bn = K9();
							bn.__click = [Y9, pt];
							var cn = A(bn);
							I0(cn, { class: "size-5" }),
								k(bn),
								We((Sn) => Tr(bn, "title", Sn), [() => Bm()]),
								$(Mr, bn);
						},
						$$slots: { default: !0 },
					}),
						k(Ut),
						Ai(
							3,
							Ut,
							() => ia,
							() => ({ duration: 150 })
						),
						$(sr, Ut);
				},
				we = (sr) => {
					var Ut = er(),
						$r = Ct(Ut);
					{
						var lr = (Tn) => {
							var an = eB(),
								Cn = A(an);
							let Gn;
							Cn.__click = [Q9, K];
							var Mr = A(Cn);
							{
								var Mn = (cn) => {
										Pm(cn, { class: "size-5" });
									},
									bn = (cn) => {
										np(cn, { class: "size-5" });
									};
								Oe(Mr, (cn) => {
									x(K) ? cn(Mn) : cn(bn, !1);
								});
							}
							k(Cn),
								k(an),
								We(
									(cn, Sn) => {
										Tr(Cn, "title", cn),
											(Gn = zr(
												Cn,
												1,
												"btn btn-square not-touchscreen:hidden shadow-md",
												null,
												Gn,
												Sn
											));
									},
									[() => (x(K) ? sb() : ub()), () => ({ "btn-primary": x(K) })]
								),
								Ai(
									1,
									an,
									() => ia,
									() => ({ delay: 150, duration: 150 })
								),
								$(Tn, an);
						};
						Oe(
							$r,
							(Tn) => {
								x(O) && x(fe).name === "paintingPixel" && Tn(lr);
							},
							!0
						);
					}
					$(sr, Ut);
				};
			Oe(Se, (sr) => {
				x(O) && x(fe).name !== "paintingPixel" ? sr(Me) : sr(we, !1);
			});
		}
		k(U), k(V);
		var Ve = j(V, 2);
		{
			var ut = (sr) => {
				var Ut = tB(),
					$r = A(Ut);
				{
					let lr = ft(() => _x.trim());
					Vx($r, {
						get siteKey() {
							return x(lr);
						},
						refreshExpired: "auto",
						appearance: "interaction-only",
						callback: (Tn) => {
							ai.captcha = { token: Tn, time: Date.now() };
						},
					});
				}
				k(Ut),
					Ai(
						2,
						Ut,
						() => ia,
						() => ({ duration: 300 })
					),
					$(sr, Ut);
			};
			Oe(Ve, (sr) => {
				mx && (!ai.captcha || ai.now - ai.captcha.time > 180 * 1e3) && sr(ut);
			});
		}
		var Ke = j(Ve, 2);
		let On;
		var kt = A(Ke);
		{
			var ye = (sr) => {
				jf(sr, {
					key: "info",
					children: (Ut, $r) => {
						var lr = nB();
						lr.__click = [rB, ct];
						var Tn = A(lr);
						w9(Tn, { class: "size-3.5" }),
							k(lr),
							We((an) => Tr(lr, "title", an), [() => pb()]),
							$(Ut, lr);
					},
					$$slots: { default: !0 },
				});
			};
			Oe(kt, (sr) => {
				x(fe).name !== "paintingPixel" && sr(ye);
			});
		}
		var Bt = j(kt, 2),
			rr = A(Bt);
		rr.__click = [iB, O];
		var Kt = j(rr, 2);
		(Kt.__click = [aB, O]), k(Bt);
		var gr = j(Bt, 2),
			Ur = A(gr),
			nn = A(Ur);
		Vv(nn, { class: "size-4" }), k(Ur), k(gr);
		var mn = j(gr, 2);
		{
			var _n = (sr) => {
				var Ut = sB();
				Ut.__click = [oB, fe];
				var $r = A(Ut);
				Gu($r, { class: "size-4" }), k(Ut), $(sr, Ut);
			};
			Oe(mn, (sr) => {
				var Ut, $r;
				x(fe).name !== "paintingPixel" &&
					(((Ut = Mt.data) == null ? void 0 : Ut.role) === "admin" ||
						(($r = Mt.data) == null ? void 0 : $r.role) ===
							"global_moderator") &&
					sr(_n);
			});
		}
		var Vt = j(mn, 2);
		{
			var Et = (sr) => {
				var Ut = lB(),
					$r = A(Ut);
				z9($r, {
					class: "size-4",
					onclick: () => {
						se(H, !x(H));
					},
				}),
					k(Ut),
					We((lr) => Tr(Ut, "title", lr), [() => rw()]),
					$(sr, Ut);
			};
			Oe(Vt, (sr) => {
				x(ne) && sr(Et);
			});
		}
		var dr = j(Vt, 2);
		{
			var ht = (sr) => {
				var Ut = uB();
				Ut.__click = [cB];
				var $r = A(Ut);
				Zx($r, { class: "size-3" }),
					k(Ut),
					We((lr) => Tr(Ut, "title", lr), [() => $x()]),
					$(sr, Ut);
			};
			Oe(dr, (sr) => {
				x(fe).name !== "paintingPixel" && sr(ht);
			});
		}
		var Xr = j(dr, 2);
		{
			var Yr = (sr) => {
				var Ut = dB();
				Ut.__click = [hB, O];
				var $r = A(Ut);
				A9($r, { class: "size-3" }),
					k(Ut),
					We(
						(lr, Tn) => {
							Tr(Ut, "title", lr), (Ut.disabled = Tn);
						},
						[() => wb(), () => !hl.hasPrev()]
					),
					Ai(
						1,
						Ut,
						() => ia,
						() => ({ delay: 1e3, duration: 300 })
					),
					Ai(
						2,
						Ut,
						() => ia,
						() => ({ duration: 300 })
					),
					$(sr, Ut);
			};
			Oe(Xr, (sr) => {
				hl.hasPrev() && x(fe).name !== "paintingPixel" && sr(Yr);
			});
		}
		k(Ke);
		var Zr = j(Ke, 2);
		let Yn;
		var mt = A(Zr);
		{
			var He = (sr) => {
				var Ut = pB(),
					$r = A(Ut);
				Ux($r, { class: "size-5" });
				var lr = j($r);
				k(Ut),
					We((Tn) => de(lr, ` ${Tn ?? ""}`), [() => Sb()]),
					Ai(
						1,
						Ut,
						() => ia,
						() => ({ duration: 1e3 })
					),
					Ai(2, Ut, () => ia),
					$(sr, Ut);
			};
			Oe(mt, (sr) => {
				Qr.online || sr(He);
			});
		}
		var At = j(mt, 2);
		{
			var Ft = (sr) => {
				var Ut = mB();
				Ut.__click = [fB, O, p];
				var $r = A(Ut);
				M9($r, { class: "size-5" });
				var lr = j($r);
				k(Ut),
					We((Tn) => de(lr, ` ${Tn ?? ""}`), [() => Mb()]),
					Ai(
						3,
						Ut,
						() => ia,
						() => ({ duration: 300 })
					),
					$(sr, Ut);
			};
			Oe(At, (sr) => {
				x(X) < z && sr(Ft);
			});
		}
		k(Zr);
		var Jt = j(Zr, 2);
		let Vn;
		var Cr = A(Jt);
		bt(Cr), k(Jt);
		var Er = j(Jt, 2);
		let wn;
		var ur = A(Er);
		{
			var rn = (sr) => {
					k0(sr, {
						class: "z-30",
						onclick: () => {
							var Ut;
							(Ut = Mt.data) != null && Ut.needsPhoneVerification
								? (se(Rt, !0), Fr.warning(Yg()))
								: Mt.charges !== void 0 && Mt.charges < 1
								? Fr.warning(RE, { icon: Xf })
								: x(O) && Mt.data
								? (aa.smallDropplet.play(),
								  se(fe, { name: "paintingPixel" }, !0))
								: (se(ze, !0), x(O) && Co(x(O).getCenter(), x(X)));
						},
						get disabled() {
							return Mt.loading;
						},
						get loading() {
							return Mt.loading;
						},
						get charges() {
							return Mt.charges;
						},
					});
				},
				pn = (sr) => {
					var Ut = _B();
					$(sr, Ut);
				};
			Oe(ur, (sr) => {
				x(fe).name === "mainMenu" ? sr(rn) : sr(pn, !1);
			});
		}
		k(Er);
		var gn = j(Er, 2);
		let Ji;
		var ln = A(gn);
		Xt(ln), k(gn);
		var En = j(gn, 2);
		{
			var pr = (sr) => {
				var Ut = er(),
					$r = Ct(Ut);
				{
					var lr = (an) => {
							var Cn = gB(),
								Gn = A(Cn),
								Mr = A(Gn);
							S7(Mr, {
								get latLon() {
									return x(fe).latLon;
								},
								get map() {
									return x(O);
								},
								get crosshair() {
									return x(he);
								},
								get pixelInfoCache() {
									return B;
								},
								get season() {
									return s;
								},
								get tileSize() {
									return y;
								},
								get pixelArtZoom() {
									return p;
								},
								get zoom() {
									return x(X);
								},
								get opaquePixelArt() {
									return x(et);
								},
								onclose: () => se(fe, { name: "mainMenu" }, !0),
								onclickshare: (Mn) => {
									se(xt, Mn, !0), se(yt, !0);
								},
								onclickpaint: ([Mn, bn]) => {
									var Sn, kn, vn;
									if (!Mt.data) {
										se(ze, !0);
										return;
									}
									if ((Sn = Mt.data) != null && Sn.needsPhoneVerification) {
										se(Rt, !0), Fr.warning(Yg());
										return;
									}
									if (Mt.charges !== void 0 && Mt.charges < 1) {
										Fr.warning(Bb());
										return;
									}
									const cn = qm(M.latLonToPixelBoundsLatLon(Mn, bn, p));
									(kn = x(O)) == null ||
										kn.flyTo({ center: { lat: cn[0], lon: cn[1] } }),
										se(
											fe,
											{ name: "paintingPixel", clickedLatLon: [Mn, bn] },
											!0
										),
										(vn = x(he)) == null || vn.clear();
								},
								onclickregion: (Mn) => {
									se(St, Mn, !0), se(Dt, !0);
								},
								onclickmodaction: (Mn, bn, cn, Sn) => {
									var vn, fn, on;
									(vn = x(O)) == null || vn.setZoom(Math.max(x(X), p + 3.5));
									const kn = M.latLonToPixelBoundsLatLon(cn[0], cn[1], p);
									(fn = x(O)) == null ||
										fn.setCenter({
											lat: kn.min[0],
											lng: (kn.max[1] + kn.min[1]) / 2,
										}),
										se(mr, bn, !0),
										se(hr, Mn, !0),
										se(_r, cn, !0),
										se(
											Ir,
											((on = x(O)) == null ? void 0 : on.getZoom()) ?? 0,
											!0
										),
										se(Vr, Sn, !0),
										se(cr, !0);
								},
							}),
								k(Gn),
								k(Cn),
								Ai(
									3,
									Gn,
									() => Hd,
									() => ({ duration: 100 })
								),
								$(an, Cn);
						},
						Tn = (an) => {
							var Cn = er(),
								Gn = Ct(Cn);
							{
								var Mr = (bn) => {
										var cn = vB(),
											Sn = A(cn),
											kn = A(Sn);
										YL(kn, {
											get map() {
												return x(O);
											},
											get clickedLatLon() {
												return x(fe).clickedLatLon;
											},
											get tileSize() {
												return y;
											},
											get tileZoom() {
												return p;
											},
											get season() {
												return s;
											},
											get zoom() {
												return x(X);
											},
											get crosshair() {
												return x(oe);
											},
											refreshPixelArt: () => x(O) && Fe(x(O)),
											hidePixelHover: Le,
											hoverLayerId: $e,
											onclose: () => {
												se(fe, { name: "mainMenu" }, !0), Le();
											},
											get screenLocked() {
												return x(K);
											},
											set screenLocked(vn) {
												se(K, vn, !0);
											},
											get opaquePixelArt() {
												return x(et);
											},
											set opaquePixelArt(vn) {
												se(et, vn, !0);
											},
										}),
											k(Sn),
											k(cn),
											Ai(
												3,
												Sn,
												() => Hd,
												() => ({ duration: 100 })
											),
											$(bn, cn);
									},
									Mn = (bn) => {
										var cn = er(),
											Sn = Ct(cn);
										{
											var kn = (fn) => {
													var on = yB(),
														po = A(on);
													B7(po, {
														get map() {
															return x(O);
														},
														get tileSize() {
															return y;
														},
														get pixelArtZoom() {
															return Lf;
														},
														get season() {
															return s;
														},
														get crosshair() {
															return x(oe);
														},
														onclose: () => {
															se(fe, { name: "mainMenu" }, !0), Le();
														},
													}),
														k(on),
														$(fn, on);
												},
												vn = (fn) => {
													var on = er(),
														po = Ct(on);
													{
														var fi = (Hn) => {
															var jn = bB(),
																zn = A(jn),
																qa = A(zn),
																Rr = A(qa),
																Gr = A(Rr),
																_a = A(Gr);
															H0(_a, { class: "inline size-4" });
															var un = j(_a);
															k(Gr);
															var Li = j(Gr, 2);
															Li.__click = [xB, fe];
															var ga = A(Li);
															_l(ga, { class: "size-4" }), k(Li), k(Rr);
															var sa = j(Rr, 2),
																Ja = A(sa);
															Ja.__click = async () => {
																var Ca;
																if (x(fe).name === "selectHq") {
																	const Qa = x(fe).hq;
																	if (Qa)
																		try {
																			se(Nt, !0),
																				await Qr.updateAllianceHeadquarters(
																					Qa[0],
																					Qa[1]
																				),
																				(Ca = x(he)) == null || Ca.clear(),
																				se(It, !0),
																				se(fe, { name: "mainMenu" }, !0);
																		} catch (Jo) {
																			Fr.error(Jo.message);
																		} finally {
																			se(Nt, !1);
																		}
																}
															};
															var Ms = A(Ja);
															x9(Ms, { class: "size-6" }),
																k(Ja),
																k(sa),
																k(qa),
																k(zn),
																k(jn),
																We(
																	(Ca) => {
																		de(un, ` ${Ca ?? ""}`),
																			(Ja.disabled =
																				x(fe).hq === void 0 || x(Nt));
																	},
																	[() => OC()]
																),
																Ai(
																	3,
																	zn,
																	() => Hd,
																	() => ({ duration: 100 })
																),
																$(Hn, jn);
														};
														Oe(
															po,
															(Hn) => {
																x(fe).name === "selectHq" && Hn(fi);
															},
															!0
														);
													}
													$(fn, on);
												};
											Oe(
												Sn,
												(fn) => {
													x(fe).name === "getPixelAreaInfo"
														? fn(kn)
														: fn(vn, !1);
												},
												!0
											);
										}
										$(bn, cn);
									};
								Oe(
									Gn,
									(bn) => {
										x(fe).name === "paintingPixel" && x(oe)
											? bn(Mr)
											: bn(Mn, !1);
									},
									!0
								);
							}
							$(an, Cn);
						};
					Oe($r, (an) => {
						x(fe).name === "pixelSelected" && x(he) ? an(lr) : an(Tn, !1);
					});
				}
				$(sr, Ut);
			};
			Oe(En, (sr) => {
				x(O) && sr(pr);
			});
		}
		k(ue),
			We(
				(sr, Ut, $r, lr, Tn, an, Cn, Gn, Mr) => {
					(Br = zr(V, 1, "absolute right-2 top-2 z-30", null, Br, sr)),
						(xn = zr(U, 1, "flex flex-col gap-4", null, xn, Ut)),
						(On = zr(
							Ke,
							1,
							"absolute left-2 top-2 z-30 flex flex-col gap-3",
							null,
							On,
							$r
						)),
						Tr(rr, "title", lr),
						Tr(Kt, "title", Tn),
						(Yn = zr(
							Zr,
							1,
							"absolute left-1/2 top-2 z-30 flex -translate-x-1/2 flex-col items-center justify-center gap-2",
							null,
							Yn,
							an
						)),
						(Vn = zr(Jt, 1, "absolute bottom-3 left-3 z-30", null, Vn, Cn)),
						(wn = zr(
							Er,
							1,
							"absolute bottom-3 left-1/2 z-30 -translate-x-1/2",
							null,
							wn,
							Gn
						)),
						(Ji = zr(gn, 1, "absolute bottom-3 right-3 z-30", null, Ji, Mr));
				},
				[
					() => ({ hidden: x(H) }),
					() => ({ "items-end": !Mt.data, "items-center": Mt.data }),
					() => ({ hidden: x(H) }),
					() => _b(),
					() => yb(),
					() => ({ hidden: x(H) }),
					() => ({ hidden: x(H) }),
					() => ({ hidden: x(H) }),
					() => ({ hidden: x(H) }),
				]
			);
	}
	var In = j(ue, 2);
	AE(In, {
		get open() {
			return x(ze);
		},
		set open(bt) {
			se(ze, bt, !0);
		},
	});
	var tn = j(In, 2);
	v9(tn, {
		get open() {
			return x(je);
		},
		set open(bt) {
			se(je, bt, !0);
		},
	});
	var en = j(tn, 2);
	v6(en, {
		get open() {
			return x(it);
		},
		set open(bt) {
			se(it, bt, !0);
		},
	});
	var ma = j(en, 2);
	B6(ma, {
		get open() {
			return x(ct);
		},
		set open(bt) {
			se(ct, bt, !0);
		},
	});
	var pi = j(ma, 2);
	m6(pi, {
		get open() {
			return x(wt);
		},
		set open(bt) {
			se(wt, bt, !0);
		},
	});
	var Xi = j(pi, 2);
	IE(Xi, {
		onvisitclick: (bt) => {
			var Xt;
			(Xt = x(O)) == null || Xt.flyTo({ center: bt, zoom: Lf + 1 }),
				Co(bt, x(X)),
				hl.push({ pos: bt, zoom: x(X) }),
				se(pt, !1);
		},
		get open() {
			return x(pt);
		},
		set open(bt) {
			se(pt, bt, !0);
		},
	});
	var Zn = j(Xi, 2);
	HR(Zn, {
		get region() {
			return x(St);
		},
		get open() {
			return x(Dt);
		},
		set open(bt) {
			se(Dt, bt, !0);
		},
	});
	var ni = j(Zn, 2);
	Ox(ni, {
		get open() {
			return ai.dropletsDialogOpen;
		},
		set open(bt) {
			ai.dropletsDialogOpen = bt;
		},
	});
	var Zi = j(ni, 2);
	{
		var Yi = (bt) => {
			YM(bt, {
				onhqchange: () => {
					se(fe, { name: "selectHq" }, !0), se(It, !1);
				},
				onhqclick: (Xt) => {
					var Br;
					(Br = x(O)) == null ||
						Br.flyTo({ center: Xt, zoom: Math.max(x(X), 15) }),
						se(fe, { name: "pixelSelected", latLon: [Xt.lat, Xt.lng] }, !0),
						se(It, !1);
				},
				onlastpixelclick: (Xt) => {
					var Br;
					(Br = x(O)) == null ||
						Br.flyTo({ center: Xt, zoom: Math.max(x(X), 15) }),
						se(fe, { name: "pixelSelected", latLon: [Xt.lat, Xt.lng] }, !0),
						se(It, !1);
				},
				get open() {
					return x(It);
				},
				set open(Xt) {
					se(It, Xt, !0);
				},
			});
		};
		Oe(Zi, (bt) => {
			x(O) && bt(Yi);
		});
	}
	var Ei = j(Zi, 2);
	_D(Ei, {
		get open() {
			return x(Rt);
		},
		set open(bt) {
			se(Rt, bt, !0);
		},
	});
	var zi = j(Ei, 2);
	{
		var Ki = (bt) => {
			l6(bt, {
				get url() {
					return x(xt);
				},
				get map() {
					return x(O);
				},
				hideHover: () => {
					var Xt, Br;
					(Xt = x(O)) == null || Xt.setPaintProperty($e, "raster-opacity", 0),
						(Br = x(he)) == null || Br.setCanvasOpacity(0);
				},
				showHover: () => {
					var Xt, Br;
					(Xt = x(O)) == null || Xt.setPaintProperty($e, "raster-opacity", Ze),
						(Br = x(he)) == null || Br.setCanvasOpacity(1);
				},
				get open() {
					return x(yt);
				},
				set open(Xt) {
					se(yt, Xt, !0);
				},
			});
		};
		Oe(zi, (bt) => {
			x(O) && bt(Ki);
		});
	}
	var oa = j(zi, 2);
	{
		var Ta = (bt) => {
			Px(bt, {
				get image() {
					return x(mr);
				},
				get paintedBy() {
					return x(hr).paintedBy;
				},
				get latLon() {
					return x(_r);
				},
				get zoom() {
					return x(Ir);
				},
				get action() {
					return x(Vr);
				},
				get open() {
					return x(cr);
				},
				set open(Xt) {
					se(cr, Xt, !0);
				},
			});
		};
		Oe(oa, (bt) => {
			x(hr) && x(mr) && x(_r) && bt(Ta);
		});
	}
	$(m, qr), Dr();
}
$n(["click"]);
export { uF as component };
